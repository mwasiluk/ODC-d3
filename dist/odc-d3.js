(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ODCD3 = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// https://d3js.org/d3-array/ Version 1.0.1. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  function descending(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  function number(x) {
    return x === null ? NaN : +x;
  }

  function variance(array, f) {
    var n = array.length,
        m = 0,
        a,
        d,
        s = 0,
        i = -1,
        j = 0;

    if (f == null) {
      while (++i < n) {
        if (!isNaN(a = number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    else {
      while (++i < n) {
        if (!isNaN(a = number(f(array[i], i, array)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    if (j > 1) return s / (j - 1);
  }

  function deviation(array, f) {
    var v = variance(array, f);
    return v ? Math.sqrt(v) : v;
  }

  function extent(array, f) {
    var i = -1,
        n = array.length,
        a,
        b,
        c;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    return [a, c];
  }

  var array = Array.prototype;

  var slice = array.slice;
  var map = array.map;

  function constant(x) {
    return function() {
      return x;
    };
  }

  function identity(x) {
    return x;
  }

  function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function ticks(start, stop, count) {
    var step = tickStep(start, stop, count);
    return range(
      Math.ceil(start / step) * step,
      Math.floor(stop / step) * step + step / 2, // inclusive
      step
    );
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function sturges(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
  }

  function histogram() {
    var value = identity,
        domain = extent,
        threshold = sturges;

    function histogram(data) {
      var i,
          n = data.length,
          x,
          values = new Array(n);

      for (i = 0; i < n; ++i) {
        values[i] = value(data[i], i, data);
      }

      var xz = domain(values),
          x0 = xz[0],
          x1 = xz[1],
          tz = threshold(values, x0, x1);

      // Convert number of thresholds into uniform thresholds.
      if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);

      // Remove any thresholds outside the domain.
      var m = tz.length;
      while (tz[0] <= x0) tz.shift(), --m;
      while (tz[m - 1] >= x1) tz.pop(), --m;

      var bins = new Array(m + 1),
          bin;

      // Initialize bins.
      for (i = 0; i <= m; ++i) {
        bin = bins[i] = [];
        bin.x0 = i > 0 ? tz[i - 1] : x0;
        bin.x1 = i < m ? tz[i] : x1;
      }

      // Assign data to bins by value, ignoring any outside the domain.
      for (i = 0; i < n; ++i) {
        x = values[i];
        if (x0 <= x && x <= x1) {
          bins[bisectRight(tz, x, 0, m)].push(data[i]);
        }
      }

      return bins;
    }

    histogram.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
    };

    histogram.domain = function(_) {
      return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
    };

    histogram.thresholds = function(_) {
      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
    };

    return histogram;
  }

  function quantile(array, p, f) {
    if (f == null) f = number;
    if (!(n = array.length)) return;
    if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
    if (p >= 1) return +f(array[n - 1], n - 1, array);
    var n,
        h = (n - 1) * p,
        i = Math.floor(h),
        a = +f(array[i], i, array),
        b = +f(array[i + 1], i + 1, array);
    return a + (b - a) * (h - i);
  }

  function freedmanDiaconis(values, min, max) {
    values = map.call(values, number).sort(ascending);
    return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
  }

  function scott(values, min, max) {
    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
  }

  function max(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
    }

    return a;
  }

  function mean(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1,
        j = n;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number(array[i]))) s += a; else --j;
    }

    else {
      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a; else --j;
    }

    if (j) return s / j;
  }

  function median(array, f) {
    var numbers = [],
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);
    }

    else {
      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);
    }

    return quantile(numbers.sort(ascending), 0.5);
  }

  function merge(arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) j += arrays[i].length;
    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  }

  function min(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
    }

    return a;
  }

  function pairs(array) {
    var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [p, p = array[++i]];
    return pairs;
  }

  function permute(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  }

  function scan(array, compare) {
    if (!(n = array.length)) return;
    var i = 0,
        n,
        j = 0,
        xi,
        xj = array[j];

    if (!compare) compare = ascending;

    while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;

    if (compare(xj, xj) === 0) return j;
  }

  function shuffle(array, i0, i1) {
    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }

    return array;
  }

  function sum(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
    }

    else {
      while (++i < n) if (a = +f(array[i], i, array)) s += a;
    }

    return s;
  }

  function transpose(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  }

  function length(d) {
    return d.length;
  }

  function zip() {
    return transpose(arguments);
  }

  exports.bisect = bisectRight;
  exports.bisectRight = bisectRight;
  exports.bisectLeft = bisectLeft;
  exports.ascending = ascending;
  exports.bisector = bisector;
  exports.descending = descending;
  exports.deviation = deviation;
  exports.extent = extent;
  exports.histogram = histogram;
  exports.thresholdFreedmanDiaconis = freedmanDiaconis;
  exports.thresholdScott = scott;
  exports.thresholdSturges = sturges;
  exports.max = max;
  exports.mean = mean;
  exports.median = median;
  exports.merge = merge;
  exports.min = min;
  exports.pairs = pairs;
  exports.permute = permute;
  exports.quantile = quantile;
  exports.range = range;
  exports.scan = scan;
  exports.shuffle = shuffle;
  exports.sum = sum;
  exports.ticks = ticks;
  exports.tickStep = tickStep;
  exports.transpose = transpose;
  exports.variance = variance;
  exports.zip = zip;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],2:[function(require,module,exports){
// https://d3js.org/d3-collection/ Version 1.0.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

var nest = function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};

var values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};

var entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){
// https://d3js.org/d3-color/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var define = function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
};

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3})$/;
var reHex6 = /^#([0-9a-f]{6})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var Kn = 18;
var Xn = 0.950470;
var Yn = 1;
var Zn = 1.088830;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861;
var B = +1.78277;
var C = -0.29227;
var D = -0.90649;
var E = +1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],4:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ Version 1.0.1. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  var noop = {value: function() {}};

  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch(_);
  }

  function Dispatch(_) {
    this._ = _;
  }

  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return {type: t, name: name};
    });
  }

  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._,
          T = parseTypenames(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
      }

      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _) copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };

  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({name: name, value: callback});
    return type;
  }

  exports.dispatch = dispatch;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],5:[function(require,module,exports){
// https://d3js.org/d3-format/ Version 1.0.2. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatDefault(x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        case "e": break out;
        default: if (i0 > 0) i0 = 0; break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "": formatDefault,
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + this.type;
  };

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function identity(x) {
    return x;
  }

  function formatLocale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
        currency = locale.currency,
        decimal = locale.decimal;

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? (type ? 6 : 12)
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Convert negative to positive, and compute the prefix.
          // Note that -0 is not less than 0, but 1 / -0 is!
          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

          // Perform the initial formatting.
          value = formatType(value, precision);

          // If the original value was negative, it may be rounded to zero during
          // formatting; treat this as (positive) zero.
          if (valueNegative) {
            i = -1, n = value.length;
            valueNegative = false;
            while (++i < n) {
              if (c = value.charCodeAt(i), (48 < c && c < 58)
                  || (type === "x" && 96 < c && c < 103)
                  || (type === "X" && 64 < c && c < 71)) {
                valueNegative = true;
                break;
              }
            }
          }

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": return valuePrefix + value + valueSuffix + padding;
          case "=": return valuePrefix + padding + value + valueSuffix;
          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
        }
        return padding + valuePrefix + value + valueSuffix;
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    exports.format = locale.format;
    exports.formatPrefix = locale.formatPrefix;
    return locale;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  }

  exports.formatDefaultLocale = defaultLocale;
  exports.formatLocale = formatLocale;
  exports.formatSpecifier = formatSpecifier;
  exports.precisionFixed = precisionFixed;
  exports.precisionPrefix = precisionPrefix;
  exports.precisionRound = precisionRound;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],6:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ Version 1.1.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

var basis$1 = function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var basisClosed = function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var constant = function(x) {
  return function() {
    return x;
  };
};

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb$1 = ((function rgbGamma(y) {
  var color$$1 = gamma(y);

  function rgb$$1(start, end) {
    var r = color$$1((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color$$1(start.g, end.g),
        b = color$$1(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$$1.gamma = rgbGamma;

  return rgb$$1;
}))(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color$$1;
    for (i = 0; i < n; ++i) {
      color$$1 = d3Color.rgb(colors[i]);
      r[i] = color$$1.r || 0;
      g[i] = color$$1.g || 0;
      b[i] = color$$1.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color$$1.opacity = 1;
    return function(t) {
      color$$1.r = r(t);
      color$$1.g = g(t);
      color$$1.b = b(t);
      return color$$1 + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

var array = function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(nb),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
};

var date = function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
};

var number = function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
};

var object = function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
};

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

var string = function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
};

var value = function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb$1) : string)
      : b instanceof d3Color.color ? rgb$1
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
};

var round = function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
};

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

var decompose = function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
};

var cssNode;
var cssRoot;
var cssView;
var svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2;
var rho2 = 2;
var rho4 = 4;
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
var zoom = function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
};

function hsl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$$1(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$$1.gamma = cubehelixGamma;

    return cubehelix$$1;
  })(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

var quantize = function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
};

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb$1;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$2;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab$1;
exports.interpolateHcl = hcl$2;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$2;
exports.interpolateCubehelixLong = cubehelixLong;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":3}],7:[function(require,module,exports){
// https://d3js.org/d3-scale/ Version 1.0.3. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-collection'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format'), require('d3-color')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format', 'd3-color'], factory) :
  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat,d3Color) { 'use strict';

  var array = Array.prototype;

  var map$1 = array.map;
  var slice = array.slice;

  var implicit = {name: "implicit"};

  function ordinal(range) {
    var index = d3Collection.map(),
        domain = [],
        unknown = implicit;

    range = range == null ? [] : slice.call(range);

    function scale(d) {
      var key = d + "", i = index.get(key);
      if (!i) {
        if (unknown !== implicit) return unknown;
        index.set(key, i = domain.push(d));
      }
      return range[(i - 1) % range.length];
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = d3Collection.map();
      var i = -1, n = _.length, d, key;
      while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
      return scale;
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), scale) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return ordinal()
          .domain(domain)
          .range(range)
          .unknown(unknown);
    };

    return scale;
  }

  function band() {
    var scale = ordinal().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range,
        range = [0, 1],
        step,
        bandwidth,
        round = false,
        paddingInner = 0,
        paddingOuter = 0,
        align = 0.5;

    delete scale.unknown;

    function rescale() {
      var n = domain().length,
          reverse = range[1] < range[0],
          start = range[reverse - 0],
          stop = range[1 - reverse];
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = d3Array.range(n).map(function(i) { return start + step * i; });
      return ordinalRange(reverse ? values.reverse() : values);
    }

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.range = function(_) {
      return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = [+_[0], +_[1]], round = true, rescale();
    };

    scale.bandwidth = function() {
      return bandwidth;
    };

    scale.step = function() {
      return step;
    };

    scale.round = function(_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };

    scale.padding = function(_) {
      return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
    };

    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };

    scale.copy = function() {
      return band()
          .domain(domain())
          .range(range)
          .round(round)
          .paddingInner(paddingInner)
          .paddingOuter(paddingOuter)
          .align(align);
    };

    return rescale();
  }

  function pointish(scale) {
    var copy = scale.copy;

    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;

    scale.copy = function() {
      return pointish(copy());
    };

    return scale;
  }

  function point() {
    return pointish(band().paddingInner(1));
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  function number(x) {
    return +x;
  }

  var unit = [0, 1];

  function deinterpolate(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant(b);
  }

  function deinterpolateClamp(deinterpolate) {
    return function(a, b) {
      var d = deinterpolate(a = +a, b = +b);
      return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
    };
  }

  function reinterpolateClamp(reinterpolate) {
    return function(a, b) {
      var r = reinterpolate(a = +a, b = +b);
      return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
    };
  }

  function bimap(domain, range, deinterpolate, reinterpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
    else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, deinterpolate, reinterpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = deinterpolate(domain[i], domain[i + 1]);
      r[i] = reinterpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = d3Array.bisect(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp());
  }

  // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
  function continuous(deinterpolate$$, reinterpolate) {
    var domain = unit,
        range = unit,
        interpolate = d3Interpolate.interpolate,
        clamp = false,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate$$) : deinterpolate$$, interpolate)))(+x);
    }

    scale.invert = function(y) {
      return (input || (input = piecewise(range, domain, deinterpolate, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, rescale()) : clamp;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    return rescale();
  }

  function tickFormat(domain, count, specifier) {
    var start = domain[0],
        stop = domain[domain.length - 1],
        step = d3Array.tickStep(start, stop, count == null ? 10 : count),
        precision;
    specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
        return d3Format.formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return d3Format.format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      return tickFormat(domain(), count, specifier);
    };

    scale.nice = function(count) {
      var d = domain(),
          i = d.length - 1,
          n = count == null ? 10 : count,
          start = d[0],
          stop = d[i],
          step = d3Array.tickStep(start, stop, n);

      if (step) {
        step = d3Array.tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
        d[0] = Math.floor(start / step) * step;
        d[i] = Math.ceil(stop / step) * step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear() {
    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber);

    scale.copy = function() {
      return copy(scale, linear());
    };

    return linearish(scale);
  }

  function identity() {
    var domain = [0, 1];

    function scale(x) {
      return +x;
    }

    scale.invert = scale;

    scale.domain = scale.range = function(_) {
      return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
    };

    scale.copy = function() {
      return identity().domain(domain);
    };

    return linearish(scale);
  }

  function nice(domain, interval) {
    domain = domain.slice();

    var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;

    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }

    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  function deinterpolate$1(a, b) {
    return (b = Math.log(b / a))
        ? function(x) { return Math.log(x / a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    return a < 0
        ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
        : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
  }

  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }

  function powp(base) {
    return base === 10 ? pow10
        : base === Math.E ? Math.exp
        : function(x) { return Math.pow(base, x); };
  }

  function logp(base) {
    return base === Math.E ? Math.log
        : base === 10 && Math.log10
        || base === 2 && Math.log2
        || (base = Math.log(base), function(x) { return Math.log(x) / base; });
  }

  function reflect(f) {
    return function(x) {
      return -f(-x);
    };
  }

  function log() {
    var scale = continuous(deinterpolate$1, reinterpolate).domain([1, 10]),
        domain = scale.domain,
        base = 10,
        logs = logp(10),
        pows = powp(10);

    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
      return scale;
    }

    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.ticks = function(count) {
      var d = domain(),
          u = d[0],
          v = d[d.length - 1],
          r;

      if (r = v < u) i = u, u = v, v = i;

      var i = logs(u),
          j = logs(v),
          p,
          k,
          t,
          n = count == null ? 10 : +count,
          z = [];

      if (!(base % 1) && j - i < n) {
        i = Math.round(i) - 1, j = Math.round(j) + 1;
        if (u > 0) for (; i < j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        } else for (; i < j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
      } else {
        z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
      }

      return r ? z.reverse() : z;
    };

    scale.tickFormat = function(count, specifier) {
      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
      if (typeof specifier !== "function") specifier = d3Format.format(specifier);
      if (count === Infinity) return specifier;
      if (count == null) count = 10;
      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
      return function(d) {
        var i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };

    scale.nice = function() {
      return domain(nice(domain(), {
        floor: function(x) { return pows(Math.floor(logs(x))); },
        ceil: function(x) { return pows(Math.ceil(logs(x))); }
      }));
    };

    scale.copy = function() {
      return copy(scale, log().base(base));
    };

    return scale;
  }

  function raise(x, exponent) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  }

  function pow() {
    var exponent = 1,
        scale = continuous(deinterpolate, reinterpolate),
        domain = scale.domain;

    function deinterpolate(a, b) {
      return (b = raise(b, exponent) - (a = raise(a, exponent)))
          ? function(x) { return (raise(x, exponent) - a) / b; }
          : constant(b);
    }

    function reinterpolate(a, b) {
      b = raise(b, exponent) - (a = raise(a, exponent));
      return function(t) { return raise(a + b * t, 1 / exponent); };
    }

    scale.exponent = function(_) {
      return arguments.length ? (exponent = +_, domain(domain())) : exponent;
    };

    scale.copy = function() {
      return copy(scale, pow().exponent(exponent));
    };

    return linearish(scale);
  }

  function sqrt() {
    return pow().exponent(0.5);
  }

  function quantile$1() {
    var domain = [],
        range = [],
        thresholds = [];

    function rescale() {
      var i = 0, n = Math.max(1, range.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
      return scale;
    }

    function scale(x) {
      if (!isNaN(x = +x)) return range[d3Array.bisect(thresholds, x)];
    }

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(d3Array.ascending);
      return rescale();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
    };

    scale.quantiles = function() {
      return thresholds.slice();
    };

    scale.copy = function() {
      return quantile$1()
          .domain(domain)
          .range(range);
    };

    return scale;
  }

  function quantize() {
    var x0 = 0,
        x1 = 1,
        n = 1,
        domain = [0.5],
        range = [0, 1];

    function scale(x) {
      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
    }

    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }

    scale.domain = function(_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
    };

    scale.range = function(_) {
      return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN]
          : i < 1 ? [x0, domain[0]]
          : i >= n ? [domain[n - 1], x1]
          : [domain[i - 1], domain[i]];
    };

    scale.copy = function() {
      return quantize()
          .domain([x0, x1])
          .range(range);
    };

    return linearish(scale);
  }

  function threshold() {
    var domain = [0.5],
        range = [0, 1],
        n = 1;

    function scale(x) {
      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
    }

    scale.domain = function(_) {
      return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return [domain[i - 1], domain[i]];
    };

    scale.copy = function() {
      return threshold()
          .domain(domain)
          .range(range);
    };

    return scale;
  }

  var durationSecond = 1000;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;
  function date(t) {
    return new Date(t);
  }

  function number$1(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }

  function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber),
        invert = scale.invert,
        domain = scale.domain;

    var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");

    var tickIntervals = [
      [second,  1,      durationSecond],
      [second,  5,  5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute,  1,      durationMinute],
      [minute,  5,  5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [  hour,  1,      durationHour  ],
      [  hour,  3,  3 * durationHour  ],
      [  hour,  6,  6 * durationHour  ],
      [  hour, 12, 12 * durationHour  ],
      [   day,  1,      durationDay   ],
      [   day,  2,  2 * durationDay   ],
      [  week,  1,      durationWeek  ],
      [ month,  1,      durationMonth ],
      [ month,  3,  3 * durationMonth ],
      [  year,  1,      durationYear  ]
    ];

    function tickFormat(date) {
      return (second(date) < date ? formatMillisecond
          : minute(date) < date ? formatSecond
          : hour(date) < date ? formatMinute
          : day(date) < date ? formatHour
          : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
          : year(date) < date ? formatMonth
          : formatYear)(date);
    }

    function tickInterval(interval, start, stop, step) {
      if (interval == null) interval = 10;

      // If a desired tick count is specified, pick a reasonable tick interval
      // based on the extent of the domain and a rough estimate of tick size.
      // Otherwise, assume interval is already a time interval and use it.
      if (typeof interval === "number") {
        var target = Math.abs(stop - start) / interval,
            i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
        if (i === tickIntervals.length) {
          step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
          interval = year;
        } else if (i) {
          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
          step = i[1];
          interval = i[0];
        } else {
          step = d3Array.tickStep(start, stop, interval);
          interval = millisecond;
        }
      }

      return step == null ? interval : interval.every(step);
    }

    scale.invert = function(y) {
      return new Date(invert(y));
    };

    scale.domain = function(_) {
      return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
    };

    scale.ticks = function(interval, step) {
      var d = domain(),
          t0 = d[0],
          t1 = d[d.length - 1],
          r = t1 < t0,
          t;
      if (r) t = t0, t0 = t1, t1 = t;
      t = tickInterval(interval, t0, t1, step);
      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
      return r ? t.reverse() : t;
    };

    scale.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat : format(specifier);
    };

    scale.nice = function(interval, step) {
      var d = domain();
      return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
          ? domain(nice(d, interval))
          : scale;
    };

    scale.copy = function() {
      return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
    };

    return scale;
  }

  function time() {
    return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
  }

  function utcTime() {
    return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
  }

  function colors(s) {
    return s.match(/.{6}/g).map(function(x) {
      return "#" + x;
    });
  }

  var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

  var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

  var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

  var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

  var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

  var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

  var rainbow = d3Color.cubehelix();

  function rainbow$1(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    rainbow.h = 360 * t - 100;
    rainbow.s = 1.5 - 1.5 * ts;
    rainbow.l = 0.8 - 0.9 * ts;
    return rainbow + "";
  }

  function ramp(range) {
    var n = range.length;
    return function(t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

  var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

  var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

  var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  function sequential(interpolator) {
    var x0 = 0,
        x1 = 1,
        clamp = false;

    function scale(x) {
      var t = (x - x0) / (x1 - x0);
      return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
    }

    scale.domain = function(_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.copy = function() {
      return sequential(interpolator).domain([x0, x1]).clamp(clamp);
    };

    return linearish(scale);
  }

  exports.scaleBand = band;
  exports.scalePoint = point;
  exports.scaleIdentity = identity;
  exports.scaleLinear = linear;
  exports.scaleLog = log;
  exports.scaleOrdinal = ordinal;
  exports.scaleImplicit = implicit;
  exports.scalePow = pow;
  exports.scaleSqrt = sqrt;
  exports.scaleQuantile = quantile$1;
  exports.scaleQuantize = quantize;
  exports.scaleThreshold = threshold;
  exports.scaleTime = time;
  exports.scaleUtc = utcTime;
  exports.schemeCategory10 = category10;
  exports.schemeCategory20b = category20b;
  exports.schemeCategory20c = category20c;
  exports.schemeCategory20 = category20;
  exports.interpolateCubehelixDefault = cubehelix$1;
  exports.interpolateRainbow = rainbow$1;
  exports.interpolateWarm = warm;
  exports.interpolateCool = cool;
  exports.interpolateViridis = viridis;
  exports.interpolateMagma = magma;
  exports.interpolateInferno = inferno;
  exports.interpolatePlasma = plasma;
  exports.scaleSequential = sequential;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{"d3-array":1,"d3-collection":2,"d3-color":3,"d3-format":5,"d3-interpolate":6,"d3-time":11,"d3-time-format":10}],8:[function(require,module,exports){
// https://d3js.org/d3-selection/ Version 1.0.2. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  var nextId = 0;

  function local() {
    return new Local;
  }

  function Local() {
    this._ = "@" + (++nextId).toString(36);
  }

  Local.prototype = local.prototype = {
    constructor: Local,
    get: function(node) {
      var id = this._;
      while (!(id in node)) if (!(node = node.parentNode)) return;
      return node[id];
    },
    set: function(node, value) {
      return node[this._] = value;
    },
    remove: function(node) {
      return this._ in node && delete node[this._];
    },
    toString: function() {
      return this._;
    }
  };

  var matcher = function(selector) {
    return function() {
      return this.matches(selector);
    };
  };

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!element.matches) {
      var vendorMatches = element.webkitMatchesSelector
          || element.msMatchesSelector
          || element.mozMatchesSelector
          || element.oMatchesSelector;
      matcher = function(selector) {
        return function() {
          return vendorMatches.call(this, selector);
        };
      };
    }
  }

  var matcher$1 = matcher;

  var filterEvents = {};

  exports.event = null;

  if (typeof document !== "undefined") {
    var element$1 = document.documentElement;
    if (!("onmouseenter" in element$1)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      var event0 = exports.event; // Events can be reentrant (e.g., focus).
      exports.event = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        exports.event = event0;
      }
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function customEvent(event1, listener, that, args) {
    var event0 = exports.event;
    event1.sourceEvent = exports.event;
    exports.event = event1;
    try {
      return listener.apply(that, args);
    } finally {
      exports.event = event0;
    }
  }

  function sourceEvent() {
    var current = exports.event, source;
    while (source = current.sourceEvent) current = source;
    return current;
  }

  function point(node, event) {
    var svg = node.ownerSVGElement || node;

    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }

    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
  }

  function mouse(node) {
    var event = sourceEvent();
    if (event.changedTouches) event = event.changedTouches[0];
    return point(node, event);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher$1(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    var node;
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : defaultView(node = this.node())
            .getComputedStyle(node, null)
            .getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (event) {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function selectAll(selector) {
    return typeof selector === "string"
        ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
        : new Selection([selector == null ? [] : selector], root);
  }

  function touch(node, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

    for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return point(node, touch);
      }
    }

    return null;
  }

  function touches(node, touches) {
    if (touches == null) touches = sourceEvent().touches;

    for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
      points[i] = point(node, touches[i]);
    }

    return points;
  }

  exports.creator = creator;
  exports.local = local;
  exports.matcher = matcher$1;
  exports.mouse = mouse;
  exports.namespace = namespace;
  exports.namespaces = namespaces;
  exports.select = select;
  exports.selectAll = selectAll;
  exports.selection = selection;
  exports.selector = selector;
  exports.selectorAll = selectorAll;
  exports.touch = touch;
  exports.touches = touches;
  exports.window = defaultView;
  exports.customEvent = customEvent;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],9:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-scale'), require('d3-format'), require('d3-array')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-scale', 'd3-format', 'd3-array'], factory) :
	(factory((global.indexRollup = global.indexRollup || {}),global.d3Selection,global.d3Dispatch,global.d3Scale,global.d3Format,global.d3Array));
}(this, (function (exports,d3Selection,d3Dispatch,d3Scale,d3Format,d3Array) { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var d3_identity = function d3_identity(d) {
  return d;
};

var d3_reverse = function d3_reverse(arr) {
  var mirror = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    mirror[i] = arr[l - i - 1];
  }
  return mirror;
};

//Text wrapping code adapted from Mike Bostock
var d3_textWrapping = function d3_textWrapping(text, width) {
  text.each(function () {
    var text = d3Selection.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.2,
        //ems
    y = text.attr("y"),
        dy = parseFloat(text.attr("dy")) || 0,
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", dy + "em");

    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width && line.length > 1) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + dy + "em").text(word);
      }
    }
  });
};

var d3_mergeLabels = function d3_mergeLabels() {
  var gen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var labels = arguments[1];
  var domain = arguments[2];
  var range = arguments[3];


  if ((typeof labels === "undefined" ? "undefined" : _typeof(labels)) === "object") {
    if (labels.length === 0) return gen;

    var i = labels.length;
    for (; i < gen.length; i++) {
      labels.push(gen[i]);
    }
    return labels;
  } else if (typeof labels === "function") {
    var customLabels = [];
    var genLength = gen.length;
    for (var _i = 0; _i < genLength; _i++) {
      customLabels.push(labels({
        i: _i,
        genLength: genLength,
        generatedLabels: gen,
        domain: domain,
        range: range }));
    }
    return customLabels;
  }

  return gen;
};

var d3_linearLegend = function d3_linearLegend(scale, cells, labelFormat) {
  var data = [];

  if (cells.length > 1) {
    data = cells;
  } else {
    var domain = scale.domain(),
        increment = (domain[domain.length - 1] - domain[0]) / (cells - 1);
    var i = 0;

    for (; i < cells; i++) {
      data.push(domain[0] + i * increment);
    }
  }

  var labels = data.map(labelFormat);
  return { data: data,
    labels: labels,
    feature: function feature(d) {
      return scale(d);
    } };
};

var d3_quantLegend = function d3_quantLegend(scale, labelFormat, labelDelimiter) {
  var labels = scale.range().map(function (d) {
    var invert = scale.invertExtent(d);
    return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
  });

  return { data: scale.range(),
    labels: labels,
    feature: d3_identity
  };
};

var d3_ordinalLegend = function d3_ordinalLegend(scale) {
  return { data: scale.domain(),
    labels: scale.domain(),
    feature: function feature(d) {
      return scale(d);
    } };
};

var d3_cellOver = function d3_cellOver(cellDispatcher, d, obj) {
  cellDispatcher.call("cellover", obj, d);
};

var d3_cellOut = function d3_cellOut(cellDispatcher, d, obj) {
  cellDispatcher.call("cellout", obj, d);
};

var d3_cellClick = function d3_cellClick(cellDispatcher, d, obj) {
  cellDispatcher.call("cellclick", obj, d);
};

var helper = {

  d3_drawShapes: function d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
    if (shape === "rect") {
      shapes.attr("height", shapeHeight).attr("width", shapeWidth);
    } else if (shape === "circle") {
      shapes.attr("r", shapeRadius);
    } else if (shape === "line") {
      shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);
    } else if (shape === "path") {
      shapes.attr("d", path);
    }
  },

  d3_addText: function d3_addText(svg, enter, labels, classPrefix, labelWidth) {
    enter.append("text").attr("class", classPrefix + "label");
    var text = svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").data(labels).text(d3_identity);

    if (labelWidth) {
      svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").call(d3_textWrapping, labelWidth);
    }

    return text;
  },

  d3_calcType: function d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter) {
    var type = scale.invertExtent ? d3_quantLegend(scale, labelFormat, labelDelimiter) : scale.ticks ? d3_linearLegend(scale, cells, labelFormat) : d3_ordinalLegend(scale);

    //for d3.scaleSequential that doesn't have a range function
    var range = scale.range && scale.range() || scale.domain();
    type.labels = d3_mergeLabels(type.labels, labels, scale.domain(), range);

    if (ascending) {
      type.labels = d3_reverse(type.labels);
      type.data = d3_reverse(type.data);
    }

    return type;
  },

  d3_filterCells: function d3_filterCells(type, cellFilter) {
    var filterCells = type.data.map(function (d, i) {
      return { data: d, label: type.labels[i] };
    }).filter(cellFilter);
    var dataValues = filterCells.map(function (d) {
      return d.data;
    });
    var labelValues = filterCells.map(function (d) {
      return d.label;
    });
    type.data = type.data.filter(function (d) {
      return dataValues.indexOf(d) !== -1;
    });
    type.labels = type.labels.filter(function (d) {
      return labelValues.indexOf(d) !== -1;
    });
    return type;
  },

  d3_placement: function d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign) {
    cell.attr("transform", cellTrans);
    text.attr("transform", textTrans);
    if (orient === "horizontal") {
      text.style("text-anchor", labelAlign);
    }
  },

  d3_addEvents: function d3_addEvents(cells, dispatcher) {
    cells.on("mouseover.legend", function (d) {
      d3_cellOver(dispatcher, d, this);
    }).on("mouseout.legend", function (d) {
      d3_cellOut(dispatcher, d, this);
    }).on("click.legend", function (d) {
      d3_cellClick(dispatcher, d, this);
    });
  },

  d3_title: function d3_title(svg, title, classPrefix, titleWidth) {
    if (title !== "") {

      var titleText = svg.selectAll('text.' + classPrefix + 'legendTitle');

      titleText.data([title]).enter().append('text').attr('class', classPrefix + 'legendTitle');

      svg.selectAll('text.' + classPrefix + 'legendTitle').text(title);

      if (titleWidth) {
        svg.selectAll('text.' + classPrefix + 'legendTitle').call(d3_textWrapping, titleWidth);
      }

      var cellsSvg = svg.select('.' + classPrefix + 'legendCells');
      var yOffset = svg.select('.' + classPrefix + 'legendTitle').nodes().map(function (d) {
        return d.getBBox().height;
      })[0],
          xOffset = -cellsSvg.nodes().map(function (d) {
        return d.getBBox().x;
      })[0];
      cellsSvg.attr('transform', 'translate(' + xOffset + ',' + yOffset + ')');
    }
  }
};

function color() {

  var scale = d3Scale.scaleLinear(),
      shape = "rect",
      shapeWidth = 15,
      shapeHeight = 15,
      shapeRadius = 10,
      shapePadding = 2,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      useClass = false,
      title = "",
      labelFormat = d3Format.format(".01f"),
      labelOffset = 10,
      labelAlign = "middle",
      labelDelimiter = "to",
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      path = void 0,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {

    var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
        legendG = svg.selectAll('g').data([scale]);

    legendG.enter().append('g').attr('class', classPrefix + 'legendCells');

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    var cell = svg.select('.' + classPrefix + 'legendCells').selectAll("." + classPrefix + "cell").data(type.data);

    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape);

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    cell.exit().transition().style("opacity", 0).remove();

    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);
    helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    // sets placement
    var text = cell.selectAll("text"),
        textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d) {
      return d.getBBox();
    });
    //sets scale
    //everything is fill except for line which is stroke,
    if (!useClass) {
      if (shape == "line") {
        shapes.style("stroke", type.feature);
      } else {
        shapes.style("fill", type.feature);
      }
    } else {
      shapes.attr("class", function (d) {
        return classPrefix + 'swatch ' + type.feature(d);
      });
    }

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(d.height, shapeSize[i].height);
        });

        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));
          return 'translate(0, ' + (height + i * shapePadding) + ')';
        };

        textTrans = function textTrans(d, i) {
          return 'translate( ' + (shapeSize[i].width + shapeSize[i].x + labelOffset) + ', ' + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ')';
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans(d, i) {
        return 'translate(' + i * (shapeSize[i].width + shapePadding) + ',0)';
      };
      textTrans = function textTrans(d, i) {
        return 'translate(' + (shapeSize[i].width * textAlign + shapeSize[i].x) + ',\n          ' + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ')';
      };
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);

    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shape = function (_, d) {
    if (!arguments.length) return shape;
    if (_ == "rect" || _ == "circle" || _ == "line" || _ == "path" && typeof d === 'string') {
      shape = _;
      path = d;
    }
    return legend;
  };

  legend.shapeWidth = function (_) {
    if (!arguments.length) return shapeWidth;
    shapeWidth = +_;
    return legend;
  };

  legend.shapeHeight = function (_) {
    if (!arguments.length) return shapeHeight;
    shapeHeight = +_;
    return legend;
  };

  legend.shapeRadius = function (_) {
    if (!arguments.length) return shapeRadius;
    shapeRadius = +_;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return labelFormat;
    labelFormat = typeof _ === 'string' ? d3Format.format(_) : _;
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.useClass = function (_) {
    if (!arguments.length) return useClass;
    if (_ === true || _ === false) {
      useClass = _;
    }
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

function size() {

  var scale = d3Scale.scaleLinear(),
      shape = "rect",
      shapeWidth = 15,
      shapePadding = 2,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      title = "",
      labelFormat = d3Format.format(".01f"),
      labelOffset = 10,
      labelAlign = "middle",
      labelDelimiter = "to",
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      path = void 0,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {

    var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
        legendG = svg.selectAll('g').data([scale]);

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    legendG.enter().append('g').attr('class', classPrefix + 'legendCells');

    var cell = svg.select('.' + classPrefix + 'legendCells').selectAll("." + classPrefix + "cell").data(type.data);
    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape);

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    cell.exit().transition().style("opacity", 0).remove();

    //creates shape
    if (shape === "line") {
      helper.d3_drawShapes(shape, shapes, 0, shapeWidth);
      shapes.attr("stroke-width", type.feature);
    } else {
      helper.d3_drawShapes(shape, shapes, type.feature, type.feature, type.feature, path);
    }

    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    //sets placement

    var textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d, i) {
      var bbox = d.getBBox();
      var stroke = scale(type.data[i]);

      if (shape === "line" && orient === "horizontal") {
        bbox.height = bbox.height + stroke;
      } else if (shape === "line" && orient === "vertical") {
        bbox.width = bbox.width;
      }
      return bbox;
    });
    //console.log('SHAPESIZE')
    var maxH = d3Array.max(shapeSize, function (d) {
      return d.height + d.y;
    }),
        maxW = d3Array.max(shapeSize, function (d) {
      return d.width + d.x;
    });

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(d.height, shapeSize[i].height);
        });
        var y = shape == "circle" || shape == "line" ? shapeSize[0].height / 2 : 0;
        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));

          return 'translate(0, ' + (y + height + i * shapePadding) + ')';
        };

        textTrans = function textTrans(d, i) {
          return 'translate( ' + (maxW + labelOffset) + ',\n          ' + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ')';
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans(d, i) {
        var width = d3Array.sum(shapeSize.slice(0, i), function (d) {
          return d.width;
        });
        var y = shape == "circle" || shape == "line" ? maxH / 2 : 0;
        return 'translate(' + (width + i * shapePadding) + ', ' + y + ')';
      };

      textTrans = function textTrans(d, i) {
        return 'translate( ' + (shapeSize[i].width * textAlign + shapeSize[i].x) + ',\n              ' + (maxH + labelOffset) + ')';
      };
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);

    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shape = function (_, d) {
    if (!arguments.length) return shape;
    if (_ == "rect" || _ == "circle" || _ == "line") {
      shape = _;
      path = d;
    }
    return legend;
  };

  legend.shapeWidth = function (_) {
    if (!arguments.length) return shapeWidth;
    shapeWidth = +_;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return labelFormat;
    labelFormat = typeof _ === 'string' ? d3Format.format(_) : _;
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

function symbol() {

  var scale = d3Scale.scaleLinear(),
      shape = "path",
      shapeWidth = 15,
      shapeHeight = 15,
      shapeRadius = 10,
      shapePadding = 5,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      title = "",
      labelFormat = d3Format.format(".01f"),
      labelAlign = "middle",
      labelOffset = 10,
      labelDelimiter = "to",
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {

    var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
        legendG = svg.selectAll('g').data([scale]);

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    legendG.enter().append('g').attr('class', classPrefix + 'legendCells');

    var cell = svg.select('.' + classPrefix + 'legendCells').selectAll("." + classPrefix + "cell").data(type.data);
    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape);

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    //remove old shapes
    cell.exit().transition().style("opacity", 0).remove();

    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, type.feature);
    helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    // sets placement
    var text = cell.selectAll("text"),
        textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d) {
      return d.getBBox();
    });

    var maxH = d3Array.max(shapeSize, function (d) {
      return d.height;
    }),
        maxW = d3Array.max(shapeSize, function (d) {
      return d.width;
    });

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(maxH, d.height);
        });

        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));
          return 'translate(0, ' + (height + i * shapePadding) + ' )';
        };
        textTrans = function textTrans(d, i) {
          return 'translate( ' + (maxW + labelOffset) + ',\n              ' + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ')';
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans(d, i) {
        return 'translate( ' + i * (maxW + shapePadding) + ',0)';
      };
      textTrans = function textTrans(d, i) {
        return 'translate( ' + (shapeSize[i].width * textAlign + shapeSize[i].x) + ',\n              ' + (maxH + labelOffset) + ')';
      };
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);
    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return labelFormat;
    labelFormat = typeof _ === 'string' ? d3Format.format(_) : _;
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

var thresholdLabels = function thresholdLabels(_ref) {
  var i = _ref.i,
      genLength = _ref.genLength,
      generatedLabels = _ref.generatedLabels;


  if (i === 0) {
    return generatedLabels[i].replace('NaN to', 'Less than');
  } else if (i === genLength - 1) {
    return 'More than ' + generatedLabels[genLength - 1].replace(' to NaN', '');
  }
  return generatedLabels[i];
};

var legendHelpers = {
  thresholdLabels: thresholdLabels
};

var index = {
  legendColor: color,
  legendSize: size,
  legendSymbol: symbol,
  legendHelpers: legendHelpers
};

exports.legendColor = color;
exports.legendSize = size;
exports.legendSymbol = symbol;
exports.legendHelpers = legendHelpers;
exports['default'] = index;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{"d3-array":1,"d3-dispatch":4,"d3-format":5,"d3-scale":7,"d3-selection":8}],10:[function(require,module,exports){
// https://d3js.org/d3-time-format/ Version 2.0.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "S": formatSeconds,
    "U": formatWeekNumberSunday,
    "w": formatWeekdayNumber,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "S": formatUTCSeconds,
    "U": formatUTCWeekNumberSunday,
    "w": formatUTCWeekdayNumber,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "S": parseSeconds,
    "U": parseWeekNumberSunday,
    "w": parseWeekdayNumber,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0);
      if (i != string.length) return null;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "W" in d ? 1 : 0;
        var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekdayNumber(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekdayNumber(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

var locale$1;





defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale$1 = formatLocale(definition);
  exports.timeFormat = locale$1.format;
  exports.timeParse = locale$1.parse;
  exports.utcFormat = locale$1.utcFormat;
  exports.utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":11}],11:[function(require,module,exports){
// https://d3js.org/d3-time/ Version 1.0.7. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date;
var t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],12:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x/*: number */)/*: number */ {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau = t * Math.exp(-Math.pow(x, 2) -
        1.26551223 +
        1.00002368 * t +
        0.37409196 * Math.pow(t, 2) +
        0.09678418 * Math.pow(t, 3) -
        0.18628806 * Math.pow(t, 4) +
        0.27886807 * Math.pow(t, 5) -
        1.13520398 * Math.pow(t, 6) +
        1.48851587 * Math.pow(t, 7) -
        0.82215223 * Math.pow(t, 8) +
        0.17087277 * Math.pow(t, 9));
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

module.exports = errorFunction;

},{}],13:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data/*: Array<Array<number>> */)/*: { m: number, b: number } */ {

    var m, b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0, sumY = 0,
            sumXX = 0, sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point, x, y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m = ((dataLength * sumXY) - (sumX * sumY)) /
            ((dataLength * sumXX) - (sumX * sumX));

        // `b` is the y-intercept of the line.
        b = (sumY / dataLength) - ((m * sumX) / dataLength);
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}


module.exports = linearRegression;

},{}],14:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb/*: { b: number, m: number }*/)/*: Function */ {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function(x) {
        return mb.b + (mb.m * x);
    };
}

module.exports = linearRegressionLine;

},{}],15:[function(require,module,exports){
'use strict';
/* @flow */

var sum = require('./sum');

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x /*: Array<number> */)/*:number*/ {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error('mean requires at least one data point');
    }

    return sum(x) / x.length;
}

module.exports = mean;

},{"./sum":24}],16:[function(require,module,exports){
'use strict';
/* @flow */

var quantileSorted = require('./quantile_sorted');
var quickselect = require('./quickselect');

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x /*: Array<number> */, p /*: Array<number> | number */) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) continue;

        var m = Math.floor((l + r) / 2);
        quantileSelect(arr, indices[m], indices[l], indices[r]);

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len /*: number */, p /*: number */)/*:number*/ {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

module.exports = quantile;

},{"./quantile_sorted":17,"./quickselect":18}],17:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x /*: Array<number> */, p /*: number */)/*:number*/ {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error('quantile requires at least one data point.');
    } else if (p < 0 || p > 1) {
        throw new Error('quantiles must be between 0 and 1');
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

module.exports = quantileSorted;

},{}],18:[function(require,module,exports){
'use strict';
/* @flow */

module.exports = quickselect;

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @private
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} left left index
 * @param {number} right right index
 * @returns {undefined}
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr /*: Array<number> */, k /*: number */, left /*: number */, right /*: number */) {
    left = left || 0;
    right = right || (arr.length - 1);

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);
            if (m - n / 2 < 0) sd *= -1;
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) i++;
            while (arr[j] > t) j--;
        }

        if (arr[left] === t) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

},{}],19:[function(require,module,exports){
'use strict';
/* @flow */

var sampleCovariance = require('./sample_covariance');
var sampleStandardDeviation = require('./sample_standard_deviation');

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x/*: Array<number> */, y/*: Array<number> */)/*:number*/ {
    var cov = sampleCovariance(x, y),
        xstd = sampleStandardDeviation(x),
        ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

module.exports = sampleCorrelation;

},{"./sample_covariance":20,"./sample_standard_deviation":21}],20:[function(require,module,exports){
'use strict';
/* @flow */

var mean = require('./mean');

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x /*:Array<number>*/, y /*:Array<number>*/)/*:number*/ {

    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error('sampleCovariance requires samples with equal lengths');
    }

    if (x.length < 2) {
        throw new Error('sampleCovariance requires at least two data points in each sample');
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x),
        ymean = mean(y),
        sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

module.exports = sampleCovariance;

},{"./mean":15}],21:[function(require,module,exports){
'use strict';
/* @flow */

var sampleVariance = require('./sample_variance');

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x/*:Array<number>*/)/*:number*/ {
    // The standard deviation of no numbers is null
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

module.exports = sampleStandardDeviation;

},{"./sample_variance":22}],22:[function(require,module,exports){
'use strict';
/* @flow */

var sumNthPowerDeviations = require('./sum_nth_power_deviations');

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x /*: Array<number> */)/*:number*/ {
    // The variance of no numbers is null
    if (x.length < 2) {
        throw new Error('sampleVariance requires at least two data points');
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

module.exports = sampleVariance;

},{"./sum_nth_power_deviations":25}],23:[function(require,module,exports){
'use strict';
/* @flow */

var variance = require('./variance');

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x /*: Array<number> */)/*:number*/ {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

module.exports = standardDeviation;

},{"./variance":26}],24:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x/*: Array<number> */)/*: number */ {

    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    for (var i = 1; i < x.length; i++) {
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += ((sum - transition) + x[i]);
        }
        else {
            correction += ((x[i] - transition) + sum);
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

module.exports = sum;

},{}],25:[function(require,module,exports){
'use strict';
/* @flow */

var mean = require('./mean');

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * var variance = sumNthPowerDeviations(input) / input.length;
 */
function sumNthPowerDeviations(x/*: Array<number> */, n/*: number */)/*:number*/ {
    var meanValue = mean(x),
        sum = 0,
        tempValue,
        i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

module.exports = sumNthPowerDeviations;

},{"./mean":15}],26:[function(require,module,exports){
'use strict';
/* @flow */

var sumNthPowerDeviations = require('./sum_nth_power_deviations');

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x/*: Array<number> */)/*:number*/ {
    // The variance of no numbers is null
    if (x.length === 0) {
        throw new Error('variance requires at least one data point');
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

module.exports = variance;

},{"./sum_nth_power_deviations":25}],27:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x/*:number*/, mean/*:number*/, standardDeviation/*:number*/)/*:number*/ {
    return (x - mean) / standardDeviation;
}

module.exports = zScore;

},{}],28:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BarChart = exports.BarChartConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var _legend = require("./legend");

var _d = require("./d3");

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var BarChartConfig = exports.BarChartConfig = function (_ChartWithColorGroups) {
    _inherits(BarChartConfig, _ChartWithColorGroups);

    function BarChartConfig(custom) {
        _classCallCheck(this, BarChartConfig);

        var _this = _possibleConstructorReturn(this, (BarChartConfig.__proto__ || Object.getPrototypeOf(BarChartConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'bar-chart';
        _this.showLegend = true;
        _this.showTooltip = true;
        _this.x = { // X axis config
            title: '', // axis label
            key: 0,
            value: function value(d, key) {
                return _utils.Utils.isNumber(d) ? d : d[key];
            }, // x value accessor
            scale: "ordinal",
            orient: "bottom",
            ticks: undefined
        };
        _this.y = { // Y axis config
            key: 1,
            value: function value(d, key) {
                return _utils.Utils.isNumber(d) ? d : d[key];
            }, // x value accessor
            title: '', // axis label,
            orient: "left",
            scale: "linear"
        };
        _this.transition = true;

        var config = _this;

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }

        return _this;
    }

    return BarChartConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

var BarChart = exports.BarChart = function (_ChartWithColorGroups2) {
    _inherits(BarChart, _ChartWithColorGroups2);

    function BarChart(placeholderSelector, data, config) {
        _classCallCheck(this, BarChart);

        return _possibleConstructorReturn(this, (BarChart.__proto__ || Object.getPrototypeOf(BarChart)).call(this, placeholderSelector, data, new BarChartConfig(config)));
    }

    _createClass(BarChart, [{
        key: "setConfig",
        value: function setConfig(config) {
            return _get(BarChart.prototype.__proto__ || Object.getPrototypeOf(BarChart.prototype), "setConfig", this).call(this, new BarChartConfig(config));
        }
    }, {
        key: "initPlot",
        value: function initPlot() {
            _get(BarChart.prototype.__proto__ || Object.getPrototypeOf(BarChart.prototype), "initPlot", this).call(this);
            var self = this;

            var conf = this.config;

            this.plot.x = {};
            this.plot.y = {};

            this.computePlotSize();
            this.setupY();
            this.setupX();
            this.setupGroupStacks();
            this.setupYDomain();

            return this;
        }
    }, {
        key: "setupX",
        value: function setupX() {

            var plot = this.plot;
            var x = plot.x;
            var conf = this.config.x;

            /* *
             * value accessor - returns the value to encode for a given data object.
             * scale - maps value to a visual display encoding, such as a pixel position.
             * map function - maps from data value to display value
             * axis - sets up axis
             **/
            x.value = function (d) {
                return conf.value(d, conf.key);
            };
            x.scale = d3.scaleBand().range([0, plot.width]).paddingInner(.08);
            x.map = function (d) {
                return x.scale(x.value(d));
            };

            x.axis = _utils.Utils.createAxis(conf.orient, x.scale);
            if (conf.ticks) {
                x.axis.ticks(conf.ticks);
            }
            var data = this.plot.data;
            var domain;
            if (!data || !data.length) {
                domain = [];
            } else if (!this.config.series) {
                domain = d3.map(data, x.value).keys();
            } else {
                domain = d3.map(data[0].values, x.value).keys();
            }

            plot.x.scale.domain(domain);
        }
    }, {
        key: "setupY",
        value: function setupY() {

            var plot = this.plot;
            var y = plot.y;
            var conf = this.config.y;
            y.value = function (d) {
                return conf.value(d, conf.key);
            };
            y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);
            y.map = function (d) {
                return y.scale(y.value(d));
            };

            y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
        }
    }, {
        key: "setupYDomain",
        value: function setupYDomain() {
            var plot = this.plot;
            var data = this.plot.data;
            var domain;
            var yStackMax = d3.max(plot.layers, function (layer) {
                return d3.max(layer.points, function (d) {
                    return d.y0 + d.y;
                });
            });

            // var min = d3.min(data, s=>d3.min(s.values, plot.y.value));
            var max = yStackMax;
            domain = [0, max];

            plot.y.scale.domain(domain);
            // console.log(' plot.y.scale.domain', plot.y.scale.domain());
        }
    }, {
        key: "setupGroupStacks",
        value: function setupGroupStacks() {
            var self = this;
            this.groupData();

            var y0s = [];
            this.plot.groupedData.forEach(function (s) {
                s.points = s.values.map(function (v) {
                    return self.mapToPoint(v);
                });
                s.points.forEach(function (p, i) {
                    var prevY0 = y0s[i];
                    if (!prevY0) prevY0 = 0;
                    p.y0 = prevY0;
                    y0s[i] = p.y + prevY0;
                });
            });
            this.plot.layers = this.plot.groupedData;
        }
    }, {
        key: "mapToPoint",
        value: function mapToPoint(value) {
            var plot = this.plot;
            return {
                x: plot.x.value(value),
                y: parseFloat(plot.y.value(value))
            };
        }
    }, {
        key: "drawAxisX",
        value: function drawAxisX() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.x;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.x.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: "drawAxisY",
        value: function drawAxisY() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.y;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.y.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: "drawBars",
        value: function drawBars() {
            var self = this;
            var plot = self.plot;

            // console.log('layers', plot.layers);

            var layerClass = this.prefixClass("layer");

            var barClass = this.prefixClass("bar");
            var layer = self.svgG.selectAll("." + layerClass).data(plot.layers);

            var layerMerge = layer.enter().append("g").attr("class", layerClass).merge(layer);

            var bar = layerMerge.selectAll("." + barClass).data(function (d) {
                return d.points;
            });

            var barEnter = bar.enter().append("g").attr("class", barClass);
            var barRectEnter = barEnter.append("rect").attr("x", 1);
            var barMerge = barEnter.merge(bar);

            var barRect = barMerge.select("rect");

            var barRectT = barRect;
            var barT = barMerge;
            var layerT = layerMerge;
            if (this.transitionEnabled()) {
                barRectT = barRect.transition();
                barT = barMerge.transition();
                layerT = layerMerge.transition();
            }

            barEnter.attr("transform", function (d) {
                return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0) + ")";
            });
            var yDomain = plot.y.scale.domain();
            barT.attr("transform", function (d) {
                return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0 + d.y) + ")";
            });
            barRectEnter.attr("width", plot.x.scale.bandwidth()).attr("height", 0);
            barRectT.attr("width", plot.x.scale.bandwidth()).attr("height", function (d) {
                return plot.y.scale(d.y0) - plot.y.scale(d.y0 + d.y - yDomain[0]);
            });

            if (this.plot.seriesColor) {
                layerT.attr("fill", this.plot.seriesColor);
            }

            if (plot.tooltip) {
                barMerge.on("mouseover", function (d) {
                    self.showTooltip(d.y);
                }).on("mouseout", function (d) {
                    self.hideTooltip();
                });
            }
            layer.exit().remove();
            bar.exit().remove();
        }
    }, {
        key: "update",
        value: function update(newData) {
            _get(BarChart.prototype.__proto__ || Object.getPrototypeOf(BarChart.prototype), "update", this).call(this, newData);
            this.drawAxisX();
            this.drawAxisY();
            this.drawBars();
            return this;
        }
    }]);

    return BarChart;
}(_chartWithColorGroups.ChartWithColorGroups);

},{"./chart-with-color-groups":31,"./d3":35,"./legend":41,"./utils":47}],29:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BoxPlotBase = exports.BoxPlotBaseConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chart = require('./chart');

var _utils = require('./utils');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var BoxPlotBaseConfig = exports.BoxPlotBaseConfig = function (_ChartConfig) {
    _inherits(BoxPlotBaseConfig, _ChartConfig);

    function BoxPlotBaseConfig(custom) {
        _classCallCheck(this, BoxPlotBaseConfig);

        var _this = _possibleConstructorReturn(this, (BoxPlotBaseConfig.__proto__ || Object.getPrototypeOf(BoxPlotBaseConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'box-plot';
        _this.showTooltip = true;
        _this.x = { // X axis config
            title: '', // axis label
            value: function value(s) {
                return s.key;
            }, // x value accessor
            guides: false, //show axis guides
            orient: 'bottom'

        };
        _this.y = { // Y axis config
            title: '',
            value: function value(d) {
                return d;
            }, // y value accessor
            scale: "linear",
            orient: 'left',
            domainMargin: 0.1,
            guides: true //show axis guides
        };

        _this.Q1 = function (d) {
            return d.values.Q1;
        };

        _this.Q2 = function (d) {
            return d.values.Q2;
        };

        _this.Q3 = function (d) {
            return d.values.Q3;
        };

        _this.Wl = function (d) {
            return d.values.whiskerLow;
        };

        _this.Wh = function (d) {
            return d.values.whiskerHigh;
        };

        _this.outliers = function (d) {
            return d.values.outliers;
        };

        _this.outlierValue = function (d, i) {
            return d;
        };

        _this.outlierLabel = function (d, i) {
            return d;
        };

        _this.minBoxWidth = 35;
        _this.maxBoxWidth = 100;
        _this.transition = true;
        _this.color = undefined;
        _this.d3ColorCategory = 'category10';

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }

        return _this;
    } // string or function returning color's value for color scale


    return BoxPlotBaseConfig;
}(_chart.ChartConfig);

var BoxPlotBase = exports.BoxPlotBase = function (_Chart) {
    _inherits(BoxPlotBase, _Chart);

    function BoxPlotBase(placeholderSelector, data, config) {
        _classCallCheck(this, BoxPlotBase);

        return _possibleConstructorReturn(this, (BoxPlotBase.__proto__ || Object.getPrototypeOf(BoxPlotBase)).call(this, placeholderSelector, data, new BoxPlotBaseConfig(config)));
    }

    _createClass(BoxPlotBase, [{
        key: 'setConfig',
        value: function setConfig(config) {
            return _get(BoxPlotBase.prototype.__proto__ || Object.getPrototypeOf(BoxPlotBase.prototype), 'setConfig', this).call(this, new BoxPlotBaseConfig(config));
        }
    }, {
        key: 'initPlot',
        value: function initPlot() {
            _get(BoxPlotBase.prototype.__proto__ || Object.getPrototypeOf(BoxPlotBase.prototype), 'initPlot', this).call(this);
            _get(BoxPlotBase.prototype.__proto__ || Object.getPrototypeOf(BoxPlotBase.prototype), 'computePlotSize', this).call(this);
            this.plot.x = {};
            this.plot.y = {};

            this.plot.data = this.getDataToPlot();
            this.setupY();
            this.setupX();

            this.setupColor();
        }
    }, {
        key: 'getDataToPlot',
        value: function getDataToPlot() {
            return this.data;
        }
    }, {
        key: 'setupX',
        value: function setupX() {

            var plot = this.plot;
            var x = plot.x;
            var conf = this.config.x;

            x.value = conf.value;
            x.scale = d3.scaleBand().range([0, plot.width]);
            x.map = function (d) {
                return x.scale(x.value(d));
            };

            x.axis = _utils.Utils.createAxis(conf.orient, x.scale);
            if (conf.guides) {
                x.axis.tickSize(-plot.height);
            }

            var data = this.plot.data;
            var domain;
            if (!data || !data.length) {
                domain = [];
            } else {
                domain = data.map(x.value);
            }

            plot.x.scale.domain(domain);
        }
    }, {
        key: 'setupY',
        value: function setupY() {
            var _this3 = this;

            var plot = this.plot;
            var y = plot.y;
            var conf = this.config.y;
            y.value = function (d) {
                return conf.value.call(_this3.config, d);
            };
            y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);
            y.map = function (d) {
                return y.scale(y.value(d));
            };

            y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
            if (conf.ticks) {
                y.axis.ticks(conf.ticks);
            }
            if (conf.guides) {
                y.axis.tickSize(-plot.width);
            }
            this.setupYDomain();
        }
    }, {
        key: 'setupYDomain',
        value: function setupYDomain() {
            var plot = this.plot;
            var data = this.plot.data;
            var c = this.config;

            var values = [],
                yMin,
                yMax;
            data.forEach(function (d, i) {
                var q1 = c.Q1(d),
                    q3 = c.Q3(d),
                    wl = c.Wl(d),
                    wh = c.Wh(d),
                    outliers = c.outliers(d);

                if (outliers) {
                    outliers.forEach(function (o, i) {
                        values.push(c.outlierValue(o, i));
                    });
                }
                if (wl) {
                    values.push(wl);
                }
                if (q1) {
                    values.push(q1);
                }
                if (q3) {
                    values.push(q3);
                }
                if (wh) {
                    values.push(wh);
                }
            });
            yMin = d3.min(values);
            yMax = d3.max(values);
            var margin = (yMax - yMin) * this.config.y.domainMargin;
            yMin -= margin;
            yMax += margin;
            var domain = [yMin, yMax];

            plot.y.scale.domain(domain);
        }
    }, {
        key: 'drawAxisX',
        value: function drawAxisX() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.x;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.x.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.label);
        }
    }, {
        key: 'drawAxisY',
        value: function drawAxisY() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.y;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.y.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: 'drawBoxPlots',
        value: function drawBoxPlots() {
            var self = this,
                plot = self.plot,
                config = self.config,
                boxplotClass = self.prefixClass("boxplot-item");

            var boxplots = self.svgG.selectAll('.' + boxplotClass).data(plot.data);
            var boxplotEnter = boxplots.enter().append('g').attr('class', boxplotClass).style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);

            var boxplotsMerge = boxplotEnter.merge(boxplots);
            var duration = 1000;
            var boxplotsT = boxplotsMerge;
            if (self.transitionEnabled()) {
                boxplotsT = boxplotsMerge.transition();
                boxplotsT.delay(function (d, i) {
                    return i * duration / plot.data.length;
                });
            }

            boxplotsT.style('fill', plot.color).style('stroke-opacity', 1).style('fill-opacity', 0.75).attr('transform', function (d, i) {
                return 'translate(' + (plot.x.map(d, i) + plot.x.scale.bandwidth() * 0.05) + ', 0)';
            });
            boxplots.exit().remove();

            var boxWidth = !config.maxBoxWidth ? plot.x.scale.bandwidth() * 0.9 : Math.min(config.maxBoxWidth, Math.max(config.minBoxWidth, plot.x.scale.bandwidth() * 0.9));
            var boxLeft = plot.x.scale.bandwidth() * 0.45 - boxWidth / 2;
            var boxRight = plot.x.scale.bandwidth() * 0.45 + boxWidth / 2;

            var boxClass = self.prefixClass("box");

            boxplotEnter.append('rect').attr('class', boxClass)
            // tooltip events
            .on('mouseover', function (d, i) {
                d3.select(this).classed('hover', true);
                var html = 'Q3: ' + config.Q3(d, i) + '<br/>Q2: ' + config.Q2(d, i) + '<br/>Q1: ' + config.Q1(d, i);
                self.showTooltip(html);
            }).on('mouseout', function (d, i) {
                d3.select(this).classed('hover', false);
                self.hideTooltip();
            });

            var boxRects = boxplotsMerge.select('rect.' + boxClass);

            var boxRectsT = boxRects;
            if (self.config.transition) {
                boxRectsT = boxRects.transition();
            }

            boxRectsT.attr('y', function (d, i) {
                return plot.y.scale(config.Q3(d));
            }).attr('width', boxWidth).attr('x', boxLeft).attr('height', function (d, i) {
                return Math.abs(plot.y.scale(config.Q3(d)) - plot.y.scale(config.Q1(d))) || 1;
            }).style('stroke', plot.color);

            // median line
            var medianClass = self.prefixClass('median');
            boxplotEnter.append('line').attr('class', medianClass);

            var medianLine = boxplotsMerge.select('line.' + medianClass);
            if (self.config.transition) {
                medianLine = medianLine.transition();
            }
            medianLine.attr('x1', boxLeft).attr('y1', function (d, i) {
                return plot.y.scale(config.Q2(d));
            }).attr('x2', boxRight).attr('y2', function (d, i) {
                return plot.y.scale(config.Q2(d));
            });

            //whiskers

            var whiskerClass = self.prefixClass("whisker"),
                tickClass = self.prefixClass("boxplot-tick");

            var whiskers = [{ key: 'low', value: config.Wl }, { key: 'high', value: config.Wh }];

            boxplotEnter.each(function (d, i) {
                var box = d3.select(this);

                whiskers.forEach(function (f) {
                    if (f.value(d)) {
                        box.append('line').style('stroke', plot.color(d, i)).attr('class', whiskerClass + ' ' + boxplotClass + '-' + f.key);
                        box.append('line').style('stroke', plot.color(d, i)).attr('class', tickClass + ' ' + boxplotClass + '-' + f.key);
                    }
                });
            });

            whiskers.forEach(function (f) {
                var endpoint = f.key === 'low' ? config.Q1 : config.Q3;

                var whisker = boxplotsMerge.select('.' + whiskerClass + '.' + boxplotClass + '-' + f.key);
                var tick = boxplotsMerge.select('.' + tickClass + '.' + boxplotClass + '-' + f.key);
                if (self.config.transition) {
                    whisker = whisker.transition();
                    tick = tick.transition();
                }
                whisker.attr('x1', plot.x.scale.bandwidth() * 0.45).attr('y1', function (d, i) {
                    return plot.y.scale(f.value(d));
                }).attr('x2', plot.x.scale.bandwidth() * 0.45).attr('y2', function (d, i) {
                    return plot.y.scale(endpoint(d));
                });

                tick.attr('x1', boxLeft).attr('y1', function (d, i) {
                    return plot.y.scale(f.value(d));
                }).attr('x2', boxRight).attr('y2', function (d, i) {
                    return plot.y.scale(f.value(d));
                });

                boxplotEnter.selectAll('.' + boxplotClass + '-' + f.key).on('mouseover', function (d, i, j) {
                    d3.select(this).classed('hover', true);
                    self.showTooltip(f.value(d));
                }).on('mouseout', function (d, i, j) {
                    d3.select(this).classed('hover', false);
                    self.hideTooltip();
                });
            });

            // outliers
            var outlierClass = self.prefixClass("outlier");
            var outliers = boxplotsMerge.selectAll('.' + outlierClass).data(function (d, i) {
                return config.outliers(d, i) || [];
            });

            var outlierEnterCircle = outliers.enter().append('circle').attr('class', outlierClass).style('z-index', 9000);

            outlierEnterCircle.on('mouseover', function (d, i, j) {
                d3.select(this).classed('hover', true);
                self.showTooltip(config.outlierLabel(d, i));
            }).on('mouseout', function (d, i, j) {
                d3.select(this).classed('hover', false);
                self.hideTooltip();
            });

            var outliersMerge = outlierEnterCircle.merge(outliers);
            var outliersT = outliersMerge;
            if (self.config.transition) {
                outliersT = outliersMerge.transition();
            }
            outliersT.attr('cx', plot.x.scale.bandwidth() * 0.45).attr('cy', function (d, i) {
                return plot.y.scale(config.outlierValue(d, i));
            }).attr('r', '3');
            outliers.exit().remove();
        }
    }, {
        key: 'update',
        value: function update(newData) {
            _get(BoxPlotBase.prototype.__proto__ || Object.getPrototypeOf(BoxPlotBase.prototype), 'update', this).call(this, newData);
            this.drawAxisX();
            this.drawAxisY();
            this.drawBoxPlots();
            return this;
        }
    }, {
        key: 'setupColor',
        value: function setupColor() {
            var _this4 = this;

            var self = this;
            var conf = this.config;

            if (conf.d3ColorCategory) {
                var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);
                this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
            }
            var colorValue = conf.color;
            if (colorValue && typeof colorValue === 'string' || colorValue instanceof String) {
                this.plot.color = colorValue;
            } else if (this.plot.colorCategory) {
                self.plot.colorValue = colorValue;
                this.plot.color = function (d) {
                    return self.plot.colorCategory(_this4.plot.x.value(d));
                };
            }
        }
    }]);

    return BoxPlotBase;
}(_chart.Chart);

},{"./chart":32,"./d3":35,"./utils":47}],30:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BoxPlot = exports.BoxPlotConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _boxPlotBase = require('./box-plot-base');

var _utils = require('./utils');

var _statisticsUtils = require('./statistics-utils');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var BoxPlotConfig = exports.BoxPlotConfig = function (_BoxPlotBaseConfig) {
    _inherits(BoxPlotConfig, _BoxPlotBaseConfig);

    function BoxPlotConfig(custom) {
        _classCallCheck(this, BoxPlotConfig);

        var _this = _possibleConstructorReturn(this, (BoxPlotConfig.__proto__ || Object.getPrototypeOf(BoxPlotConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'box-plot';
        _this.showLegend = true;
        _this.showTooltip = true;
        _this.y = { // Y axis config
            key: undefined,
            value: function value(d) {
                return this.y.key === undefined ? d : d[this.y.key];
            }, // y value accessor
            scale: "linear",
            orient: 'left',
            domainMargin: 0.1,
            guides: true //show axis guides
        };
        _this.series = false;
        _this.groups = {
            key: undefined,
            value: function value(d) {
                return this.groups.key === undefined ? '' : d[this.groups.key];
            }, // grouping value accessor,
            label: "",
            displayValue: undefined // optional function returning display value (series label) for given group value, or object/array mapping value to display value
        };
        _this.tukey = false;

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }
        return _this;
    }

    return BoxPlotConfig;
}(_boxPlotBase.BoxPlotBaseConfig);

var BoxPlot = exports.BoxPlot = function (_BoxPlotBase) {
    _inherits(BoxPlot, _BoxPlotBase);

    function BoxPlot(placeholderSelector, data, config) {
        _classCallCheck(this, BoxPlot);

        return _possibleConstructorReturn(this, (BoxPlot.__proto__ || Object.getPrototypeOf(BoxPlot)).call(this, placeholderSelector, data, new BoxPlotConfig(config)));
    }

    _createClass(BoxPlot, [{
        key: 'setConfig',
        value: function setConfig(config) {
            return _get(BoxPlot.prototype.__proto__ || Object.getPrototypeOf(BoxPlot.prototype), 'setConfig', this).call(this, new BoxPlotConfig(config));
        }
    }, {
        key: 'getDataToPlot',
        value: function getDataToPlot() {
            var self = this;
            var conf = self.config;
            self.plot.groupingEnabled = this.isGroupingEnabled();

            var data = this.data;
            if (!self.plot.groupingEnabled) {
                self.plot.groupedData = [{
                    key: '',
                    values: data
                }];
                self.plot.dataLength = data.length;
            } else {
                if (self.config.series) {
                    self.plot.groupedData = data.map(function (s) {
                        return {
                            key: s.label || s.key || '',
                            values: s.values
                        };
                    });
                } else {
                    self.plot.groupValue = function (d) {
                        return conf.groups.value.call(conf, d);
                    };
                    self.plot.groupedData = d3.nest().key(this.plot.groupValue).entries(data);

                    var getDisplayValue = function getDisplayValue(k) {
                        return k;
                    };
                    if (self.config.groups.displayValue) {
                        if (_utils.Utils.isFunction(self.config.groups.displayValue)) {
                            getDisplayValue = function getDisplayValue(k) {
                                return self.config.groups.displayValue(k) || k;
                            };
                        } else if (_utils.Utils.isObject(self.config.groups.displayValue)) {
                            getDisplayValue = function getDisplayValue(k) {
                                return self.config.groups.displayValue[k] || k;
                            };
                        }
                    }
                    self.plot.groupedData.forEach(function (g) {
                        g.key = getDisplayValue(g.key);
                    });
                }

                self.plot.dataLength = d3.sum(this.plot.groupedData, function (s) {
                    return s.values.length;
                });
            }

            self.plot.groupedData.forEach(function (s) {
                if (!Array.isArray(s.values)) {
                    return;
                }

                var values = s.values.map(function (d) {
                    return parseFloat(self.config.y.value.call(self.config, d));
                });
                s.values.Q1 = _statisticsUtils.StatisticsUtils.quantile(values, 0.25);
                s.values.Q2 = _statisticsUtils.StatisticsUtils.quantile(values, 0.5);
                s.values.Q3 = _statisticsUtils.StatisticsUtils.quantile(values, 0.75);
                var IQR = s.values.Q3 - s.values.Q1;

                if (!self.config.tukey) {
                    s.values.whiskerLow = d3.min(values);
                    s.values.whiskerHigh = d3.max(values);
                } else {
                    s.values.whiskerLow = s.values.Q1 - 1.5 * IQR;
                    s.values.whiskerHigh = s.values.Q3 + 1.5 * IQR;
                    s.values.outliers = values.filter(function (d) {
                        return d < s.values.whiskerLow || d > s.values.whiskerHigh;
                    });
                }
            });

            return self.plot.groupedData;
        }
    }, {
        key: 'isGroupingEnabled',
        value: function isGroupingEnabled() {
            return this.config.series || !!(this.config.groups && this.config.groups.value);
        }
    }]);

    return BoxPlot;
}(_boxPlotBase.BoxPlotBase);

},{"./box-plot-base":29,"./d3":35,"./statistics-utils":46,"./utils":47}],31:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChartWithColorGroups = exports.ChartWithColorGroupsConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chart = require("./chart");

var _utils = require("./utils");

var _legend = require("./legend");

var _d = require("./d3");

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ChartWithColorGroupsConfig = exports.ChartWithColorGroupsConfig = function (_ChartConfig) {
    _inherits(ChartWithColorGroupsConfig, _ChartConfig);

    function ChartWithColorGroupsConfig(custom) {
        _classCallCheck(this, ChartWithColorGroupsConfig);

        var _this = _possibleConstructorReturn(this, (ChartWithColorGroupsConfig.__proto__ || Object.getPrototypeOf(ChartWithColorGroupsConfig)).call(this));

        _this.showLegend = true;
        _this.forceLegend = false;
        _this.legend = {
            width: 80,
            margin: 10,
            shapeWidth: 20
        };
        _this.groups = {
            key: 2,
            value: function value(d) {
                return d[this.groups.key];
            }, // grouping value accessor,
            label: "",
            displayValue: undefined // optional function returning display value (series label) for given group value, or object/array mapping value to display value
        };
        _this.series = false;
        _this.color = undefined;
        _this.d3ColorCategory = 'category10';

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }

        return _this;
    } // string or function returning color's value for color scale


    return ChartWithColorGroupsConfig;
}(_chart.ChartConfig);

var ChartWithColorGroups = exports.ChartWithColorGroups = function (_Chart) {
    _inherits(ChartWithColorGroups, _Chart);

    function ChartWithColorGroups(placeholderSelector, data, config) {
        _classCallCheck(this, ChartWithColorGroups);

        return _possibleConstructorReturn(this, (ChartWithColorGroups.__proto__ || Object.getPrototypeOf(ChartWithColorGroups)).call(this, placeholderSelector, data, new ChartWithColorGroupsConfig(config)));
    }

    _createClass(ChartWithColorGroups, [{
        key: "setConfig",
        value: function setConfig(config) {
            return _get(ChartWithColorGroups.prototype.__proto__ || Object.getPrototypeOf(ChartWithColorGroups.prototype), "setConfig", this).call(this, new ChartWithColorGroupsConfig(config));
        }
    }, {
        key: "initPlot",
        value: function initPlot() {
            _get(ChartWithColorGroups.prototype.__proto__ || Object.getPrototypeOf(ChartWithColorGroups.prototype), "initPlot", this).call(this);
            var self = this;

            var conf = this.config;

            this.plot.showLegend = conf.showLegend;
            this.setupGroups();
            this.plot.data = this.getDataToPlot();
            this.groupData();

            if (this.plot.showLegend) {
                var scale = this.plot.colorCategory;
                if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
                    this.plot.showLegend = false;
                } else {
                    this.plot.margin.right = conf.margin.right + conf.legend.width + conf.legend.margin * 2;
                }
            }
            return this;
        }
    }, {
        key: "isGroupingEnabled",
        value: function isGroupingEnabled() {
            return this.config.series || !!(this.config.groups && this.config.groups.value);
        }
    }, {
        key: "computeGroupColorDomain",
        value: function computeGroupColorDomain() {
            var _this3 = this;

            var map = d3.set(this.data, function (d) {
                return _this3.plot.groupValue(d);
            });
            return Object.getOwnPropertyNames(map).map(function (d) {
                return map[d];
            });
        }
    }, {
        key: "setupGroups",
        value: function setupGroups() {
            var _this4 = this;

            var self = this;
            var conf = this.config;

            this.plot.groupingEnabled = this.isGroupingEnabled();
            var domain = [];
            if (this.plot.groupingEnabled) {
                self.plot.groupToLabel = {};
                if (this.config.series) {
                    this.plot.groupValue = function (s) {
                        return s.key;
                    };
                    domain = this.computeGroupColorDomain();

                    this.data.forEach(function (s) {
                        self.plot.groupToLabel[s.key] = s.label || s.key;
                    });
                } else {
                    this.plot.groupValue = function (d) {
                        return conf.groups.value.call(conf, d);
                    };
                    domain = this.computeGroupColorDomain();
                    var getLabel = function getLabel(k) {
                        return k;
                    };
                    if (self.config.groups.displayValue) {
                        if (_utils.Utils.isFunction(self.config.groups.displayValue)) {
                            getLabel = function getLabel(k) {
                                return self.config.groups.displayValue(k) || k;
                            };
                        } else if (_utils.Utils.isObject(self.config.groups.displayValue)) {
                            getLabel = function getLabel(k) {
                                return self.config.groups.displayValue[k] || k;
                            };
                        }
                    }
                    domain.forEach(function (k) {
                        self.plot.groupToLabel[k] = getLabel(k);
                    });
                }
            } else {
                this.plot.groupValue = function (d) {
                    return null;
                };
            }
            this.plot.groupColorDomain = domain;
            if (conf.d3ColorCategory) {
                var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);
                this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
            }
            var colorValue = conf.color;

            if (colorValue) {
                if (typeof colorValue === 'string' || colorValue instanceof String) {
                    this.plot.color = colorValue;
                    this.plot.seriesColor = this.plot.color;
                } else {
                    this.plot.color = colorValue;
                    this.plot.seriesColor = this.plot.color;
                    var range = domain.map(function (v) {
                        return _this4.plot.seriesColor({ key: v });
                    });
                    this.plot.colorCategory = d3.scaleOrdinal(range);
                    this.plot.colorCategory.domain(domain);
                }
            } else if (this.plot.colorCategory) {
                self.plot.colorValue = colorValue;
                self.plot.colorCategory.domain(domain);

                this.plot.seriesColor = function (s) {
                    return self.plot.colorCategory(s.key);
                };
                this.plot.color = function (d) {
                    return self.plot.colorCategory(_this4.plot.groupValue(d));
                };
            } else {
                this.plot.color = this.plot.seriesColor = function (s) {
                    return 'black';
                };
            }
        }
    }, {
        key: "groupData",
        value: function groupData() {
            var self = this;
            var data = this.plot.data;
            if (!self.plot.groupingEnabled) {
                self.plot.groupedData = [{
                    key: null,
                    label: '',
                    values: data
                }];
                self.plot.dataLength = data.length;
            } else {

                if (self.config.series) {
                    self.plot.groupedData = data.map(function (s) {
                        return {
                            key: s.key,
                            label: s.label,
                            values: s.values
                        };
                    });
                } else {
                    self.plot.groupedData = d3.nest().key(this.plot.groupValue).entries(data);
                    self.plot.groupedData.forEach(function (g) {
                        g.label = self.plot.groupToLabel[g.key];
                    });
                }

                self.plot.dataLength = d3.sum(this.plot.groupedData, function (s) {
                    return s.values.length;
                });
            }

            // this.plot.seriesColor
        }
    }, {
        key: "getDataToPlot",
        value: function getDataToPlot() {
            var _this5 = this;

            if (!this.plot.groupingEnabled || !this.enabledGroups) {
                return this.data;
            }
            return this.data.filter(function (d) {
                return _this5.enabledGroups.indexOf(_this5.plot.groupValue(d)) > -1;
            });
        }
    }, {
        key: "update",
        value: function update(newData) {
            _get(ChartWithColorGroups.prototype.__proto__ || Object.getPrototypeOf(ChartWithColorGroups.prototype), "update", this).call(this, newData);
            this.updateLegend();

            return this;
        }
    }, {
        key: "updateLegend",
        value: function updateLegend() {

            var self = this;
            var plot = this.plot;

            var scale = plot.colorCategory;

            if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
                plot.showLegend = false;
            }

            if (!plot.showLegend) {
                if (plot.legend && plot.legend.container) {
                    plot.legend.container.remove();
                }
                return;
            }

            var legendX = this.plot.width + this.config.legend.margin;
            var legendY = this.config.legend.margin;

            plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY);

            plot.legendColor = plot.legend.color().shapeWidth(this.config.legend.shapeWidth).orient('vertical').scale(scale).labelWrap(this.config.legend.width).labels(scale.domain().map(function (v) {
                return plot.groupToLabel[v];
            }));

            plot.legendColor.on('cellclick', function (c) {
                return self.onLegendCellClick(c);
            });

            plot.legend.container.call(plot.legendColor);

            this.updateLegendCellStatuses();
        }
    }, {
        key: "onLegendCellClick",
        value: function onLegendCellClick(cellValue) {
            this.updateEnabledGroups(cellValue);
            this.init();
        }
    }, {
        key: "updateLegendCellStatuses",
        value: function updateLegendCellStatuses() {
            var self = this;
            this.plot.legend.container.selectAll("g.cell").each(function (cell) {
                var isDisabled = self.enabledGroups && self.enabledGroups.indexOf(cell) < 0;
                d3.select(this).classed("odc-disabled", isDisabled);
            });
        }
    }, {
        key: "updateEnabledGroups",
        value: function updateEnabledGroups(cellValue) {
            if (!this.enabledGroups) {
                this.enabledGroups = this.plot.colorCategory.domain().slice();
            }
            var index = this.enabledGroups.indexOf(cellValue);

            if (index < 0) {
                this.enabledGroups.push(cellValue);
            } else {
                this.enabledGroups.splice(index, 1);
            }

            if (!this.enabledGroups.length) {
                this.enabledGroups = this.plot.colorCategory.domain().slice();
            }
        }
    }, {
        key: "setData",
        value: function setData(data) {
            _get(ChartWithColorGroups.prototype.__proto__ || Object.getPrototypeOf(ChartWithColorGroups.prototype), "setData", this).call(this, data);
            this.enabledGroups = null;
            return this;
        }
    }]);

    return ChartWithColorGroups;
}(_chart.Chart);

},{"./chart":32,"./d3":35,"./legend":41,"./utils":47}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chart = exports.ChartConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _utils = require('./utils');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ChartConfig = exports.ChartConfig = function ChartConfig(custom) {
    _classCallCheck(this, ChartConfig);

    this.cssClassPrefix = "odc-";
    this.svgClass = this.cssClassPrefix + 'mw-d3-chart';
    this.width = undefined;
    this.height = undefined;
    this.margin = {
        left: 50,
        right: 30,
        top: 30,
        bottom: 50
    };
    this.showTooltip = false;
    this.transition = true;
    this.title = undefined;
    this.titleSize = 20;
    this.titleMargin = {
        left: 0,
        right: 0,
        top: 15,
        bottom: 20
    };
    this.subtitle = undefined;
    this.subtitleSize = 14;
    this.subtitleMargin = {
        left: 0,
        right: 0,
        top: 10,
        bottom: 20
    };

    if (custom) {
        _utils.Utils.deepExtend(this, custom);
    }
};

var Chart = exports.Chart = function () {
    function Chart(base, data, config) {
        _classCallCheck(this, Chart);

        this.utils = _utils.Utils;
        this.plot = {
            margin: {}
        };
        this._attached = {};
        this._layers = {};
        this._events = {};
        this._isInitialized = false;

        this._id = _utils.Utils.guid();
        this._isAttached = base instanceof Chart;

        this.baseContainer = base;

        this.setConfig(config);

        if (data) {
            this.setData(data);
        }
        this.init();
        this.postInit();
    }

    _createClass(Chart, [{
        key: 'setConfig',
        value: function setConfig(config) {
            if (!config) {
                this.config = new ChartConfig();
            } else {
                this.config = config;
            }
            this.initConfigAccessors();
            return this;
        }
    }, {
        key: 'setData',
        value: function setData(data) {
            this.data = data;
            return this;
        }
    }, {
        key: 'init',
        value: function init() {
            var self = this;
            self.initPlot();
            self.initSvg();

            if (!this._isInitialized) {
                self.initTooltip();
            }
            self.draw();
            this._isInitialized = true;
            return this;
        }
    }, {
        key: 'redraw',
        value: function redraw() {
            this.initConfigAccessors(true);
            return this.init();
        }
    }, {
        key: 'postInit',
        value: function postInit() {}
    }, {
        key: 'initSvg',
        value: function initSvg() {
            var self = this;
            var config = this.config;

            var margin = self.plot.margin;
            var width = self.svgWidth = self.plot.width + margin.left + margin.right;
            var height = self.svgHeight = self.plot.height + margin.top + margin.bottom;
            var aspect = width / height;
            if (!self._isAttached) {
                if (!this._isInitialized) {
                    d3.select(self.baseContainer).select("svg").remove();
                }
                self.svg = d3.select(self.baseContainer).selectOrAppend("svg").classed(config.svgClass, true);

                self.svg.attr("width", width).attr("height", height).attr("viewBox", "0 0 " + " " + width + " " + height).attr("preserveAspectRatio", "xMidYMid meet");
                self.svgG = self.svg.selectOrAppend("g.main-group");
            } else {
                // console.log(self.baseContainer);
                self.svg = self.baseContainer.svg;
                self.svgG = self.svg.selectOrAppend("g.main-group." + config.svgClass);
            }

            self.svgG.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            if (!config.width || config.height) {
                d3.select(window).on("resize." + self._id, function () {
                    var transition = self.config.transition;
                    self.config.transition = false;
                    self.init();
                    self.config.transition = transition;
                });
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            d3.select(this.baseContainer).selectAll("*").remove();
            d3.select(window).on("resize." + this._id, null);
        }
    }, {
        key: 'initTooltip',
        value: function initTooltip() {
            var self = this;
            if (self.config.showTooltip) {
                if (!self._isAttached) {
                    self.plot.tooltip = d3.select("body").selectOrAppend('div.' + self.config.cssClassPrefix + 'tooltip').style("opacity", 0);
                } else {
                    self.plot.tooltip = self.baseContainer.plot.tooltip;
                }
            } else {
                self.plot.tooltip = null;
            }
        }
    }, {
        key: 'initPlot',
        value: function initPlot() {
            var margin = this.config.margin;
            this.plot = this.plot || {};
            this.plot.margin = {
                top: margin.top,
                bottom: margin.bottom,
                left: margin.left,
                right: margin.right
            };

            var titleMarginSize = 0;
            if (this.config.title) {
                titleMarginSize = this.config.titleSize + this.config.titleMargin.top;
                if (!this.config.subtitle) {
                    titleMarginSize += this.config.titleMargin.bottom;
                }

                this.plot.margin.top = Math.max(this.plot.margin.top, titleMarginSize);
            }

            if (this.config.subtitle) {

                this.plot.margin.top = Math.max(this.plot.margin.top, titleMarginSize + this.config.subtitleMargin.top + this.config.subtitleSize + this.config.subtitleMargin.bottom);
            }
        }
    }, {
        key: 'update',
        value: function update(data) {
            if (data) {
                this.setData(data);
            }
            this.updateTitle();
            this.updateSubtitle();

            var layerName, attachmentData;
            for (var attachmentName in this._attached) {

                attachmentData = data;

                this._attached[attachmentName].update(attachmentData);
            }
            return this;
        }
    }, {
        key: 'updateTitle',
        value: function updateTitle() {
            var titleClass = this.prefixClass('plot-title');
            if (!this.config.title) {
                this.svg.select("text." + titleClass).remove();
                return;
            }

            this.svg.selectOrAppend("text." + titleClass).attr("transform", "translate(" + this.svgWidth / 2 + "," + this.config.titleMargin.top + ")") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "0.5em").style("text-anchor", "middle").style("dominant-baseline", "central").style("font-size", this.config.titleSize + "px").text(this.config.title);
        }
    }, {
        key: 'updateSubtitle',
        value: function updateSubtitle() {
            var subtitleClass = this.prefixClass('plot-subtitle');
            if (!this.config.subtitle) {
                this.svg.select("text." + subtitleClass).remove();
                return;
            }

            var y = this.config.subtitleMargin.top;
            if (this.config.title) {
                y += this.config.titleMargin.top + this.config.titleSize;
            }

            this.svg.selectOrAppend("text." + subtitleClass).attr("transform", "translate(" + this.svgWidth / 2 + "," + y + ")") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "0.5em").style("text-anchor", "middle").style("dominant-baseline", "central").style("font-size", this.config.subtitleSize + "px").text(this.config.subtitle);
        }
    }, {
        key: 'draw',
        value: function draw(data) {
            this.update(data);

            return this;
        }

        //Borrowed from d3.chart
        /**
         * Register or retrieve an "attachment" Chart. The "attachment" chart's `draw`
         * method will be invoked whenever the containing chart's `draw` method is
         * invoked.
         *
         * @externalExample chart-attach
         *
         * @param {String} attachmentName Name of the attachment
         * @param {Chart} [chart] Chart to register as a mix in of this chart. When
         *        unspecified, this method will return the attachment previously
         *        registered with the specified `attachmentName` (if any).
         *
         * @returns {Chart} Reference to this chart (chainable).
         */

    }, {
        key: 'attach',
        value: function attach(attachmentName, chart) {
            if (arguments.length === 1) {
                return this._attached[attachmentName];
            }

            this._attached[attachmentName] = chart;
            return chart;
        }
    }, {
        key: 'on',

        //Borrowed from d3.chart
        /**
         * Subscribe a callback function to an event triggered on the chart. See {@link
            * Chart#once} to subscribe a callback function to an event for one occurence.
         *
         * @externalExample {runnable} chart-on
         *
         * @param {String} name Name of the event
         * @param {ChartEventHandler} callback Function to be invoked when the event
         *        occurs
         * @param {Object} [context] Value to set as `this` when invoking the
         *        `callback`. Defaults to the chart instance.
         *
         * @returns {Chart} A reference to this chart (chainable).
         */
        value: function on(name, callback, context) {
            var events = this._events[name] || (this._events[name] = []);
            events.push({
                callback: callback,
                context: context || this,
                _chart: this
            });
            return this;
        }

        //Borrowed from d3.chart
        /**
         *
         * Subscribe a callback function to an event triggered on the chart. This
         * function will be invoked at the next occurance of the event and immediately
         * unsubscribed. See {@link Chart#on} to subscribe a callback function to an
         * event indefinitely.
         *
         * @externalExample {runnable} chart-once
         *
         * @param {String} name Name of the event
         * @param {ChartEventHandler} callback Function to be invoked when the event
         *        occurs
         * @param {Object} [context] Value to set as `this` when invoking the
         *        `callback`. Defaults to the chart instance
         *
         * @returns {Chart} A reference to this chart (chainable)
         */

    }, {
        key: 'once',
        value: function once(name, callback, context) {
            var self = this;
            var once = function once() {
                self.off(name, once);
                callback.apply(this, arguments);
            };
            return this.on(name, once, context);
        }

        //Borrowed from d3.chart
        /**
         * Unsubscribe one or more callback functions from an event triggered on the
         * chart. When no arguments are specified, *all* handlers will be unsubscribed.
         * When only a `name` is specified, all handlers subscribed to that event will
         * be unsubscribed. When a `name` and `callback` are specified, only that
         * function will be unsubscribed from that event. When a `name` and `context`
         * are specified (but `callback` is omitted), all events bound to the given
         * event with the given context will be unsubscribed.
         *
         * @externalExample {runnable} chart-off
         *
         * @param {String} [name] Name of the event to be unsubscribed
         * @param {ChartEventHandler} [callback] Function to be unsubscribed
         * @param {Object} [context] Contexts to be unsubscribe
         *
         * @returns {Chart} A reference to this chart (chainable).
         */

    }, {
        key: 'off',
        value: function off(name, callback, context) {
            var names, n, events, event, i, j;

            // remove all events
            if (arguments.length === 0) {
                for (name in this._events) {
                    this._events[name].length = 0;
                }
                return this;
            }

            // remove all events for a specific name
            if (arguments.length === 1) {
                events = this._events[name];
                if (events) {
                    events.length = 0;
                }
                return this;
            }

            // remove all events that match whatever combination of name, context
            // and callback.
            names = name ? [name] : Object.keys(this._events);
            for (i = 0; i < names.length; i++) {
                n = names[i];
                events = this._events[n];
                j = events.length;
                while (j--) {
                    event = events[j];
                    if (callback && callback === event.callback || context && context === event.context) {
                        events.splice(j, 1);
                    }
                }
            }

            return this;
        }
    }, {
        key: 'trigger',

        //Borrowed from d3.chart
        /**
         * Publish an event on this chart with the given `name`.
         *
         * @externalExample {runnable} chart-trigger
         *
         * @param {String} name Name of the event to publish
         * @param {...*} arguments Values with which to invoke the registered
         *        callbacks.
         *
         * @returns {Chart} A reference to this chart (chainable).
         */
        value: function trigger(name) {
            var args = Array.prototype.slice.call(arguments, 1);
            var events = this._events[name];
            var i, ev;

            if (events !== undefined) {
                for (i = 0; i < events.length; i++) {
                    ev = events[i];
                    ev.callback.apply(ev.context, args);
                }
            }

            return this;
        }
    }, {
        key: 'getBaseContainer',
        value: function getBaseContainer() {
            if (this._isAttached) {
                return this.baseContainer.svg;
            }
            return d3.select(this.baseContainer);
        }
    }, {
        key: 'getBaseContainerNode',
        value: function getBaseContainerNode() {

            return this.getBaseContainer().node();
        }
    }, {
        key: 'prefixClass',
        value: function prefixClass(clazz, addDot) {
            return addDot ? '.' : '' + this.config.cssClassPrefix + clazz;
        }
    }, {
        key: 'computePlotSize',
        value: function computePlotSize() {
            this.plot.width = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), this.plot.margin);
            this.plot.height = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), this.plot.margin);
        }
    }, {
        key: 'transitionEnabled',
        value: function transitionEnabled() {
            return this._isInitialized && this.config.transition;
        }
    }, {
        key: 'showTooltip',
        value: function showTooltip(html) {
            if (!this.plot.tooltip) {
                return;
            }
            this.plot.tooltip.transition().duration(200).style("opacity", .9);
            this.plot.tooltip.html(html).style("left", d3.event.pageX + 5 + "px").style("top", d3.event.pageY - 28 + "px");
        }
    }, {
        key: 'hideTooltip',
        value: function hideTooltip() {
            if (!this.plot.tooltip) {
                return;
            }
            this.plot.tooltip.transition().duration(500).style("opacity", 0);
        }
    }, {
        key: 'initConfigAccessors',
        value: function initConfigAccessors(clean) {
            if (clean) {
                this.removePropertyAccessors(this, this, this.config, "$");
            }
            this.initPropertyAccessors(this, this, this.config, "$", true);
        }
    }, {
        key: 'removePropertyAccessors',
        value: function removePropertyAccessors(bindTo, returnObj, source, prefix) {
            var self = this;
            for (var i in source) {
                if (!source.hasOwnProperty(i)) {
                    continue;
                }

                delete bindTo[prefix + i];
            }
        }
    }, {
        key: 'initPropertyAccessors',
        value: function initPropertyAccessors(bindTo, returnObj, source, prefix, recursive) {
            var self = this;
            for (var i in source) {
                if (!source.hasOwnProperty(i)) {
                    continue;
                }

                var accessor = self.initPropertyAccessor(bindTo, returnObj, source, i, prefix);

                if (recursive && _utils.Utils.isObjectNotArray(source[i])) {
                    self.initPropertyAccessors(accessor, bindTo, source[i], prefix, recursive);
                }
            }
        }
    }, {
        key: 'initPropertyAccessor',
        value: function initPropertyAccessor(bindTo, returnObj, source, propertyKey, prefix) {
            return bindTo[prefix + propertyKey] = function (_) {
                if (!arguments.length) {
                    return source[propertyKey];
                }
                source[propertyKey] = _;
                return returnObj;
            };
        }
    }]);

    return Chart;
}();

},{"./d3":35,"./utils":47}],33:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CorrelationMatrix = exports.CorrelationMatrixConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chart = require('./chart');

var _utils = require('./utils');

var _statisticsUtils = require('./statistics-utils');

var _legend = require('./legend');

var _scatterplot = require('./scatterplot');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var CorrelationMatrixConfig = exports.CorrelationMatrixConfig = function (_ChartConfig) {
    _inherits(CorrelationMatrixConfig, _ChartConfig);

    //show axis guides
    function CorrelationMatrixConfig(custom) {
        _classCallCheck(this, CorrelationMatrixConfig);

        var _this = _possibleConstructorReturn(this, (CorrelationMatrixConfig.__proto__ || Object.getPrototypeOf(CorrelationMatrixConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'correlation-matrix';
        _this.guides = false;
        _this.showTooltip = true;
        _this.showLegend = true;
        _this.highlightLabels = true;
        _this.rotateLabelsX = true;
        _this.rotateLabelsY = true;
        _this.variables = {
            labels: undefined,
            keys: [], //optional array of variable keys
            value: function value(d, variableKey) {
                return parseFloat(d[variableKey]);
            }, // variable value accessor
            scale: "ordinal"
        };
        _this.correlation = {
            scale: "linear",
            domain: [-1, -0.75, -0.5, 0, 0.5, 0.75, 1],
            range: ["darkblue", "blue", "lightskyblue", "white", "orangered", "crimson", "darkred"],
            value: function value(xValues, yValues) {
                return _statisticsUtils.StatisticsUtils.sampleCorrelation(xValues, yValues);
            }

        };
        _this.cell = {
            shape: "ellipse", //possible values: rect, circle, ellipse
            size: undefined,
            sizeMin: 15,
            sizeMax: 250,
            padding: 1
        };
        _this.margin = {
            left: 60,
            right: 50,
            top: 30,
            bottom: 60
        };
        _this.groups = {
            key: null
        };

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }
        return _this;
    } //show tooltip on dot hover


    return CorrelationMatrixConfig;
}(_chart.ChartConfig);

var CorrelationMatrix = exports.CorrelationMatrix = function (_Chart) {
    _inherits(CorrelationMatrix, _Chart);

    function CorrelationMatrix(placeholderSelector, data, config) {
        _classCallCheck(this, CorrelationMatrix);

        return _possibleConstructorReturn(this, (CorrelationMatrix.__proto__ || Object.getPrototypeOf(CorrelationMatrix)).call(this, placeholderSelector, data, new CorrelationMatrixConfig(config)));
    }

    _createClass(CorrelationMatrix, [{
        key: 'setConfig',
        value: function setConfig(config) {
            return _get(CorrelationMatrix.prototype.__proto__ || Object.getPrototypeOf(CorrelationMatrix.prototype), 'setConfig', this).call(this, new CorrelationMatrixConfig(config));
        }
    }, {
        key: 'initPlot',
        value: function initPlot() {
            _get(CorrelationMatrix.prototype.__proto__ || Object.getPrototypeOf(CorrelationMatrix.prototype), 'initPlot', this).call(this);
            var self = this;
            var margin = this.config.margin;
            var conf = this.config;

            this.plot.x = {};
            this.plot.correlation = {
                matrix: undefined,
                cells: undefined,
                color: {},
                shape: {}
            };

            this.setupVariables();
            var width = conf.width;
            var placeholderNode = this.getBaseContainerNode();
            this.plot.placeholderNode = placeholderNode;

            var parentWidth = placeholderNode.getBoundingClientRect().width;
            if (width) {

                if (!this.plot.cellSize) {
                    this.plot.cellSize = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (width - margin.left - margin.right) / this.plot.variables.length));
                }
            } else {
                this.plot.cellSize = this.config.cell.size;

                if (!this.plot.cellSize) {
                    this.plot.cellSize = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (parentWidth - margin.left - margin.right) / this.plot.variables.length));
                }

                width = this.plot.cellSize * this.plot.variables.length + margin.left + margin.right;
            }

            var height = width;
            if (!height) {
                height = placeholderNode.getBoundingClientRect().height;
            }

            this.plot.width = width - margin.left - margin.right;
            this.plot.height = this.plot.width;

            this.setupVariablesScales();
            this.setupCorrelationScales();
            this.setupCorrelationMatrix();

            return this;
        }
    }, {
        key: 'setupVariablesScales',
        value: function setupVariablesScales() {

            var plot = this.plot;
            var x = plot.x;
            var conf = this.config.variables;

            /* *
             * value accessor - returns the value to encode for a given data object.
             * scale - maps value to a visual display encoding, such as a pixel position.
             * map function - maps from data value to display value
             * axis - sets up axis
             **/
            x.value = conf.value;
            x.scale = d3.scaleBand().range([plot.width, 0]);
            x.map = function (d) {
                return x.scale(x.value(d));
            };
        }
    }, {
        key: 'setupCorrelationScales',
        value: function setupCorrelationScales() {
            var plot = this.plot;
            var corrConf = this.config.correlation;

            plot.correlation.color.scale = _utils.Utils.createScale(corrConf.scale).domain(corrConf.domain).range(corrConf.range);
            var shape = plot.correlation.shape = {};

            var cellConf = this.config.cell;
            shape.type = cellConf.shape;

            var shapeSize = plot.cellSize - cellConf.padding * 2;
            if (shape.type == 'circle') {
                var radiusMax = shapeSize / 2;
                shape.radiusScale = d3.scaleLinear().domain([0, 1]).range([2, radiusMax]);
                shape.radius = function (c) {
                    return shape.radiusScale(Math.abs(c.value));
                };
            } else if (shape.type == 'ellipse') {
                var radiusMax = shapeSize / 2;
                shape.radiusScale = d3.scaleLinear().domain([0, 1]).range([radiusMax, 2]);
                shape.radiusX = function (c) {
                    return shape.radiusScale(Math.abs(c.value));
                };
                shape.radiusY = radiusMax;

                shape.rotateVal = function (v) {
                    if (v == 0) return "0";
                    if (v < 0) return "-45";
                    return "45";
                };
            } else if (shape.type == 'rect') {
                shape.size = shapeSize;
            }
        }
    }, {
        key: 'setupVariables',
        value: function setupVariables() {

            var variablesConf = this.config.variables;

            var data = this.data;
            var plot = this.plot;
            plot.domainByVariable = {};
            plot.variables = variablesConf.keys;
            if (!plot.variables || !plot.variables.length) {
                plot.variables = _utils.Utils.inferVariables(data, this.config.groups.key, this.config.includeInPlot);
            }

            plot.labels = [];
            plot.labelByVariable = {};
            plot.variables.forEach(function (variableKey, index) {
                plot.domainByVariable[variableKey] = d3.extent(data, function (d) {
                    return variablesConf.value(d, variableKey);
                });
                var label = variableKey;
                if (variablesConf.labels && variablesConf.labels.length > index) {

                    label = variablesConf.labels[index];
                }
                plot.labels.push(label);
                plot.labelByVariable[variableKey] = label;
            });

            // console.log(plot.labelByVariable);
        }
    }, {
        key: 'setupCorrelationMatrix',
        value: function setupCorrelationMatrix() {
            var self = this;
            var data = this.data;
            var matrix = this.plot.correlation.matrix = [];
            var matrixCells = this.plot.correlation.matrix.cells = [];
            var plot = this.plot;

            var variableToValues = {};
            plot.variables.forEach(function (v, i) {

                variableToValues[v] = data.map(function (d) {
                    return plot.x.value(d, v);
                });
            });

            plot.variables.forEach(function (v1, i) {
                var row = [];
                matrix.push(row);

                plot.variables.forEach(function (v2, j) {
                    var corr = 1;
                    if (v1 != v2) {
                        corr = self.config.correlation.value(variableToValues[v1], variableToValues[v2]);
                    }
                    var cell = {
                        rowVar: v1,
                        colVar: v2,
                        row: i,
                        col: j,
                        value: corr
                    };
                    row.push(cell);

                    matrixCells.push(cell);
                });
            });
        }
    }, {
        key: 'update',
        value: function update(newData) {
            _get(CorrelationMatrix.prototype.__proto__ || Object.getPrototypeOf(CorrelationMatrix.prototype), 'update', this).call(this, newData);
            // this.update
            this.updateCells();
            this.updateVariableLabels();

            if (this.config.showLegend) {
                this.updateLegend();
            }
        }
    }, {
        key: 'updateVariableLabels',
        value: function updateVariableLabels() {
            this.plot.labelClass = this.prefixClass("label");
            this.updateAxisX();
            this.updateAxisY();
        }
    }, {
        key: 'updateAxisX',
        value: function updateAxisX() {
            var self = this;
            var plot = self.plot;
            var labelClass = plot.labelClass;
            var labelXClass = labelClass + "-x";

            var labels = self.svgG.selectAll("text." + labelXClass).data(plot.variables, function (d, i) {
                return i;
            });

            var labelsMerge = labels.enter().append("text").attr("class", function (d, i) {
                return labelClass + " " + labelXClass + " " + labelXClass + "-" + i;
            }).merge(labels);

            labelsMerge.attr("x", function (d, i) {
                return i * plot.cellSize + plot.cellSize / 2;
            }).attr("y", plot.height).attr("dx", -2).attr("dy", 5).attr("text-anchor", "end")

            // .attr("dominant-baseline", "hanging")
            .text(function (v) {
                return plot.labelByVariable[v];
            });

            if (this.config.rotateLabelsX) {
                labelsMerge.attr("transform", function (d, i) {
                    return "rotate(-45, " + (i * plot.cellSize + plot.cellSize / 2) + ", " + plot.height + ")";
                });
            }

            var maxWidth = self.computeXAxisLabelsWidth();
            labelsMerge.each(function (label) {
                _utils.Utils.placeTextWithEllipsisAndTooltip(d3.select(this), label, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
            });

            labels.exit().remove();
        }
    }, {
        key: 'updateAxisY',
        value: function updateAxisY() {
            var self = this;
            var plot = self.plot;
            var labelClass = plot.labelClass;
            var labelYClass = plot.labelClass + "-y";
            var labels = self.svgG.selectAll("text." + labelYClass).data(plot.variables);

            var labelsMerge = labels.enter().append("text").merge(labels);

            labelsMerge.attr("x", 0).attr("y", function (d, i) {
                return i * plot.cellSize + plot.cellSize / 2;
            }).attr("dx", -2).attr("text-anchor", "end").attr("class", function (d, i) {
                return labelClass + " " + labelYClass + " " + labelYClass + "-" + i;
            })
            // .attr("dominant-baseline", "hanging")
            .text(function (v) {
                return plot.labelByVariable[v];
            });

            if (this.config.rotateLabelsY) {
                labelsMerge.attr("transform", function (d, i) {
                    return "rotate(-45, " + 0 + ", " + (i * plot.cellSize + plot.cellSize / 2) + ")";
                }).attr("text-anchor", "end");
            }

            var maxWidth = self.computeYAxisLabelsWidth();
            labelsMerge.each(function (label) {
                _utils.Utils.placeTextWithEllipsisAndTooltip(d3.select(this), label, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
            });

            labels.exit().remove();
        }
    }, {
        key: 'computeYAxisLabelsWidth',
        value: function computeYAxisLabelsWidth() {
            var maxWidth = this.plot.margin.left;
            if (!this.config.rotateLabelsY) {
                return maxWidth;
            }

            maxWidth *= _utils.Utils.SQRT_2;
            var fontSize = 11; //todo check actual font size
            maxWidth -= fontSize / 2;

            return maxWidth;
        }
    }, {
        key: 'computeXAxisLabelsWidth',
        value: function computeXAxisLabelsWidth(offset) {
            if (!this.config.rotateLabelsX) {
                return this.plot.cellSize - 2;
            }
            var size = this.plot.margin.bottom;
            size *= _utils.Utils.SQRT_2;
            var fontSize = 11; //todo check actual font size
            size -= fontSize / 2;
            return size;
        }
    }, {
        key: 'updateCells',
        value: function updateCells() {

            var self = this;
            var plot = self.plot;
            var cellClass = self.prefixClass("cell");
            var cellShape = plot.correlation.shape.type;

            var cells = self.svgG.selectAll("g." + cellClass).data(plot.correlation.matrix.cells);

            var cellsEnter = cells.enter().append("g").classed(cellClass, true);
            var cellsMerge = cellsEnter.merge(cells);
            cellsMerge.attr("transform", function (c) {
                return "translate(" + (plot.cellSize * c.col + plot.cellSize / 2) + "," + (plot.cellSize * c.row + plot.cellSize / 2) + ")";
            });

            cellsMerge.classed(self.config.cssClassPrefix + "selectable", !!self.scatterPlot);

            var selector = "*:not(.cell-shape-" + cellShape + ")";

            var wrongShapes = cells.selectAll(selector);
            wrongShapes.remove();

            var shapes = cellsMerge.selectOrAppend(cellShape + ".cell-shape-" + cellShape);

            if (plot.correlation.shape.type == 'circle') {

                shapes.attr("r", plot.correlation.shape.radius).attr("cx", 0).attr("cy", 0);
            }

            if (plot.correlation.shape.type == 'ellipse') {
                // cells.attr("transform", c=> "translate(300,150) rotate("+plot.correlation.shape.rotateVal(c.value)+")");
                shapes.attr("rx", plot.correlation.shape.radiusX).attr("ry", plot.correlation.shape.radiusY).attr("cx", 0).attr("cy", 0).attr("transform", function (c) {
                    return "rotate(" + plot.correlation.shape.rotateVal(c.value) + ")";
                });
            }

            if (plot.correlation.shape.type == 'rect') {
                shapes.attr("width", plot.correlation.shape.size).attr("height", plot.correlation.shape.size).attr("x", -plot.cellSize / 2).attr("y", -plot.cellSize / 2);
            }
            shapes.style("fill", function (c) {
                return plot.correlation.color.scale(c.value);
            });

            var mouseoverCallbacks = [];
            var mouseoutCallbacks = [];

            if (plot.tooltip) {

                mouseoverCallbacks.push(function (c) {
                    var html = c.value;
                    self.showTooltip(html);
                });

                mouseoutCallbacks.push(function (c) {
                    self.hideTooltip();
                });
            }

            if (self.config.highlightLabels) {
                var highlightClass = self.config.cssClassPrefix + "highlight";
                var xLabelClass = function xLabelClass(c) {
                    return plot.labelClass + "-x-" + c.col;
                };
                var yLabelClass = function yLabelClass(c) {
                    return plot.labelClass + "-y-" + c.row;
                };

                mouseoverCallbacks.push(function (c) {

                    self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, true);
                    self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, true);
                });
                mouseoutCallbacks.push(function (c) {
                    self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, false);
                    self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, false);
                });
            }

            cellsMerge.on("mouseover", function (c) {
                mouseoverCallbacks.forEach(function (callback) {
                    return callback(c);
                });
            }).on("mouseout", function (c) {
                mouseoutCallbacks.forEach(function (callback) {
                    return callback(c);
                });
            });

            cellsMerge.on("click", function (c) {
                self.trigger("cell-selected", c);
            });

            cells.exit().remove();
        }
    }, {
        key: 'updateLegend',
        value: function updateLegend() {

            var plot = this.plot;
            var legendX = this.plot.width + 10;
            var legendY = 0;
            var barWidth = 10;
            var barHeight = this.plot.height - 2;
            var scale = plot.correlation.color.scale;

            plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY).linearGradientBar(barWidth, barHeight);
        }
    }, {
        key: 'attachScatterPlot',
        value: function attachScatterPlot(containerSelector, config) {
            var _this3 = this;

            var self = this;

            config = config || {};

            var scatterPlotConfig = {
                height: self.plot.height + self.config.margin.top + self.config.margin.bottom,
                width: self.plot.height + self.config.margin.top + self.config.margin.bottom,
                groups: {
                    key: self.config.groups.key,
                    label: self.config.groups.label
                },
                guides: true,
                showLegend: false
            };

            self.scatterPlot = true;

            scatterPlotConfig = _utils.Utils.deepExtend(scatterPlotConfig, config);
            this.update();

            this.on("cell-selected", function (c) {

                scatterPlotConfig.x = {
                    key: c.rowVar,
                    label: self.plot.labelByVariable[c.rowVar]
                };
                scatterPlotConfig.y = {
                    key: c.colVar,
                    label: self.plot.labelByVariable[c.colVar]
                };
                if (self.scatterPlot && self.scatterPlot !== true) {
                    self.scatterPlot.setConfig(scatterPlotConfig).init();
                } else {
                    self.scatterPlot = new _scatterplot.ScatterPlot(containerSelector, self.data, scatterPlotConfig);
                    _this3.attach("ScatterPlot", self.scatterPlot);
                }
            });
        }
    }]);

    return CorrelationMatrix;
}(_chart.Chart);

},{"./chart":32,"./d3":35,"./legend":41,"./scatterplot":44,"./statistics-utils":46,"./utils":47}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.D3Extensions = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _d = require("./d3");

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var D3Extensions = exports.D3Extensions = function () {
    function D3Extensions() {
        _classCallCheck(this, D3Extensions);
    }

    _createClass(D3Extensions, null, [{
        key: "extend",
        value: function extend() {

            d3.selection.prototype.enter.prototype.insertSelector = d3.selection.prototype.insertSelector = function (selector, before) {
                return D3Extensions.insertSelector(this, selector, before);
            };

            d3.selection.prototype.enter.prototype.appendSelector = d3.selection.prototype.appendSelector = function (selector) {
                return D3Extensions.appendSelector(this, selector);
            };

            d3.selection.prototype.enter.prototype.selectOrAppend = d3.selection.prototype.selectOrAppend = function (selector) {
                return D3Extensions.selectOrAppend(this, selector);
            };

            d3.selection.prototype.enter.prototype.selectOrInsert = d3.selection.prototype.selectOrInsert = function (selector, before) {
                return D3Extensions.selectOrInsert(this, selector, before);
            };
        }
    }, {
        key: "insertOrAppendSelector",
        value: function insertOrAppendSelector(parent, selector, operation, before) {

            var selectorParts = selector.split(/([\.\#])/);
            var element = parent[operation](selectorParts.shift(), before); //":first-child"

            while (selectorParts.length > 1) {
                var selectorModifier = selectorParts.shift();
                var selectorItem = selectorParts.shift();
                if (selectorModifier === ".") {
                    element = element.classed(selectorItem, true);
                } else if (selectorModifier === "#") {
                    element = element.attr('id', selectorItem);
                }
            }
            return element;
        }
    }, {
        key: "insertSelector",
        value: function insertSelector(parent, selector, before) {
            return D3Extensions.insertOrAppendSelector(parent, selector, "insert", before);
        }
    }, {
        key: "appendSelector",
        value: function appendSelector(parent, selector) {
            return D3Extensions.insertOrAppendSelector(parent, selector, "append");
        }
    }, {
        key: "selectOrAppend",
        value: function selectOrAppend(parent, selector, element) {
            var selection = parent.select(selector);
            if (selection.empty()) {
                if (element) {
                    return parent.append(element);
                }
                return D3Extensions.appendSelector(parent, selector);
            }
            return selection;
        }
    }, {
        key: "selectOrInsert",
        value: function selectOrInsert(parent, selector, before) {
            var selection = parent.select(selector);
            if (selection.empty()) {
                return D3Extensions.insertSelector(parent, selector, before);
            }
            return selection;
        }
    }]);

    return D3Extensions;
}();

},{"./d3":35}],35:[function(require,module,exports){
"use strict";

module.exports = d3;

},{}],36:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DivergingStackedBarChart = exports.DivergingStackedBarChartConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chart = require('./chart');

var _utils = require('./utils');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
        }return arr2;
    } else {
        return Array.from(arr);
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var DivergingStackedBarChartConfig = exports.DivergingStackedBarChartConfig = function (_ChartConfig) {
    _inherits(DivergingStackedBarChartConfig, _ChartConfig);

    // string or function returning color's value for color scale
    function DivergingStackedBarChartConfig(custom) {
        _classCallCheck(this, DivergingStackedBarChartConfig);

        var _this = _possibleConstructorReturn(this, (DivergingStackedBarChartConfig.__proto__ || Object.getPrototypeOf(DivergingStackedBarChartConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'diverging-stacked-bar-chart';
        _this.showTooltip = true;
        _this.x = { // X axis config
            title: '', // axis label
            value: function value(d) {
                return d.values;
            }, // x value accessor
            guides: true, //show axis guides
            orient: 'top',
            scale: "linear",
            domainMargin: 0.02
        };
        _this.y = { // Y axis config
            title: '',
            value: function value(d) {
                return d.key;
            }, // y value accessor
            scale: "ordinal",
            orient: 'left',
            guides: true //show axis guides
        };
        _this.transition = true;
        _this.color = undefined;
        _this.d3ColorCategory = 'category10';
        _this.colorRange = undefined;
        _this.categoryNames = undefined;
        _this.middleValue = 0;

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }
        return _this;
    }

    return DivergingStackedBarChartConfig;
}(_chart.ChartConfig);

var DivergingStackedBarChart = exports.DivergingStackedBarChart = function (_Chart) {
    _inherits(DivergingStackedBarChart, _Chart);

    function DivergingStackedBarChart(placeholderSelector, data, config) {
        _classCallCheck(this, DivergingStackedBarChart);

        return _possibleConstructorReturn(this, (DivergingStackedBarChart.__proto__ || Object.getPrototypeOf(DivergingStackedBarChart)).call(this, placeholderSelector, data, new DivergingStackedBarChartConfig(config)));
    }

    _createClass(DivergingStackedBarChart, [{
        key: 'setConfig',
        value: function setConfig(config) {
            return _get(DivergingStackedBarChart.prototype.__proto__ || Object.getPrototypeOf(DivergingStackedBarChart.prototype), 'setConfig', this).call(this, new DivergingStackedBarChartConfig(config));
        }
    }, {
        key: 'initPlot',
        value: function initPlot() {
            _get(DivergingStackedBarChart.prototype.__proto__ || Object.getPrototypeOf(DivergingStackedBarChart.prototype), 'initPlot', this).call(this);
            _get(DivergingStackedBarChart.prototype.__proto__ || Object.getPrototypeOf(DivergingStackedBarChart.prototype), 'computePlotSize', this).call(this);
            this.plot.x = {};
            this.plot.y = {};

            this.plot.data = this.getDataToPlot();
            this.setupY();
            this.setupX();

            this.setupColor();
        }
    }, {
        key: 'getDataToPlot',
        value: function getDataToPlot() {
            return this.data;
        }
    }, {
        key: 'setupX',
        value: function setupX() {
            var _this3 = this;

            var plot = this.plot;
            var x = plot.x;
            var conf = this.config.x;

            x.value = function (d) {
                return conf.value.call(_this3.config, d);
            };
            x.scale = _utils.Utils.createScale(conf.scale).rangeRound([0, plot.width]);
            x.map = function (d) {
                return x.scale(x.value(d));
            };

            x.axis = _utils.Utils.createAxis(conf.orient, x.scale);
            if (conf.guides) {
                x.axis.tickSize(-plot.height);
            }

            var data = this.plot.data;

            plot.categoryNames = this.config.categoryNames;

            plot.neutralIndex = Math.floor(plot.categoryNames.length / 2);

            plot.rows = data.map(function (d) {
                var originalValues = x.value(d);
                var x0 = _this3.config.middleValue - d3.sum(originalValues.map(function (v, i) {
                    return i < plot.neutralIndex ? v : 0;
                }));
                if (plot.categoryNames.length & 1) x0 += -1 * originalValues[plot.neutralIndex] / 2;

                var values = originalValues.map(function (v, i) {
                    return i < plot.neutralIndex ? _this3.config.middleValue - v : _this3.config.middleValue + v;
                });
                var total = d3.sum(originalValues);
                return {
                    datum: d,
                    originalValues: originalValues,
                    values: values,
                    min: x0,
                    max: x0 + total,
                    total: total,
                    boxes: values.map(function (v, i) {
                        return {
                            name: plot.categoryNames[i],
                            x0: x0,
                            x1: x0 += originalValues[i],
                            originalValue: originalValues[i]
                        };
                    })
                };
            });

            var domain;
            if (!data || !data.length) {
                domain = [];
            } else {
                var _ref;

                domain = d3.extent((_ref = []).concat.apply(_ref, _toConsumableArray(plot.rows.map(function (b) {
                    return [b.min, b.max];
                }))));
                var margin = (domain[1] - domain[0]) * conf.domainMargin;
                domain[0] -= margin;
                domain[1] += margin;
            }

            plot.x.scale.domain(domain);
        }
    }, {
        key: 'setupY',
        value: function setupY() {
            var _this4 = this;

            var plot = this.plot;
            var y = plot.y;
            var conf = this.config.y;
            y.value = function (d) {
                return conf.value.call(_this4.config, d);
            };
            y.scale = d3.scaleBand().range([0, plot.height]).padding(.3);
            y.map = function (d) {
                return y.scale(y.value(d));
            };

            y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
            if (conf.ticks) {
                y.axis.ticks(conf.ticks);
            }
            if (conf.guides) {
                y.axis.tickSize(-plot.width);
            }
            this.setupYDomain();
        }
    }, {
        key: 'setupYDomain',
        value: function setupYDomain() {
            var plot = this.plot;
            var data = this.plot.data;
            var c = this.config;

            var domain = data.map(plot.y.value);

            plot.y.scale.domain(domain);
        }
    }, {
        key: 'drawAxisX',
        value: function drawAxisX() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.x;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));

            if (axisConf.orient === 'bottom') {
                axis.attr("transform", "translate(0," + plot.height + ")");
            }

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.x.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.label);
        }
    }, {
        key: 'drawAxisY',
        value: function drawAxisY() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.y;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.y.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: 'drawBars',
        value: function drawBars() {
            var self = this,
                plot = self.plot,
                config = self.config;

            var rowClass = self.prefixClass("row");
            var rows = self.svgG.selectAll("." + rowClass).data(plot.rows);

            var rowEnter = rows.enter().appendSelector("g." + rowClass);

            var rowMerge = rowEnter.merge(rows).attr("transform", function (d) {
                return "translate(0," + plot.y.map(d.datum) + ")";
            });

            rows.exit().remove();

            var barClass = self.prefixClass("bar");

            var bars = rowMerge.selectAll("g." + barClass).data(function (d) {
                return d.boxes;
            });
            bars.exit().remove();

            var barsEnter = bars.enter().append("g").attr("class", barClass);

            barsEnter.append("rect");
            barsEnter.append("text");

            var barsM = barsEnter.merge(bars);

            barsM.select("rect").attr("height", plot.y.scale.bandwidth()).attr("x", function (d) {
                return plot.x.scale(d.x0);
            }).attr("width", function (d) {
                return plot.x.scale(d.x1) - plot.x.scale(d.x0);
            }).style("fill", function (d, i) {
                return plot.color(d.name, i);
            });

            barsM.select("text").attr("x", function (d) {
                return plot.x.scale(d.x0);
            }).attr("y", plot.y.scale.bandwidth() / 2).attr("dy", "0.5em").attr("dx", function (d) {
                return (plot.x.scale(d.x1) - plot.x.scale(d.x0)) / 2;
            }).style("text-anchor", "middle").text(function (d) {
                return d.originalValue !== 0 && d.x1 - d.x0 > 0.04 ? d.originalValue : "";
            });

            self.svgG.selectOrAppend("line." + self.prefixClass("middle-line")).attr("x1", plot.x.scale(self.config.middleValue)).attr("y1", 0).attr("x2", plot.x.scale(self.config.middleValue)).attr("y2", plot.height);
        }
    }, {
        key: 'update',
        value: function update(newData) {
            _get(DivergingStackedBarChart.prototype.__proto__ || Object.getPrototypeOf(DivergingStackedBarChart.prototype), 'update', this).call(this, newData);
            this.drawAxisX();
            this.drawAxisY();
            this.drawBars();
            return this;
        }
    }, {
        key: 'setupColor',
        value: function setupColor() {
            var self = this;
            var conf = this.config;

            if (conf.d3ColorCategory) {
                var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);
                this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
            }

            var colorValue = conf.color;
            if (colorValue && typeof colorValue === 'string' || colorValue instanceof String) {
                this.plot.color = colorValue;
            } else if (conf.colorRange) {
                this.plot.color = _utils.Utils.createScale("ordinal").domain(this.plot.categoryNames).range(conf.colorRange);
            } else if (this.plot.colorCategory) {
                self.plot.colorValue = colorValue;
                this.plot.color = this.plot.colorCategory;
            }
        }
    }]);

    return DivergingStackedBarChart;
}(_chart.Chart);

},{"./chart":32,"./d3":35,"./utils":47}],37:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HeatmapTimeSeries = exports.HeatmapTimeSeriesConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chart = require("./chart");

var _heatmap = require("./heatmap");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var _d = require("./d3");

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var HeatmapTimeSeriesConfig = exports.HeatmapTimeSeriesConfig = function (_HeatmapConfig) {
    _inherits(HeatmapTimeSeriesConfig, _HeatmapConfig);

    function HeatmapTimeSeriesConfig(custom) {
        _classCallCheck(this, HeatmapTimeSeriesConfig);

        var _this = _possibleConstructorReturn(this, (HeatmapTimeSeriesConfig.__proto__ || Object.getPrototypeOf(HeatmapTimeSeriesConfig)).call(this));

        _this.x = {
            fillMissing: false, // fill missing values using interval and intervalStep
            interval: undefined, //used in filling missing ticks
            intervalStep: 1,
            format: undefined, //input data d3 time format
            displayFormat: undefined, //d3 time format for display
            intervalToFormats: [//used to guess interval and format
            {
                name: 'year',
                formats: ["%Y"]
            }, {
                name: 'month',
                formats: ["%Y-%m"]
            }, {
                name: 'day',
                formats: ["%Y-%m-%d"]
            }, {
                name: 'hour',
                formats: ['%H', '%Y-%m-%d %H']
            }, {
                name: 'minute',
                formats: ['%H:%M', '%Y-%m-%d %H:%M']
            }, {
                name: 'second',
                formats: ['%H:%M:%S', '%Y-%m-%d %H:%M:%S']
            }],

            sortComparator: function sortComparator(a, b) {
                return _utils.Utils.isString(a) ? a.localeCompare(b) : a - b;
            },
            formatter: undefined
        };
        _this.z = {
            fillMissing: true // fiill missing values with nearest previous value
        };
        _this.legend = {
            formatter: function formatter(v) {
                var suffix = "";
                if (v / 1000000 >= 1) {
                    suffix = " M";
                    v = Number(v / 1000000).toFixed(3);
                }
                var nf = Intl.NumberFormat();
                return nf.format(v) + suffix;
            }
        };

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }
        return _this;
    }

    return HeatmapTimeSeriesConfig;
}(_heatmap.HeatmapConfig);

var HeatmapTimeSeries = exports.HeatmapTimeSeries = function (_Heatmap) {
    _inherits(HeatmapTimeSeries, _Heatmap);

    function HeatmapTimeSeries(placeholderSelector, data, config) {
        _classCallCheck(this, HeatmapTimeSeries);

        return _possibleConstructorReturn(this, (HeatmapTimeSeries.__proto__ || Object.getPrototypeOf(HeatmapTimeSeries)).call(this, placeholderSelector, data, new HeatmapTimeSeriesConfig(config)));
    }

    _createClass(HeatmapTimeSeries, [{
        key: "setConfig",
        value: function setConfig(config) {
            return _get(HeatmapTimeSeries.prototype.__proto__ || Object.getPrototypeOf(HeatmapTimeSeries.prototype), "setConfig", this).call(this, new HeatmapTimeSeriesConfig(config));
        }
    }, {
        key: "setupValuesBeforeGroupsSort",
        value: function setupValuesBeforeGroupsSort() {
            var _this3 = this;

            this.plot.x.timeFormat = this.config.x.format;
            if (this.config.x.displayFormat && !this.plot.x.timeFormat) {
                this.guessTimeFormat();
            }

            _get(HeatmapTimeSeries.prototype.__proto__ || Object.getPrototypeOf(HeatmapTimeSeries.prototype), "setupValuesBeforeGroupsSort", this).call(this);
            if (!this.config.x.fillMissing) {
                return;
            }

            var self = this;

            this.initTimeFormatAndInterval();

            this.plot.x.intervalStep = this.config.x.intervalStep || 1;

            this.plot.x.timeParser = this.getTimeParser();

            this.plot.x.uniqueValues.sort(this.config.x.sortComparator);

            var prev = null;

            this.plot.x.uniqueValues.forEach(function (x, i) {
                var current = _this3.parseTime(x);
                if (prev === null) {
                    prev = current;
                    return;
                }

                var next = self.nextTimeTickValue(prev);
                var missing = [];
                var iteration = 0;
                while (self.compareTimeValues(next, current) <= 0) {
                    iteration++;
                    if (iteration > 100) {
                        break;
                    }
                    var d = {};
                    var timeString = self.formatTime(next);
                    d[_this3.config.x.key] = timeString;

                    self.updateGroups(d, timeString, self.plot.x.groups, self.config.x.groups);
                    missing.push(next);
                    next = self.nextTimeTickValue(next);
                }
                prev = current;
            });
        }
    }, {
        key: "parseTime",
        value: function parseTime(x) {
            var parser = this.getTimeParser();
            return parser(x);
        }
    }, {
        key: "formatTime",
        value: function formatTime(date) {
            var formatter = this.getTimeFormatter();
            return formatter(date);
        }
    }, {
        key: "formatValueX",
        value: function formatValueX(value) {
            //used only for display
            if (this.config.x.formatter) return this.config.x.formatter.call(this.config, value);

            if (this.config.x.displayFormat) {
                var date = this.parseTime(value);
                return d3.timeFormat(this.config.x.displayFormat)(date);
            }

            if (!this.plot.x.timeFormat) return value;

            if (_utils.Utils.isDate(value)) {
                return this.formatTime(value);
            }

            return value;
        }
    }, {
        key: "compareTimeValues",
        value: function compareTimeValues(a, b) {
            return a - b;
        }
    }, {
        key: "timeValuesEqual",
        value: function timeValuesEqual(a, b) {
            var parser = this.plot.x.timeParser;
            return parser(a) === parser(b);
        }
    }, {
        key: "nextTimeTickValue",
        value: function nextTimeTickValue(t) {
            var interval = 'time' + _utils.Utils.capitalizeFirstLetter(this.plot.x.interval);

            return d3[interval].offset(t, this.plot.x.intervalStep);
        }
    }, {
        key: "initPlot",
        value: function initPlot() {
            _get(HeatmapTimeSeries.prototype.__proto__ || Object.getPrototypeOf(HeatmapTimeSeries.prototype), "initPlot", this).call(this);

            if (this.config.z.fillMissing) {
                this.plot.matrix.forEach(function (row, rowIndex) {
                    var prevRowValue = undefined;
                    row.forEach(function (cell, colIndex) {
                        if (cell.value === undefined && prevRowValue !== undefined) {
                            cell.value = prevRowValue;
                            cell.missing = true;
                        }
                        prevRowValue = cell.value;
                    });
                });
            }
        }
    }, {
        key: "update",
        value: function update(newData) {
            _get(HeatmapTimeSeries.prototype.__proto__ || Object.getPrototypeOf(HeatmapTimeSeries.prototype), "update", this).call(this, newData);
        }
    }, {
        key: "initTimeFormatAndInterval",
        value: function initTimeFormatAndInterval() {

            this.plot.x.interval = this.config.x.interval;

            if (!this.plot.x.timeFormat) {
                this.guessTimeFormat();
            }

            if (!this.plot.x.interval && this.plot.x.timeFormat) {
                this.guessInterval();
            }
        }
    }, {
        key: "guessTimeFormat",
        value: function guessTimeFormat() {
            var self = this;
            for (var i = 0; i < self.config.x.intervalToFormats.length; i++) {
                var intervalFormat = self.config.x.intervalToFormats[i];
                var format = null;
                var formatMatch = intervalFormat.formats.some(function (f) {
                    format = f;
                    var parser = d3.timeParse(f);
                    return self.plot.x.uniqueValues.every(function (x) {
                        return parser(x) !== null;
                    });
                });
                if (formatMatch) {
                    self.plot.x.timeFormat = format;
                    // console.log('Guessed timeFormat', format);
                    if (!self.plot.x.interval) {
                        self.plot.x.interval = intervalFormat.name;
                        // console.log('Guessed interval', self.plot.x.interval);
                    }
                    return;
                }
            }
        }
    }, {
        key: "guessInterval",
        value: function guessInterval() {
            var self = this;
            for (var i = 0; i < self.config.x.intervalToFormats.length; i++) {
                var intervalFormat = self.config.x.intervalToFormats[i];

                if (intervalFormat.formats.indexOf(self.plot.x.timeFormat) >= 0) {
                    self.plot.x.interval = intervalFormat.name;
                    // console.log('Guessed interval', self.plot.x.interval);
                    return;
                }
            }
        }
    }, {
        key: "getTimeFormatter",
        value: function getTimeFormatter() {
            if (!this.plot.x.timeFormatter) {
                this.plot.x.timeFormatter = d3.timeFormat(this.plot.x.timeFormat);
            }
            return this.plot.x.timeFormatter;
        }
    }, {
        key: "getTimeParser",
        value: function getTimeParser() {
            if (!this.plot.x.timeParser) {
                this.plot.x.timeParser = d3.timeParse(this.plot.x.timeFormat);
            }
            return this.plot.x.timeParser;
        }
    }]);

    return HeatmapTimeSeries;
}(_heatmap.Heatmap);

},{"./chart":32,"./d3":35,"./heatmap":38,"./statistics-utils":46,"./utils":47}],38:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Heatmap = exports.HeatmapConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chart = require('./chart');

var _utils = require('./utils');

var _legend = require('./legend');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var HeatmapConfig = exports.HeatmapConfig = function (_ChartConfig) {
    _inherits(HeatmapConfig, _ChartConfig);

    //show tooltip on dot hover
    function HeatmapConfig(custom) {
        _classCallCheck(this, HeatmapConfig);

        var _this = _possibleConstructorReturn(this, (HeatmapConfig.__proto__ || Object.getPrototypeOf(HeatmapConfig)).call(this));

        _this.svgClass = 'odc-heatmap';
        _this.showTooltip = true;
        _this.tooltip = {
            noDataText: "N/A"
        };
        _this.showLegend = true;
        _this.legend = {
            width: 30,
            rotateLabels: false,
            decimalPlaces: undefined,
            formatter: function formatter(v) {
                return _this.legend.decimalPlaces === undefined ? v : Number(v).toFixed(_this.legend.decimalPlaces);
            }
        };
        _this.highlightLabels = true;
        _this.x = { // X axis config
            title: '', // axis title
            key: 0,
            value: function value(d) {
                return d[_this.x.key];
            }, // x value accessor
            rotateLabels: true,
            sortLabels: false,
            sortComparator: function sortComparator(a, b) {
                return _utils.Utils.isNumber(a) ? a - b : a.localeCompare(b);
            },
            groups: {
                keys: [],
                labels: [],
                value: function value(d, key) {
                    return d[key];
                },
                overlap: {
                    top: 20,
                    bottom: 20
                }
            },
            formatter: undefined // value formatter function

        };
        _this.y = { // Y axis config
            title: '', // axis title,
            rotateLabels: true,
            key: 1,
            value: function value(d) {
                return d[_this.y.key];
            }, // y value accessor
            sortLabels: false,
            sortComparator: function sortComparator(a, b) {
                return _utils.Utils.isNumber(b) ? b - a : b.localeCompare(a);
            },
            groups: {
                keys: [],
                labels: [],
                value: function value(d, key) {
                    return d[key];
                },
                overlap: {
                    left: 20,
                    right: 20
                }
            },
            formatter: undefined // value formatter function
        };
        _this.z = {
            key: 2,
            value: function value(d) {
                return d[_this.z.key];
            },
            notAvailableValue: function notAvailableValue(v) {
                return v === null || v === undefined;
            },

            decimalPlaces: undefined,
            formatter: function formatter(v) {
                return _this.z.decimalPlaces === undefined ? v : Number(v).toFixed(_this.z.decimalPlaces);
            } // value formatter function

        };
        _this.color = {
            noDataColor: "white",
            scale: "linear",
            reverseScale: false,
            range: ["darkblue", "lightskyblue", "orange", "crimson", "darkred"]
        };
        _this.cell = {
            width: undefined,
            height: undefined,
            sizeMin: 15,
            sizeMax: 250,
            padding: 0
        };
        _this.margin = {
            left: 60,
            right: 50,
            top: 30,
            bottom: 80
        };

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }
        return _this;
    }

    return HeatmapConfig;
}(_chart.ChartConfig);

//TODO refactor


var Heatmap = exports.Heatmap = function (_Chart) {
    _inherits(Heatmap, _Chart);

    function Heatmap(placeholderSelector, data, config) {
        _classCallCheck(this, Heatmap);

        return _possibleConstructorReturn(this, (Heatmap.__proto__ || Object.getPrototypeOf(Heatmap)).call(this, placeholderSelector, data, new HeatmapConfig(config)));
    }

    _createClass(Heatmap, [{
        key: 'setConfig',
        value: function setConfig(config) {
            return _get(Heatmap.prototype.__proto__ || Object.getPrototypeOf(Heatmap.prototype), 'setConfig', this).call(this, new HeatmapConfig(config));
        }
    }, {
        key: 'initPlot',
        value: function initPlot() {
            _get(Heatmap.prototype.__proto__ || Object.getPrototypeOf(Heatmap.prototype), 'initPlot', this).call(this);
            var self = this;
            var margin = this.config.margin;
            var conf = this.config;

            this.plot.x = {};
            this.plot.y = {};
            this.plot.z = {
                matrixes: undefined,
                cells: undefined,
                color: {},
                shape: {}
            };

            this.setupValues();
            this.buildCells();

            var titleRectWidth = 6;
            this.plot.x.overlap = {
                top: 0,
                bottom: 0
            };
            if (this.plot.groupByX) {
                var depth = self.config.x.groups.keys.length;
                var allTitlesWidth = depth * titleRectWidth;

                this.plot.x.overlap.bottom = self.config.x.groups.overlap.bottom;
                this.plot.x.overlap.top = self.config.x.groups.overlap.top + allTitlesWidth;
                this.plot.margin.top = this.plot.margin.top + conf.x.groups.overlap.top;
                this.plot.margin.bottom = this.plot.margin.bottom + conf.x.groups.overlap.bottom;
            }

            this.plot.y.overlap = {
                left: 0,
                right: 0
            };

            if (this.plot.groupByY) {
                var _depth = self.config.y.groups.keys.length;
                var _allTitlesWidth = _depth * titleRectWidth;
                this.plot.y.overlap.right = self.config.y.groups.overlap.left + _allTitlesWidth;
                this.plot.y.overlap.left = self.config.y.groups.overlap.left;
                this.plot.margin.left = this.plot.margin.left + this.plot.y.overlap.left;
                this.plot.margin.right = this.plot.margin.right + this.plot.y.overlap.right;
            }
            this.plot.showLegend = conf.showLegend;
            if (this.plot.showLegend) {
                this.plot.margin.right += conf.legend.width;
            }
            this.computePlotSize();
            this.setupZScale();

            return this;
        }
    }, {
        key: 'setupValues',
        value: function setupValues() {
            var _this3 = this;

            var self = this;
            var config = self.config;
            var x = self.plot.x;
            var y = self.plot.y;
            var z = self.plot.z;

            x.value = function (d) {
                return config.x.value.call(config, d);
            };
            y.value = function (d) {
                return config.y.value.call(config, d);
            };
            z.value = function (d) {
                return config.z.value.call(config, d);
            };

            x.uniqueValues = [];
            y.uniqueValues = [];

            self.plot.groupByY = !!config.y.groups.keys.length;
            self.plot.groupByX = !!config.x.groups.keys.length;

            y.groups = {
                key: undefined,
                label: '',
                values: [],
                children: null,
                level: 0,
                index: 0,
                lastIndex: 0
            };
            x.groups = {
                key: undefined,
                label: '',
                values: [],
                children: null,
                level: 0,
                index: 0,
                lastIndex: 0
            };

            var valueMap = {};
            var minZ = undefined;
            var maxZ = undefined;
            this.data.forEach(function (d) {

                var xVal = x.value(d);
                var yVal = y.value(d);
                var zValRaw = z.value(d);
                var zVal = config.z.notAvailableValue(zValRaw) ? undefined : parseFloat(zValRaw);

                if (x.uniqueValues.indexOf(xVal) === -1) {
                    x.uniqueValues.push(xVal);
                }

                if (y.uniqueValues.indexOf(yVal) === -1) {
                    y.uniqueValues.push(yVal);
                }

                var groupY = y.groups;
                if (self.plot.groupByY) {
                    groupY = _this3.updateGroups(d, yVal, y.groups, config.y.groups);
                }
                var groupX = x.groups;
                if (self.plot.groupByX) {

                    groupX = _this3.updateGroups(d, xVal, x.groups, config.x.groups);
                }

                if (!valueMap[groupY.index]) {
                    valueMap[groupY.index] = {};
                }

                if (!valueMap[groupY.index][groupX.index]) {
                    valueMap[groupY.index][groupX.index] = {};
                }
                if (!valueMap[groupY.index][groupX.index][yVal]) {
                    valueMap[groupY.index][groupX.index][yVal] = {};
                }
                valueMap[groupY.index][groupX.index][yVal][xVal] = zVal;

                if (minZ === undefined || zVal < minZ) {
                    minZ = zVal;
                }
                if (maxZ === undefined || zVal > maxZ) {
                    maxZ = zVal;
                }
            });
            self.plot.valueMap = valueMap;

            if (!self.plot.groupByX) {
                x.groups.values = x.uniqueValues;
            }

            if (!self.plot.groupByY) {
                y.groups.values = y.uniqueValues;
            }

            this.setupValuesBeforeGroupsSort();

            x.gaps = [];
            x.totalValuesCount = 0;
            x.allValuesList = [];
            this.sortGroups(x, x.groups, config.x);

            y.gaps = [];
            y.totalValuesCount = 0;
            y.allValuesList = [];
            this.sortGroups(y, y.groups, config.y);

            z.min = minZ;
            z.max = maxZ;
        }
    }, {
        key: 'setupValuesBeforeGroupsSort',
        value: function setupValuesBeforeGroupsSort() {}
    }, {
        key: 'buildCells',
        value: function buildCells() {
            var self = this;
            var x = self.plot.x;
            var y = self.plot.y;
            var z = self.plot.z;
            var valueMap = self.plot.valueMap;

            var matrixCells = self.plot.cells = [];
            var matrix = self.plot.matrix = [];

            y.allValuesList.forEach(function (v1, i) {
                var row = [];
                matrix.push(row);

                x.allValuesList.forEach(function (v2, j) {
                    var zVal = undefined;
                    try {
                        zVal = valueMap[v1.group.index][v2.group.index][v1.val][v2.val];
                    } catch (e) {}

                    var cell = {
                        rowVar: v1,
                        colVar: v2,
                        row: i,
                        col: j,
                        value: zVal
                    };
                    row.push(cell);

                    matrixCells.push(cell);
                });
            });
        }
    }, {
        key: 'updateGroups',
        value: function updateGroups(d, axisVal, rootGroup, axisGroupsConfig) {

            var config = this.config;
            var currentGroup = rootGroup;
            axisGroupsConfig.keys.forEach(function (groupKey, groupKeyIndex) {
                currentGroup.key = groupKey;

                if (!currentGroup.children) {
                    currentGroup.children = {};
                }

                var groupingValue = axisGroupsConfig.value.call(config, d, groupKey);

                if (!currentGroup.children.hasOwnProperty(groupingValue)) {
                    rootGroup.lastIndex++;
                    currentGroup.children[groupingValue] = {
                        values: [],
                        children: null,
                        groupingValue: groupingValue,
                        level: currentGroup.level + 1,
                        index: rootGroup.lastIndex,
                        key: groupKey
                    };
                }

                currentGroup = currentGroup.children[groupingValue];
            });

            if (currentGroup.values.indexOf(axisVal) === -1) {
                currentGroup.values.push(axisVal);
            }

            return currentGroup;
        }
    }, {
        key: 'sortGroups',
        value: function sortGroups(axis, group, axisConfig, gaps) {
            if (axisConfig.groups.labels && axisConfig.groups.labels.length > group.level) {
                group.label = axisConfig.groups.labels[group.level];
            } else {
                group.label = group.key;
            }

            if (!gaps) {
                gaps = [0];
            }
            if (gaps.length <= group.level) {
                gaps.push(0);
            }

            group.allValuesCount = group.allValuesCount || 0;
            group.allValuesBeforeCount = group.allValuesBeforeCount || 0;

            group.gaps = gaps.slice();
            group.gapsBefore = gaps.slice();

            group.gapsSize = Heatmap.computeGapsSize(group.gaps);
            group.gapsBeforeSize = group.gapsSize;
            if (group.values) {
                if (axisConfig.sortLabels) {
                    group.values.sort(axisConfig.sortComparator);
                }
                group.values.forEach(function (v) {
                    return axis.allValuesList.push({ val: v, group: group });
                });
                group.allValuesBeforeCount = axis.totalValuesCount;
                axis.totalValuesCount += group.values.length;
                group.allValuesCount += group.values.length;
            }

            group.childrenList = [];
            if (group.children) {
                var childrenCount = 0;

                for (var childProp in group.children) {
                    if (group.children.hasOwnProperty(childProp)) {
                        var child = group.children[childProp];
                        group.childrenList.push(child);
                        childrenCount++;

                        this.sortGroups(axis, child, axisConfig, gaps);
                        group.allValuesCount += child.allValuesCount;
                        gaps[group.level] += 1;
                    }
                }

                if (gaps && childrenCount > 1) {
                    gaps[group.level] -= 1;
                }

                group.gapsInside = [];
                gaps.forEach(function (d, i) {
                    group.gapsInside.push(d - (group.gapsBefore[i] || 0));
                });
                group.gapsInsideSize = Heatmap.computeGapsSize(group.gapsInside);

                if (axis.gaps.length < gaps.length) {
                    axis.gaps = gaps;
                }
            }
        }
    }, {
        key: 'computeYAxisLabelsWidth',
        value: function computeYAxisLabelsWidth(offset) {
            var maxWidth = this.plot.margin.left;
            if (this.config.y.title) {
                maxWidth -= 15;
            }
            if (offset && offset.x) {
                maxWidth += offset.x;
            }

            if (this.config.y.rotateLabels) {
                maxWidth *= _utils.Utils.SQRT_2;
                var fontSize = 11; //todo check actual font size
                maxWidth -= fontSize / 2;
            }

            return maxWidth;
        }
    }, {
        key: 'computeXAxisLabelsWidth',
        value: function computeXAxisLabelsWidth(offset) {
            if (!this.config.x.rotateLabels) {
                return this.plot.cellWidth - 2;
            }
            var size = this.plot.margin.bottom;
            if (this.config.x.title) {
                size -= 15;
            }
            if (offset && offset.y) {
                size -= offset.y;
            }

            size *= _utils.Utils.SQRT_2;

            var fontSize = 11; //todo check actual font size
            size -= fontSize / 2;

            return size;
        }
    }, {
        key: 'computePlotSize',
        value: function computePlotSize() {

            var plot = this.plot;
            var conf = this.config;
            var margin = plot.margin;
            var availableWidth = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), this.plot.margin);
            var availableHeight = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), this.plot.margin);
            var width = availableWidth;
            var height = availableHeight;

            var xGapsSize = Heatmap.computeGapsSize(plot.x.gaps);

            var computedCellWidth = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (availableWidth - xGapsSize) / this.plot.x.totalValuesCount));
            if (this.config.width) {

                if (!this.config.cell.width) {
                    this.plot.cellWidth = computedCellWidth;
                }
            } else {
                this.plot.cellWidth = this.config.cell.width;

                if (!this.plot.cellWidth) {
                    this.plot.cellWidth = computedCellWidth;
                }
            }
            width = this.plot.cellWidth * this.plot.x.totalValuesCount + margin.left + margin.right + xGapsSize;

            var yGapsSize = Heatmap.computeGapsSize(plot.y.gaps);
            var computedCellHeight = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (availableHeight - yGapsSize) / this.plot.y.totalValuesCount));
            if (this.config.height) {
                if (!this.config.cell.height) {
                    this.plot.cellHeight = computedCellHeight;
                }
            } else {
                this.plot.cellHeight = this.config.cell.height;

                if (!this.plot.cellHeight) {
                    this.plot.cellHeight = computedCellHeight;
                }
            }

            height = this.plot.cellHeight * this.plot.y.totalValuesCount + margin.top + margin.bottom + yGapsSize;

            this.plot.width = width - margin.left - margin.right;
            this.plot.height = height - margin.top - margin.bottom;
        }
    }, {
        key: 'setupZScale',
        value: function setupZScale() {

            var self = this;
            var config = self.config;
            var z = self.plot.z;
            var range = config.color.range;
            var extent = z.max - z.min;
            var scale;
            z.domain = [];
            if (config.color.scale == "pow") {
                var exponent = 10;
                range.forEach(function (c, i) {
                    var v = z.max - extent / Math.pow(10, i);
                    z.domain.push(v);
                });
                scale = d3.scalePow().exponent(exponent);
            } else if (config.color.scale == "log") {

                range.forEach(function (c, i) {
                    var v = z.min + extent / Math.pow(10, i);
                    z.domain.unshift(v);
                });

                scale = d3.scaleLog();
            } else {
                range.forEach(function (c, i) {
                    var v = z.min + extent * (i / (range.length - 1));
                    z.domain.push(v);
                });
                scale = _utils.Utils.createScale(config.color.scale);
            }

            z.domain[0] = z.min; //removing unnecessary floating points
            z.domain[z.domain.length - 1] = z.max; //removing unnecessary floating points
            // console.log(z.domain);

            if (config.color.reverseScale) {
                z.domain.reverse();
            }

            var plot = this.plot;

            // console.log(range);

            plot.z.color.scale = scale.domain(z.domain).range(range);
            var shape = plot.z.shape = {};

            var cellConf = this.config.cell;
            shape.type = "rect";

            plot.z.shape.width = plot.cellWidth - cellConf.padding * 2;
            plot.z.shape.height = plot.cellHeight - cellConf.padding * 2;
        }
    }, {
        key: 'update',
        value: function update(newData) {
            _get(Heatmap.prototype.__proto__ || Object.getPrototypeOf(Heatmap.prototype), 'update', this).call(this, newData);
            if (this.plot.groupByY) {
                this.drawGroupsY(this.plot.y.groups, this.svgG);
            }
            if (this.plot.groupByX) {
                this.drawGroupsX(this.plot.x.groups, this.svgG);
            }

            this.updateCells();

            // this.updateVariableLabels();

            this.updateAxisX();
            this.updateAxisY();

            if (this.config.showLegend) {
                this.updateLegend();
            }

            this.updateAxisTitles();
        }
    }, {
        key: 'updateAxisTitles',
        value: function updateAxisTitles() {
            var self = this;
            var plot = self.plot;
        }
    }, {
        key: 'updateAxisX',
        value: function updateAxisX() {
            var self = this;
            var plot = self.plot;
            var labelClass = self.prefixClass("label");
            var labelXClass = labelClass + "-x";
            var labelYClass = labelClass + "-y";
            plot.labelClass = labelClass;

            var offsetX = {
                x: 0,
                y: 0
            };
            var gapSize = Heatmap.computeGapSize(0);
            if (plot.groupByX) {
                var overlap = self.config.x.groups.overlap;

                offsetX.x = gapSize / 2;
                offsetX.y = overlap.bottom + gapSize / 2 + 6;
            } else if (plot.groupByY) {
                offsetX.y = gapSize;
            }

            var labels = self.svgG.selectAll("text." + labelXClass).data(plot.x.allValuesList, function (d, i) {
                return i;
            });

            var labelsMerge = labels.enter().append("text").attr("class", function (d, i) {
                return labelClass + " " + labelXClass + " " + labelXClass + "-" + i;
            }).merge(labels);

            labelsMerge.attr("x", function (d, i) {
                return i * plot.cellWidth + plot.cellWidth / 2 + d.group.gapsSize + offsetX.x;
            }).attr("y", plot.height + offsetX.y).attr("dy", 10).attr("text-anchor", "middle").text(function (d) {
                return self.formatValueX(d.val);
            });

            var maxWidth = self.computeXAxisLabelsWidth(offsetX);

            labelsMerge.each(function (label) {
                var elem = d3.select(this),
                    text = self.formatValueX(label.val);
                _utils.Utils.placeTextWithEllipsisAndTooltip(elem, text, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
            });

            if (self.config.x.rotateLabels) {
                labelsMerge.attr("transform", function (d, i) {
                    return "rotate(-45, " + (i * plot.cellWidth + plot.cellWidth / 2 + d.group.gapsSize + offsetX.x) + ", " + (plot.height + offsetX.y) + ")";
                }).attr("dx", -2).attr("dy", 8).attr("text-anchor", "end");
            }

            labels.exit().remove();

            self.svgG.selectOrAppend("g." + self.prefixClass('axis-x')).attr("transform", "translate(" + plot.width / 2 + "," + (plot.height + plot.margin.bottom) + ")").selectOrAppend("text." + self.prefixClass('label')).attr("dy", "-0.5em").style("text-anchor", "middle").text(self.config.x.title);
        }
    }, {
        key: 'updateAxisY',
        value: function updateAxisY() {
            var self = this;
            var plot = self.plot;
            var labelClass = self.prefixClass("label");
            var labelYClass = labelClass + "-y";
            plot.labelClass = labelClass;

            var labels = self.svgG.selectAll("text." + labelYClass).data(plot.y.allValuesList);

            var labelsEnter = labels.enter().append("text");
            var labelsMerge = labelsEnter.merge(labels);

            var offsetY = {
                x: 0,
                y: 0
            };
            if (plot.groupByY) {
                var overlap = self.config.y.groups.overlap;
                var gapSize = Heatmap.computeGapSize(0);
                offsetY.x = -overlap.left;

                offsetY.y = gapSize / 2;
            }
            labelsMerge.attr("x", offsetY.x).attr("y", function (d, i) {
                return i * plot.cellHeight + plot.cellHeight / 2 + d.group.gapsSize + offsetY.y;
            }).attr("dx", -2).attr("text-anchor", "end").attr("class", function (d, i) {
                return labelClass + " " + labelYClass + " " + labelYClass + "-" + i;
            }).text(function (d) {
                var formatted = self.formatValueY(d.val);
                return formatted;
            });

            var maxWidth = self.computeYAxisLabelsWidth(offsetY);

            labelsMerge.each(function (label) {
                var elem = d3.select(this),
                    text = self.formatValueY(label.val);
                _utils.Utils.placeTextWithEllipsisAndTooltip(elem, text, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
            });

            if (self.config.y.rotateLabels) {
                labelsMerge.attr("transform", function (d, i) {
                    return "rotate(-45, " + offsetY.x + ", " + (d.group.gapsSize + (i * plot.cellHeight + plot.cellHeight / 2) + offsetY.y) + ")";
                }).attr("text-anchor", "end");
                // .attr("dx", -7);
            } else {
                labelsMerge.attr("dominant-baseline", "middle");
            }

            labels.exit().remove();

            self.svgG.selectOrAppend("g." + self.prefixClass('axis-y')).selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)").attr("dy", "1em").style("text-anchor", "middle").text(self.config.y.title);
        }
    }, {
        key: 'drawGroupsY',
        value: function drawGroupsY(parentGroup, container, availableWidth) {

            var self = this;
            var plot = self.plot;

            var groupClass = self.prefixClass("group");
            var groupYClass = groupClass + "-y";
            var groups = container.selectAll("g." + groupClass + "." + groupYClass).data(parentGroup.childrenList);

            var valuesBeforeCount = 0;
            var gapsBeforeSize = 0;

            var groupsEnter = groups.enter().append("g");
            groupsEnter.classed(groupClass, true).classed(groupYClass, true).append("rect").classed("group-rect", true);

            var titleGroupEnter = groupsEnter.appendSelector("g.title");
            titleGroupEnter.append("rect");
            titleGroupEnter.append("text");

            var gapSize = Heatmap.computeGapSize(parentGroup.level);
            var padding = gapSize / 4;

            var titleRectWidth = Heatmap.groupTitleRectHeight;
            var depth = self.config.y.groups.keys.length - parentGroup.level;
            var overlap = {
                left: 0,
                right: 0
            };

            if (!availableWidth) {
                overlap.right = plot.y.overlap.left;
                overlap.left = plot.y.overlap.left;
                availableWidth = plot.width + gapSize + overlap.left + overlap.right;
            }

            var groupsMerge = groupsEnter.merge(groups);

            groupsMerge.attr("transform", function (d, i) {
                var translate = "translate(" + (padding - overlap.left) + "," + (plot.cellHeight * valuesBeforeCount + i * gapSize + gapsBeforeSize + padding) + ")";
                gapsBeforeSize += d.gapsInsideSize || 0;
                valuesBeforeCount += d.allValuesCount || 0;
                return translate;
            });

            var groupWidth = availableWidth - padding * 2;

            var titleGroups = groupsMerge.selectAll("g.title").attr("transform", function (d, i) {
                return "translate(" + (groupWidth - titleRectWidth) + ", 0)";
            });

            var tileRects = titleGroups.selectAll("rect").attr("width", titleRectWidth).attr("height", function (d) {
                return (d.gapsInsideSize || 0) + plot.cellHeight * d.allValuesCount + padding * 2;
            }).attr("x", 0).attr("y", 0)
            // .attr("fill", "lightgrey")
            .attr("stroke-width", 0);

            this.setGroupMouseCallbacks(parentGroup, tileRects);

            groupsMerge.selectAll("rect.group-rect").attr("class", function (d) {
                return "group-rect group-rect-" + d.index;
            }).attr("width", groupWidth).attr("height", function (d) {
                return (d.gapsInsideSize || 0) + plot.cellHeight * d.allValuesCount + padding * 2;
            }).attr("x", 0).attr("y", 0).attr("fill", "white").attr("fill-opacity", 0).attr("stroke-width", 0.5).attr("stroke", "black");

            groupsMerge.each(function (group) {

                self.drawGroupsY.call(self, group, d3.select(this), groupWidth - titleRectWidth);
            });

            groups.exit().remove();
        }
    }, {
        key: 'drawGroupsX',
        value: function drawGroupsX(parentGroup, container, availableHeight) {

            var self = this;
            var plot = self.plot;

            var groupClass = self.prefixClass("group");
            var groupXClass = groupClass + "-x";
            var groups = container.selectAll("g." + groupClass + "." + groupXClass).data(parentGroup.childrenList);

            var valuesBeforeCount = 0;
            var gapsBeforeSize = 0;

            var groupsEnter = groups.enter().append("g");
            groupsEnter.classed(groupClass, true).classed(groupXClass, true).append("rect").classed("group-rect", true);

            var titleGroupEnter = groupsEnter.appendSelector("g.title");
            titleGroupEnter.append("rect");
            titleGroupEnter.append("text");

            var gapSize = Heatmap.computeGapSize(parentGroup.level);
            var padding = gapSize / 4;
            var titleRectHeight = Heatmap.groupTitleRectHeight;

            var depth = self.config.x.groups.keys.length - parentGroup.level;

            var overlap = {
                top: 0,
                bottom: 0
            };

            if (!availableHeight) {
                overlap.bottom = plot.x.overlap.bottom;
                overlap.top = plot.x.overlap.top;
                availableHeight = plot.height + gapSize + overlap.top + overlap.bottom;
            } else {
                overlap.top = -titleRectHeight;
            }
            // console.log('parentGroup',parentGroup, 'gapSize', gapSize, plot.x.overlap);

            var groupsMerge = groupsEnter.merge(groups);

            groupsMerge.attr("transform", function (d, i) {
                var translate = "translate(" + (plot.cellWidth * valuesBeforeCount + i * gapSize + gapsBeforeSize + padding) + ", " + (padding - overlap.top) + ")";
                gapsBeforeSize += d.gapsInsideSize || 0;
                valuesBeforeCount += d.allValuesCount || 0;
                return translate;
            });

            var groupHeight = availableHeight - padding * 2;

            var titleGroups = groupsMerge.selectAll("g.title").attr("transform", function (d, i) {
                return "translate(0, " + 0 + ")";
            });

            var tileRects = titleGroups.selectAll("rect").attr("height", titleRectHeight).attr("width", function (d) {
                return (d.gapsInsideSize || 0) + plot.cellWidth * d.allValuesCount + padding * 2;
            }).attr("x", 0).attr("y", 0)
            // .attr("fill", "lightgrey")
            .attr("stroke-width", 0);

            this.setGroupMouseCallbacks(parentGroup, tileRects);

            groupsMerge.selectAll("rect.group-rect").attr("class", function (d) {
                return "group-rect group-rect-" + d.index;
            }).attr("height", groupHeight).attr("width", function (d) {
                return (d.gapsInsideSize || 0) + plot.cellWidth * d.allValuesCount + padding * 2;
            }).attr("x", 0).attr("y", 0).attr("fill", "white").attr("fill-opacity", 0).attr("stroke-width", 0.5).attr("stroke", "black");

            groupsMerge.each(function (group) {
                self.drawGroupsX.call(self, group, d3.select(this), groupHeight - titleRectHeight);
            });

            groups.exit().remove();
        }
    }, {
        key: 'setGroupMouseCallbacks',
        value: function setGroupMouseCallbacks(parentGroup, tileRects) {
            var plot = this.plot;
            var self = this;
            var mouseoverCallbacks = [];
            mouseoverCallbacks.push(function (d) {
                d3.select(this).classed('highlighted', true);
                d3.select(this.parentNode.parentNode).selectAll("rect.group-rect-" + d.index).classed('highlighted', true);
            });

            var mouseoutCallbacks = [];
            mouseoutCallbacks.push(function (d) {
                d3.select(this).classed('highlighted', false);
                d3.select(this.parentNode.parentNode).selectAll("rect.group-rect-" + d.index).classed('highlighted', false);
            });
            if (plot.tooltip) {

                mouseoverCallbacks.push(function (d) {
                    var html = parentGroup.label + ": " + d.groupingValue;
                    self.showTooltip(html);
                });

                mouseoutCallbacks.push(function (d) {
                    self.hideTooltip();
                });
            }
            tileRects.on("mouseover", function (d) {
                var self = this;
                mouseoverCallbacks.forEach(function (callback) {
                    callback.call(self, d);
                });
            });
            tileRects.on("mouseout", function (d) {
                var self = this;
                mouseoutCallbacks.forEach(function (callback) {
                    callback.call(self, d);
                });
            });
        }
    }, {
        key: 'updateCells',
        value: function updateCells() {

            var self = this;
            var plot = self.plot;
            var cellContainerClass = self.prefixClass("cells");
            var gapSize = Heatmap.computeGapSize(0);
            var paddingX = plot.x.groups.childrenList.length ? gapSize / 2 : 0;
            var paddingY = plot.y.groups.childrenList.length ? gapSize / 2 : 0;
            var cellContainer = self.svgG.selectOrAppend("g." + cellContainerClass);
            cellContainer.attr("transform", "translate(" + paddingX + ", " + paddingY + ")");

            var cellClass = self.prefixClass("cell");
            var cellShape = plot.z.shape.type;

            var cells = cellContainer.selectAll("g." + cellClass).data(self.plot.cells);

            var cellEnter = cells.enter().append("g").classed(cellClass, true);

            var cellsMerge = cellEnter.merge(cells);
            cellsMerge.attr("transform", function (c) {
                return "translate(" + (plot.cellWidth * c.col + plot.cellWidth / 2 + c.colVar.group.gapsSize) + "," + (plot.cellHeight * c.row + plot.cellHeight / 2 + c.rowVar.group.gapsSize) + ")";
            });

            var shapes = cellsMerge.selectOrAppend(cellShape + ".cell-shape-" + cellShape);

            shapes.attr("width", plot.z.shape.width).attr("height", plot.z.shape.height).attr("x", -plot.cellWidth / 2).attr("y", -plot.cellHeight / 2);

            shapes.style("fill", function (c) {
                return c.value === undefined ? self.config.color.noDataColor : plot.z.color.scale(c.value);
            });
            shapes.attr("fill-opacity", function (d) {
                return d.value === undefined ? 0 : 1;
            });

            var mouseoverCallbacks = [];
            var mouseoutCallbacks = [];

            if (plot.tooltip) {

                mouseoverCallbacks.push(function (c) {
                    var html = c.value === undefined ? self.config.tooltip.noDataText : self.formatValueZ(c.value);
                    self.showTooltip(html);
                });

                mouseoutCallbacks.push(function (c) {
                    self.hideTooltip();
                });
            }

            if (self.config.highlightLabels) {
                var highlightClass = self.config.cssClassPrefix + "highlight";
                var xLabelClass = function xLabelClass(c) {
                    return plot.labelClass + "-x-" + c.col;
                };
                var yLabelClass = function yLabelClass(c) {
                    return plot.labelClass + "-y-" + c.row;
                };

                mouseoverCallbacks.push(function (c) {

                    self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, true);
                    self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, true);
                });
                mouseoutCallbacks.push(function (c) {
                    self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, false);
                    self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, false);
                });
            }

            cellsMerge.on("mouseover", function (c) {
                mouseoverCallbacks.forEach(function (callback) {
                    return callback(c);
                });
            }).on("mouseout", function (c) {
                mouseoutCallbacks.forEach(function (callback) {
                    return callback(c);
                });
            });

            cellsMerge.on("click", function (c) {
                self.trigger("cell-selected", c);
            });

            cells.exit().remove();
        }
    }, {
        key: 'formatValueX',
        value: function formatValueX(value) {
            if (!this.config.x.formatter) return value;

            return this.config.x.formatter.call(this.config, value);
        }
    }, {
        key: 'formatValueY',
        value: function formatValueY(value) {
            if (!this.config.y.formatter) return value;

            return this.config.y.formatter.call(this.config, value);
        }
    }, {
        key: 'formatValueZ',
        value: function formatValueZ(value) {
            if (!this.config.z.formatter) return value;

            return this.config.z.formatter.call(this.config, value);
        }
    }, {
        key: 'formatLegendValue',
        value: function formatLegendValue(value) {
            if (!this.config.legend.formatter) return value;

            return this.config.legend.formatter.call(this.config, value);
        }
    }, {
        key: 'updateLegend',
        value: function updateLegend() {
            var self = this;
            var plot = this.plot;
            var legendX = this.plot.width + 10;
            var gapSize = Heatmap.computeGapSize(0);
            if (this.plot.groupByY) {
                legendX += gapSize / 2 + plot.y.overlap.right;
            } else if (this.plot.groupByX) {
                legendX += gapSize;
            }
            var legendY = 0;
            if (this.plot.groupByX || this.plot.groupByY) {
                legendY += gapSize / 2;
            }

            var barWidth = 10;
            var barHeight = this.plot.height - 2;
            var scale = plot.z.color.scale;

            plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY, function (v) {
                return self.formatLegendValue(v);
            }).setRotateLabels(self.config.legend.rotateLabels).linearGradientBar(barWidth, barHeight);
        }
    }], [{
        key: 'computeGapSize',
        value: function computeGapSize(gapLevel) {
            return Heatmap.maxGroupGapSize / (gapLevel + 1);
        }
    }, {
        key: 'computeGapsSize',
        value: function computeGapsSize(gaps) {
            var gapsSize = 0;
            gaps.forEach(function (gapsNumber, gapsLevel) {
                return gapsSize += gapsNumber * Heatmap.computeGapSize(gapsLevel);
            });
            return gapsSize;
        }
    }]);

    return Heatmap;
}(_chart.Chart);

Heatmap.maxGroupGapSize = 24;
Heatmap.groupTitleRectHeight = 6;

},{"./chart":32,"./d3":35,"./legend":41,"./utils":47}],39:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Histogram = exports.HistogramConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chartWithColorGroups = require('./chart-with-color-groups');

var _utils = require('./utils');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var HistogramConfig = exports.HistogramConfig = function (_ChartWithColorGroups) {
    _inherits(HistogramConfig, _ChartWithColorGroups);

    function HistogramConfig(custom) {
        _classCallCheck(this, HistogramConfig);

        var _this = _possibleConstructorReturn(this, (HistogramConfig.__proto__ || Object.getPrototypeOf(HistogramConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'histogram';
        _this.showLegend = true;
        _this.showTooltip = true;
        _this.x = { // X axis config
            title: '', // axis label
            key: 0,
            value: function value(d, key) {
                return _utils.Utils.isNumber(d) ? d : parseFloat(d[key]);
            }, // x value accessor
            scale: "linear",
            orient: "bottom",
            ticks: undefined
        };
        _this.y = { // Y axis config
            title: '', // axis label,
            orient: "left",
            scale: "linear"
        };
        _this.frequency = true;
        _this.groups = {
            key: 1
        };
        _this.transition = true;

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }

        return _this;
    }

    return HistogramConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

var Histogram = exports.Histogram = function (_ChartWithColorGroups2) {
    _inherits(Histogram, _ChartWithColorGroups2);

    function Histogram(placeholderSelector, data, config) {
        _classCallCheck(this, Histogram);

        return _possibleConstructorReturn(this, (Histogram.__proto__ || Object.getPrototypeOf(Histogram)).call(this, placeholderSelector, data, new HistogramConfig(config)));
    }

    _createClass(Histogram, [{
        key: 'setConfig',
        value: function setConfig(config) {
            return _get(Histogram.prototype.__proto__ || Object.getPrototypeOf(Histogram.prototype), 'setConfig', this).call(this, new HistogramConfig(config));
        }
    }, {
        key: 'initPlot',
        value: function initPlot() {
            _get(Histogram.prototype.__proto__ || Object.getPrototypeOf(Histogram.prototype), 'initPlot', this).call(this);
            var self = this;

            var conf = this.config;

            this.plot.x = {};
            this.plot.y = {};
            this.plot.bar = {
                color: null //color scale mapping function
            };

            this.computePlotSize();

            this.setupX();
            this.setupHistogram();
            this.setupGroupStacks();
            this.setupY();
            return this;
        }
    }, {
        key: 'setupX',
        value: function setupX() {

            var plot = this.plot;
            var x = plot.x;
            var conf = this.config.x;

            /* *
             * value accessor - returns the value to encode for a given data object.
             * scale - maps value to a visual display encoding, such as a pixel position.
             * map function - maps from data value to display value
             * axis - sets up axis
             **/
            x.value = function (d) {
                return conf.value(d, conf.key);
            };
            x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);
            x.map = function (d) {
                return x.scale(x.value(d));
            };

            x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

            if (conf.ticks) {
                x.axis.ticks(conf.ticks);
            }
            var data = this.plot.groupedData;
            plot.x.scale.domain([d3.min(data, function (s) {
                return d3.min(s.values, plot.x.value);
            }), d3.max(data, function (s) {
                return d3.max(s.values, plot.x.value);
            })]);
        }
    }, {
        key: 'setupY',
        value: function setupY() {

            var plot = this.plot;
            var y = plot.y;
            var conf = this.config.y;
            y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

            y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
            var data = this.plot.data;
            var yStackMax = d3.max(plot.stackedHistograms, function (layer) {
                return d3.max(layer.histogramBins, function (d) {
                    return d.y0 + d.y;
                });
            });
            plot.y.scale.domain([0, yStackMax]);
        }
    }, {
        key: 'setupHistogram',
        value: function setupHistogram() {
            var plot = this.plot;
            var x = plot.x;
            var y = plot.y;
            var ticks = this.config.x.ticks ? x.scale.ticks(this.config.x.ticks) : x.scale.ticks();

            plot.histogram = d3.histogram().domain(x.scale.domain()).value(x.value).thresholds(ticks);
        }
    }, {
        key: 'setupGroupStacks',
        value: function setupGroupStacks() {
            var _this3 = this;

            var self = this;
            var y0s = [];
            this.plot.groupedData.forEach(function (d) {
                d.histogramBins = _this3.plot.histogram(d.values);

                d.histogramBins.forEach(function (b, i) {
                    b.x = b.x0;
                    b.dx = b.x1 - b.x0;
                    b.y = b.length;
                    var prevY0 = y0s[i];
                    if (!prevY0) prevY0 = 0;
                    b.y0 = prevY0;

                    if (!_this3.config.frequency) {
                        b.y /= _this3.plot.dataLength;
                    }
                    y0s[i] = b.y + prevY0;
                });
            });
            var keys = this.plot.groupedData.map(function (d) {
                return d.key;
            });
            // console.log(this.plot.groupedData);

            this.plot.stack = d3.stack().keys(keys).value(function (d) {
                return d.histogramBins;
            });
            this.plot.stackedHistograms = this.plot.groupedData;
        }
    }, {
        key: 'drawAxisX',
        value: function drawAxisX() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.x;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.x.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: 'drawAxisY',
        value: function drawAxisY() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.y;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));

            var axisT = axis;
            if (self.config.transition) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.y.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: 'drawHistogram',
        value: function drawHistogram() {
            var self = this;
            var plot = self.plot;

            var layerClass = this.prefixClass("layer");

            var barClass = this.prefixClass("bar");
            var layer = self.svgG.selectAll("." + layerClass).data(plot.stackedHistograms);

            var layerMerge = layer.enter().append("g").attr("class", layerClass).merge(layer);

            var bar = layerMerge.selectAll("." + barClass).data(function (d) {
                return d.histogramBins;
            });

            var barEnter = bar.enter().append("g");
            barEnter.attr("class", barClass).append("rect").attr("x", 1);

            var barMerge = barEnter.merge(bar);
            var barRect = barMerge.select("rect");

            var barRectT = barRect;
            var barT = barMerge;
            var layerT = layerMerge;
            if (this.transitionEnabled()) {
                barRectT = barRect.transition();
                barT = barMerge.transition();
                layerT = layerMerge.transition();
            }

            barT.attr("transform", function (d) {
                return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0 + d.y) + ")";
            });
            var rectWidth = plot.stackedHistograms.length ? plot.stackedHistograms[0].histogramBins.length ? plot.x.scale(plot.stackedHistograms[0].histogramBins[0].x1) - plot.x.scale(plot.stackedHistograms[0].histogramBins[0].x0) - 1 : 0 : 0;

            barRectT.attr("width", function (d) {
                return Math.max(0, plot.x.scale(d.x1) - plot.x.scale(d.x0) - 1);
            }).attr("height", function (d) {
                return plot.height - plot.y.scale(d.y);
            });

            if (this.plot.color) {
                layerT.attr("fill", this.plot.seriesColor);
            }

            if (plot.tooltip) {
                barMerge.on("mouseover", function (d) {
                    self.showTooltip(d.y);
                }).on("mouseout", function (d) {
                    self.hideTooltip();
                });
            }
            layer.exit().remove();
            bar.exit().remove();
        }
    }, {
        key: 'update',
        value: function update(newData) {
            _get(Histogram.prototype.__proto__ || Object.getPrototypeOf(Histogram.prototype), 'update', this).call(this, newData);
            this.drawAxisX();
            this.drawAxisY();

            this.drawHistogram();
            return this;
        }
    }]);

    return Histogram;
}(_chartWithColorGroups.ChartWithColorGroups);

},{"./chart-with-color-groups":31,"./d3":35,"./utils":47}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Legend = exports.Utils = exports.StatisticsUtils = exports.DivergingStackedBarChartConfig = exports.DivergingStackedBarChart = exports.BoxPlotConfig = exports.BoxPlot = exports.BoxPlotBaseConfig = exports.BoxPlotBase = exports.BarChartConfig = exports.BarChart = exports.HistogramConfig = exports.Histogram = exports.HeatmapTimeSeriesConfig = exports.HeatmapTimeSeries = exports.HeatmapConfig = exports.Heatmap = exports.CorrelationMatrixConfig = exports.CorrelationMatrix = exports.RegressionConfig = exports.Regression = exports.ScatterPlotMatrixConfig = exports.ScatterPlotMatrix = exports.ScatterPlotConfig = exports.ScatterPlot = undefined;

var _scatterplot = require("./scatterplot");

Object.defineProperty(exports, "ScatterPlot", {
  enumerable: true,
  get: function get() {
    return _scatterplot.ScatterPlot;
  }
});
Object.defineProperty(exports, "ScatterPlotConfig", {
  enumerable: true,
  get: function get() {
    return _scatterplot.ScatterPlotConfig;
  }
});

var _scatterplotMatrix = require("./scatterplot-matrix");

Object.defineProperty(exports, "ScatterPlotMatrix", {
  enumerable: true,
  get: function get() {
    return _scatterplotMatrix.ScatterPlotMatrix;
  }
});
Object.defineProperty(exports, "ScatterPlotMatrixConfig", {
  enumerable: true,
  get: function get() {
    return _scatterplotMatrix.ScatterPlotMatrixConfig;
  }
});

var _regression = require("./regression");

Object.defineProperty(exports, "Regression", {
  enumerable: true,
  get: function get() {
    return _regression.Regression;
  }
});
Object.defineProperty(exports, "RegressionConfig", {
  enumerable: true,
  get: function get() {
    return _regression.RegressionConfig;
  }
});

var _correlationMatrix = require("./correlation-matrix");

Object.defineProperty(exports, "CorrelationMatrix", {
  enumerable: true,
  get: function get() {
    return _correlationMatrix.CorrelationMatrix;
  }
});
Object.defineProperty(exports, "CorrelationMatrixConfig", {
  enumerable: true,
  get: function get() {
    return _correlationMatrix.CorrelationMatrixConfig;
  }
});

var _heatmap = require("./heatmap");

Object.defineProperty(exports, "Heatmap", {
  enumerable: true,
  get: function get() {
    return _heatmap.Heatmap;
  }
});
Object.defineProperty(exports, "HeatmapConfig", {
  enumerable: true,
  get: function get() {
    return _heatmap.HeatmapConfig;
  }
});

var _heatmapTimeseries = require("./heatmap-timeseries");

Object.defineProperty(exports, "HeatmapTimeSeries", {
  enumerable: true,
  get: function get() {
    return _heatmapTimeseries.HeatmapTimeSeries;
  }
});
Object.defineProperty(exports, "HeatmapTimeSeriesConfig", {
  enumerable: true,
  get: function get() {
    return _heatmapTimeseries.HeatmapTimeSeriesConfig;
  }
});

var _histogram = require("./histogram");

Object.defineProperty(exports, "Histogram", {
  enumerable: true,
  get: function get() {
    return _histogram.Histogram;
  }
});
Object.defineProperty(exports, "HistogramConfig", {
  enumerable: true,
  get: function get() {
    return _histogram.HistogramConfig;
  }
});

var _barChart = require("./bar-chart");

Object.defineProperty(exports, "BarChart", {
  enumerable: true,
  get: function get() {
    return _barChart.BarChart;
  }
});
Object.defineProperty(exports, "BarChartConfig", {
  enumerable: true,
  get: function get() {
    return _barChart.BarChartConfig;
  }
});

var _boxPlotBase = require("./box-plot-base");

Object.defineProperty(exports, "BoxPlotBase", {
  enumerable: true,
  get: function get() {
    return _boxPlotBase.BoxPlotBase;
  }
});
Object.defineProperty(exports, "BoxPlotBaseConfig", {
  enumerable: true,
  get: function get() {
    return _boxPlotBase.BoxPlotBaseConfig;
  }
});

var _boxPlot = require("./box-plot");

Object.defineProperty(exports, "BoxPlot", {
  enumerable: true,
  get: function get() {
    return _boxPlot.BoxPlot;
  }
});
Object.defineProperty(exports, "BoxPlotConfig", {
  enumerable: true,
  get: function get() {
    return _boxPlot.BoxPlotConfig;
  }
});

var _divergingStackedBarChart = require("./diverging-stacked-bar-chart");

Object.defineProperty(exports, "DivergingStackedBarChart", {
  enumerable: true,
  get: function get() {
    return _divergingStackedBarChart.DivergingStackedBarChart;
  }
});
Object.defineProperty(exports, "DivergingStackedBarChartConfig", {
  enumerable: true,
  get: function get() {
    return _divergingStackedBarChart.DivergingStackedBarChartConfig;
  }
});

var _statisticsUtils = require("./statistics-utils");

Object.defineProperty(exports, "StatisticsUtils", {
  enumerable: true,
  get: function get() {
    return _statisticsUtils.StatisticsUtils;
  }
});

var _utils = require("./utils");

Object.defineProperty(exports, "Utils", {
  enumerable: true,
  get: function get() {
    return _utils.Utils;
  }
});

var _legend = require("./legend");

Object.defineProperty(exports, "Legend", {
  enumerable: true,
  get: function get() {
    return _legend.Legend;
  }
});

var _d3Extensions = require("./d3-extensions");

_d3Extensions.D3Extensions.extend();

},{"./bar-chart":28,"./box-plot":30,"./box-plot-base":29,"./correlation-matrix":33,"./d3-extensions":34,"./diverging-stacked-bar-chart":36,"./heatmap":38,"./heatmap-timeseries":37,"./histogram":39,"./legend":41,"./regression":42,"./scatterplot":44,"./scatterplot-matrix":43,"./statistics-utils":46,"./utils":47}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Legend = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _utils = require("./utils");

var _d3SvgLegend = require("d3-svg-legend");

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

/*var d3 = require('../bower_components/d3');
*/
// var legend = require('../bower_components/d3-legend/no-extend');
//
// module.exports.legend = legend;

var Legend = exports.Legend = function () {
    function Legend(svg, legendParent, scale, legendX, legendY, labelFormat) {
        _classCallCheck(this, Legend);

        this.cssClassPrefix = "odc-";
        this.legendClass = this.cssClassPrefix + "legend";
        this.color = _d3SvgLegend.legendColor;
        this.size = _d3SvgLegend.legendSize;
        this.symbol = _d3SvgLegend.legendSymbol;
        this.labelFormat = undefined;

        this.scale = scale;
        this.svg = svg;
        this.guid = _utils.Utils.guid();
        this.container = _utils.Utils.selectOrAppend(legendParent, "g." + this.legendClass, "g").attr("transform", "translate(" + legendX + "," + legendY + ")").classed(this.legendClass, true);

        this.labelFormat = labelFormat;
    }

    _createClass(Legend, [{
        key: "linearGradientBar",
        value: function linearGradientBar(barWidth, barHeight, title) {
            var gradientId = this.cssClassPrefix + "linear-gradient" + "-" + this.guid;
            var scale = this.scale;
            var self = this;

            this.linearGradient = _utils.Utils.linearGradient(this.svg, gradientId, this.scale.range(), 0, 100, 0, 0);

            this.container.selectOrAppend("rect").attr("width", barWidth).attr("height", barHeight).attr("x", 0).attr("y", 0).style("fill", "url(#" + gradientId + ")");

            var ticks = this.container.selectAll("text").data(scale.domain());
            var ticksNumber = scale.domain().length - 1;
            var ticksMerge = ticks.enter().append("text").merge(ticks);

            ticksMerge.attr("x", barWidth).attr("y", function (d, i) {
                return barHeight - i * barHeight / ticksNumber;
            }).attr("dx", 3)
            // .attr("dy", 1)
            .attr("alignment-baseline", "middle").text(function (d) {
                return self.labelFormat ? self.labelFormat(d) : d;
            });
            ticksMerge.attr("dominant-baseline", "middle");
            if (this.rotateLabels) {
                ticksMerge.attr("transform", function (d, i) {
                    return "rotate(-45, " + barWidth + ", " + (barHeight - i * barHeight / ticksNumber) + ")";
                }).attr("text-anchor", "start").attr("dx", 5).attr("dy", 5);
            } else {}

            ticks.exit().remove();

            return this;
        }
    }, {
        key: "setRotateLabels",
        value: function setRotateLabels(rotateLabels) {
            this.rotateLabels = rotateLabels;
            return this;
        }
    }]);

    return Legend;
}();

},{"./utils":47,"d3-svg-legend":9}],42:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Regression = exports.RegressionConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chart = require("./chart");

var _scatterplot = require("./scatterplot");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var _d = require("./d3");

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var RegressionConfig = exports.RegressionConfig = function (_ScatterPlotConfig) {
    _inherits(RegressionConfig, _ScatterPlotConfig);

    function RegressionConfig(custom) {
        _classCallCheck(this, RegressionConfig);

        var _this = _possibleConstructorReturn(this, (RegressionConfig.__proto__ || Object.getPrototypeOf(RegressionConfig)).call(this));

        _this.mainRegression = true;
        _this.groupRegression = true;
        _this.confidence = {
            level: 0.95,
            criticalValue: function criticalValue(degreesOfFreedom, criticalProbability) {
                return _statisticsUtils.StatisticsUtils.tValue(degreesOfFreedom, criticalProbability);
            },
            marginOfError: undefined, //custom  margin Of Error function (x, points)
            areaCurve: d3.curveNatural
        };

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }

        return _this;
    }

    return RegressionConfig;
}(_scatterplot.ScatterPlotConfig);

var Regression = exports.Regression = function (_ScatterPlot) {
    _inherits(Regression, _ScatterPlot);

    function Regression(placeholderSelector, data, config) {
        _classCallCheck(this, Regression);

        return _possibleConstructorReturn(this, (Regression.__proto__ || Object.getPrototypeOf(Regression)).call(this, placeholderSelector, data, new RegressionConfig(config)));
    }

    _createClass(Regression, [{
        key: "setConfig",
        value: function setConfig(config) {
            return _get(Regression.prototype.__proto__ || Object.getPrototypeOf(Regression.prototype), "setConfig", this).call(this, new RegressionConfig(config));
        }
    }, {
        key: "initPlot",
        value: function initPlot() {
            _get(Regression.prototype.__proto__ || Object.getPrototypeOf(Regression.prototype), "initPlot", this).call(this);
            this.initRegressionLines();
        }
    }, {
        key: "initRegressionLines",
        value: function initRegressionLines() {

            var self = this;
            var groupsAvailable = self.plot.groupingEnabled;

            self.plot.regressions = [];

            if (groupsAvailable && self.config.mainRegression) {
                var regression = this.initRegression(this.plot.data, false);
                self.plot.regressions.push(regression);
            }

            if (self.config.groupRegression) {
                this.initGroupRegression();
            }
        }
    }, {
        key: "initGroupRegression",
        value: function initGroupRegression() {
            var _this3 = this;

            var self = this;

            self.plot.groupedData.forEach(function (group) {
                if (group.values.length < 2) {
                    return;
                }

                var regression = _this3.initRegression(group.values, group.key);
                self.plot.regressions.push(regression);
            });
        }
    }, {
        key: "initRegression",
        value: function initRegression(values, groupVal) {
            var self = this;

            var points = values.map(function (d) {
                return [parseFloat(self.plot.x.value(d)), parseFloat(self.plot.y.value(d))];
            });

            // points.sort((a,b) => a[0]-b[0]);

            var linearRegression = _statisticsUtils.StatisticsUtils.linearRegression(points);
            var linearRegressionLine = _statisticsUtils.StatisticsUtils.linearRegressionLine(linearRegression);

            var extentX = d3.extent(points, function (d) {
                return d[0];
            });

            var linePoints = [{
                x: extentX[0],
                y: linearRegressionLine(extentX[0])
            }, {
                x: extentX[1],
                y: linearRegressionLine(extentX[1])
            }];

            var line = d3.line().curve(d3.curveBasis).x(function (d) {
                return self.plot.x.scale(d.x);
            }).y(function (d) {
                return self.plot.y.scale(d.y);
            });

            var color = self.plot.color;

            var defaultColor = "black";
            if (_utils.Utils.isFunction(color)) {
                if (values.length && groupVal !== false) {
                    if (self.config.series) {
                        color = self.plot.colorCategory(groupVal);
                    } else {
                        color = color(values[0]);
                    }
                } else {
                    color = defaultColor;
                }
            } else if (!color && groupVal === false) {
                color = defaultColor;
            }

            var confidence = this.computeConfidence(points, extentX, linearRegression, linearRegressionLine);
            return {
                group: groupVal || false,
                line: line,
                linePoints: linePoints,
                color: color,
                confidence: confidence
            };
        }
    }, {
        key: "computeConfidence",
        value: function computeConfidence(points, extentX, linearRegression, linearRegressionLine) {
            var self = this;
            var slope = linearRegression.m;
            var n = points.length;
            var degreesOfFreedom = Math.max(0, n - 2);

            var alpha = 1 - self.config.confidence.level;
            var criticalProbability = 1 - alpha / 2;
            var criticalValue = self.config.confidence.criticalValue(degreesOfFreedom, criticalProbability);

            var xValues = points.map(function (d) {
                return d[0];
            });
            var meanX = _statisticsUtils.StatisticsUtils.mean(xValues);
            var xMySum = 0;
            var xSum = 0;
            var xPowSum = 0;
            var ySum = 0;
            var yPowSum = 0;
            points.forEach(function (p) {
                var x = p[0];
                var y = p[1];

                xMySum += x * y;
                xSum += x;
                ySum += y;
                xPowSum += x * x;
                yPowSum += y * y;
            });
            var a = linearRegression.m;
            var b = linearRegression.b;

            var Sa2 = n / (n + 2) * ((yPowSum - a * xMySum - b * ySum) / (n * xPowSum - xSum * xSum)); //Wariancja współczynnika kierunkowego regresji liniowej a
            var Sy2 = (yPowSum - a * xMySum - b * ySum) / (n * (n - 2)); //Sa2 //Mean y value variance

            var errorFn = function errorFn(x) {
                return Math.sqrt(Sy2 + Math.pow(x - meanX, 2) * Sa2);
            }; //pierwiastek kwadratowy z wariancji dowolnego punktu prostej
            var marginOfError = function marginOfError(x) {
                return criticalValue * errorFn(x);
            };

            // console.log('n', n, 'degreesOfFreedom', degreesOfFreedom, 'criticalProbability',criticalProbability);
            // var confidenceDown = x => linearRegressionLine(x) -  marginOfError(x);
            // var confidenceUp = x => linearRegressionLine(x) +  marginOfError(x);


            var computeConfidenceAreaPoint = function computeConfidenceAreaPoint(x) {
                var linearRegression = linearRegressionLine(x);
                var moe = marginOfError(x);
                var confDown = linearRegression - moe;
                var confUp = linearRegression + moe;
                return {
                    x: x,
                    y0: confDown,
                    y1: confUp
                };
            };

            var centerX = (extentX[1] + extentX[0]) / 2;

            // var confidenceAreaPoints = [extentX[0], centerX,  extentX[1]].map(computeConfidenceAreaPoint);
            var confidenceAreaPoints = [extentX[0], centerX, extentX[1]].map(computeConfidenceAreaPoint);

            var fitInPlot = function fitInPlot(y) {
                return y;
            };

            var confidenceArea = d3.area().curve(self.config.confidence.areaCurve).x(function (d) {
                return self.plot.x.scale(d.x);
            }).y0(function (d) {
                return fitInPlot(self.plot.y.scale(d.y0));
            }).y1(function (d) {
                return fitInPlot(self.plot.y.scale(d.y1));
            });

            return {
                area: confidenceArea,
                points: confidenceAreaPoints
            };
        }
    }, {
        key: "update",
        value: function update(newData) {
            _get(Regression.prototype.__proto__ || Object.getPrototypeOf(Regression.prototype), "update", this).call(this, newData);
            this.updateRegressionLines();
        }
    }, {
        key: "updateRegressionLines",
        value: function updateRegressionLines() {
            var self = this;
            var regressionContainerClass = this.prefixClass("regression-container");
            var regressionContainerSelector = "g." + regressionContainerClass;

            var clipPathId = self.prefixClass("clip");

            var regressionContainer = self.svgG.selectOrInsert(regressionContainerSelector, "." + self.dotsContainerClass);
            var regressionContainerClip = regressionContainer.selectOrAppend("clipPath").attr("id", clipPathId);

            regressionContainerClip.selectOrAppend('rect').attr('width', self.plot.width).attr('height', self.plot.height).attr('x', 0).attr('y', 0);

            regressionContainer.attr("clip-path", function (d, i) {
                return "url(#" + clipPathId + ")";
            });

            var regressionClass = this.prefixClass("regression");
            var confidenceAreaClass = self.prefixClass("confidence");
            var regressionSelector = "g." + regressionClass;
            var regression = regressionContainer.selectAll(regressionSelector).data(self.plot.regressions, function (d, i) {
                return d.group;
            });

            var regressionEnter = regression.enter().appendSelector(regressionSelector);
            var regressionMerge = regressionEnter.merge(regression);
            var lineClass = self.prefixClass("line");
            regressionEnter.append("path").attr("class", lineClass).attr("shape-rendering", "optimizeQuality");

            var line = regressionMerge.select("path." + lineClass).style("stroke", function (r) {
                return r.color;
            });

            var lineT = line;
            if (self.transitionEnabled()) {
                lineT = line.transition();
            }

            lineT.attr("d", function (r) {
                return r.line(r.linePoints);
            });

            regressionEnter.append("path").attr("class", confidenceAreaClass).attr("shape-rendering", "optimizeQuality").style("opacity", "0.4");

            var area = regressionMerge.select("path." + confidenceAreaClass);

            var areaT = area;
            if (self.transitionEnabled()) {
                areaT = area.transition();
            }
            areaT.attr("d", function (r) {
                return r.confidence.area(r.confidence.points);
            });
            areaT.style("fill", function (r) {
                return r.color;
            });
            regression.exit().remove();
        }
    }]);

    return Regression;
}(_scatterplot.ScatterPlot);

},{"./chart":32,"./d3":35,"./scatterplot":44,"./statistics-utils":46,"./utils":47}],43:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScatterPlotMatrix = exports.ScatterPlotMatrixConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chartWithColorGroups = require("./chart-with-color-groups");

var _scatterplot = require("./scatterplot");

var _utils = require("./utils");

var _legend = require("./legend");

var _d = require("./d3");

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ScatterPlotMatrixConfig = exports.ScatterPlotMatrixConfig = function (_ScatterPlotConfig) {
    _inherits(ScatterPlotMatrixConfig, _ScatterPlotConfig);

    //ticks number, (default: computed using cell size)
    //show axis guides
    //scatter plot cell padding
    function ScatterPlotMatrixConfig(custom) {
        _classCallCheck(this, ScatterPlotMatrixConfig);

        var _this = _possibleConstructorReturn(this, (ScatterPlotMatrixConfig.__proto__ || Object.getPrototypeOf(ScatterPlotMatrixConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'scatterplot-matrix';
        _this.size = undefined;
        _this.minCellSize = 50;
        _this.maxCellSize = 1000;
        _this.padding = 20;
        _this.brush = true;
        _this.guides = true;
        _this.showTooltip = true;
        _this.ticks = undefined;
        _this.x = { // X axis config
            orient: "bottom",
            scale: "linear"
        };
        _this.y = { // Y axis config
            orient: "left",
            scale: "linear"
        };
        _this.groups = {
            key: undefined, //object property name or array index with grouping variable
            includeInPlot: false //include group as variable in plot, boolean (default: false)
        };
        _this.variables = {
            labels: [], //optional array of variable labels (for the diagonal of the plot).
            keys: [], //optional array of variable keys
            value: function value(d, variableKey) {
                return d[variableKey];
            } // variable value accessor
        };

        _utils.Utils.deepExtend(_this, custom);
        return _this;
    } //show tooltip on dot hover
    //scatter plot cell size


    return ScatterPlotMatrixConfig;
}(_scatterplot.ScatterPlotConfig);

var ScatterPlotMatrix = exports.ScatterPlotMatrix = function (_ChartWithColorGroups) {
    _inherits(ScatterPlotMatrix, _ChartWithColorGroups);

    function ScatterPlotMatrix(placeholderSelector, data, config) {
        _classCallCheck(this, ScatterPlotMatrix);

        return _possibleConstructorReturn(this, (ScatterPlotMatrix.__proto__ || Object.getPrototypeOf(ScatterPlotMatrix)).call(this, placeholderSelector, data, new ScatterPlotMatrixConfig(config)));
    }

    _createClass(ScatterPlotMatrix, [{
        key: "setConfig",
        value: function setConfig(config) {
            return _get(ScatterPlotMatrix.prototype.__proto__ || Object.getPrototypeOf(ScatterPlotMatrix.prototype), "setConfig", this).call(this, new ScatterPlotMatrixConfig(config));
        }
    }, {
        key: "initPlot",
        value: function initPlot() {
            _get(ScatterPlotMatrix.prototype.__proto__ || Object.getPrototypeOf(ScatterPlotMatrix.prototype), "initPlot", this).call(this);

            var self = this;
            var margin = this.plot.margin;
            var conf = this.config;
            this.plot.x = {};
            this.plot.y = {};
            this.plot.dot = {
                color: null //color scale mapping function
            };

            this.setupVariables();

            this.plot.size = conf.size;

            var width = conf.width;
            var availableWidth = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), margin);
            var availableHeight = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), margin);
            if (!width) {
                if (!this.plot.size) {
                    this.plot.size = Math.min(conf.maxCellSize, Math.max(conf.minCellSize, availableWidth / this.plot.variables.length));
                }
                width = margin.left + margin.right + this.plot.variables.length * this.plot.size;
            }
            if (!this.plot.size) {
                this.plot.size = (width - (margin.left + margin.right)) / this.plot.variables.length;
            }

            var height = width;
            if (!height) {
                height = availableHeight;
            }

            this.plot.width = width - margin.left - margin.right;
            this.plot.height = height - margin.top - margin.bottom;

            this.plot.ticks = conf.ticks;

            if (this.plot.ticks === undefined) {
                this.plot.ticks = this.plot.size / 40;
            }

            this.setupX();
            this.setupY();

            return this;
        }
    }, {
        key: "setupVariables",
        value: function setupVariables() {
            var variablesConf = this.config.variables;

            var data = this.plot.groupedData;
            var plot = this.plot;
            plot.domainByVariable = {};
            plot.variables = variablesConf.keys;
            if (!plot.variables || !plot.variables.length) {

                plot.variables = data.length ? _utils.Utils.inferVariables(data[0].values, this.config.groups.key, this.config.includeInPlot) : [];
            }

            plot.labels = [];
            plot.labelByVariable = {};
            plot.variables.forEach(function (variableKey, index) {
                var min = d3.min(data, function (s) {
                    return d3.min(s.values, function (d) {
                        return variablesConf.value(d, variableKey);
                    });
                });
                var max = d3.max(data, function (s) {
                    return d3.max(s.values, function (d) {
                        return variablesConf.value(d, variableKey);
                    });
                });
                plot.domainByVariable[variableKey] = [min, max];
                var label = variableKey;
                if (variablesConf.labels && variablesConf.labels.length > index) {

                    label = variablesConf.labels[index];
                }
                plot.labels.push(label);
                plot.labelByVariable[variableKey] = label;
            });

            plot.subplots = [];
        }
    }, {
        key: "setupX",
        value: function setupX() {

            var plot = this.plot;
            var x = plot.x;
            var conf = this.config;

            x.value = conf.variables.value;
            x.scale = _utils.Utils.createScale(conf.x.scale).range([conf.padding / 2, plot.size - conf.padding / 2]);
            x.map = function (d, variable) {
                return x.scale(x.value(d, variable));
            };

            x.axis = _utils.Utils.createAxis(conf.x.orient, x.scale).ticks(plot.ticks);
            x.axis.tickSize(plot.size * plot.variables.length);
        }
    }, {
        key: "setupY",
        value: function setupY() {

            var plot = this.plot;
            var y = plot.y;
            var conf = this.config;

            y.value = conf.variables.value;
            y.scale = _utils.Utils.createScale(conf.y.scale).range([plot.size - conf.padding / 2, conf.padding / 2]);

            y.map = function (d, variable) {
                return y.scale(y.value(d, variable));
            };
            y.axis = _utils.Utils.createAxis(conf.y.orient, y.scale).ticks(plot.ticks);
            y.axis.tickSize(-plot.size * plot.variables.length);
        }
    }, {
        key: "update",
        value: function update(newData) {
            _get(ScatterPlotMatrix.prototype.__proto__ || Object.getPrototypeOf(ScatterPlotMatrix.prototype), "update", this).call(this, newData);

            var self = this;
            var n = self.plot.variables.length;
            var conf = this.config;

            var axisClass = self.prefixClass("axis");
            var axisXClass = axisClass + "-x";
            var axisYClass = axisClass + "-y";

            var xAxisSelector = "g." + axisXClass + "." + axisClass;
            var yAxisSelector = "g." + axisYClass + "." + axisClass;

            var noGuidesClass = self.prefixClass("no-guides");
            var xAxis = self.svgG.selectAll(xAxisSelector).data(self.plot.variables);

            var xAxisMerge = xAxis.enter().appendSelector(xAxisSelector).classed(noGuidesClass, !conf.guides).merge(xAxis);

            xAxisMerge.attr("transform", function (d, i) {
                return "translate(" + (n - i - 1) * self.plot.size + ",0)";
            }).each(function (d) {
                self.plot.x.scale.domain(self.plot.domainByVariable[d]);
                var axis = d3.select(this);
                if (self.transitionEnabled()) {
                    axis = axis.transition();
                }
                axis.call(self.plot.x.axis);
            });

            xAxis.exit().remove();

            var yAxis = self.svgG.selectAll(yAxisSelector).data(self.plot.variables);
            var yAxisMerge = yAxis.enter().appendSelector(yAxisSelector).merge(yAxis);
            yAxisMerge.classed(noGuidesClass, !conf.guides).attr("transform", function (d, i) {
                return "translate(0," + i * self.plot.size + ")";
            });
            yAxisMerge.each(function (d) {
                self.plot.y.scale.domain(self.plot.domainByVariable[d]);
                var axis = d3.select(this);
                if (self.transitionEnabled()) {
                    axis = axis.transition();
                }
                axis.call(self.plot.y.axis);
            });

            yAxis.exit().remove();

            var cellClass = self.prefixClass("cell");
            var cell = self.svgG.selectAll("." + cellClass).data(self.utils.cross(self.plot.variables, self.plot.variables));

            var cellEnter = cell.enter().appendSelector("g." + cellClass);
            cellEnter.filter(function (d) {
                return d.i === d.j;
            }).append("text");

            var cellMerge = cellEnter.merge(cell);
            cellMerge.attr("transform", function (d) {
                return "translate(" + (n - d.i - 1) * self.plot.size + "," + d.j * self.plot.size + ")";
            });

            if (conf.brush) {
                this.drawBrush(cellMerge);
            }

            cellMerge.each(plotSubplot);

            //Labels
            cellMerge.select("text").attr("x", conf.padding).attr("y", conf.padding).attr("dy", ".71em").text(function (d) {
                return self.plot.labelByVariable[d.x];
            });

            cell.exit().remove();

            function plotSubplot(p) {
                var plot = self.plot;
                plot.subplots.push(p);
                var cell = d3.select(this);

                plot.x.scale.domain(plot.domainByVariable[p.x]);
                plot.y.scale.domain(plot.domainByVariable[p.y]);

                var frameClass = self.prefixClass("frame");
                cell.selectOrAppend("rect." + frameClass).attr("class", frameClass).attr("x", conf.padding / 2).attr("y", conf.padding / 2).attr("width", plot.size - conf.padding).attr("height", plot.size - conf.padding);

                p.update = function () {

                    var subplot = this;
                    var layerClass = self.prefixClass('layer');

                    var layer = cell.selectAll("g." + layerClass).data(self.plot.groupedData);

                    var layerMerge = layer.enter().appendSelector("g." + layerClass).merge(layer);

                    var dots = layerMerge.selectAll("circle").data(function (d) {
                        return d.values;
                    });

                    var dotsMerge = dots.enter().append("circle").merge(dots);

                    var dotsT = dotsMerge;
                    if (self.transitionEnabled()) {
                        dotsT = dotsMerge.transition();
                    }

                    dotsT.attr("cx", function (d) {
                        return plot.x.map(d, subplot.x);
                    }).attr("cy", function (d) {
                        return plot.y.map(d, subplot.y);
                    }).attr("r", self.config.dotRadius);

                    if (plot.seriesColor) {
                        layerMerge.style("fill", plot.seriesColor);
                    } else if (plot.color) {
                        dotsMerge.style("fill", plot.color);
                    }

                    if (plot.tooltip) {
                        dotsMerge.on("mouseover", function (d) {

                            var html = "(" + plot.x.value(d, subplot.x) + ", " + plot.y.value(d, subplot.y) + ")";
                            var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;
                            if (group || group === 0) {
                                group = plot.groupToLabel[group];
                                html += "<br/>";
                                var label = self.config.groups.label;
                                if (label) {
                                    html += label + ": ";
                                }
                                html += group;
                            }
                            self.showTooltip(html);
                        }).on("mouseout", function (d) {
                            self.hideTooltip();
                        });
                    }

                    dots.exit().remove();
                    layer.exit().remove();
                };
                p.update();
            }
        }
    }, {
        key: "drawBrush",
        value: function drawBrush(cell) {
            var self = this;
            var hiddenClass = self.plot.hiddenClass = self.prefixClass("hidden");
            var brush = d3.brush()
            // .x(self.plot.x.scale)
            // .y(self.plot.y.scale)
            .on("start", brushstart).on("brush", brushmove).on("end", brushend);

            brush.extent([[0, 0], [self.plot.size, self.plot.size]]);
            cell.selectOrAppend("g.brush-container").call(brush);

            self.clearBrush();

            // Clear the previously-active brush, if any.
            function brushstart(p) {
                if (self.plot.brushCell !== this) {
                    self.clearBrush();
                    self.plot.x.scale.domain(self.plot.domainByVariable[p.x]);
                    self.plot.y.scale.domain(self.plot.domainByVariable[p.y]);
                    self.plot.brushCell = this;
                    self.plot.brush = brush;
                }
            }

            // Highlight the selected circles.
            function brushmove(p) {
                var s = d3.event.selection;
                if (!s) return;
                var e = s.map(function (_) {
                    return [self.plot.x.scale.invert(_[0]), self.plot.y.scale.invert(_[1])];
                });
                // console.log(e);

                self.svgG.selectAll("circle").classed(hiddenClass, function (d) {
                    var x = parseFloat(d[p.x]),
                        y = parseFloat(d[p.y]);

                    return e[0][0] > x || x > e[1][0] || e[1][1] > y || y > e[0][1];
                });
            }
            // If the brush is empty, select all circles.
            function brushend() {
                if (!d3.event.selection) self.svgG.selectAll("." + hiddenClass).classed(hiddenClass, false);
            }
        }
    }, {
        key: "clearBrush",
        value: function clearBrush() {
            var self = this;
            if (!self.plot.brushCell) {
                return;
            }

            self.plot.brush.move(d3.select(self.plot.brushCell), null);
            self.svgG.selectAll("." + self.plot.hiddenClass).classed(self.plot.hiddenClass, false);
            self.plot.brushCell = null;
        }
    }]);

    return ScatterPlotMatrix;
}(_chartWithColorGroups.ChartWithColorGroups);

},{"./chart-with-color-groups":31,"./d3":35,"./legend":41,"./scatterplot":44,"./utils":47}],44:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScatterPlot = exports.ScatterPlotConfig = undefined;

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;if (getter === undefined) {
            return undefined;
        }return getter.call(receiver);
    }
};

var _chartWithColorGroups = require('./chart-with-color-groups');

var _utils = require('./utils');

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ScatterPlotConfig = exports.ScatterPlotConfig = function (_ChartWithColorGroups) {
    _inherits(ScatterPlotConfig, _ChartWithColorGroups);

    //show tooltip on dot hover

    function ScatterPlotConfig(custom) {
        _classCallCheck(this, ScatterPlotConfig);

        var _this = _possibleConstructorReturn(this, (ScatterPlotConfig.__proto__ || Object.getPrototypeOf(ScatterPlotConfig)).call(this));

        _this.svgClass = _this.cssClassPrefix + 'scatterplot';
        _this.guides = false;
        _this.showTooltip = true;
        _this.x = { // X axis config
            title: '', // axis label
            key: 0,
            value: function value(d, key) {
                return d[key];
            }, // x value accessor
            orient: "bottom",
            scale: "linear",
            domainMargin: 0.05
        };
        _this.y = { // Y axis config
            title: '', // axis label,
            key: 1,
            value: function value(d, key) {
                return d[key];
            }, // y value accessor
            orient: "left",
            scale: "linear",
            domainMargin: 0.05
        };
        _this.groups = {
            key: 2
        };
        _this.dotRadius = 2;

        _this.dotId = function (d, i) {
            return undefined;
        };

        _this.transition = true;

        _this.onDotHover = function (d, i) {};

        _this.onDotHoverOut = function (d, i) {};

        if (custom) {
            _utils.Utils.deepExtend(_this, custom);
        }

        return _this;
    } //show axis guides


    return ScatterPlotConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

var ScatterPlot = exports.ScatterPlot = function (_ChartWithColorGroups2) {
    _inherits(ScatterPlot, _ChartWithColorGroups2);

    function ScatterPlot(placeholderSelector, data, config) {
        _classCallCheck(this, ScatterPlot);

        return _possibleConstructorReturn(this, (ScatterPlot.__proto__ || Object.getPrototypeOf(ScatterPlot)).call(this, placeholderSelector, data, new ScatterPlotConfig(config)));
    }

    _createClass(ScatterPlot, [{
        key: 'setConfig',
        value: function setConfig(config) {
            return _get(ScatterPlot.prototype.__proto__ || Object.getPrototypeOf(ScatterPlot.prototype), 'setConfig', this).call(this, new ScatterPlotConfig(config));
        }
    }, {
        key: 'initPlot',
        value: function initPlot() {
            _get(ScatterPlot.prototype.__proto__ || Object.getPrototypeOf(ScatterPlot.prototype), 'initPlot', this).call(this);
            var self = this;

            var conf = this.config;

            this.plot.x = {};
            this.plot.y = {};

            this.computePlotSize();
            this.setupX();
            this.setupY();

            return this;
        }
    }, {
        key: 'setupX',
        value: function setupX() {

            var plot = this.plot;
            var x = plot.x;
            var conf = this.config.x;

            /* *
             * value accessor - returns the value to encode for a given data object.
             * scale - maps value to a visual display encoding, such as a pixel position.
             * map function - maps from data value to display value
             * axis - sets up axis
             **/
            x.value = function (d) {
                return conf.value(d, conf.key);
            };

            x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);
            x.map = function (d) {
                return x.scale(x.value(d));
            };

            x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

            var data = this.plot.groupedData;

            var domain = [parseFloat(d3.min(data, function (s) {
                return d3.min(s.values, plot.x.value);
            })), parseFloat(d3.max(data, function (s) {
                return d3.max(s.values, plot.x.value);
            }))];
            var extent = domain[1] - domain[0] || 1;
            var margin = extent * conf.domainMargin;
            domain[0] -= margin;
            domain[1] += margin;
            plot.x.scale.domain(domain);
            if (this.config.guides) {
                x.axis.tickSize(-plot.height);
            }
        }
    }, {
        key: 'setupY',
        value: function setupY() {

            var plot = this.plot;
            var y = plot.y;
            var conf = this.config.y;

            /*
             * value accessor - returns the value to encode for a given data object.
             * scale - maps value to a visual display encoding, such as a pixel position.
             * map function - maps from data value to display value
             * axis - sets up axis
             */
            y.value = function (d) {
                return conf.value(d, conf.key);
            };

            y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

            y.map = function (d) {
                return y.scale(y.value(d));
            };

            y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

            if (this.config.guides) {
                y.axis.tickSize(-plot.width);
            }

            var data = this.plot.groupedData;

            var domain = [parseFloat(d3.min(data, function (s) {
                return d3.min(s.values, plot.y.value);
            })), parseFloat(d3.max(data, function (s) {
                return d3.max(s.values, plot.y.value);
            }))];
            var extent = domain[1] - domain[0] || 1;
            var margin = extent * conf.domainMargin;

            domain[0] -= margin;
            domain[1] += margin;
            plot.y.scale.domain(domain);
            // plot.y.scale.domain([d3.min(data, plot.y.value)-1, d3.max(data, plot.y.value)+1]);
        }
    }, {
        key: 'drawAxisX',
        value: function drawAxisX() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.x;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");

            var axisT = axis;
            if (self.transitionEnabled()) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.x.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: 'drawAxisY',
        value: function drawAxisY() {
            var self = this;
            var plot = self.plot;
            var axisConf = this.config.y;
            var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));

            var axisT = axis;
            if (self.transitionEnabled()) {
                axisT = axis.transition().ease(d3.easeSinInOut);
            }

            axisT.call(plot.y.axis);

            axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
            .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
        }
    }, {
        key: 'update',
        value: function update(newData) {
            _get(ScatterPlot.prototype.__proto__ || Object.getPrototypeOf(ScatterPlot.prototype), 'update', this).call(this, newData);
            this.drawAxisX();
            this.drawAxisY();

            this.updateDots();
        }
    }, {
        key: 'updateDots',
        value: function updateDots() {
            var self = this;
            var plot = self.plot;
            var data = plot.data;
            var layerClass = self.prefixClass('layer');
            var dotClass = this.dotClass = self.prefixClass('dot');
            self.dotsContainerClass = self.prefixClass('dots-container');

            var dotsContainer = self.svgG.selectOrAppend("g." + self.dotsContainerClass);

            var layer = dotsContainer.selectAll("g." + layerClass).data(plot.groupedData);

            var layerEnter = layer.enter().appendSelector("g." + layerClass);

            var layerMerge = layerEnter.merge(layer);

            var dots = layerMerge.selectAll('.' + dotClass).data(function (d) {
                return d.values;
            });

            var dotsEnter = dots.enter().append("circle").attr("class", dotClass);

            var dotsMerge = dotsEnter.merge(dots);

            var dotsT = dotsMerge;
            if (self.transitionEnabled()) {
                dotsT = dotsMerge.transition();
            }

            dotsT.attr("r", self.config.dotRadius).attr("cx", plot.x.map).attr("cy", plot.y.map).attr("id", this.config.dotId);

            if (plot.tooltip) {
                dotsMerge.on("mouseover", function (d) {
                    var html = "(" + plot.x.value(d) + ", " + plot.y.value(d) + ")";
                    var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;
                    if (group || group === 0) {
                        group = plot.groupToLabel[group];
                        html += "<br/>";
                        var label = self.config.groups.label;
                        if (label) {
                            html += label + ": ";
                        }
                        html += group;
                    }
                    self.showTooltip(html);
                }).on("mouseout", function (d) {
                    self.hideTooltip();
                });
            }

            dotsMerge.on("mouseover.onDotHover", this.config.onDotHover);
            dotsMerge.on("mouseout.onDotHoverOut", this.config.onDotHoverOut);

            if (plot.seriesColor) {
                layerMerge.style("fill", plot.seriesColor);
            } else if (plot.color) {
                dotsMerge.style("fill", plot.color);
            }

            dots.exit().remove();
            layer.exit().remove();
        }
    }]);

    return ScatterPlot;
}(_chartWithColorGroups.ChartWithColorGroups);

},{"./chart-with-color-groups":31,"./d3":35,"./utils":47}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.tdistr = tdistr;
/*
 * https://gist.github.com/benrasmusen/1261977
 * NAME
 * 
 * statistics-distributions.js - JavaScript library for calculating
 *   critical values and upper probabilities of common statistical
 *   distributions
 * 
 * SYNOPSIS
 * 
 * 
 *   // Chi-squared-crit (2 degrees of freedom, 95th percentile = 0.05 level
 *   chisqrdistr(2, .05)
 *   
 *   // u-crit (95th percentile = 0.05 level)
 *   udistr(.05);
 *   
 *   // t-crit (1 degree of freedom, 99.5th percentile = 0.005 level) 
 *   tdistr(1,.005);
 *   
 *   // F-crit (1 degree of freedom in numerator, 3 degrees of freedom 
 *   //         in denominator, 99th percentile = 0.01 level)
 *   fdistr(1,3,.01);
 *   
 *   // upper probability of the u distribution (u = -0.85): Q(u) = 1-G(u)
 *   uprob(-0.85);
 *   
 *   // upper probability of the chi-square distribution
 *   // (3 degrees of freedom, chi-squared = 6.25): Q = 1-G
 *   chisqrprob(3,6.25);
 *   
 *   // upper probability of the t distribution
 *   // (3 degrees of freedom, t = 6.251): Q = 1-G
 *   tprob(3,6.251);
 *   
 *   // upper probability of the F distribution
 *   // (3 degrees of freedom in numerator, 5 degrees of freedom in
 *   //  denominator, F = 6.25): Q = 1-G
 *   fprob(3,5,.625);
 * 
 * 
 *  DESCRIPTION
 * 
 * This library calculates percentage points (5 significant digits) of the u
 * (standard normal) distribution, the student's t distribution, the
 * chi-square distribution and the F distribution. It can also calculate the
 * upper probability (5 significant digits) of the u (standard normal), the
 * chi-square, the t and the F distribution.
 * 
 * These critical values are needed to perform statistical tests, like the u
 * test, the t test, the F test and the chi-squared test, and to calculate
 * confidence intervals.
 * 
 * If you are interested in more precise algorithms you could look at:
 *   StatLib: http://lib.stat.cmu.edu/apstat/ ; 
 *   Applied Statistics Algorithms by Griffiths, P. and Hill, I.D.
 *   , Ellis Horwood: Chichester (1985)
 * 
 * BUGS 
 * 
 * This port was produced from the Perl module Statistics::Distributions
 * that has had no bug reports in several years.  If you find a bug then
 * please double-check that JavaScript does not thing the numbers you are
 * passing in are strings.  (You can subtract 0 from them as you pass them
 * in so that "5" is properly understood to be 5.)  If you have passed in a
 * number then please contact the author
 * 
 * AUTHOR
 * 
 * Ben Tilly <btilly@gmail.com>
 * 
 * Originl Perl version by Michael Kospach <mike.perl@gmx.at>
 * 
 * Nice formating, simplification and bug repair by Matthias Trautner Kromann
 * <mtk@id.cbs.dk>
 * 
 * COPYRIGHT 
 * 
 * Copyright 2008 Ben Tilly.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the same terms as Perl itself.  This means under either the Perl
 * Artistic License or the GPL v1 or later.
 */

var SIGNIFICANT = 5; // number of significant digits to be returned

function chisqrdistr($n, $p) {
	if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
		throw "Invalid n: $n\n"; /* degree of freedom */
	}
	if ($p <= 0 || $p > 1) {
		throw "Invalid p: $p\n";
	}
	return precision_string(_subchisqr($n - 0, $p - 0));
}

function udistr($p) {
	if ($p > 1 || $p <= 0) {
		throw "Invalid p: $p\n";
	}
	return precision_string(_subu($p - 0));
}

function tdistr($n, $p) {
	if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
		throw "Invalid n: $n\n";
	}
	if ($p <= 0 || $p >= 1) {
		throw "Invalid p: $p\n";
	}
	return precision_string(_subt($n - 0, $p - 0));
}

function fdistr($n, $m, $p) {
	if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
		throw "Invalid n: $n\n"; /* first degree of freedom */
	}
	if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {
		throw "Invalid m: $m\n"; /* second degree of freedom */
	}
	if ($p <= 0 || $p > 1) {
		throw "Invalid p: $p\n";
	}
	return precision_string(_subf($n - 0, $m - 0, $p - 0));
}

function uprob($x) {
	return precision_string(_subuprob($x - 0));
}

function chisqrprob($n, $x) {
	if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
		throw "Invalid n: $n\n"; /* degree of freedom */
	}
	return precision_string(_subchisqrprob($n - 0, $x - 0));
}

function tprob($n, $x) {
	if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
		throw "Invalid n: $n\n"; /* degree of freedom */
	}
	return precision_string(_subtprob($n - 0, $x - 0));
}

function fprob($n, $m, $x) {
	if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
		throw "Invalid n: $n\n"; /* first degree of freedom */
	}
	if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {
		throw "Invalid m: $m\n"; /* second degree of freedom */
	}
	return precision_string(_subfprob($n - 0, $m - 0, $x - 0));
}

function _subfprob($n, $m, $x) {
	var $p;

	if ($x <= 0) {
		$p = 1;
	} else if ($m % 2 == 0) {
		var $z = $m / ($m + $n * $x);
		var $a = 1;
		for (var $i = $m - 2; $i >= 2; $i -= 2) {
			$a = 1 + ($n + $i - 2) / $i * $z * $a;
		}
		$p = 1 - Math.pow(1 - $z, $n / 2 * $a);
	} else if ($n % 2 == 0) {
		var $z = $n * $x / ($m + $n * $x);
		var $a = 1;
		for (var $i = $n - 2; $i >= 2; $i -= 2) {
			$a = 1 + ($m + $i - 2) / $i * $z * $a;
		}
		$p = Math.pow(1 - $z, $m / 2) * $a;
	} else {
		var $y = Math.atan2(Math.sqrt($n * $x / $m), 1);
		var $z = Math.pow(Math.sin($y), 2);
		var $a = $n == 1 ? 0 : 1;
		for (var $i = $n - 2; $i >= 3; $i -= 2) {
			$a = 1 + ($m + $i - 2) / $i * $z * $a;
		}
		var $b = Math.PI;
		for (var $i = 2; $i <= $m - 1; $i += 2) {
			$b *= ($i - 1) / $i;
		}
		var $p1 = 2 / $b * Math.sin($y) * Math.pow(Math.cos($y), $m) * $a;

		$z = Math.pow(Math.cos($y), 2);
		$a = $m == 1 ? 0 : 1;
		for (var $i = $m - 2; $i >= 3; $i -= 2) {
			$a = 1 + ($i - 1) / $i * $z * $a;
		}
		$p = max(0, $p1 + 1 - 2 * $y / Math.PI - 2 / Math.PI * Math.sin($y) * Math.cos($y) * $a);
	}
	return $p;
}

function _subchisqrprob($n, $x) {
	var $p;

	if ($x <= 0) {
		$p = 1;
	} else if ($n > 100) {
		$p = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));
	} else if ($x > 400) {
		$p = 0;
	} else {
		var $a;
		var $i;
		var $i1;
		if ($n % 2 != 0) {
			$p = 2 * _subuprob(Math.sqrt($x));
			$a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);
			$i1 = 1;
		} else {
			$p = $a = Math.exp(-$x / 2);
			$i1 = 2;
		}

		for ($i = $i1; $i <= $n - 2; $i += 2) {
			$a *= $x / $i;
			$p += $a;
		}
	}
	return $p;
}

function _subu($p) {
	var $y = -Math.log(4 * $p * (1 - $p));
	var $x = Math.sqrt($y * (1.570796288 + $y * (.03706987906 + $y * (-.8364353589E-3 + $y * (-.2250947176E-3 + $y * (.6841218299E-5 + $y * (0.5824238515E-5 + $y * (-.104527497E-5 + $y * (.8360937017E-7 + $y * (-.3231081277E-8 + $y * (.3657763036E-10 + $y * .6936233982E-12)))))))))));
	if ($p > .5) $x = -$x;
	return $x;
}

function _subuprob($x) {
	var $p = 0; /* if ($absx > 100) */
	var $absx = Math.abs($x);

	if ($absx < 1.9) {
		$p = Math.pow(1 + $absx * (.049867347 + $absx * (.0211410061 + $absx * (.0032776263 + $absx * (.0000380036 + $absx * (.0000488906 + $absx * .000005383))))), -16) / 2;
	} else if ($absx <= 100) {
		for (var $i = 18; $i >= 1; $i--) {
			$p = $i / ($absx + $p);
		}
		$p = Math.exp(-.5 * $absx * $absx) / Math.sqrt(2 * Math.PI) / ($absx + $p);
	}

	if ($x < 0) $p = 1 - $p;
	return $p;
}

function _subt($n, $p) {

	if ($p >= 1 || $p <= 0) {
		throw "Invalid p: $p\n";
	}

	if ($p == 0.5) {
		return 0;
	} else if ($p < 0.5) {
		return -_subt($n, 1 - $p);
	}

	var $u = _subu($p);
	var $u2 = Math.pow($u, 2);

	var $a = ($u2 + 1) / 4;
	var $b = ((5 * $u2 + 16) * $u2 + 3) / 96;
	var $c = (((3 * $u2 + 19) * $u2 + 17) * $u2 - 15) / 384;
	var $d = ((((79 * $u2 + 776) * $u2 + 1482) * $u2 - 1920) * $u2 - 945) / 92160;
	var $e = (((((27 * $u2 + 339) * $u2 + 930) * $u2 - 1782) * $u2 - 765) * $u2 + 17955) / 368640;

	var $x = $u * (1 + ($a + ($b + ($c + ($d + $e / $n) / $n) / $n) / $n) / $n);

	if ($n <= Math.pow(log10($p), 2) + 3) {
		var $round;
		do {
			var $p1 = _subtprob($n, $x);
			var $n1 = $n + 1;
			var $delta = ($p1 - $p) / Math.exp(($n1 * Math.log($n1 / ($n + $x * $x)) + Math.log($n / $n1 / 2 / Math.PI) - 1 + (1 / $n1 - 1 / $n) / 6) / 2);
			$x += $delta;
			$round = round_to_precision($delta, Math.abs(integer(log10(Math.abs($x)) - 4)));
		} while ($x && $round != 0);
	}
	return $x;
}

function _subtprob($n, $x) {

	var $a;
	var $b;
	var $w = Math.atan2($x / Math.sqrt($n), 1);
	var $z = Math.pow(Math.cos($w), 2);
	var $y = 1;

	for (var $i = $n - 2; $i >= 2; $i -= 2) {
		$y = 1 + ($i - 1) / $i * $z * $y;
	}

	if ($n % 2 == 0) {
		$a = Math.sin($w) / 2;
		$b = .5;
	} else {
		$a = $n == 1 ? 0 : Math.sin($w) * Math.cos($w) / Math.PI;
		$b = .5 + $w / Math.PI;
	}
	return max(0, 1 - $b - $a * $y);
}

function _subf($n, $m, $p) {
	var $x;

	if ($p >= 1 || $p <= 0) {
		throw "Invalid p: $p\n";
	}

	if ($p == 1) {
		$x = 0;
	} else if ($m == 1) {
		$x = 1 / Math.pow(_subt($n, 0.5 - $p / 2), 2);
	} else if ($n == 1) {
		$x = Math.pow(_subt($m, $p / 2), 2);
	} else if ($m == 2) {
		var $u = _subchisqr($m, 1 - $p);
		var $a = $m - 2;
		$x = 1 / ($u / $m * (1 + (($u - $a) / 2 + (((4 * $u - 11 * $a) * $u + $a * (7 * $m - 10)) / 24 + (((2 * $u - 10 * $a) * $u + $a * (17 * $m - 26)) * $u - $a * $a * (9 * $m - 6)) / 48 / $n) / $n) / $n));
	} else if ($n > $m) {
		$x = 1 / _subf2($m, $n, 1 - $p);
	} else {
		$x = _subf2($n, $m, $p);
	}
	return $x;
}

function _subf2($n, $m, $p) {
	var $u = _subchisqr($n, $p);
	var $n2 = $n - 2;
	var $x = $u / $n * (1 + (($u - $n2) / 2 + (((4 * $u - 11 * $n2) * $u + $n2 * (7 * $n - 10)) / 24 + (((2 * $u - 10 * $n2) * $u + $n2 * (17 * $n - 26)) * $u - $n2 * $n2 * (9 * $n - 6)) / 48 / $m) / $m) / $m);
	var $delta;
	do {
		var $z = Math.exp((($n + $m) * Math.log(($n + $m) / ($n * $x + $m)) + ($n - 2) * Math.log($x) + Math.log($n * $m / ($n + $m)) - Math.log(4 * Math.PI) - (1 / $n + 1 / $m - 1 / ($n + $m)) / 6) / 2);
		$delta = (_subfprob($n, $m, $x) - $p) / $z;
		$x += $delta;
	} while (Math.abs($delta) > 3e-4);
	return $x;
}

function _subchisqr($n, $p) {
	var $x;

	if ($p > 1 || $p <= 0) {
		throw "Invalid p: $p\n";
	} else if ($p == 1) {
		$x = 0;
	} else if ($n == 1) {
		$x = Math.pow(_subu($p / 2), 2);
	} else if ($n == 2) {
		$x = -2 * Math.log($p);
	} else {
		var $u = _subu($p);
		var $u2 = $u * $u;

		$x = max(0, $n + Math.sqrt(2 * $n) * $u + 2 / 3 * ($u2 - 1) + $u * ($u2 - 7) / 9 / Math.sqrt(2 * $n) - 2 / 405 / $n * ($u2 * (3 * $u2 + 7) - 16));

		if ($n <= 100) {
			var $x0;
			var $p1;
			var $z;
			do {
				$x0 = $x;
				if ($x < 0) {
					$p1 = 1;
				} else if ($n > 100) {
					$p1 = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));
				} else if ($x > 400) {
					$p1 = 0;
				} else {
					var $i0;
					var $a;
					if ($n % 2 != 0) {
						$p1 = 2 * _subuprob(Math.sqrt($x));
						$a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);
						$i0 = 1;
					} else {
						$p1 = $a = Math.exp(-$x / 2);
						$i0 = 2;
					}

					for (var $i = $i0; $i <= $n - 2; $i += 2) {
						$a *= $x / $i;
						$p1 += $a;
					}
				}
				$z = Math.exp((($n - 1) * Math.log($x / $n) - Math.log(4 * Math.PI * $x) + $n - $x - 1 / $n / 6) / 2);
				$x += ($p1 - $p) / $z;
				$x = round_to_precision($x, 5);
			} while ($n < 31 && Math.abs($x0 - $x) > 1e-4);
		}
	}
	return $x;
}

function log10($n) {
	return Math.log($n) / Math.log(10);
}

function max() {
	var $max = arguments[0];
	for (var $i = 0; i < arguments.length; i++) {
		if ($max < arguments[$i]) $max = arguments[$i];
	}
	return $max;
}

function min() {
	var $min = arguments[0];
	for (var $i = 0; i < arguments.length; i++) {
		if ($min > arguments[$i]) $min = arguments[$i];
	}
	return $min;
}

function precision($x) {
	return Math.abs(integer(log10(Math.abs($x)) - SIGNIFICANT));
}

function precision_string($x) {
	if ($x) {
		return round_to_precision($x, precision($x));
	} else {
		return "0";
	}
}

function round_to_precision($x, $p) {
	$x = $x * Math.pow(10, $p);
	$x = Math.round($x);
	return $x / Math.pow(10, $p);
}

function integer($i) {
	if ($i > 0) return Math.floor($i);else return Math.ceil($i);
}

},{}],46:[function(require,module,exports){
'use strict';

var _statisticsDistributions = require('./statistics-distributions');

var su = module.exports.StatisticsUtils = {};
su.sampleCorrelation = require('simple-statistics/src/sample_correlation');
su.linearRegression = require('simple-statistics/src/linear_regression');
su.linearRegressionLine = require('simple-statistics/src/linear_regression_line');
su.errorFunction = require('simple-statistics/src/error_function');
su.standardDeviation = require('simple-statistics/src/standard_deviation');
su.sampleStandardDeviation = require('simple-statistics/src/sample_standard_deviation');
su.variance = require('simple-statistics/src/variance');
su.mean = require('simple-statistics/src/mean');
su.zScore = require('simple-statistics/src/z_score');
su.standardError = function (arr) {
    return Math.sqrt(su.variance(arr) / (arr.length - 1));
};
su.quantile = require('simple-statistics/src/quantile');

su.tValue = function (degreesOfFreedom, criticalProbability) {
    //as in http://stattrek.com/online-calculator/t-distribution.aspx
    return (0, _statisticsDistributions.tdistr)(degreesOfFreedom, criticalProbability);
};

},{"./statistics-distributions":45,"simple-statistics/src/error_function":12,"simple-statistics/src/linear_regression":13,"simple-statistics/src/linear_regression_line":14,"simple-statistics/src/mean":15,"simple-statistics/src/quantile":16,"simple-statistics/src/sample_correlation":19,"simple-statistics/src/sample_standard_deviation":21,"simple-statistics/src/standard_deviation":23,"simple-statistics/src/variance":26,"simple-statistics/src/z_score":27}],47:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Utils = undefined;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _d = require('./d3');

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
        obj[key] = value;
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var Utils = exports.Utils = function () {
    function Utils() {
        _classCallCheck(this, Utils);
    }

    _createClass(Utils, null, [{
        key: 'deepExtend',

        // usage example deepExtend({}, objA, objB); => should work similar to $.extend(true, {}, objA, objB);
        value: function deepExtend(out) {

            var utils = this;
            var emptyOut = {};

            if (!out && arguments.length > 1 && Array.isArray(arguments[1])) {
                out = [];
            }
            out = out || {};

            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                if (!source) continue;

                for (var key in source) {
                    if (!source.hasOwnProperty(key)) {
                        continue;
                    }
                    var isArray = Array.isArray(out[key]);
                    var isObject = utils.isObject(out[key]);
                    var srcObj = utils.isObject(source[key]);

                    if (isObject && !isArray && srcObj) {
                        utils.deepExtend(out[key], source[key]);
                    } else {
                        out[key] = source[key];
                    }
                }
            }

            return out;
        }
    }, {
        key: 'mergeDeep',
        value: function mergeDeep(target, source) {
            var output = Object.assign({}, target);
            if (Utils.isObjectNotArray(target) && Utils.isObjectNotArray(source)) {
                Object.keys(source).forEach(function (key) {
                    if (Utils.isObjectNotArray(source[key])) {
                        if (!(key in target)) Object.assign(output, _defineProperty({}, key, source[key]));else output[key] = Utils.mergeDeep(target[key], source[key]);
                    } else {
                        Object.assign(output, _defineProperty({}, key, source[key]));
                    }
                });
            }
            return output;
        }
    }, {
        key: 'cross',
        value: function cross(a, b) {
            var c = [],
                n = a.length,
                m = b.length,
                i,
                j;
            for (i = -1; ++i < n;) {
                for (j = -1; ++j < m;) {
                    c.push({ x: a[i], i: i, y: b[j], j: j });
                }
            }return c;
        }
    }, {
        key: 'inferVariables',
        value: function inferVariables(data, groupKey, includeGroup) {
            var res = [];
            if (!data) {
                return res;
            }

            if (data.length) {
                var d = data[0];
                if (d instanceof Array) {
                    res = d.map(function (v, i) {
                        return i;
                    });
                } else if ((typeof d === 'undefined' ? 'undefined' : _typeof(d)) === 'object') {

                    for (var prop in d) {
                        if (!d.hasOwnProperty(prop)) continue;

                        res.push(prop);
                    }
                }
            }
            if (groupKey !== null && groupKey !== undefined && !includeGroup) {
                var index = res.indexOf(groupKey);
                if (index > -1) {
                    res.splice(index, 1);
                }
            }
            return res;
        }
    }, {
        key: 'isObjectNotArray',
        value: function isObjectNotArray(item) {
            return item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !Array.isArray(item) && item !== null;
        }
    }, {
        key: 'isArray',
        value: function isArray(item) {
            return Array.isArray(item);
        }
    }, {
        key: 'isObject',
        value: function isObject(a) {
            return a !== null && (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object';
        }
    }, {
        key: 'isNumber',
        value: function isNumber(a) {
            return !isNaN(a) && typeof a === 'number';
        }
    }, {
        key: 'isFunction',
        value: function isFunction(a) {
            return typeof a === 'function';
        }
    }, {
        key: 'isDate',
        value: function isDate(a) {
            return Object.prototype.toString.call(a) === '[object Date]';
        }
    }, {
        key: 'isString',
        value: function isString(a) {
            return typeof a === 'string' || a instanceof String;
        }
    }, {
        key: 'insertOrAppendSelector',
        value: function insertOrAppendSelector(parent, selector, operation, before) {

            var selectorParts = selector.split(/([\.\#])/);
            var element = parent[operation](selectorParts.shift(), before); //":first-child"

            while (selectorParts.length > 1) {
                var selectorModifier = selectorParts.shift();
                var selectorItem = selectorParts.shift();
                if (selectorModifier === ".") {
                    element = element.classed(selectorItem, true);
                } else if (selectorModifier === "#") {
                    element = element.attr('id', selectorItem);
                }
            }
            return element;
        }
    }, {
        key: 'insertSelector',
        value: function insertSelector(parent, selector, before) {
            return Utils.insertOrAppendSelector(parent, selector, "insert", before);
        }
    }, {
        key: 'appendSelector',
        value: function appendSelector(parent, selector) {
            return Utils.insertOrAppendSelector(parent, selector, "append");
        }
    }, {
        key: 'selectOrAppend',
        value: function selectOrAppend(parent, selector, element) {
            var selection = parent.select(selector);
            if (selection.empty()) {
                if (element) {
                    return parent.append(element);
                }
                return Utils.appendSelector(parent, selector);
            }
            return selection;
        }
    }, {
        key: 'selectOrInsert',
        value: function selectOrInsert(parent, selector, before) {
            var selection = parent.select(selector);
            if (selection.empty()) {
                return Utils.insertSelector(parent, selector, before);
            }
            return selection;
        }
    }, {
        key: 'linearGradient',
        value: function linearGradient(svg, gradientId, range, x1, y1, x2, y2) {
            var defs = Utils.selectOrAppend(svg, "defs");
            var linearGradient = defs.append("linearGradient").attr("id", gradientId);

            linearGradient.attr("x1", x1 + "%").attr("y1", y1 + "%").attr("x2", x2 + "%").attr("y2", y2 + "%");

            //Append multiple color stops by using D3's data/enter step
            var stops = linearGradient.selectAll("stop").data(range);

            var stopsMerge = stops.enter().append("stop").merge(stops);

            stopsMerge.attr("offset", function (d, i) {
                return i / (range.length - 1);
            }).attr("stop-color", function (d) {
                return d;
            });

            stops.exit().remove();
        }
    }, {
        key: 'guid',
        value: function guid() {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
            }

            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
        }

        //places textString in textObj, adds an ellipsis if text can't fit in width

    }, {
        key: 'placeTextWithEllipsis',
        value: function placeTextWithEllipsis(textD3Obj, textString, width) {
            var textObj = textD3Obj.node();
            textObj.textContent = textString;

            var margin = 0;
            var ellipsisLength = 9;
            //ellipsis is needed
            if (textObj.getComputedTextLength() > width + margin) {
                for (var x = textString.length - 3; x > 0; x -= 1) {
                    if (textObj.getSubStringLength(0, x) + ellipsisLength <= width + margin) {
                        textObj.textContent = textString.substring(0, x) + "...";
                        return true;
                    }
                }
                textObj.textContent = "..."; //can't place at all
                return true;
            }
            return false;
        }
    }, {
        key: 'placeTextWithEllipsisAndTooltip',
        value: function placeTextWithEllipsisAndTooltip(textD3Obj, textString, width, tooltip) {
            var ellipsisPlaced = Utils.placeTextWithEllipsis(textD3Obj, textString, width);
            if (ellipsisPlaced && tooltip) {
                textD3Obj.on("mouseover", function (d) {
                    tooltip.transition().duration(200).style("opacity", .9);
                    tooltip.html(textString).style("left", d3.event.pageX + 5 + "px").style("top", d3.event.pageY - 28 + "px");
                });

                textD3Obj.on("mouseout", function (d) {
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            }
        }
    }, {
        key: 'getFontSize',
        value: function getFontSize(element) {
            return window.getComputedStyle(element, null).getPropertyValue("font-size");
        }
    }, {
        key: 'capitalizeFirstLetter',
        value: function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }
    }, {
        key: 'createScale',
        value: function createScale(scaleName) {
            var scaleFunctionName = 'scale' + Utils.capitalizeFirstLetter(scaleName);
            try {
                return d3[scaleFunctionName]();
            } catch (e) {
                throw 'ODC-D3 - scale not supported: ' + scaleName + ' (' + scaleFunctionName + ')';
            }
        }
    }, {
        key: 'createAxis',
        value: function createAxis(orient, scale) {
            var axisFnName = 'axis' + Utils.capitalizeFirstLetter(orient);
            try {
                return d3[axisFnName](scale);
            } catch (e) {
                throw 'ODC-D3 - axis orient not supported: ' + orient;
            }
        }
    }]);

    return Utils;
}();

Utils.SQRT_2 = 1.41421356237;

Utils.sanitizeHeight = function (height, container) {
    return height || parseInt(container.style('height'), 10) || 400;
};

Utils.sanitizeWidth = function (width, container) {
    return width || parseInt(container.style('width'), 10) || 960;
};

Utils.availableHeight = function (height, container, margin) {
    return Math.max(0, Utils.sanitizeHeight(height, container) - margin.top - margin.bottom);
};

Utils.availableWidth = function (width, container, margin) {
    return Math.max(0, Utils.sanitizeWidth(width, container) - margin.left - margin.right);
};

},{"./d3":35}]},{},[40])(40)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMtYXJyYXkvYnVpbGQvZDMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZDMtY29sbGVjdGlvbi9idWlsZC9kMy1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2J1aWxkL2QzLWNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL2J1aWxkL2QzLWRpc3BhdGNoLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9kMy1mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvYnVpbGQvZDMtaW50ZXJwb2xhdGUuanMiLCJub2RlX21vZHVsZXMvZDMtc2NhbGUvYnVpbGQvZDMtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL2J1aWxkL2QzLXNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kMy1zdmctbGVnZW5kL2luZGV4Um9sbHVwLmpzIiwibm9kZV9tb2R1bGVzL2QzLXRpbWUtZm9ybWF0L2J1aWxkL2QzLXRpbWUtZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2QzLXRpbWUvYnVpbGQvZDMtdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvZXJyb3JfZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2xpbmVhcl9yZWdyZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9saW5lYXJfcmVncmVzc2lvbl9saW5lLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9tZWFuLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9xdWFudGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvcXVhbnRpbGVfc29ydGVkLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9xdWlja3NlbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvc2FtcGxlX2NvcnJlbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zYW1wbGVfY292YXJpYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvc2FtcGxlX3N0YW5kYXJkX2RldmlhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvc2FtcGxlX3ZhcmlhbmNlLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zdGFuZGFyZF9kZXZpYXRpb24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvc3VtX250aF9wb3dlcl9kZXZpYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy92YXJpYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvel9zY29yZS5qcyIsInNyYy9iYXItY2hhcnQuanMiLCJzcmMvYm94LXBsb3QtYmFzZS5qcyIsInNyYy9ib3gtcGxvdC5qcyIsInNyYy9jaGFydC13aXRoLWNvbG9yLWdyb3Vwcy5qcyIsInNyYy9jaGFydC5qcyIsInNyYy9jb3JyZWxhdGlvbi1tYXRyaXguanMiLCJzcmMvZDMtZXh0ZW5zaW9ucy5qcyIsInNyYy9kMy5qcyIsInNyYy9kaXZlcmdpbmctc3RhY2tlZC1iYXItY2hhcnQuanMiLCJzcmMvaGVhdG1hcC10aW1lc2VyaWVzLmpzIiwic3JjL2hlYXRtYXAuanMiLCJzcmMvaGlzdG9ncmFtLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL2xlZ2VuZC5qcyIsInNyYy9yZWdyZXNzaW9uLmpzIiwic3JjL3NjYXR0ZXJwbG90LW1hdHJpeC5qcyIsInNyYy9zY2F0dGVycGxvdC5qcyIsInNyYy9zdGF0aXN0aWNzLWRpc3RyaWJ1dGlvbnMuanMiLCJzcmMvc3RhdGlzdGljcy11dGlscy5qcyIsInNyYy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3I0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QixXQUFqQixBQUE0QixRQUFRLEFBQ3hEO1dBQU8sS0FBQSxBQUFLLElBQUwsQUFBUyxHQUFHLE1BQUEsQUFBTSxjQUFOLEFBQW9CLE9BQXBCLEFBQTJCLGFBQWEsT0FBeEMsQUFBK0MsT0FBTyxPQUF6RSxBQUFPLEFBQXlFLEFBQ25GO0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1hcnJheS8gVmVyc2lvbiAxLjAuMS4gQ29weXJpZ2h0IDIwMTYgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG4gIH1cblxuICBmdW5jdGlvbiBiaXNlY3Rvcihjb21wYXJlKSB7XG4gICAgaWYgKGNvbXBhcmUubGVuZ3RoID09PSAxKSBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihjb21wYXJlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9LFxuICAgICAgcmlnaHQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7XG4gICAgICAgICAgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgeCkge1xuICAgICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG4gIHZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbiAgdmFyIGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcblxuICBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG4gIH1cblxuICBmdW5jdGlvbiBudW1iZXIoeCkge1xuICAgIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG4gIH1cblxuICBmdW5jdGlvbiB2YXJpYW5jZShhcnJheSwgZikge1xuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBtID0gMCxcbiAgICAgICAgYSxcbiAgICAgICAgZCxcbiAgICAgICAgcyA9IDAsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgaiA9IDA7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoIWlzTmFOKGEgPSBudW1iZXIoYXJyYXlbaV0pKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKCFpc05hTihhID0gbnVtYmVyKGYoYXJyYXlbaV0sIGksIGFycmF5KSkpKSB7XG4gICAgICAgICAgZCA9IGEgLSBtO1xuICAgICAgICAgIG0gKz0gZCAvICsrajtcbiAgICAgICAgICBzICs9IGQgKiAoYSAtIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGogPiAxKSByZXR1cm4gcyAvIChqIC0gMSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXZpYXRpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgdiA9IHZhcmlhbmNlKGFycmF5LCBmKTtcbiAgICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbnQoYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYyA9IGI7IGJyZWFrOyB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBjID0gYjsgYnJlYWs7IH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2EsIGNdO1xuICB9XG5cbiAgdmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuICB2YXIgbWFwID0gYXJyYXkubWFwO1xuXG4gIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIHZhciBlMTAgPSBNYXRoLnNxcnQoNTApO1xuICB2YXIgZTUgPSBNYXRoLnNxcnQoMTApO1xuICB2YXIgZTIgPSBNYXRoLnNxcnQoMik7XG4gIGZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICByZXR1cm4gcmFuZ2UoXG4gICAgICBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKSAqIHN0ZXAsXG4gICAgICBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKSAqIHN0ZXAgKyBzdGVwIC8gMiwgLy8gaW5jbHVzaXZlXG4gICAgICBzdGVwXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICAgIGVycm9yID0gc3RlcDAgLyBzdGVwMTtcbiAgICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcDEgKj0gMjtcbiAgICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG4gIH1cblxuICBmdW5jdGlvbiBzdHVyZ2VzKHZhbHVlcykge1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLkxOMikgKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlzdG9ncmFtKCkge1xuICAgIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgICBkb21haW4gPSBleHRlbnQsXG4gICAgICAgIHRocmVzaG9sZCA9IHN0dXJnZXM7XG5cbiAgICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeHogPSBkb21haW4odmFsdWVzKSxcbiAgICAgICAgICB4MCA9IHh6WzBdLFxuICAgICAgICAgIHgxID0geHpbMV0sXG4gICAgICAgICAgdHogPSB0aHJlc2hvbGQodmFsdWVzLCB4MCwgeDEpO1xuXG4gICAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHR6KSkgdHogPSB0aWNrcyh4MCwgeDEsIHR6KTtcblxuICAgICAgLy8gUmVtb3ZlIGFueSB0aHJlc2hvbGRzIG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICAgIHZhciBtID0gdHoubGVuZ3RoO1xuICAgICAgd2hpbGUgKHR6WzBdIDw9IHgwKSB0ei5zaGlmdCgpLCAtLW07XG4gICAgICB3aGlsZSAodHpbbSAtIDFdID49IHgxKSB0ei5wb3AoKSwgLS1tO1xuXG4gICAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksXG4gICAgICAgICAgYmluO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGJpbnMuXG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IG07ICsraSkge1xuICAgICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICAgIGJpbi54MCA9IGkgPiAwID8gdHpbaSAtIDFdIDogeDA7XG4gICAgICAgIGJpbi54MSA9IGkgPCBtID8gdHpbaV0gOiB4MTtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzaWduIGRhdGEgdG8gYmlucyBieSB2YWx1ZSwgaWdub3JpbmcgYW55IG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHgwIDw9IHggJiYgeCA8PSB4MSkge1xuICAgICAgICAgIGJpbnNbYmlzZWN0UmlnaHQodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5zO1xuICAgIH1cblxuICAgIGhpc3RvZ3JhbS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICAgIH07XG5cbiAgICBoaXN0b2dyYW0uZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICAgIH07XG5cbiAgICBoaXN0b2dyYW0udGhyZXNob2xkcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGlsZShhcnJheSwgcCwgZikge1xuICAgIGlmIChmID09IG51bGwpIGYgPSBudW1iZXI7XG4gICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuICtmKGFycmF5WzBdLCAwLCBhcnJheSk7XG4gICAgaWYgKHAgPj0gMSkgcmV0dXJuICtmKGFycmF5W24gLSAxXSwgbiAtIDEsIGFycmF5KTtcbiAgICB2YXIgbixcbiAgICAgICAgaCA9IChuIC0gMSkgKiBwLFxuICAgICAgICBpID0gTWF0aC5mbG9vcihoKSxcbiAgICAgICAgYSA9ICtmKGFycmF5W2ldLCBpLCBhcnJheSksXG4gICAgICAgIGIgPSArZihhcnJheVtpICsgMV0sIGkgKyAxLCBhcnJheSk7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogKGggLSBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVkbWFuRGlhY29uaXModmFsdWVzLCBtaW4sIG1heCkge1xuICAgIHZhbHVlcyA9IG1hcC5jYWxsKHZhbHVlcywgbnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgyICogKHF1YW50aWxlKHZhbHVlcywgMC43NSkgLSBxdWFudGlsZSh2YWx1ZXMsIDAuMjUpKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjb3R0KHZhbHVlcywgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDMuNSAqIGRldmlhdGlvbih2YWx1ZXMpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgYSxcbiAgICAgICAgYjtcblxuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGI7IGJyZWFrOyB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGI7IGJyZWFrOyB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYW4oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgaiA9IG47XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpc05hTihhID0gbnVtYmVyKGFycmF5W2ldKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpc05hTihhID0gbnVtYmVyKGYoYXJyYXlbaV0sIGksIGFycmF5KSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH1cblxuICAgIGlmIChqKSByZXR1cm4gcyAvIGo7XG4gIH1cblxuICBmdW5jdGlvbiBtZWRpYW4oYXJyYXksIGYpIHtcbiAgICB2YXIgbnVtYmVycyA9IFtdLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBpID0gLTE7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpc05hTihhID0gbnVtYmVyKGFycmF5W2ldKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWlzTmFOKGEgPSBudW1iZXIoZihhcnJheVtpXSwgaSwgYXJyYXkpKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVhbnRpbGUobnVtYmVycy5zb3J0KGFzY2VuZGluZyksIDAuNSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgIG0sXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIG1lcmdlZCxcbiAgICAgICAgYXJyYXk7XG5cbiAgICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcblxuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgICBtID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGI7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBwYWlycyhhcnJheSkge1xuICAgIHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aCAtIDEsIHAgPSBhcnJheVswXSwgcGFpcnMgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gICAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IFtwLCBwID0gYXJyYXlbKytpXV07XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVybXV0ZShhcnJheSwgaW5kZXhlcykge1xuICAgIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gICAgcmV0dXJuIHBlcm11dGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbihhcnJheSwgY29tcGFyZSkge1xuICAgIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgeGksXG4gICAgICAgIHhqID0gYXJyYXlbal07XG5cbiAgICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKGNvbXBhcmUoeGkgPSBhcnJheVtpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHhqID0geGksIGogPSBpO1xuXG4gICAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XG4gIH1cblxuICBmdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBpMCwgaTEpIHtcbiAgICB2YXIgbSA9IChpMSA9PSBudWxsID8gYXJyYXkubGVuZ3RoIDogaTEpIC0gKGkwID0gaTAgPT0gbnVsbCA/IDAgOiAraTApLFxuICAgICAgICB0LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICAgIHQgPSBhcnJheVttICsgaTBdO1xuICAgICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgICBhcnJheVtpICsgaTBdID0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzdW0oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGkgPSAtMTtcblxuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoYSA9ICthcnJheVtpXSkgcyArPSBhOyAvLyBOb3RlOiB6ZXJvIGFuZCBudWxsIGFyZSBlcXVpdmFsZW50LlxuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChhID0gK2YoYXJyYXlbaV0sIGksIGFycmF5KSkgcyArPSBhO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNwb3NlKG1hdHJpeCkge1xuICAgIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICAgIGZvciAodmFyIGkgPSAtMSwgbSA9IG1pbihtYXRyaXgsIGxlbmd0aCksIHRyYW5zcG9zZSA9IG5ldyBBcnJheShtKTsgKytpIDwgbTspIHtcbiAgICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOykge1xuICAgICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3Bvc2U7XG4gIH1cblxuICBmdW5jdGlvbiBsZW5ndGgoZCkge1xuICAgIHJldHVybiBkLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHppcCgpIHtcbiAgICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XG4gIH1cblxuICBleHBvcnRzLmJpc2VjdCA9IGJpc2VjdFJpZ2h0O1xuICBleHBvcnRzLmJpc2VjdFJpZ2h0ID0gYmlzZWN0UmlnaHQ7XG4gIGV4cG9ydHMuYmlzZWN0TGVmdCA9IGJpc2VjdExlZnQ7XG4gIGV4cG9ydHMuYXNjZW5kaW5nID0gYXNjZW5kaW5nO1xuICBleHBvcnRzLmJpc2VjdG9yID0gYmlzZWN0b3I7XG4gIGV4cG9ydHMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG4gIGV4cG9ydHMuZGV2aWF0aW9uID0gZGV2aWF0aW9uO1xuICBleHBvcnRzLmV4dGVudCA9IGV4dGVudDtcbiAgZXhwb3J0cy5oaXN0b2dyYW0gPSBoaXN0b2dyYW07XG4gIGV4cG9ydHMudGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcyA9IGZyZWVkbWFuRGlhY29uaXM7XG4gIGV4cG9ydHMudGhyZXNob2xkU2NvdHQgPSBzY290dDtcbiAgZXhwb3J0cy50aHJlc2hvbGRTdHVyZ2VzID0gc3R1cmdlcztcbiAgZXhwb3J0cy5tYXggPSBtYXg7XG4gIGV4cG9ydHMubWVhbiA9IG1lYW47XG4gIGV4cG9ydHMubWVkaWFuID0gbWVkaWFuO1xuICBleHBvcnRzLm1lcmdlID0gbWVyZ2U7XG4gIGV4cG9ydHMubWluID0gbWluO1xuICBleHBvcnRzLnBhaXJzID0gcGFpcnM7XG4gIGV4cG9ydHMucGVybXV0ZSA9IHBlcm11dGU7XG4gIGV4cG9ydHMucXVhbnRpbGUgPSBxdWFudGlsZTtcbiAgZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuICBleHBvcnRzLnNjYW4gPSBzY2FuO1xuICBleHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuICBleHBvcnRzLnN1bSA9IHN1bTtcbiAgZXhwb3J0cy50aWNrcyA9IHRpY2tzO1xuICBleHBvcnRzLnRpY2tTdGVwID0gdGlja1N0ZXA7XG4gIGV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuICBleHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gIGV4cG9ydHMuemlwID0gemlwO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTsiLCIvLyBodHRwczovL2QzanMub3JnL2QzLWNvbGxlY3Rpb24vIFZlcnNpb24gMS4wLjQuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHByZWZpeCA9IFwiJFwiO1xuXG5mdW5jdGlvbiBNYXAoKSB7fVxuXG5NYXAucHJvdG90eXBlID0gbWFwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE1hcCxcbiAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gKHByZWZpeCArIGtleSkgaW4gdGhpcztcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpc1twcmVmaXggKyBrZXldO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW3ByZWZpeCArIGtleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBwcmVmaXggKyBrZXk7XG4gICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcbiAgfSxcbiAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkga2V5cy5wdXNoKHByb3BlcnR5LnNsaWNlKDEpKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfSxcbiAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHZhbHVlcy5wdXNoKHRoaXNbcHJvcGVydHldKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9LFxuICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBlbnRyaWVzLnB1c2goe2tleTogcHJvcGVydHkuc2xpY2UoMSksIHZhbHVlOiB0aGlzW3Byb3BlcnR5XX0pO1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9LFxuICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpICsrc2l6ZTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfSxcbiAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZih0aGlzW3Byb3BlcnR5XSwgcHJvcGVydHkuc2xpY2UoMSksIHRoaXMpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYXAob2JqZWN0LCBmKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwO1xuXG4gIC8vIENvcHkgY29uc3RydWN0b3IuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgbWFwLnNldChrZXksIHZhbHVlKTsgfSk7XG5cbiAgLy8gSW5kZXggYXJyYXkgYnkgbnVtZXJpYyBpbmRleCBvciBzcGVjaWZpZWQga2V5IGZ1bmN0aW9uLlxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgbztcblxuICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGksIG9iamVjdFtpXSk7XG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChmKG8gPSBvYmplY3RbaV0sIGksIG9iamVjdCksIG8pO1xuICB9XG5cbiAgLy8gQ29udmVydCBvYmplY3QgdG8gbWFwLlxuICBlbHNlIGlmIChvYmplY3QpIGZvciAodmFyIGtleSBpbiBvYmplY3QpIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIG5lc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBbXSxcbiAgICAgIHNvcnRLZXlzID0gW10sXG4gICAgICBzb3J0VmFsdWVzLFxuICAgICAgcm9sbHVwLFxuICAgICAgbmVzdDtcblxuICBmdW5jdGlvbiBhcHBseShhcnJheSwgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSB7XG4gICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIHJvbGx1cCAhPSBudWxsID8gcm9sbHVwKGFycmF5KSA6IGFycmF5O1xuICAgIH1cblxuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGtleSA9IGtleXNbZGVwdGgrK10sXG4gICAgICAgIGtleVZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWVzQnlLZXkgPSBtYXAoKSxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgXCJcIikpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZXNCeUtleS5lYWNoKGZ1bmN0aW9uKHZhbHVlcywga2V5KSB7XG4gICAgICBzZXRSZXN1bHQocmVzdWx0LCBrZXksIGFwcGx5KHZhbHVlcywgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cmllcyhtYXAkJDEsIGRlcHRoKSB7XG4gICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcCQkMTtcbiAgICB2YXIgYXJyYXksIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCAtIDFdO1xuICAgIGlmIChyb2xsdXAgIT0gbnVsbCAmJiBkZXB0aCA+PSBrZXlzLmxlbmd0aCkgYXJyYXkgPSBtYXAkJDEuZW50cmllcygpO1xuICAgIGVsc2UgYXJyYXkgPSBbXSwgbWFwJCQxLmVhY2goZnVuY3Rpb24odiwgaykgeyBhcnJheS5wdXNoKHtrZXk6IGssIHZhbHVlczogZW50cmllcyh2LCBkZXB0aCl9KTsgfSk7XG4gICAgcmV0dXJuIHNvcnRLZXkgIT0gbnVsbCA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpOyB9KSA6IGFycmF5O1xuICB9XG5cbiAgcmV0dXJuIG5lc3QgPSB7XG4gICAgb2JqZWN0OiBmdW5jdGlvbihhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU9iamVjdCwgc2V0T2JqZWN0KTsgfSxcbiAgICBtYXA6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCksIDApOyB9LFxuICAgIGtleTogZnVuY3Rpb24oZCkgeyBrZXlzLnB1c2goZCk7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRLZXlzOiBmdW5jdGlvbihvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRWYWx1ZXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRWYWx1ZXMgPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgcm9sbHVwOiBmdW5jdGlvbihmKSB7IHJvbGx1cCA9IGY7IHJldHVybiBuZXN0OyB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gc2V0T2JqZWN0KG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gIHJldHVybiBtYXAoKTtcbn1cblxuZnVuY3Rpb24gc2V0TWFwKG1hcCQkMSwga2V5LCB2YWx1ZSkge1xuICBtYXAkJDEuc2V0KGtleSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBTZXQoKSB7fVxuXG52YXIgcHJvdG8gPSBtYXAucHJvdG90eXBlO1xuXG5TZXQucHJvdG90eXBlID0gc2V0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNldCxcbiAgaGFzOiBwcm90by5oYXMsXG4gIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSArPSBcIlwiO1xuICAgIHRoaXNbcHJlZml4ICsgdmFsdWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogcHJvdG8ucmVtb3ZlLFxuICBjbGVhcjogcHJvdG8uY2xlYXIsXG4gIHZhbHVlczogcHJvdG8ua2V5cyxcbiAgc2l6ZTogcHJvdG8uc2l6ZSxcbiAgZW1wdHk6IHByb3RvLmVtcHR5LFxuICBlYWNoOiBwcm90by5lYWNoXG59O1xuXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBmKSB7XG4gIHZhciBzZXQgPSBuZXcgU2V0O1xuXG4gIC8vIENvcHkgY29uc3RydWN0b3IuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTZXQpIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IHNldC5hZGQodmFsdWUpOyB9KTtcblxuICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdOKAmXMgYW4gYXJyYXkuXG4gIGVsc2UgaWYgKG9iamVjdCkge1xuICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoO1xuICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKG9iamVjdFtpXSk7XG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChmKG9iamVjdFtpXSwgaSwgb2JqZWN0KSk7XG4gIH1cblxuICByZXR1cm4gc2V0O1xufVxuXG52YXIga2V5cyA9IGZ1bmN0aW9uKG1hcCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgdmFsdWVzID0gZnVuY3Rpb24obWFwKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICByZXR1cm4gdmFsdWVzO1xufTtcblxudmFyIGVudHJpZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgZW50cmllcy5wdXNoKHtrZXk6IGtleSwgdmFsdWU6IG1hcFtrZXldfSk7XG4gIHJldHVybiBlbnRyaWVzO1xufTtcblxuZXhwb3J0cy5uZXN0ID0gbmVzdDtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLmtleXMgPSBrZXlzO1xuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5leHBvcnRzLmVudHJpZXMgPSBlbnRyaWVzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1jb2xvci8gVmVyc2lvbiAxLjAuMy4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG59O1xuXG5mdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG4gIHJldHVybiBwcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIENvbG9yKCkge31cblxudmFyIGRhcmtlciA9IDAuNztcbnZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIjtcbnZhciByZU4gPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiO1xudmFyIHJlUCA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiO1xudmFyIHJlSGV4MyA9IC9eIyhbMC05YS1mXXszfSkkLztcbnZhciByZUhleDYgPSAvXiMoWzAtOWEtZl17Nn0pJC87XG52YXIgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlSSwgcmVJLCByZUldICsgXCJcXFxcKSRcIik7XG52YXIgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlUCwgcmVQLCByZVBdICsgXCJcXFxcKSRcIik7XG52YXIgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVJLCByZUksIHJlSSwgcmVOXSArIFwiXFxcXCkkXCIpO1xudmFyIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlUCwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcbnZhciByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKTtcbnZhciByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xhXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIik7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkgKyBcIlwiO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4My5leGVjKGZvcm1hdCkpID8gKG0gPSBwYXJzZUludChtWzFdLCAxNiksIG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHgwZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpKSAvLyAjZjAwXG4gICAgICA6IChtID0gcmVIZXg2LmV4ZWMoZm9ybWF0KSkgPyByZ2JuKHBhcnNlSW50KG1bMV0sIDE2KSkgLy8gI2ZmMDAwMFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSlcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIHJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnIgJiYgdGhpcy5yIDw9IDI1NSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5nICYmIHRoaXMuZyA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMuYiAmJiB0aGlzLmIgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCIpXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuYikgfHwgMCkpXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24gaHNsYShoLCBzLCBsLCBhKSB7XG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcbiAgZWxzZSBpZiAobCA8PSAwIHx8IGwgPj0gMSkgaCA9IHMgPSBOYU47XG4gIGVsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfVxufSkpO1xuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG5cbnZhciBkZWcycmFkID0gTWF0aC5QSSAvIDE4MDtcbnZhciByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcblxudmFyIEtuID0gMTg7XG52YXIgWG4gPSAwLjk1MDQ3MDtcbnZhciBZbiA9IDE7XG52YXIgWm4gPSAxLjA4ODgzMDtcbnZhciB0MCA9IDQgLyAyOTtcbnZhciB0MSA9IDYgLyAyOTtcbnZhciB0MiA9IDMgKiB0MSAqIHQxO1xudmFyIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgdmFyIGggPSBvLmggKiBkZWcycmFkO1xuICAgIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xuICB9XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIGIgPSByZ2IyeHl6KG8uciksXG4gICAgICBhID0gcmdiMnh5eihvLmcpLFxuICAgICAgbCA9IHJnYjJ4eXooby5iKSxcbiAgICAgIHggPSB4eXoybGFiKCgwLjQxMjQ1NjQgKiBiICsgMC4zNTc1NzYxICogYSArIDAuMTgwNDM3NSAqIGwpIC8gWG4pLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIGIgKyAwLjcxNTE1MjIgKiBhICsgMC4wNzIxNzUwICogbCkgLyBZbiksXG4gICAgICB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogYiArIDAuMTE5MTkyMCAqIGEgKyAwLjk1MDMwNDEgKiBsKSAvIFpuKTtcbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgS24gKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gS24gKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICB4eXoycmdiKCAzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIDAuNDk4NTMxNCAqIHopLCAvLyBENjUgLT4gc1JHQlxuICAgICAgeHl6MnJnYigtMC45NjkyNjYwICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NjAgKiB6KSxcbiAgICAgIHh5ejJyZ2IoIDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24geHl6MnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogcmFkMmRlZztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhYkNvbnZlcnQodGhpcykucmdiKCk7XG4gIH1cbn0pKTtcblxudmFyIEEgPSAtMC4xNDg2MTtcbnZhciBCID0gKzEuNzgyNzc7XG52YXIgQyA9IC0wLjI5MjI3O1xudmFyIEQgPSAtMC45MDY0OTtcbnZhciBFID0gKzEuOTcyOTQ7XG52YXIgRUQgPSBFICogRDtcbnZhciBFQiA9IEUgKiBCO1xudmFyIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSByZXR1cm4gbmV3IEN1YmVoZWxpeChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcbiAgICAgIGJsID0gYiAtIGwsXG4gICAgICBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQsXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSwgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiByYWQyZGVnIC0gMTIwIDogTmFOO1xuICByZXR1cm4gbmV3IEN1YmVoZWxpeChoIDwgMCA/IGggKyAzNjAgOiBoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGN1YmVoZWxpeENvbnZlcnQoaCkgOiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShDdWJlaGVsaXgsIGN1YmVoZWxpeCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiBkZWcycmFkLFxuICAgICAgICBsID0gK3RoaXMubCxcbiAgICAgICAgYSA9IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zICogbCAqICgxIC0gbCksXG4gICAgICAgIGNvc2ggPSBNYXRoLmNvcyhoKSxcbiAgICAgICAgc2luaCA9IE1hdGguc2luKGgpO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgMjU1ICogKGwgKyBhICogKEEgKiBjb3NoICsgQiAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoRSAqIGNvc2gpKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZXhwb3J0cy5jb2xvciA9IGNvbG9yO1xuZXhwb3J0cy5yZ2IgPSByZ2I7XG5leHBvcnRzLmhzbCA9IGhzbDtcbmV4cG9ydHMubGFiID0gbGFiO1xuZXhwb3J0cy5oY2wgPSBoY2w7XG5leHBvcnRzLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZGlzcGF0Y2gvIFZlcnNpb24gMS4wLjEuIENvcHlyaWdodCAyMDE2IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBub29wID0ge3ZhbHVlOiBmdW5jdGlvbigpIHt9fTtcblxuICBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgICBfW3RdID0gW107XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG4gIH1cblxuICBmdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gICAgdGhpcy5fID0gXztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICAgIH0pO1xuICB9XG5cbiAgRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgICB0LFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gICAgfSxcbiAgICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZXhwb3J0cy5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTsiLCIvLyBodHRwczovL2QzanMub3JnL2QzLWZvcm1hdC8gVmVyc2lvbiAxLjAuMi4gQ29weXJpZ2h0IDIwMTYgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuICAvLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbiAgLy8gRm9yIGV4YW1wbGUsIGZvcm1hdERlY2ltYWwoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG4gIGZ1bmN0aW9uIGZvcm1hdERlY2ltYWwoeCwgcCkge1xuICAgIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICAgIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gICAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgICByZXR1cm4gW1xuICAgICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAgICt4LnNsaWNlKGkgKyAxKVxuICAgIF07XG4gIH1cblxuICBmdW5jdGlvbiBleHBvbmVudCh4KSB7XG4gICAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRHcm91cChncm91cGluZywgdGhvdXNhbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgdCA9IFtdLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdERlZmF1bHQoeCwgcCkge1xuICAgIHggPSB4LnRvUHJlY2lzaW9uKHApO1xuXG4gICAgb3V0OiBmb3IgKHZhciBuID0geC5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgICAgc3dpdGNoICh4W2ldKSB7XG4gICAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlXCI6IGJyZWFrIG91dDtcbiAgICAgICAgZGVmYXVsdDogaWYgKGkwID4gMCkgaTAgPSAwOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaTAgPiAwID8geC5zbGljZSgwLCBpMCkgKyB4LnNsaWNlKGkxICsgMSkgOiB4O1xuICB9XG5cbiAgdmFyIHByZWZpeEV4cG9uZW50O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeEF1dG8oeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um91bmRlZCh4LCBwKSB7XG4gICAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICAgIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICAgIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xuICB9XG5cbiAgdmFyIGZvcm1hdFR5cGVzID0ge1xuICAgIFwiXCI6IGZvcm1hdERlZmF1bHQsXG4gICAgXCIlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuICh4ICogMTAwKS50b0ZpeGVkKHApOyB9LFxuICAgIFwiYlwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpOyB9LFxuICAgIFwiY1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgXCJcIjsgfSxcbiAgICBcImRcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxMCk7IH0sXG4gICAgXCJlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9FeHBvbmVudGlhbChwKTsgfSxcbiAgICBcImZcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0ZpeGVkKHApOyB9LFxuICAgIFwiZ1wiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvUHJlY2lzaW9uKHApOyB9LFxuICAgIFwib1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDgpOyB9LFxuICAgIFwicFwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApOyB9LFxuICAgIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICAgIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICAgIFwiWFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9LFxuICAgIFwieFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KTsgfVxuICB9O1xuXG4gIC8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bdHlwZV1cbiAgdmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLVxcKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyhbYS16JV0pPyQvaTtcblxuICBmdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG5cbiAgICB2YXIgbWF0Y2gsXG4gICAgICAgIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIixcbiAgICAgICAgYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIixcbiAgICAgICAgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLFxuICAgICAgICBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLFxuICAgICAgICB6ZXJvID0gISFtYXRjaFs1XSxcbiAgICAgICAgd2lkdGggPSBtYXRjaFs2XSAmJiArbWF0Y2hbNl0sXG4gICAgICAgIGNvbW1hID0gISFtYXRjaFs3XSxcbiAgICAgICAgcHJlY2lzaW9uID0gbWF0Y2hbOF0gJiYgK21hdGNoWzhdLnNsaWNlKDEpLFxuICAgICAgICB0eXBlID0gbWF0Y2hbOV0gfHwgXCJcIjtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIE1hcCBpbnZhbGlkIHR5cGVzIHRvIHRoZSBkZWZhdWx0IGZvcm1hdC5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHR5cGUgPSBcIlwiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLnNpZ24gPSBzaWduO1xuICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgIHRoaXMuemVybyA9IHplcm87XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY29tbWEgPSBjb21tYTtcbiAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICAgKyB0aGlzLmFsaWduXG4gICAgICAgICsgdGhpcy5zaWduXG4gICAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLndpZHRoID09IG51bGwgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLnByZWNpc2lvbiA9PSBudWxsID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICAgKyB0aGlzLnR5cGU7XG4gIH07XG5cbiAgdmFyIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gICAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nICYmIGxvY2FsZS50aG91c2FuZHMgPyBmb3JtYXRHcm91cChsb2NhbGUuZ3JvdXBpbmcsIGxvY2FsZS50aG91c2FuZHMpIDogaWRlbnRpdHksXG4gICAgICAgIGN1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LFxuICAgICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWw7XG5cbiAgICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzBdIDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVsxXSA6IC9bJXBdLy50ZXN0KHR5cGUpID8gXCIlXCIgOiBcIlwiO1xuXG4gICAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgICBtYXliZVN1ZmZpeCA9ICF0eXBlIHx8IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAodHlwZSA/IDYgOiAxMilcbiAgICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgICAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgICAgaSwgbiwgYztcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBuZWdhdGl2ZSB0byBwb3NpdGl2ZSwgYW5kIGNvbXB1dGUgdGhlIHByZWZpeC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gKHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwKSAmJiAodmFsdWUgKj0gLTEsIHRydWUpO1xuXG4gICAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICAgIHZhbHVlID0gZm9ybWF0VHlwZSh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB2YWx1ZSB3YXMgbmVnYXRpdmUsIGl0IG1heSBiZSByb3VuZGVkIHRvIHplcm8gZHVyaW5nXG4gICAgICAgICAgLy8gZm9ybWF0dGluZzsgdHJlYXQgdGhpcyBhcyAocG9zaXRpdmUpIHplcm8uXG4gICAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgKDQ4IDwgYyAmJiBjIDwgNTgpXG4gICAgICAgICAgICAgICAgICB8fCAodHlwZSA9PT0gXCJ4XCIgJiYgOTYgPCBjICYmIGMgPCAxMDMpXG4gICAgICAgICAgICAgICAgICB8fCAodHlwZSA9PT0gXCJYXCIgJiYgNjQgPCBjICYmIGMgPCA3MSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZU5lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogXCItXCIpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHZhbHVlU3VmZml4ICsgKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7XG4gICAgICAgICAgY2FzZSBcIj1cIjogcmV0dXJuIHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgY2FzZSBcIl5cIjogcmV0dXJuIHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7XG4gICAgICB9XG5cbiAgICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3BlY2lmaWVyICsgXCJcIjtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzLFxuICAgICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgICB9O1xuICB9XG5cbiAgdmFyIGxvY2FsZTtcbiAgZGVmYXVsdExvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICAgIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgICBleHBvcnRzLmZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gICAgZXhwb3J0cy5mb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICAgIHJldHVybiBsb2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvblJvdW5kKHN0ZXAsIG1heCkge1xuICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50KG1heCkgLSBleHBvbmVudChzdGVwKSkgKyAxO1xuICB9XG5cbiAgZXhwb3J0cy5mb3JtYXREZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgZXhwb3J0cy5mb3JtYXRMb2NhbGUgPSBmb3JtYXRMb2NhbGU7XG4gIGV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuICBleHBvcnRzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XG4gIGV4cG9ydHMucHJlY2lzaW9uUHJlZml4ID0gcHJlY2lzaW9uUHJlZml4O1xuICBleHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpOyIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtaW50ZXJwb2xhdGUvIFZlcnNpb24gMS4xLjUuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtY29sb3InKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWNvbG9yJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0NvbG9yKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxudmFyIGJhc2lzJDEgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxuICAgICAgICB2MSA9IHZhbHVlc1tpXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbaSArIDFdLFxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxuICAgICAgICB2MyA9IGkgPCBuIC0gMSA/IHZhbHVlc1tpICsgMl0gOiAyICogdjIgLSB2MTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59O1xuXG52YXIgYmFzaXNDbG9zZWQgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59O1xuXG52YXIgY29uc3RhbnQgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHVlKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG52YXIgcmdiJDEgPSAoKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcbiAgdmFyIGNvbG9yJCQxID0gZ2FtbWEoeSk7XG5cbiAgZnVuY3Rpb24gcmdiJCQxKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGNvbG9yJCQxKChzdGFydCA9IGQzQ29sb3IucmdiKHN0YXJ0KSkuciwgKGVuZCA9IGQzQ29sb3IucmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3IkJDEoc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3IkJDEoc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiJCQxLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYiQkMTtcbn0pKSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvciQkMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciQkMSA9IGQzQ29sb3IucmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IkJDEuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yJCQxLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvciQkMS5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yJCQxLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvciQkMS5yID0gcih0KTtcbiAgICAgIGNvbG9yJCQxLmcgPSBnKHQpO1xuICAgICAgY29sb3IkJDEuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IkJDEgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbnZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyQxKTtcbnZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYiksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn07XG5cbnZhciBkYXRlID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgZCA9IG5ldyBEYXRlO1xuICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZC5zZXRUaW1lKGEgKyBiICogdCksIGQ7XG4gIH07XG59O1xuXG52YXIgbnVtYmVyID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIGIgKiB0O1xuICB9O1xufTtcblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSB2YWx1ZShhW2tdLCBiW2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1trXSA9IGJba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59O1xuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nO1xudmFyIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn07XG5cbnZhciB2YWx1ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIHQgPSB0eXBlb2YgYiwgYztcbiAgcmV0dXJuIGIgPT0gbnVsbCB8fCB0ID09PSBcImJvb2xlYW5cIiA/IGNvbnN0YW50KGIpXG4gICAgICA6ICh0ID09PSBcIm51bWJlclwiID8gbnVtYmVyXG4gICAgICA6IHQgPT09IFwic3RyaW5nXCIgPyAoKGMgPSBkM0NvbG9yLmNvbG9yKGIpKSA/IChiID0gYywgcmdiJDEpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgZDNDb2xvci5jb2xvciA/IHJnYiQxXG4gICAgICA6IGIgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gYXJyYXlcbiAgICAgIDogdHlwZW9mIGIudmFsdWVPZiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiLnRvU3RyaW5nICE9PSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4oYikgPyBvYmplY3RcbiAgICAgIDogbnVtYmVyKShhLCBiKTtcbn07XG5cbnZhciByb3VuZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiAtPSBhLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSArIGIgKiB0KTtcbiAgfTtcbn07XG5cbnZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxudmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxudmFyIGRlY29tcG9zZSA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufTtcblxudmFyIGNzc05vZGU7XG52YXIgY3NzUm9vdDtcbnZhciBjc3NWaWV3O1xudmFyIHN2Z05vZGU7XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJub25lXCIpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFjc3NOb2RlKSBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKSwgY3NzUm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgY3NzVmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjc3NOb2RlLnN0eWxlLnRyYW5zZm9ybSA9IHZhbHVlO1xuICB2YWx1ZSA9IGNzc1ZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjc3NSb290LmFwcGVuZENoaWxkKGNzc05vZGUpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwidHJhbnNmb3JtXCIpO1xuICBjc3NSb290LnJlbW92ZUNoaWxkKGNzc05vZGUpO1xuICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDcsIC0xKS5zcGxpdChcIixcIik7XG4gIHJldHVybiBkZWNvbXBvc2UoK3ZhbHVlWzBdLCArdmFsdWVbMV0sICt2YWx1ZVsyXSwgK3ZhbHVlWzNdLCArdmFsdWVbNF0sICt2YWx1ZVs1XSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3ZnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghc3ZnTm9kZSkgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdmFsdWUpO1xuICBpZiAoISh2YWx1ZSA9IHN2Z05vZGUudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkpIHJldHVybiBpZGVudGl0eTtcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XG4gIHJldHVybiBkZWNvbXBvc2UodmFsdWUuYSwgdmFsdWUuYiwgdmFsdWUuYywgdmFsdWUuZCwgdmFsdWUuZSwgdmFsdWUuZik7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuXG4gIGZ1bmN0aW9uIHBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiIFwiIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiIHx8IHliKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB4YiArIHB4Q29tbWEgKyB5YiArIHB4UGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdGF0ZShhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIGlmIChhIC0gYiA+IDE4MCkgYiArPSAzNjA7IGVsc2UgaWYgKGIgLSBhID4gMTgwKSBhICs9IDM2MDsgLy8gc2hvcnRlc3QgcGF0aFxuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2V3WChhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiICE9PSAxIHx8IHliICE9PSAxKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiArIHhiICsgXCIsXCIgKyB5YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XG4gICAgdHJhbnNsYXRlKGEudHJhbnNsYXRlWCwgYS50cmFuc2xhdGVZLCBiLnRyYW5zbGF0ZVgsIGIudHJhbnNsYXRlWSwgcywgcSk7XG4gICAgcm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XG4gICAgc2NhbGUoYS5zY2FsZVgsIGEuc2NhbGVZLCBiLnNjYWxlWCwgYi5zY2FsZVksIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDsgLy8gZ2NcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG52YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuXG52YXIgcmhvID0gTWF0aC5TUVJUMjtcbnZhciByaG8yID0gMjtcbnZhciByaG80ID0gNDtcbnZhciBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG4vLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4vLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG52YXIgem9vbSA9IGZ1bmN0aW9uKHAwLCBwMSkge1xuICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLFxuICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgZHggPSB1eDEgLSB1eDAsXG4gICAgICBkeSA9IHV5MSAtIHV5MCxcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICBpLFxuICAgICAgUztcblxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgaWYgKGQyIDwgZXBzaWxvbjIpIHtcbiAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XG4gICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHV4MCArIHQgKiBkeCxcbiAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICB3MCAqIE1hdGguZXhwKHJobyAqIHQgKiBTKVxuICAgICAgXTtcbiAgICB9O1xuICB9XG5cbiAgLy8gR2VuZXJhbCBjYXNlLlxuICBlbHNlIHtcbiAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG80ICogZDIpIC8gKDIgKiB3MSAqIHJobzIgKiBkMSksXG4gICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgIFMgPSAocjEgLSByMCkgLyByaG87XG4gICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgY29zaHIwID0gY29zaChyMCksXG4gICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdXgwICsgdSAqIGR4LFxuICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICBdO1xuICAgIH07XG4gIH1cblxuICBpLmR1cmF0aW9uID0gUyAqIDEwMDA7XG5cbiAgcmV0dXJuIGk7XG59O1xuXG5mdW5jdGlvbiBoc2wkMShodWUkJDEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSQkMSgoc3RhcnQgPSBkM0NvbG9yLmhzbChzdGFydCkpLmgsIChlbmQgPSBkM0NvbG9yLmhzbChlbmQpKS5oKSxcbiAgICAgICAgcyA9IG5vZ2FtbWEoc3RhcnQucywgZW5kLnMpLFxuICAgICAgICBsID0gbm9nYW1tYShzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGhzbCQyID0gaHNsJDEoaHVlKTtcbnZhciBoc2xMb25nID0gaHNsJDEobm9nYW1tYSk7XG5cbmZ1bmN0aW9uIGxhYiQxKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBub2dhbW1hKChzdGFydCA9IGQzQ29sb3IubGFiKHN0YXJ0KSkubCwgKGVuZCA9IGQzQ29sb3IubGFiKGVuZCkpLmwpLFxuICAgICAgYSA9IG5vZ2FtbWEoc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IG5vZ2FtbWEoc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgIHN0YXJ0LmEgPSBhKHQpO1xuICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGhjbCQxKGh1ZSQkMSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlJCQxKChzdGFydCA9IGQzQ29sb3IuaGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGQzQ29sb3IuaGNsKGVuZCkpLmgpLFxuICAgICAgICBjID0gbm9nYW1tYShzdGFydC5jLCBlbmQuYyksXG4gICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaGNsJDIgPSBoY2wkMShodWUpO1xudmFyIGhjbExvbmcgPSBoY2wkMShub2dhbW1hKTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4JDEoaHVlJCQxKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeCQkMShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSQkMSgoc3RhcnQgPSBkM0NvbG9yLmN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBkM0NvbG9yLmN1YmVoZWxpeChlbmQpKS5oKSxcbiAgICAgICAgICBzID0gbm9nYW1tYShzdGFydC5zLCBlbmQucyksXG4gICAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4JCQxLmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG5cbiAgICByZXR1cm4gY3ViZWhlbGl4JCQxO1xuICB9KSgxKTtcbn1cblxudmFyIGN1YmVoZWxpeCQyID0gY3ViZWhlbGl4JDEoaHVlKTtcbnZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4JDEobm9nYW1tYSk7XG5cbnZhciBxdWFudGl6ZSA9IGZ1bmN0aW9uKGludGVycG9sYXRvciwgbikge1xuICB2YXIgc2FtcGxlcyA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoaSAvIChuIC0gMSkpO1xuICByZXR1cm4gc2FtcGxlcztcbn07XG5cbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVBcnJheSA9IGFycmF5O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJhc2lzID0gYmFzaXMkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZURhdGUgPSBkYXRlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVPYmplY3QgPSBvYmplY3Q7XG5leHBvcnRzLmludGVycG9sYXRlUm91bmQgPSByb3VuZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVTdHJpbmcgPSBzdHJpbmc7XG5leHBvcnRzLmludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3M7XG5leHBvcnRzLmludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Tdmc7XG5leHBvcnRzLmludGVycG9sYXRlWm9vbSA9IHpvb207XG5leHBvcnRzLmludGVycG9sYXRlUmdiID0gcmdiJDE7XG5leHBvcnRzLmludGVycG9sYXRlUmdiQmFzaXMgPSByZ2JCYXNpcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZCA9IHJnYkJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbCA9IGhzbCQyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbExvbmcgPSBoc2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUxhYiA9IGxhYiQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbCA9IGhjbCQyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbExvbmcgPSBoY2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeCA9IGN1YmVoZWxpeCQyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXhMb25nO1xuZXhwb3J0cy5xdWFudGl6ZSA9IHF1YW50aXplO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zY2FsZS8gVmVyc2lvbiAxLjAuMy4gQ29weXJpZ2h0IDIwMTYgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1hcnJheScpLCByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLWZvcm1hdCcpLCByZXF1aXJlKCdkMy10aW1lJyksIHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLWNvbG9yJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1hcnJheScsICdkMy1jb2xsZWN0aW9uJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLWZvcm1hdCcsICdkMy10aW1lJywgJ2QzLXRpbWUtZm9ybWF0JywgJ2QzLWNvbG9yJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLGQzQXJyYXksZDNDb2xsZWN0aW9uLGQzSW50ZXJwb2xhdGUsZDNGb3JtYXQsZDNUaW1lLGQzVGltZUZvcm1hdCxkM0NvbG9yKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIG1hcCQxID0gYXJyYXkubWFwO1xuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcblxuICB2YXIgaW1wbGljaXQgPSB7bmFtZTogXCJpbXBsaWNpdFwifTtcblxuICBmdW5jdGlvbiBvcmRpbmFsKHJhbmdlKSB7XG4gICAgdmFyIGluZGV4ID0gZDNDb2xsZWN0aW9uLm1hcCgpLFxuICAgICAgICBkb21haW4gPSBbXSxcbiAgICAgICAgdW5rbm93biA9IGltcGxpY2l0O1xuXG4gICAgcmFuZ2UgPSByYW5nZSA9PSBudWxsID8gW10gOiBzbGljZS5jYWxsKHJhbmdlKTtcblxuICAgIGZ1bmN0aW9uIHNjYWxlKGQpIHtcbiAgICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgICAgaWYgKCFpKSB7XG4gICAgICAgIGlmICh1bmtub3duICE9PSBpbXBsaWNpdCkgcmV0dXJuIHVua25vd247XG4gICAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VbKGkgLSAxKSAlIHJhbmdlLmxlbmd0aF07XG4gICAgfVxuXG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgICBkb21haW4gPSBbXSwgaW5kZXggPSBkM0NvbGxlY3Rpb24ubWFwKCk7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4LmhhcyhrZXkgPSAoZCA9IF9baV0pICsgXCJcIikpIGluZGV4LnNldChrZXksIGRvbWFpbi5wdXNoKGQpKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG9yZGluYWwoKVxuICAgICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFuZCgpIHtcbiAgICB2YXIgc2NhbGUgPSBvcmRpbmFsKCkudW5rbm93bih1bmRlZmluZWQpLFxuICAgICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgYmFuZHdpZHRoLFxuICAgICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgICBhbGlnbiA9IDAuNTtcblxuICAgIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBuID0gZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICAgIHN0YXJ0ID0gcmFuZ2VbcmV2ZXJzZSAtIDBdLFxuICAgICAgICAgIHN0b3AgPSByYW5nZVsxIC0gcmV2ZXJzZV07XG4gICAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgc3RhcnQgKz0gKHN0b3AgLSBzdGFydCAtIHN0ZXAgKiAobiAtIHBhZGRpbmdJbm5lcikpICogYWxpZ247XG4gICAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgICB2YXIgdmFsdWVzID0gZDNBcnJheS5yYW5nZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgICB9XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiByYW5nZSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYmFuZHdpZHRoO1xuICAgIH07XG5cbiAgICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9O1xuXG4gICAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICAgIH07XG5cbiAgICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gcGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICAgIH07XG5cbiAgICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gICAgfTtcblxuICAgIHNjYWxlLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdPdXRlcjtcbiAgICB9O1xuXG4gICAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbGlnbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IGFsaWduO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYmFuZCgpXG4gICAgICAgICAgLmRvbWFpbihkb21haW4oKSlcbiAgICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAgIC5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKVxuICAgICAgICAgIC5hbGlnbihhbGlnbik7XG4gICAgfTtcblxuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludGlzaChzY2FsZSkge1xuICAgIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICAgIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gICAgZGVsZXRlIHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBvaW50aXNoKGNvcHkoKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50KCkge1xuICAgIHJldHVybiBwb2ludGlzaChiYW5kKCkucGFkZGluZ0lubmVyKDEpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgICByZXR1cm4gK3g7XG4gIH1cblxuICB2YXIgdW5pdCA9IFswLCAxXTtcblxuICBmdW5jdGlvbiBkZWludGVycG9sYXRlKGEsIGIpIHtcbiAgICByZXR1cm4gKGIgLT0gKGEgPSArYSkpXG4gICAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgICAgOiBjb25zdGFudChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGVDbGFtcChkZWludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciBkID0gZGVpbnRlcnBvbGF0ZShhID0gK2EsIGIgPSArYik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geCA8PSBhID8gMCA6IHggPj0gYiA/IDEgOiBkKHgpOyB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgciA9IHJlaW50ZXJwb2xhdGUoYSA9ICthLCBiID0gK2IpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQgPD0gMCA/IGEgOiB0ID49IDEgPyBiIDogcih0KTsgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSkge1xuICAgIHZhciBkMCA9IGRvbWFpblswXSwgZDEgPSBkb21haW5bMV0sIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV07XG4gICAgaWYgKGQxIDwgZDApIGQwID0gZGVpbnRlcnBvbGF0ZShkMSwgZDApLCByMCA9IHJlaW50ZXJwb2xhdGUocjEsIHIwKTtcbiAgICBlbHNlIGQwID0gZGVpbnRlcnBvbGF0ZShkMCwgZDEpLCByMCA9IHJlaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gcjAoZDAoeCkpOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gICAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcbiAgICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgICAgaSA9IC0xO1xuXG4gICAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gICAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgZFtpXSA9IGRlaW50ZXJwb2xhdGUoZG9tYWluW2ldLCBkb21haW5baSArIDFdKTtcbiAgICAgIHJbaV0gPSByZWludGVycG9sYXRlKHJhbmdlW2ldLCByYW5nZVtpICsgMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgaSA9IGQzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xuICAgICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0XG4gICAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShzb3VyY2UuaW50ZXJwb2xhdGUoKSlcbiAgICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKTtcbiAgfVxuXG4gIC8vIGRlaW50ZXJwb2xhdGUoYSwgYikoeCkgdGFrZXMgYSBkb21haW4gdmFsdWUgeCBpbiBbYSxiXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgdCBpbiBbMCwxXS5cbiAgLy8gcmVpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdLlxuICBmdW5jdGlvbiBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUkJCwgcmVpbnRlcnBvbGF0ZSkge1xuICAgIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgICByYW5nZSA9IHVuaXQsXG4gICAgICAgIGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZSxcbiAgICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgICAgcGllY2V3aXNlLFxuICAgICAgICBvdXRwdXQsXG4gICAgICAgIGlucHV0O1xuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHBpZWNld2lzZSA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgICAgb3V0cHV0ID0gaW5wdXQgPSBudWxsO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UoZG9tYWluLCByYW5nZSwgY2xhbXAgPyBkZWludGVycG9sYXRlQ2xhbXAoZGVpbnRlcnBvbGF0ZSQkKSA6IGRlaW50ZXJwb2xhdGUkJCwgaW50ZXJwb2xhdGUpKSkoK3gpO1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiAoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlLCBkb21haW4sIGRlaW50ZXJwb2xhdGUsIGNsYW1wID8gcmVpbnRlcnBvbGF0ZUNsYW1wKHJlaW50ZXJwb2xhdGUpIDogcmVpbnRlcnBvbGF0ZSkpKSgreSk7XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcCQxLmNhbGwoXywgbnVtYmVyKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCByZXNjYWxlKCkpIDogY2xhbXA7XG4gICAgfTtcblxuICAgIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGU7XG4gICAgfTtcblxuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrRm9ybWF0KGRvbWFpbiwgY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBzdGFydCA9IGRvbWFpblswXSxcbiAgICAgICAgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sXG4gICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCksXG4gICAgICAgIHByZWNpc2lvbjtcbiAgICBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICAgIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IGQzRm9ybWF0LnByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgICByZXR1cm4gZDNGb3JtYXQuZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlwiOlxuICAgICAgY2FzZSBcImVcIjpcbiAgICAgIGNhc2UgXCJnXCI6XG4gICAgICBjYXNlIFwicFwiOlxuICAgICAgY2FzZSBcInJcIjoge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImZcIjpcbiAgICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChzcGVjaWZpZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gICAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgICByZXR1cm4gZDNBcnJheS50aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgICB9O1xuXG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICAgIHJldHVybiB0aWNrRm9ybWF0KGRvbWFpbigpLCBjb3VudCwgc3BlY2lmaWVyKTtcbiAgICB9O1xuXG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICAgIGkgPSBkLmxlbmd0aCAtIDEsXG4gICAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LFxuICAgICAgICAgIHN0YXJ0ID0gZFswXSxcbiAgICAgICAgICBzdG9wID0gZFtpXSxcbiAgICAgICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCwgc3RvcCwgbik7XG5cbiAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXAsIE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwLCBuKTtcbiAgICAgICAgZFswXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIGRbaV0gPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgZG9tYWluKGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcblxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXIpO1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgICB2YXIgZG9tYWluID0gWzAsIDFdO1xuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuICt4O1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gICAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAkMS5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKS5kb21haW4oZG9tYWluKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBuaWNlKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICAgIHZhciBpMCA9IDAsXG4gICAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgICAgeDEgPSBkb21haW5baTFdLFxuICAgICAgICB0O1xuXG4gICAgaWYgKHgxIDwgeDApIHtcbiAgICAgIHQgPSBpMCwgaTAgPSBpMSwgaTEgPSB0O1xuICAgICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgfVxuXG4gICAgZG9tYWluW2kwXSA9IGludGVydmFsLmZsb29yKHgwKTtcbiAgICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUkMShhLCBiKSB7XG4gICAgcmV0dXJuIChiID0gTWF0aC5sb2coYiAvIGEpKVxuICAgICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHggLyBhKSAvIGI7IH1cbiAgICAgICAgOiBjb25zdGFudChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIHJldHVybiBhIDwgMFxuICAgICAgICA/IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIC1NYXRoLnBvdygtYiwgdCkgKiBNYXRoLnBvdygtYSwgMSAtIHQpOyB9XG4gICAgICAgIDogZnVuY3Rpb24odCkgeyByZXR1cm4gTWF0aC5wb3coYiwgdCkgKiBNYXRoLnBvdyhhLCAxIC0gdCk7IH07XG4gIH1cblxuICBmdW5jdGlvbiBwb3cxMCh4KSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG4gIH1cblxuICBmdW5jdGlvbiBwb3dwKGJhc2UpIHtcbiAgICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5wb3coYmFzZSwgeCk7IH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgICByZXR1cm4gYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5sb2dcbiAgICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICAgIHx8IChiYXNlID0gTWF0aC5sb2coYmFzZSksIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHgpIC8gYmFzZTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC1mKC14KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nKCkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSQxLCByZWludGVycG9sYXRlKS5kb21haW4oWzEsIDEwXSksXG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgICAgYmFzZSA9IDEwLFxuICAgICAgICBsb2dzID0gbG9ncCgxMCksXG4gICAgICAgIHBvd3MgPSBwb3dwKDEwKTtcblxuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICBsb2dzID0gbG9ncChiYXNlKSwgcG93cyA9IHBvd3AoYmFzZSk7XG4gICAgICBpZiAoZG9tYWluKClbMF0gPCAwKSBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuXG4gICAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhc2UgPSArXywgcmVzY2FsZSgpKSA6IGJhc2U7XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICAgIH07XG5cbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICAgIHUgPSBkWzBdLFxuICAgICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgcjtcblxuICAgICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICAgIGogPSBsb2dzKHYpLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgayxcbiAgICAgICAgICB0LFxuICAgICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgICAgeiA9IFtdO1xuXG4gICAgICBpZiAoIShiYXNlICUgMSkgJiYgaiAtIGkgPCBuKSB7XG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpIC0gMSwgaiA9IE1hdGgucm91bmQoaikgKyAxO1xuICAgICAgICBpZiAodSA+IDApIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgZm9yIChrID0gMSwgcCA9IHBvd3MoaSk7IGsgPCBiYXNlOyArK2spIHtcbiAgICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6ID0gZDNBcnJheS50aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHIgPyB6LnJldmVyc2UoKSA6IHo7XG4gICAgfTtcblxuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xuICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0KHNwZWNpZmllcik7XG4gICAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gc3BlY2lmaWVyO1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgICByZXR1cm4gaSA8PSBrID8gc3BlY2lmaWVyKGQpIDogXCJcIjtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgICAgY2VpbDogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmNlaWwobG9ncyh4KSkpOyB9XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKS5iYXNlKGJhc2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFpc2UoeCwgZXhwb25lbnQpIHtcbiAgICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvdygpIHtcbiAgICB2YXIgZXhwb25lbnQgPSAxLFxuICAgICAgICBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSksXG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICAgIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgICAgcmV0dXJuIChiID0gcmFpc2UoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZShhLCBleHBvbmVudCkpKVxuICAgICAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHJhaXNlKHgsIGV4cG9uZW50KSAtIGEpIC8gYjsgfVxuICAgICAgICAgIDogY29uc3RhbnQoYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgICBiID0gcmFpc2UoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZShhLCBleHBvbmVudCkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHJhaXNlKGEgKyBiICogdCwgMSAvIGV4cG9uZW50KTsgfTtcbiAgICB9XG5cbiAgICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIGRvbWFpbihkb21haW4oKSkpIDogZXhwb25lbnQ7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKS5leHBvbmVudChleHBvbmVudCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNxcnQoKSB7XG4gICAgcmV0dXJuIHBvdygpLmV4cG9uZW50KDAuNSk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGlsZSQxKCkge1xuICAgIHZhciBkb21haW4gPSBbXSxcbiAgICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgICAgdGhyZXNob2xkcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgICB0aHJlc2hvbGRzID0gbmV3IEFycmF5KG4gLSAxKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IGQzQXJyYXkucXVhbnRpbGUoZG9tYWluLCBpIC8gbik7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gcmFuZ2VbZDNBcnJheS5iaXNlY3QodGhyZXNob2xkcywgeCldO1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgICBdO1xuICAgIH07XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgICAgZG9tYWluLnNvcnQoZDNBcnJheS5hc2NlbmRpbmcpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWFudGlsZSQxKClcbiAgICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgICAucmFuZ2UocmFuZ2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgICB2YXIgeDAgPSAwLFxuICAgICAgICB4MSA9IDEsXG4gICAgICAgIG4gPSAxLFxuICAgICAgICBkb21haW4gPSBbMC41XSxcbiAgICAgICAgcmFuZ2UgPSBbMCwgMV07XG5cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoeCA8PSB4KSByZXR1cm4gcmFuZ2VbZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAwLCBuKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBpID0gLTE7XG4gICAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF0sIHgxID0gK19bMV0sIHJlc2NhbGUoKSkgOiBbeDAsIHgxXTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gKHJhbmdlID0gc2xpY2UuY2FsbChfKSkubGVuZ3RoIC0gMSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgICAgOiBpID49IG4gPyBbZG9tYWluW24gLSAxXSwgeDFdXG4gICAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1YW50aXplKClcbiAgICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAgIC5yYW5nZShyYW5nZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICAgIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICAgIG4gPSAxO1xuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2QzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildO1xuICAgIH1cblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgICAgLnJhbmdlKHJhbmdlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgdmFyIGR1cmF0aW9uU2Vjb25kID0gMTAwMDtcbiAgdmFyIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbiAgdmFyIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjA7XG4gIHZhciBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0O1xuICB2YXIgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xuICB2YXIgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzA7XG4gIHZhciBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcbiAgZnVuY3Rpb24gZGF0ZSh0KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbnVtYmVyJDEodCkge1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSB7XG4gICAgdmFyIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlLCBkM0ludGVycG9sYXRlLmludGVycG9sYXRlTnVtYmVyKSxcbiAgICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQoXCIuJUxcIiksXG4gICAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgICAgZm9ybWF0TWludXRlID0gZm9ybWF0KFwiJUk6JU1cIiksXG4gICAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQoXCIlSSAlcFwiKSxcbiAgICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICAgIGZvcm1hdFdlZWsgPSBmb3JtYXQoXCIlYiAlZFwiKSxcbiAgICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQoXCIlQlwiKSxcbiAgICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gICAgdmFyIHRpY2tJbnRlcnZhbHMgPSBbXG4gICAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbc2Vjb25kLCAxNSwgMTUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbbWludXRlLCAgNSwgIDUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbICBob3VyLCAgMSwgICAgICBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICBob3VyLCAxMiwgMTIgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgICBbICB3ZWVrLCAgMSwgICAgICBkdXJhdGlvbldlZWsgIF0sXG4gICAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgICBbICB5ZWFyLCAgMSwgICAgICBkdXJhdGlvblllYXIgIF1cbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgICByZXR1cm4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgICA6IGRheShkYXRlKSA8IGRhdGUgPyBmb3JtYXRIb3VyXG4gICAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgaWYgKGludGVydmFsID09IG51bGwpIGludGVydmFsID0gMTA7XG5cbiAgICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxuICAgICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGludGVydmFsIGlzIGFscmVhZHkgYSB0aW1lIGludGVydmFsIGFuZCB1c2UgaXQuXG4gICAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgICBpID0gZDNBcnJheS5iaXNlY3RvcihmdW5jdGlvbihpKSB7IHJldHVybiBpWzJdOyB9KS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgICAgICBpZiAoaSA9PT0gdGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICAgIGludGVydmFsID0geWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChpKSB7XG4gICAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgICBpbnRlcnZhbCA9IGlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcCA9IGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIGludGVydmFsKTtcbiAgICAgICAgICBpbnRlcnZhbCA9IG1pbGxpc2Vjb25kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICAgIH07XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihtYXAkMS5jYWxsKF8sIG51bWJlciQxKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gICAgfTtcblxuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgICAgdDAgPSBkWzBdLFxuICAgICAgICAgIHQxID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICAgIHQ7XG4gICAgICBpZiAocikgdCA9IHQwLCB0MCA9IHQxLCB0MSA9IHQ7XG4gICAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgICAgdCA9IHQgPyB0LnJhbmdlKHQwLCB0MSArIDEpIDogW107IC8vIGluY2x1c2l2ZSBzdG9wXG4gICAgICByZXR1cm4gciA/IHQucmV2ZXJzZSgpIDogdDtcbiAgICB9O1xuXG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IHRpY2tGb3JtYXQgOiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICB9O1xuXG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgICA/IGRvbWFpbihuaWNlKGQsIGludGVydmFsKSlcbiAgICAgICAgICA6IHNjYWxlO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29weShzY2FsZSwgY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZSgpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIoZDNUaW1lLnRpbWVZZWFyLCBkM1RpbWUudGltZU1vbnRoLCBkM1RpbWUudGltZVdlZWssIGQzVGltZS50aW1lRGF5LCBkM1RpbWUudGltZUhvdXIsIGQzVGltZS50aW1lTWludXRlLCBkM1RpbWUudGltZVNlY29uZCwgZDNUaW1lLnRpbWVNaWxsaXNlY29uZCwgZDNUaW1lRm9ybWF0LnRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGNUaW1lKCkge1xuICAgIHJldHVybiBjYWxlbmRhcihkM1RpbWUudXRjWWVhciwgZDNUaW1lLnV0Y01vbnRoLCBkM1RpbWUudXRjV2VlaywgZDNUaW1lLnV0Y0RheSwgZDNUaW1lLnV0Y0hvdXIsIGQzVGltZS51dGNNaW51dGUsIGQzVGltZS51dGNTZWNvbmQsIGQzVGltZS51dGNNaWxsaXNlY29uZCwgZDNUaW1lRm9ybWF0LnV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyMDAwLCAwLCAxKSwgRGF0ZS5VVEMoMjAwMCwgMCwgMildKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9ycyhzKSB7XG4gICAgcmV0dXJuIHMubWF0Y2goLy57Nn0vZykubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBcIiNcIiArIHg7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2F0ZWdvcnkxMCA9IGNvbG9ycyhcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKTtcblxuICB2YXIgY2F0ZWdvcnkyMGIgPSBjb2xvcnMoXCIzOTNiNzk1MjU0YTM2YjZlY2Y5YzllZGU2Mzc5Mzk4Y2EyNTJiNWNmNmJjZWRiOWM4YzZkMzFiZDllMzllN2JhNTJlN2NiOTQ4NDNjMzlhZDQ5NGFkNjYxNmJlNzk2OWM3YjQxNzNhNTUxOTRjZTZkYmRkZTllZDZcIik7XG5cbiAgdmFyIGNhdGVnb3J5MjBjID0gY29sb3JzKFwiMzE4MmJkNmJhZWQ2OWVjYWUxYzZkYmVmZTY1NTBkZmQ4ZDNjZmRhZTZiZmRkMGEyMzFhMzU0NzRjNDc2YTFkOTliYzdlOWMwNzU2YmIxOWU5YWM4YmNiZGRjZGFkYWViNjM2MzYzOTY5Njk2YmRiZGJkZDlkOWQ5XCIpO1xuXG4gIHZhciBjYXRlZ29yeTIwID0gY29sb3JzKFwiMWY3N2I0YWVjN2U4ZmY3ZjBlZmZiYjc4MmNhMDJjOThkZjhhZDYyNzI4ZmY5ODk2OTQ2N2JkYzViMGQ1OGM1NjRiYzQ5Yzk0ZTM3N2MyZjdiNmQyN2Y3ZjdmYzdjN2M3YmNiZDIyZGJkYjhkMTdiZWNmOWVkYWU1XCIpO1xuXG4gIHZhciBjdWJlaGVsaXgkMSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KDMwMCwgMC41LCAwLjApLCBkM0NvbG9yLmN1YmVoZWxpeCgtMjQwLCAwLjUsIDEuMCkpO1xuXG4gIHZhciB3YXJtID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoLTEwMCwgMC43NSwgMC4zNSksIGQzQ29sb3IuY3ViZWhlbGl4KDgwLCAxLjUwLCAwLjgpKTtcblxuICB2YXIgY29vbCA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KDI2MCwgMC43NSwgMC4zNSksIGQzQ29sb3IuY3ViZWhlbGl4KDgwLCAxLjUwLCAwLjgpKTtcblxuICB2YXIgcmFpbmJvdyA9IGQzQ29sb3IuY3ViZWhlbGl4KCk7XG5cbiAgZnVuY3Rpb24gcmFpbmJvdyQxKHQpIHtcbiAgICBpZiAodCA8IDAgfHwgdCA+IDEpIHQgLT0gTWF0aC5mbG9vcih0KTtcbiAgICB2YXIgdHMgPSBNYXRoLmFicyh0IC0gMC41KTtcbiAgICByYWluYm93LmggPSAzNjAgKiB0IC0gMTAwO1xuICAgIHJhaW5ib3cucyA9IDEuNSAtIDEuNSAqIHRzO1xuICAgIHJhaW5ib3cubCA9IDAuOCAtIDAuOSAqIHRzO1xuICAgIHJldHVybiByYWluYm93ICsgXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbXAocmFuZ2UpIHtcbiAgICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHZpcmlkaXMgPSByYW1wKGNvbG9ycyhcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSk7XG5cbiAgdmFyIG1hZ21hID0gcmFtcChjb2xvcnMoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMDkwMjAyMGIwMjAyMGQwMzAzMGYwMzAzMTIwNDA0MTQwNTA0MTYwNjA1MTgwNjA1MWEwNzA2MWMwODA3MWUwOTA3MjAwYTA4MjIwYjA5MjQwYzA5MjYwZDBhMjkwZTBiMmIxMDBiMmQxMTBjMmYxMjBkMzExMzBkMzQxNDBlMzYxNTBlMzgxNjBmM2IxODBmM2QxOTEwM2YxYTEwNDIxYzEwNDQxZDExNDcxZTExNDkyMDExNGIyMTExNGUyMjExNTAyNDEyNTMyNTEyNTUyNzEyNTgyOTExNWEyYTExNWMyYzExNWYyZDExNjEyZjExNjMzMTExNjUzMzEwNjczNDEwNjkzNjEwNmIzODEwNmMzOTBmNmUzYjBmNzAzZDBmNzEzZjBmNzI0MDBmNzQ0MjBmNzU0NDBmNzY0NTEwNzc0NzEwNzg0OTEwNzg0YTEwNzk0YzExN2E0ZTExN2I0ZjEyN2I1MTEyN2M1MjEzN2M1NDEzN2Q1NjE0N2Q1NzE1N2U1OTE1N2U1YTE2N2U1YzE2N2Y1ZDE3N2Y1ZjE4N2Y2MDE4ODA2MjE5ODA2NDFhODA2NTFhODA2NzFiODA2ODFjODE2YTFjODE2YjFkODE2ZDFkODE2ZTFlODE3MDFmODE3MjFmODE3MzIwODE3NTIxODE3NjIxODE3ODIyODE3OTIyODI3YjIzODI3YzIzODI3ZTI0ODI4MDI1ODI4MTI1ODE4MzI2ODE4NDI2ODE4NjI3ODE4ODI3ODE4OTI4ODE4YjI5ODE4YzI5ODE4ZTJhODE5MDJhODE5MTJiODE5MzJiODA5NDJjODA5NjJjODA5ODJkODA5OTJkODA5YjJlN2Y5YzJlN2Y5ZTJmN2ZhMDJmN2ZhMTMwN2VhMzMwN2VhNTMxN2VhNjMxN2RhODMyN2RhYTMzN2RhYjMzN2NhZDM0N2NhZTM0N2JiMDM1N2JiMjM1N2JiMzM2N2FiNTM2N2FiNzM3NzliODM3NzliYTM4NzhiYzM5NzhiZDM5NzdiZjNhNzdjMDNhNzZjMjNiNzVjNDNjNzVjNTNjNzRjNzNkNzNjODNlNzNjYTNlNzJjYzNmNzFjZDQwNzFjZjQwNzBkMDQxNmZkMjQyNmZkMzQzNmVkNTQ0NmRkNjQ1NmNkODQ1NmNkOTQ2NmJkYjQ3NmFkYzQ4NjlkZTQ5NjhkZjRhNjhlMDRjNjdlMjRkNjZlMzRlNjVlNDRmNjRlNTUwNjRlNzUyNjNlODUzNjJlOTU0NjJlYTU2NjFlYjU3NjBlYzU4NjBlZDVhNWZlZTViNWVlZjVkNWVmMDVmNWVmMTYwNWRmMjYyNWRmMjY0NWNmMzY1NWNmNDY3NWNmNDY5NWNmNTZiNWNmNjZjNWNmNjZlNWNmNzcwNWNmNzcyNWNmODc0NWNmODc2NWNmOTc4NWRmOTc5NWRmOTdiNWRmYTdkNWVmYTdmNWVmYTgxNWZmYjgzNWZmYjg1NjBmYjg3NjFmYzg5NjFmYzhhNjJmYzhjNjNmYzhlNjRmYzkwNjVmZDkyNjZmZDk0NjdmZDk2NjhmZDk4NjlmZDlhNmFmZDliNmJmZTlkNmNmZTlmNmRmZWExNmVmZWEzNmZmZWE1NzFmZWE3NzJmZWE5NzNmZWFhNzRmZWFjNzZmZWFlNzdmZWIwNzhmZWIyN2FmZWI0N2JmZWI2N2NmZWI3N2VmZWI5N2ZmZWJiODFmZWJkODJmZWJmODRmZWMxODVmZWMyODdmZWM0ODhmZWM2OGFmZWM4OGNmZWNhOGRmZWNjOGZmZWNkOTBmZWNmOTJmZWQxOTRmZWQzOTVmZWQ1OTdmZWQ3OTlmZWQ4OWFmZGRhOWNmZGRjOWVmZGRlYTBmZGUwYTFmZGUyYTNmZGUzYTVmZGU1YTdmZGU3YTlmZGU5YWFmZGViYWNmY2VjYWVmY2VlYjBmY2YwYjJmY2YyYjRmY2Y0YjZmY2Y2YjhmY2Y3YjlmY2Y5YmJmY2ZiYmRmY2ZkYmZcIikpO1xuXG4gIHZhciBpbmZlcm5vID0gcmFtcChjb2xvcnMoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMGEwMjAyMGMwMjAyMGUwMzAyMTAwNDAzMTIwNDAzMTQwNTA0MTcwNjA0MTkwNzA1MWIwODA1MWQwOTA2MWYwYTA3MjIwYjA3MjQwYzA4MjYwZDA4MjkwZTA5MmIxMDA5MmQxMTBhMzAxMjBhMzIxNDBiMzQxNTBiMzcxNjBiMzkxODBjM2MxOTBjM2UxYjBjNDExYzBjNDMxZTBjNDUxZjBjNDgyMTBjNGEyMzBjNGMyNDBjNGYyNjBjNTEyODBiNTMyOTBiNTUyYjBiNTcyZDBiNTkyZjBhNWIzMTBhNWMzMjBhNWUzNDBhNWYzNjA5NjEzODA5NjIzOTA5NjMzYjA5NjQzZDA5NjUzZTA5NjY0MDBhNjc0MjBhNjg0NDBhNjg0NTBhNjk0NzBiNmE0OTBiNmE0YTBjNmI0YzBjNmI0ZDBkNmM0ZjBkNmM1MTBlNmM1MjBlNmQ1NDBmNmQ1NTBmNmQ1NzEwNmU1OTEwNmU1YTExNmU1YzEyNmU1ZDEyNmU1ZjEzNmU2MTEzNmU2MjE0NmU2NDE1NmU2NTE1NmU2NzE2NmU2OTE2NmU2YTE3NmU2YzE4NmU2ZDE4NmU2ZjE5NmU3MTE5NmU3MjFhNmU3NDFhNmU3NTFiNmU3NzFjNmQ3ODFjNmQ3YTFkNmQ3YzFkNmQ3ZDFlNmQ3ZjFlNmM4MDFmNmM4MjIwNmM4NDIwNmI4NTIxNmI4NzIxNmI4ODIyNmE4YTIyNmE4YzIzNjk4ZDIzNjk4ZjI0Njk5MDI1Njg5MjI1Njg5MzI2Njc5NTI2Njc5NzI3NjY5ODI3NjY5YTI4NjU5YjI5NjQ5ZDI5NjQ5ZjJhNjNhMDJhNjNhMjJiNjJhMzJjNjFhNTJjNjBhNjJkNjBhODJlNWZhOTJlNWVhYjJmNWVhZDMwNWRhZTMwNWNiMDMxNWJiMTMyNWFiMzMyNWFiNDMzNTliNjM0NThiNzM1NTdiOTM1NTZiYTM2NTViYzM3NTRiZDM4NTNiZjM5NTJjMDNhNTFjMTNhNTBjMzNiNGZjNDNjNGVjNjNkNGRjNzNlNGNjODNmNGJjYTQwNGFjYjQxNDljYzQyNDhjZTQzNDdjZjQ0NDZkMDQ1NDVkMjQ2NDRkMzQ3NDNkNDQ4NDJkNTRhNDFkNzRiM2ZkODRjM2VkOTRkM2RkYTRlM2NkYjUwM2JkZDUxM2FkZTUyMzhkZjUzMzdlMDU1MzZlMTU2MzVlMjU3MzRlMzU5MzNlNDVhMzFlNTVjMzBlNjVkMmZlNzVlMmVlODYwMmRlOTYxMmJlYTYzMmFlYjY0MjllYjY2MjhlYzY3MjZlZDY5MjVlZTZhMjRlZjZjMjNlZjZlMjFmMDZmMjBmMTcxMWZmMTczMWRmMjc0MWNmMzc2MWJmMzc4MTlmNDc5MThmNTdiMTdmNTdkMTVmNjdlMTRmNjgwMTNmNzgyMTJmNzg0MTBmODg1MGZmODg3MGVmODg5MGNmOThiMGJmOThjMGFmOThlMDlmYTkwMDhmYTkyMDdmYTk0MDdmYjk2MDZmYjk3MDZmYjk5MDZmYjliMDZmYjlkMDdmYzlmMDdmY2ExMDhmY2EzMDlmY2E1MGFmY2E2MGNmY2E4MGRmY2FhMGZmY2FjMTFmY2FlMTJmY2IwMTRmY2IyMTZmY2I0MThmYmI2MWFmYmI4MWRmYmJhMWZmYmJjMjFmYmJlMjNmYWMwMjZmYWMyMjhmYWM0MmFmYWM2MmRmOWM3MmZmOWM5MzJmOWNiMzVmOGNkMzdmOGNmM2FmN2QxM2RmN2QzNDBmNmQ1NDNmNmQ3NDZmNWQ5NDlmNWRiNGNmNGRkNGZmNGRmNTNmNGUxNTZmM2UzNWFmM2U1NWRmMmU2NjFmMmU4NjVmMmVhNjlmMWVjNmRmMWVkNzFmMWVmNzVmMWYxNzlmMmYyN2RmMmY0ODJmM2Y1ODZmM2Y2OGFmNGY4OGVmNWY5OTJmNmZhOTZmOGZiOWFmOWZjOWRmYWZkYTFmY2ZmYTRcIikpO1xuXG4gIHZhciBwbGFzbWEgPSByYW1wKGNvbG9ycyhcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSk7XG5cbiAgZnVuY3Rpb24gc2VxdWVudGlhbChpbnRlcnBvbGF0b3IpIHtcbiAgICB2YXIgeDAgPSAwLFxuICAgICAgICB4MSA9IDEsXG4gICAgICAgIGNsYW1wID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICB2YXIgdCA9ICh4IC0geDApIC8gKHgxIC0geDApO1xuICAgICAgcmV0dXJuIGludGVycG9sYXRvcihjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKSA6IHQpO1xuICAgIH1cblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF0sIHgxID0gK19bMV0sIHNjYWxlKSA6IFt4MCwgeDFdO1xuICAgIH07XG5cbiAgICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgICB9O1xuXG4gICAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VxdWVudGlhbChpbnRlcnBvbGF0b3IpLmRvbWFpbihbeDAsIHgxXSkuY2xhbXAoY2xhbXApO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbiAgfVxuXG4gIGV4cG9ydHMuc2NhbGVCYW5kID0gYmFuZDtcbiAgZXhwb3J0cy5zY2FsZVBvaW50ID0gcG9pbnQ7XG4gIGV4cG9ydHMuc2NhbGVJZGVudGl0eSA9IGlkZW50aXR5O1xuICBleHBvcnRzLnNjYWxlTGluZWFyID0gbGluZWFyO1xuICBleHBvcnRzLnNjYWxlTG9nID0gbG9nO1xuICBleHBvcnRzLnNjYWxlT3JkaW5hbCA9IG9yZGluYWw7XG4gIGV4cG9ydHMuc2NhbGVJbXBsaWNpdCA9IGltcGxpY2l0O1xuICBleHBvcnRzLnNjYWxlUG93ID0gcG93O1xuICBleHBvcnRzLnNjYWxlU3FydCA9IHNxcnQ7XG4gIGV4cG9ydHMuc2NhbGVRdWFudGlsZSA9IHF1YW50aWxlJDE7XG4gIGV4cG9ydHMuc2NhbGVRdWFudGl6ZSA9IHF1YW50aXplO1xuICBleHBvcnRzLnNjYWxlVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICBleHBvcnRzLnNjYWxlVGltZSA9IHRpbWU7XG4gIGV4cG9ydHMuc2NhbGVVdGMgPSB1dGNUaW1lO1xuICBleHBvcnRzLnNjaGVtZUNhdGVnb3J5MTAgPSBjYXRlZ29yeTEwO1xuICBleHBvcnRzLnNjaGVtZUNhdGVnb3J5MjBiID0gY2F0ZWdvcnkyMGI7XG4gIGV4cG9ydHMuc2NoZW1lQ2F0ZWdvcnkyMGMgPSBjYXRlZ29yeTIwYztcbiAgZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTIwID0gY2F0ZWdvcnkyMDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHQgPSBjdWJlaGVsaXgkMTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZVJhaW5ib3cgPSByYWluYm93JDE7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVXYXJtID0gd2FybTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUNvb2wgPSBjb29sO1xuICBleHBvcnRzLmludGVycG9sYXRlVmlyaWRpcyA9IHZpcmlkaXM7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVNYWdtYSA9IG1hZ21hO1xuICBleHBvcnRzLmludGVycG9sYXRlSW5mZXJubyA9IGluZmVybm87XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVQbGFzbWEgPSBwbGFzbWE7XG4gIGV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsID0gc2VxdWVudGlhbDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zZWxlY3Rpb24vIFZlcnNpb24gMS4wLjIuIENvcHlyaWdodCAyMDE2IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG4gIHZhciBuYW1lc3BhY2VzID0ge1xuICAgIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHhodG1sOiB4aHRtbCxcbiAgICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbiAgfTtcblxuICBmdW5jdGlvbiBuYW1lc3BhY2UobmFtZSkge1xuICAgIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gICAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0b3IobmFtZSkge1xuICAgIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHZhciBuZXh0SWQgPSAwO1xuXG4gIGZ1bmN0aW9uIGxvY2FsKCkge1xuICAgIHJldHVybiBuZXcgTG9jYWw7XG4gIH1cblxuICBmdW5jdGlvbiBMb2NhbCgpIHtcbiAgICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xuICB9XG5cbiAgTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBMb2NhbCxcbiAgICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIG5vZGVbaWRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl87XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYXRjaGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQubWF0Y2hlcykge1xuICAgICAgdmFyIHZlbmRvck1hdGNoZXMgPSBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgICB8fCBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgIHx8IGVsZW1lbnQub01hdGNoZXNTZWxlY3RvcjtcbiAgICAgIG1hdGNoZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHZlbmRvck1hdGNoZXMuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXRjaGVyJDEgPSBtYXRjaGVyO1xuXG4gIHZhciBmaWx0ZXJFdmVudHMgPSB7fTtcblxuICBleHBvcnRzLmV2ZW50ID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIGVsZW1lbnQkMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoIShcIm9ubW91c2VlbnRlclwiIGluIGVsZW1lbnQkMSkpIHtcbiAgICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gICAgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgOCkpKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBmdW5jdGlvbihldmVudDEpIHtcbiAgICAgIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgaW5kZXgsIGdyb3VwKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICAgIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25bKytpXSA9IG87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICAgIHZhciB3cmFwID0gZmlsdGVyRXZlbnRzLmhhc093blByb3BlcnR5KHR5cGVuYW1lLnR5cGUpID8gZmlsdGVyQ29udGV4dExpc3RlbmVyIDogY29udGV4dExpc3RlbmVyO1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBpLCBncm91cCkge1xuICAgICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8uY2FwdHVyZSA9IGNhcHR1cmUpO1xuICAgICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBjYXB0dXJlOiBjYXB0dXJlfTtcbiAgICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX29uKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICAgIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICAgIGlmIChjYXB0dXJlID09IG51bGwpIGNhcHR1cmUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgY2FwdHVyZSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICAgIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50O1xuICAgIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV4cG9ydHMuZXZlbnQ7XG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNvdXJjZUV2ZW50KCkge1xuICAgIHZhciBjdXJyZW50ID0gZXhwb3J0cy5ldmVudCwgc291cmNlO1xuICAgIHdoaWxlIChzb3VyY2UgPSBjdXJyZW50LnNvdXJjZUV2ZW50KSBjdXJyZW50ID0gc291cmNlO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQobm9kZSwgZXZlbnQpIHtcbiAgICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcblxuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZShub2RlKSB7XG4gICAgdmFyIGV2ZW50ID0gc291cmNlRXZlbnQoKTtcbiAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgcmV0dXJuIHBvaW50KG5vZGUsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vbmUoKSB7fVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdChzZWxlY3QpIHtcbiAgICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdEFsbChzZWxlY3QpIHtcbiAgICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2ZpbHRlcihtYXRjaCkge1xuICAgIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyJDEobWF0Y2gpO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BhcnNlKHVwZGF0ZSkge1xuICAgIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZW50ZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gICAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG4gIH1cblxuICBFbnRlck5vZGUucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBrZXlQcmVmaXggPSBcIiRcIjsgLy8gUHJvdGVjdCBhZ2FpbnN0IGtleXMgbGlrZSDigJxfX3Byb3RvX1/igJ0uXG5cbiAgZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAgIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAgIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gICAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gICAgdmFyIGksXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVCeUtleVZhbHVlID0ge30sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICAgIGtleVZhbHVlO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gICAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAgIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICAgIGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVzW2ldXSA9PT0gbm9kZSkpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2RhdGEodmFsdWUsIGtleSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGRhdGEgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBqID0gLTE7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICAgIGRhdGEgPSB2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cyksXG4gICAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gICAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICAgIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9leGl0KCkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9tZXJnZShzZWxlY3Rpb24pIHtcblxuICAgIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX29yZGVyKCkge1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gbm9kZS5uZXh0U2libGluZykgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3NvcnQoY29tcGFyZSkge1xuICAgIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2NhbGwoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICAgIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9ub2RlcygpIHtcbiAgICB2YXIgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBpID0gLTE7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBub2Rlc1srK2ldID0gdGhpczsgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX25vZGUoKSB7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9zaXplKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7ICsrc2l6ZTsgfSk7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9lYWNoKGNhbGxiYWNrKSB7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Vmlldyhub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG5vZGU7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICAgIDogZGVmYXVsdFZpZXcobm9kZSA9IHRoaXMubm9kZSgpKVxuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbClcbiAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG4gIH1cblxuICBDbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICAgIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25faHRtbCh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFpc2UoKSB7XG4gICAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9yYWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvd2VyKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzU2libGluZykgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fbG93ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fYXBwZW5kKG5hbWUpIHtcbiAgICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9pbnNlcnQobmFtZSwgYmVmb3JlKSB7XG4gICAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBzZWxlY3RvcihiZWZvcmUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fcmVtb3ZlKCkge1xuICAgIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9kYXR1bSh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXG4gICAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gICAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZGlzcGF0Y2godHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBbbnVsbF07XG5cbiAgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICAgIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCByb290KTtcbiAgfVxuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gICAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICAgIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gICAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gICAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICAgIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gICAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gICAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gICAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICAgIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICAgIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICAgIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gICAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICAgIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gICAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICAgIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gICAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgICBvbjogc2VsZWN0aW9uX29uLFxuICAgIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2hcbiAgfTtcblxuICBmdW5jdGlvbiBzZWxlY3Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBuZXcgU2VsZWN0aW9uKFtkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgICA6IG5ldyBTZWxlY3Rpb24oW3NlbGVjdG9yID09IG51bGwgPyBbXSA6IHNlbGVjdG9yXSwgcm9vdCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaChub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gcG9pbnQobm9kZSwgdG91Y2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlcyhub2RlLCB0b3VjaGVzKSB7XG4gICAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgcG9pbnRzID0gbmV3IEFycmF5KG4pOyBpIDwgbjsgKytpKSB7XG4gICAgICBwb2ludHNbaV0gPSBwb2ludChub2RlLCB0b3VjaGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZXhwb3J0cy5jcmVhdG9yID0gY3JlYXRvcjtcbiAgZXhwb3J0cy5sb2NhbCA9IGxvY2FsO1xuICBleHBvcnRzLm1hdGNoZXIgPSBtYXRjaGVyJDE7XG4gIGV4cG9ydHMubW91c2UgPSBtb3VzZTtcbiAgZXhwb3J0cy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGV4cG9ydHMubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG4gIGV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xuICBleHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbiAgZXhwb3J0cy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIGV4cG9ydHMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgZXhwb3J0cy5zZWxlY3RvckFsbCA9IHNlbGVjdG9yQWxsO1xuICBleHBvcnRzLnRvdWNoID0gdG91Y2g7XG4gIGV4cG9ydHMudG91Y2hlcyA9IHRvdWNoZXM7XG4gIGV4cG9ydHMud2luZG93ID0gZGVmYXVsdFZpZXc7XG4gIGV4cG9ydHMuY3VzdG9tRXZlbnQgPSBjdXN0b21FdmVudDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtZGlzcGF0Y2gnKSwgcmVxdWlyZSgnZDMtc2NhbGUnKSwgcmVxdWlyZSgnZDMtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLWFycmF5JykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1zZWxlY3Rpb24nLCAnZDMtZGlzcGF0Y2gnLCAnZDMtc2NhbGUnLCAnZDMtZm9ybWF0JywgJ2QzLWFycmF5J10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5pbmRleFJvbGx1cCA9IGdsb2JhbC5pbmRleFJvbGx1cCB8fCB7fSksZ2xvYmFsLmQzU2VsZWN0aW9uLGdsb2JhbC5kM0Rpc3BhdGNoLGdsb2JhbC5kM1NjYWxlLGdsb2JhbC5kM0Zvcm1hdCxnbG9iYWwuZDNBcnJheSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNTZWxlY3Rpb24sZDNEaXNwYXRjaCxkM1NjYWxlLGQzRm9ybWF0LGQzQXJyYXkpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxudmFyIGQzX2lkZW50aXR5ID0gZnVuY3Rpb24gZDNfaWRlbnRpdHkoZCkge1xuICByZXR1cm4gZDtcbn07XG5cbnZhciBkM19yZXZlcnNlID0gZnVuY3Rpb24gZDNfcmV2ZXJzZShhcnIpIHtcbiAgdmFyIG1pcnJvciA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBtaXJyb3JbaV0gPSBhcnJbbCAtIGkgLSAxXTtcbiAgfVxuICByZXR1cm4gbWlycm9yO1xufTtcblxuLy9UZXh0IHdyYXBwaW5nIGNvZGUgYWRhcHRlZCBmcm9tIE1pa2UgQm9zdG9ja1xudmFyIGQzX3RleHRXcmFwcGluZyA9IGZ1bmN0aW9uIGQzX3RleHRXcmFwcGluZyh0ZXh0LCB3aWR0aCkge1xuICB0ZXh0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0ID0gZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLFxuICAgICAgICB3b3JkcyA9IHRleHQudGV4dCgpLnNwbGl0KC9cXHMrLykucmV2ZXJzZSgpLFxuICAgICAgICB3b3JkLFxuICAgICAgICBsaW5lID0gW10sXG4gICAgICAgIGxpbmVOdW1iZXIgPSAwLFxuICAgICAgICBsaW5lSGVpZ2h0ID0gMS4yLFxuICAgICAgICAvL2Vtc1xuICAgIHkgPSB0ZXh0LmF0dHIoXCJ5XCIpLFxuICAgICAgICBkeSA9IHBhcnNlRmxvYXQodGV4dC5hdHRyKFwiZHlcIikpIHx8IDAsXG4gICAgICAgIHRzcGFuID0gdGV4dC50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCBkeSArIFwiZW1cIik7XG5cbiAgICB3aGlsZSAod29yZCA9IHdvcmRzLnBvcCgpKSB7XG4gICAgICBsaW5lLnB1c2god29yZCk7XG4gICAgICB0c3Bhbi50ZXh0KGxpbmUuam9pbihcIiBcIikpO1xuICAgICAgaWYgKHRzcGFuLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA+IHdpZHRoICYmIGxpbmUubGVuZ3RoID4gMSkge1xuICAgICAgICBsaW5lLnBvcCgpO1xuICAgICAgICB0c3Bhbi50ZXh0KGxpbmUuam9pbihcIiBcIikpO1xuICAgICAgICBsaW5lID0gW3dvcmRdO1xuICAgICAgICB0c3BhbiA9IHRleHQuYXBwZW5kKFwidHNwYW5cIikuYXR0cihcInhcIiwgMCkuYXR0cihcImR5XCIsIGxpbmVIZWlnaHQgKyBkeSArIFwiZW1cIikudGV4dCh3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGQzX21lcmdlTGFiZWxzID0gZnVuY3Rpb24gZDNfbWVyZ2VMYWJlbHMoKSB7XG4gIHZhciBnZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICB2YXIgbGFiZWxzID0gYXJndW1lbnRzWzFdO1xuICB2YXIgZG9tYWluID0gYXJndW1lbnRzWzJdO1xuICB2YXIgcmFuZ2UgPSBhcmd1bWVudHNbM107XG5cblxuICBpZiAoKHR5cGVvZiBsYWJlbHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihsYWJlbHMpKSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKSByZXR1cm4gZ2VuO1xuXG4gICAgdmFyIGkgPSBsYWJlbHMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgZ2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsYWJlbHMucHVzaChnZW5baV0pO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWxzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBjdXN0b21MYWJlbHMgPSBbXTtcbiAgICB2YXIgZ2VuTGVuZ3RoID0gZ2VuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZ2VuTGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjdXN0b21MYWJlbHMucHVzaChsYWJlbHMoe1xuICAgICAgICBpOiBfaSxcbiAgICAgICAgZ2VuTGVuZ3RoOiBnZW5MZW5ndGgsXG4gICAgICAgIGdlbmVyYXRlZExhYmVsczogZ2VuLFxuICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgcmFuZ2U6IHJhbmdlIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1c3RvbUxhYmVscztcbiAgfVxuXG4gIHJldHVybiBnZW47XG59O1xuXG52YXIgZDNfbGluZWFyTGVnZW5kID0gZnVuY3Rpb24gZDNfbGluZWFyTGVnZW5kKHNjYWxlLCBjZWxscywgbGFiZWxGb3JtYXQpIHtcbiAgdmFyIGRhdGEgPSBbXTtcblxuICBpZiAoY2VsbHMubGVuZ3RoID4gMSkge1xuICAgIGRhdGEgPSBjZWxscztcbiAgfSBlbHNlIHtcbiAgICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgIGluY3JlbWVudCA9IChkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdIC0gZG9tYWluWzBdKSAvIChjZWxscyAtIDEpO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgY2VsbHM7IGkrKykge1xuICAgICAgZGF0YS5wdXNoKGRvbWFpblswXSArIGkgKiBpbmNyZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYWJlbHMgPSBkYXRhLm1hcChsYWJlbEZvcm1hdCk7XG4gIHJldHVybiB7IGRhdGE6IGRhdGEsXG4gICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgZmVhdHVyZTogZnVuY3Rpb24gZmVhdHVyZShkKSB7XG4gICAgICByZXR1cm4gc2NhbGUoZCk7XG4gICAgfSB9O1xufTtcblxudmFyIGQzX3F1YW50TGVnZW5kID0gZnVuY3Rpb24gZDNfcXVhbnRMZWdlbmQoc2NhbGUsIGxhYmVsRm9ybWF0LCBsYWJlbERlbGltaXRlcikge1xuICB2YXIgbGFiZWxzID0gc2NhbGUucmFuZ2UoKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0RXh0ZW50KGQpO1xuICAgIHJldHVybiBsYWJlbEZvcm1hdChpbnZlcnRbMF0pICsgXCIgXCIgKyBsYWJlbERlbGltaXRlciArIFwiIFwiICsgbGFiZWxGb3JtYXQoaW52ZXJ0WzFdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgZGF0YTogc2NhbGUucmFuZ2UoKSxcbiAgICBsYWJlbHM6IGxhYmVscyxcbiAgICBmZWF0dXJlOiBkM19pZGVudGl0eVxuICB9O1xufTtcblxudmFyIGQzX29yZGluYWxMZWdlbmQgPSBmdW5jdGlvbiBkM19vcmRpbmFsTGVnZW5kKHNjYWxlKSB7XG4gIHJldHVybiB7IGRhdGE6IHNjYWxlLmRvbWFpbigpLFxuICAgIGxhYmVsczogc2NhbGUuZG9tYWluKCksXG4gICAgZmVhdHVyZTogZnVuY3Rpb24gZmVhdHVyZShkKSB7XG4gICAgICByZXR1cm4gc2NhbGUoZCk7XG4gICAgfSB9O1xufTtcblxudmFyIGQzX2NlbGxPdmVyID0gZnVuY3Rpb24gZDNfY2VsbE92ZXIoY2VsbERpc3BhdGNoZXIsIGQsIG9iaikge1xuICBjZWxsRGlzcGF0Y2hlci5jYWxsKFwiY2VsbG92ZXJcIiwgb2JqLCBkKTtcbn07XG5cbnZhciBkM19jZWxsT3V0ID0gZnVuY3Rpb24gZDNfY2VsbE91dChjZWxsRGlzcGF0Y2hlciwgZCwgb2JqKSB7XG4gIGNlbGxEaXNwYXRjaGVyLmNhbGwoXCJjZWxsb3V0XCIsIG9iaiwgZCk7XG59O1xuXG52YXIgZDNfY2VsbENsaWNrID0gZnVuY3Rpb24gZDNfY2VsbENsaWNrKGNlbGxEaXNwYXRjaGVyLCBkLCBvYmopIHtcbiAgY2VsbERpc3BhdGNoZXIuY2FsbChcImNlbGxjbGlja1wiLCBvYmosIGQpO1xufTtcblxudmFyIGhlbHBlciA9IHtcblxuICBkM19kcmF3U2hhcGVzOiBmdW5jdGlvbiBkM19kcmF3U2hhcGVzKHNoYXBlLCBzaGFwZXMsIHNoYXBlSGVpZ2h0LCBzaGFwZVdpZHRoLCBzaGFwZVJhZGl1cywgcGF0aCkge1xuICAgIGlmIChzaGFwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICAgIHNoYXBlcy5hdHRyKFwiaGVpZ2h0XCIsIHNoYXBlSGVpZ2h0KS5hdHRyKFwid2lkdGhcIiwgc2hhcGVXaWR0aCk7XG4gICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgc2hhcGVzLmF0dHIoXCJyXCIsIHNoYXBlUmFkaXVzKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlID09PSBcImxpbmVcIikge1xuICAgICAgc2hhcGVzLmF0dHIoXCJ4MVwiLCAwKS5hdHRyKFwieDJcIiwgc2hhcGVXaWR0aCkuYXR0cihcInkxXCIsIDApLmF0dHIoXCJ5MlwiLCAwKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlID09PSBcInBhdGhcIikge1xuICAgICAgc2hhcGVzLmF0dHIoXCJkXCIsIHBhdGgpO1xuICAgIH1cbiAgfSxcblxuICBkM19hZGRUZXh0OiBmdW5jdGlvbiBkM19hZGRUZXh0KHN2ZywgZW50ZXIsIGxhYmVscywgY2xhc3NQcmVmaXgsIGxhYmVsV2lkdGgpIHtcbiAgICBlbnRlci5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwibGFiZWxcIik7XG4gICAgdmFyIHRleHQgPSBzdmcuc2VsZWN0QWxsKFwiZy5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsIHRleHQuXCIgKyBjbGFzc1ByZWZpeCArIFwibGFiZWxcIikuZGF0YShsYWJlbHMpLnRleHQoZDNfaWRlbnRpdHkpO1xuXG4gICAgaWYgKGxhYmVsV2lkdGgpIHtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoXCJnLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGwgdGV4dC5cIiArIGNsYXNzUHJlZml4ICsgXCJsYWJlbFwiKS5jYWxsKGQzX3RleHRXcmFwcGluZywgbGFiZWxXaWR0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH0sXG5cbiAgZDNfY2FsY1R5cGU6IGZ1bmN0aW9uIGQzX2NhbGNUeXBlKHNjYWxlLCBhc2NlbmRpbmcsIGNlbGxzLCBsYWJlbHMsIGxhYmVsRm9ybWF0LCBsYWJlbERlbGltaXRlcikge1xuICAgIHZhciB0eXBlID0gc2NhbGUuaW52ZXJ0RXh0ZW50ID8gZDNfcXVhbnRMZWdlbmQoc2NhbGUsIGxhYmVsRm9ybWF0LCBsYWJlbERlbGltaXRlcikgOiBzY2FsZS50aWNrcyA/IGQzX2xpbmVhckxlZ2VuZChzY2FsZSwgY2VsbHMsIGxhYmVsRm9ybWF0KSA6IGQzX29yZGluYWxMZWdlbmQoc2NhbGUpO1xuXG4gICAgLy9mb3IgZDMuc2NhbGVTZXF1ZW50aWFsIHRoYXQgZG9lc24ndCBoYXZlIGEgcmFuZ2UgZnVuY3Rpb25cbiAgICB2YXIgcmFuZ2UgPSBzY2FsZS5yYW5nZSAmJiBzY2FsZS5yYW5nZSgpIHx8IHNjYWxlLmRvbWFpbigpO1xuICAgIHR5cGUubGFiZWxzID0gZDNfbWVyZ2VMYWJlbHModHlwZS5sYWJlbHMsIGxhYmVscywgc2NhbGUuZG9tYWluKCksIHJhbmdlKTtcblxuICAgIGlmIChhc2NlbmRpbmcpIHtcbiAgICAgIHR5cGUubGFiZWxzID0gZDNfcmV2ZXJzZSh0eXBlLmxhYmVscyk7XG4gICAgICB0eXBlLmRhdGEgPSBkM19yZXZlcnNlKHR5cGUuZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH0sXG5cbiAgZDNfZmlsdGVyQ2VsbHM6IGZ1bmN0aW9uIGQzX2ZpbHRlckNlbGxzKHR5cGUsIGNlbGxGaWx0ZXIpIHtcbiAgICB2YXIgZmlsdGVyQ2VsbHMgPSB0eXBlLmRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBkLCBsYWJlbDogdHlwZS5sYWJlbHNbaV0gfTtcbiAgICB9KS5maWx0ZXIoY2VsbEZpbHRlcik7XG4gICAgdmFyIGRhdGFWYWx1ZXMgPSBmaWx0ZXJDZWxscy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmRhdGE7XG4gICAgfSk7XG4gICAgdmFyIGxhYmVsVmFsdWVzID0gZmlsdGVyQ2VsbHMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5sYWJlbDtcbiAgICB9KTtcbiAgICB0eXBlLmRhdGEgPSB0eXBlLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZGF0YVZhbHVlcy5pbmRleE9mKGQpICE9PSAtMTtcbiAgICB9KTtcbiAgICB0eXBlLmxhYmVscyA9IHR5cGUubGFiZWxzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGxhYmVsVmFsdWVzLmluZGV4T2YoZCkgIT09IC0xO1xuICAgIH0pO1xuICAgIHJldHVybiB0eXBlO1xuICB9LFxuXG4gIGQzX3BsYWNlbWVudDogZnVuY3Rpb24gZDNfcGxhY2VtZW50KG9yaWVudCwgY2VsbCwgY2VsbFRyYW5zLCB0ZXh0LCB0ZXh0VHJhbnMsIGxhYmVsQWxpZ24pIHtcbiAgICBjZWxsLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgY2VsbFRyYW5zKTtcbiAgICB0ZXh0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdGV4dFRyYW5zKTtcbiAgICBpZiAob3JpZW50ID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgdGV4dC5zdHlsZShcInRleHQtYW5jaG9yXCIsIGxhYmVsQWxpZ24pO1xuICAgIH1cbiAgfSxcblxuICBkM19hZGRFdmVudHM6IGZ1bmN0aW9uIGQzX2FkZEV2ZW50cyhjZWxscywgZGlzcGF0Y2hlcikge1xuICAgIGNlbGxzLm9uKFwibW91c2VvdmVyLmxlZ2VuZFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgZDNfY2VsbE92ZXIoZGlzcGF0Y2hlciwgZCwgdGhpcyk7XG4gICAgfSkub24oXCJtb3VzZW91dC5sZWdlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzX2NlbGxPdXQoZGlzcGF0Y2hlciwgZCwgdGhpcyk7XG4gICAgfSkub24oXCJjbGljay5sZWdlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzX2NlbGxDbGljayhkaXNwYXRjaGVyLCBkLCB0aGlzKTtcbiAgICB9KTtcbiAgfSxcblxuICBkM190aXRsZTogZnVuY3Rpb24gZDNfdGl0bGUoc3ZnLCB0aXRsZSwgY2xhc3NQcmVmaXgsIHRpdGxlV2lkdGgpIHtcbiAgICBpZiAodGl0bGUgIT09IFwiXCIpIHtcblxuICAgICAgdmFyIHRpdGxlVGV4dCA9IHN2Zy5zZWxlY3RBbGwoJ3RleHQuJyArIGNsYXNzUHJlZml4ICsgJ2xlZ2VuZFRpdGxlJyk7XG5cbiAgICAgIHRpdGxlVGV4dC5kYXRhKFt0aXRsZV0pLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCBjbGFzc1ByZWZpeCArICdsZWdlbmRUaXRsZScpO1xuXG4gICAgICBzdmcuc2VsZWN0QWxsKCd0ZXh0LicgKyBjbGFzc1ByZWZpeCArICdsZWdlbmRUaXRsZScpLnRleHQodGl0bGUpO1xuXG4gICAgICBpZiAodGl0bGVXaWR0aCkge1xuICAgICAgICBzdmcuc2VsZWN0QWxsKCd0ZXh0LicgKyBjbGFzc1ByZWZpeCArICdsZWdlbmRUaXRsZScpLmNhbGwoZDNfdGV4dFdyYXBwaW5nLCB0aXRsZVdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlbGxzU3ZnID0gc3ZnLnNlbGVjdCgnLicgKyBjbGFzc1ByZWZpeCArICdsZWdlbmRDZWxscycpO1xuICAgICAgdmFyIHlPZmZzZXQgPSBzdmcuc2VsZWN0KCcuJyArIGNsYXNzUHJlZml4ICsgJ2xlZ2VuZFRpdGxlJykubm9kZXMoKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpLmhlaWdodDtcbiAgICAgIH0pWzBdLFxuICAgICAgICAgIHhPZmZzZXQgPSAtY2VsbHNTdmcubm9kZXMoKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpLng7XG4gICAgICB9KVswXTtcbiAgICAgIGNlbGxzU3ZnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHhPZmZzZXQgKyAnLCcgKyB5T2Zmc2V0ICsgJyknKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNvbG9yKCkge1xuXG4gIHZhciBzY2FsZSA9IGQzU2NhbGUuc2NhbGVMaW5lYXIoKSxcbiAgICAgIHNoYXBlID0gXCJyZWN0XCIsXG4gICAgICBzaGFwZVdpZHRoID0gMTUsXG4gICAgICBzaGFwZUhlaWdodCA9IDE1LFxuICAgICAgc2hhcGVSYWRpdXMgPSAxMCxcbiAgICAgIHNoYXBlUGFkZGluZyA9IDIsXG4gICAgICBjZWxscyA9IFs1XSxcbiAgICAgIGNlbGxGaWx0ZXIgPSB2b2lkIDAsXG4gICAgICBsYWJlbHMgPSBbXSxcbiAgICAgIGNsYXNzUHJlZml4ID0gXCJcIixcbiAgICAgIHVzZUNsYXNzID0gZmFsc2UsXG4gICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICBsYWJlbEZvcm1hdCA9IGQzRm9ybWF0LmZvcm1hdChcIi4wMWZcIiksXG4gICAgICBsYWJlbE9mZnNldCA9IDEwLFxuICAgICAgbGFiZWxBbGlnbiA9IFwibWlkZGxlXCIsXG4gICAgICBsYWJlbERlbGltaXRlciA9IFwidG9cIixcbiAgICAgIGxhYmVsV3JhcCA9IHZvaWQgMCxcbiAgICAgIG9yaWVudCA9IFwidmVydGljYWxcIixcbiAgICAgIGFzY2VuZGluZyA9IGZhbHNlLFxuICAgICAgcGF0aCA9IHZvaWQgMCxcbiAgICAgIHRpdGxlV2lkdGggPSB2b2lkIDAsXG4gICAgICBsZWdlbmREaXNwYXRjaGVyID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcImNlbGxvdmVyXCIsIFwiY2VsbG91dFwiLCBcImNlbGxjbGlja1wiKTtcblxuICBmdW5jdGlvbiBsZWdlbmQoc3ZnKSB7XG5cbiAgICB2YXIgdHlwZSA9IGhlbHBlci5kM19jYWxjVHlwZShzY2FsZSwgYXNjZW5kaW5nLCBjZWxscywgbGFiZWxzLCBsYWJlbEZvcm1hdCwgbGFiZWxEZWxpbWl0ZXIpLFxuICAgICAgICBsZWdlbmRHID0gc3ZnLnNlbGVjdEFsbCgnZycpLmRhdGEoW3NjYWxlXSk7XG5cbiAgICBsZWdlbmRHLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCBjbGFzc1ByZWZpeCArICdsZWdlbmRDZWxscycpO1xuXG4gICAgaWYgKGNlbGxGaWx0ZXIpIHtcbiAgICAgIGhlbHBlci5kM19maWx0ZXJDZWxscyh0eXBlLCBjZWxsRmlsdGVyKTtcbiAgICB9XG5cbiAgICB2YXIgY2VsbCA9IHN2Zy5zZWxlY3QoJy4nICsgY2xhc3NQcmVmaXggKyAnbGVnZW5kQ2VsbHMnKS5zZWxlY3RBbGwoXCIuXCIgKyBjbGFzc1ByZWZpeCArIFwiY2VsbFwiKS5kYXRhKHR5cGUuZGF0YSk7XG5cbiAgICB2YXIgY2VsbEVudGVyID0gY2VsbC5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpO1xuICAgIGNlbGxFbnRlci5hcHBlbmQoc2hhcGUpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwic3dhdGNoXCIpO1xuXG4gICAgdmFyIHNoYXBlcyA9IHN2Zy5zZWxlY3RBbGwoXCJnLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGwgXCIgKyBzaGFwZSk7XG5cbiAgICAvL2FkZCBldmVudCBoYW5kbGVyc1xuICAgIGhlbHBlci5kM19hZGRFdmVudHMoY2VsbEVudGVyLCBsZWdlbmREaXNwYXRjaGVyKTtcblxuICAgIGNlbGwuZXhpdCgpLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG5cbiAgICBoZWxwZXIuZDNfZHJhd1NoYXBlcyhzaGFwZSwgc2hhcGVzLCBzaGFwZUhlaWdodCwgc2hhcGVXaWR0aCwgc2hhcGVSYWRpdXMsIHBhdGgpO1xuICAgIGhlbHBlci5kM19hZGRUZXh0KHN2ZywgY2VsbEVudGVyLCB0eXBlLmxhYmVscywgY2xhc3NQcmVmaXgsIGxhYmVsV3JhcCk7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIHRoZSBzZWxlY3Rpb24sIG90aGVyd2lzZSBjaGFuZ2VzIGluIHRoZSBsZWdlbmQgKGUuZy4gY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBhcmUgYXBwbGllZCBvbmx5IHRvIHRoZSBuZXcgY2VsbHMgYW5kIG5vdCB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBjZWxsID0gY2VsbEVudGVyLm1lcmdlKGNlbGwpO1xuXG4gICAgLy8gc2V0cyBwbGFjZW1lbnRcbiAgICB2YXIgdGV4dCA9IGNlbGwuc2VsZWN0QWxsKFwidGV4dFwiKSxcbiAgICAgICAgdGV4dFNpemUgPSB0ZXh0Lm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5nZXRCQm94KCk7XG4gICAgfSksXG4gICAgICAgIHNoYXBlU2l6ZSA9IHNoYXBlcy5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpO1xuICAgIH0pO1xuICAgIC8vc2V0cyBzY2FsZVxuICAgIC8vZXZlcnl0aGluZyBpcyBmaWxsIGV4Y2VwdCBmb3IgbGluZSB3aGljaCBpcyBzdHJva2UsXG4gICAgaWYgKCF1c2VDbGFzcykge1xuICAgICAgaWYgKHNoYXBlID09IFwibGluZVwiKSB7XG4gICAgICAgIHNoYXBlcy5zdHlsZShcInN0cm9rZVwiLCB0eXBlLmZlYXR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVzLnN0eWxlKFwiZmlsbFwiLCB0eXBlLmZlYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZXMuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBjbGFzc1ByZWZpeCArICdzd2F0Y2ggJyArIHR5cGUuZmVhdHVyZShkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjZWxsVHJhbnMgPSB2b2lkIDAsXG4gICAgICAgIHRleHRUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dEFsaWduID0gbGFiZWxBbGlnbiA9PSBcInN0YXJ0XCIgPyAwIDogbGFiZWxBbGlnbiA9PSBcIm1pZGRsZVwiID8gMC41IDogMTtcblxuICAgIC8vcG9zaXRpb25zIGNlbGxzIGFuZCB0ZXh0XG4gICAgaWYgKG9yaWVudCA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbFNpemUgPSB0ZXh0U2l6ZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZC5oZWlnaHQsIHNoYXBlU2l6ZVtpXS5oZWlnaHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjZWxsVHJhbnMgPSBmdW5jdGlvbiBjZWxsVHJhbnMoZCwgaSkge1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBkM0FycmF5LnN1bShjZWxsU2l6ZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwgJyArIChoZWlnaHQgKyBpICogc2hhcGVQYWRkaW5nKSArICcpJztcbiAgICAgICAgfTtcblxuICAgICAgICB0ZXh0VHJhbnMgPSBmdW5jdGlvbiB0ZXh0VHJhbnMoZCwgaSkge1xuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCAnICsgKHNoYXBlU2l6ZVtpXS53aWR0aCArIHNoYXBlU2l6ZVtpXS54ICsgbGFiZWxPZmZzZXQpICsgJywgJyArIChzaGFwZVNpemVbaV0ueSArIHNoYXBlU2l6ZVtpXS5oZWlnaHQgLyAyICsgNSkgKyAnKSc7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAob3JpZW50ID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgY2VsbFRyYW5zID0gZnVuY3Rpb24gY2VsbFRyYW5zKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGkgKiAoc2hhcGVTaXplW2ldLndpZHRoICsgc2hhcGVQYWRkaW5nKSArICcsMCknO1xuICAgICAgfTtcbiAgICAgIHRleHRUcmFucyA9IGZ1bmN0aW9uIHRleHRUcmFucyhkLCBpKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoc2hhcGVTaXplW2ldLndpZHRoICogdGV4dEFsaWduICsgc2hhcGVTaXplW2ldLngpICsgJyxcXG4gICAgICAgICAgJyArIChzaGFwZVNpemVbaV0uaGVpZ2h0ICsgc2hhcGVTaXplW2ldLnkgKyBsYWJlbE9mZnNldCArIDgpICsgJyknO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBoZWxwZXIuZDNfcGxhY2VtZW50KG9yaWVudCwgY2VsbCwgY2VsbFRyYW5zLCB0ZXh0LCB0ZXh0VHJhbnMsIGxhYmVsQWxpZ24pO1xuICAgIGhlbHBlci5kM190aXRsZShzdmcsIHRpdGxlLCBjbGFzc1ByZWZpeCwgdGl0bGVXaWR0aCk7XG5cbiAgICBjZWxsLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gIH1cblxuICBsZWdlbmQuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgIHNjYWxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5jZWxscyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VsbHM7XG4gICAgaWYgKF8ubGVuZ3RoID4gMSB8fCBfID49IDIpIHtcbiAgICAgIGNlbGxzID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2VsbEZpbHRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VsbEZpbHRlcjtcbiAgICBjZWxsRmlsdGVyID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZSA9IGZ1bmN0aW9uIChfLCBkKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgaWYgKF8gPT0gXCJyZWN0XCIgfHwgXyA9PSBcImNpcmNsZVwiIHx8IF8gPT0gXCJsaW5lXCIgfHwgXyA9PSBcInBhdGhcIiAmJiB0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNoYXBlID0gXztcbiAgICAgIHBhdGggPSBkO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZVdpZHRoO1xuICAgIHNoYXBlV2lkdGggPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZUhlaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVIZWlnaHQ7XG4gICAgc2hhcGVIZWlnaHQgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVJhZGl1cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVSYWRpdXM7XG4gICAgc2hhcGVSYWRpdXMgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlUGFkZGluZztcbiAgICBzaGFwZVBhZGRpbmcgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVscztcbiAgICBsYWJlbHMgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsQWxpZ24gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsQWxpZ247XG4gICAgaWYgKF8gPT0gXCJzdGFydFwiIHx8IF8gPT0gXCJlbmRcIiB8fCBfID09IFwibWlkZGxlXCIpIHtcbiAgICAgIGxhYmVsQWxpZ24gPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbEZvcm1hdCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxGb3JtYXQ7XG4gICAgbGFiZWxGb3JtYXQgPSB0eXBlb2YgXyA9PT0gJ3N0cmluZycgPyBkM0Zvcm1hdC5mb3JtYXQoXykgOiBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsT2Zmc2V0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbE9mZnNldDtcbiAgICBsYWJlbE9mZnNldCA9ICtfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsRGVsaW1pdGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbERlbGltaXRlcjtcbiAgICBsYWJlbERlbGltaXRlciA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxXcmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbFdyYXA7XG4gICAgbGFiZWxXcmFwID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC51c2VDbGFzcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdXNlQ2xhc3M7XG4gICAgaWYgKF8gPT09IHRydWUgfHwgXyA9PT0gZmFsc2UpIHtcbiAgICAgIHVzZUNsYXNzID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgXyA9IF8udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoXyA9PSBcImhvcml6b250YWxcIiB8fCBfID09IFwidmVydGljYWxcIikge1xuICAgICAgb3JpZW50ID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuYXNjZW5kaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhc2NlbmRpbmc7XG4gICAgYXNjZW5kaW5nID0gISFfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNsYXNzUHJlZml4ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFzc1ByZWZpeDtcbiAgICBjbGFzc1ByZWZpeCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIHRpdGxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVdpZHRoO1xuICAgIHRpdGxlV2lkdGggPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnRleHRXcmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0ZXh0V3JhcDtcbiAgICB0ZXh0V3JhcCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gbGVnZW5kRGlzcGF0Y2hlci5vbi5hcHBseShsZWdlbmREaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGVnZW5kRGlzcGF0Y2hlciA/IGxlZ2VuZCA6IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBsZWdlbmQ7XG59XG5cbmZ1bmN0aW9uIHNpemUoKSB7XG5cbiAgdmFyIHNjYWxlID0gZDNTY2FsZS5zY2FsZUxpbmVhcigpLFxuICAgICAgc2hhcGUgPSBcInJlY3RcIixcbiAgICAgIHNoYXBlV2lkdGggPSAxNSxcbiAgICAgIHNoYXBlUGFkZGluZyA9IDIsXG4gICAgICBjZWxscyA9IFs1XSxcbiAgICAgIGNlbGxGaWx0ZXIgPSB2b2lkIDAsXG4gICAgICBsYWJlbHMgPSBbXSxcbiAgICAgIGNsYXNzUHJlZml4ID0gXCJcIixcbiAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgIGxhYmVsRm9ybWF0ID0gZDNGb3JtYXQuZm9ybWF0KFwiLjAxZlwiKSxcbiAgICAgIGxhYmVsT2Zmc2V0ID0gMTAsXG4gICAgICBsYWJlbEFsaWduID0gXCJtaWRkbGVcIixcbiAgICAgIGxhYmVsRGVsaW1pdGVyID0gXCJ0b1wiLFxuICAgICAgbGFiZWxXcmFwID0gdm9pZCAwLFxuICAgICAgb3JpZW50ID0gXCJ2ZXJ0aWNhbFwiLFxuICAgICAgYXNjZW5kaW5nID0gZmFsc2UsXG4gICAgICBwYXRoID0gdm9pZCAwLFxuICAgICAgdGl0bGVXaWR0aCA9IHZvaWQgMCxcbiAgICAgIGxlZ2VuZERpc3BhdGNoZXIgPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKFwiY2VsbG92ZXJcIiwgXCJjZWxsb3V0XCIsIFwiY2VsbGNsaWNrXCIpO1xuXG4gIGZ1bmN0aW9uIGxlZ2VuZChzdmcpIHtcblxuICAgIHZhciB0eXBlID0gaGVscGVyLmQzX2NhbGNUeXBlKHNjYWxlLCBhc2NlbmRpbmcsIGNlbGxzLCBsYWJlbHMsIGxhYmVsRm9ybWF0LCBsYWJlbERlbGltaXRlciksXG4gICAgICAgIGxlZ2VuZEcgPSBzdmcuc2VsZWN0QWxsKCdnJykuZGF0YShbc2NhbGVdKTtcblxuICAgIGlmIChjZWxsRmlsdGVyKSB7XG4gICAgICBoZWxwZXIuZDNfZmlsdGVyQ2VsbHModHlwZSwgY2VsbEZpbHRlcik7XG4gICAgfVxuXG4gICAgbGVnZW5kRy5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgY2xhc3NQcmVmaXggKyAnbGVnZW5kQ2VsbHMnKTtcblxuICAgIHZhciBjZWxsID0gc3ZnLnNlbGVjdCgnLicgKyBjbGFzc1ByZWZpeCArICdsZWdlbmRDZWxscycpLnNlbGVjdEFsbChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpLmRhdGEodHlwZS5kYXRhKTtcbiAgICB2YXIgY2VsbEVudGVyID0gY2VsbC5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpO1xuICAgIGNlbGxFbnRlci5hcHBlbmQoc2hhcGUpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwic3dhdGNoXCIpO1xuXG4gICAgdmFyIHNoYXBlcyA9IHN2Zy5zZWxlY3RBbGwoXCJnLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGwgXCIgKyBzaGFwZSk7XG5cbiAgICAvL2FkZCBldmVudCBoYW5kbGVyc1xuICAgIGhlbHBlci5kM19hZGRFdmVudHMoY2VsbEVudGVyLCBsZWdlbmREaXNwYXRjaGVyKTtcblxuICAgIGNlbGwuZXhpdCgpLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG5cbiAgICAvL2NyZWF0ZXMgc2hhcGVcbiAgICBpZiAoc2hhcGUgPT09IFwibGluZVwiKSB7XG4gICAgICBoZWxwZXIuZDNfZHJhd1NoYXBlcyhzaGFwZSwgc2hhcGVzLCAwLCBzaGFwZVdpZHRoKTtcbiAgICAgIHNoYXBlcy5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIHR5cGUuZmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlbHBlci5kM19kcmF3U2hhcGVzKHNoYXBlLCBzaGFwZXMsIHR5cGUuZmVhdHVyZSwgdHlwZS5mZWF0dXJlLCB0eXBlLmZlYXR1cmUsIHBhdGgpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gaGVscGVyLmQzX2FkZFRleHQoc3ZnLCBjZWxsRW50ZXIsIHR5cGUubGFiZWxzLCBjbGFzc1ByZWZpeCwgbGFiZWxXcmFwKTtcblxuICAgIC8vIHdlIG5lZWQgdG8gbWVyZ2UgdGhlIHNlbGVjdGlvbiwgb3RoZXJ3aXNlIGNoYW5nZXMgaW4gdGhlIGxlZ2VuZCAoZS5nLiBjaGFuZ2Ugb2Ygb3JpZW50YXRpb24pIGFyZSBhcHBsaWVkIG9ubHkgdG8gdGhlIG5ldyBjZWxscyBhbmQgbm90IHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGNlbGwgPSBjZWxsRW50ZXIubWVyZ2UoY2VsbCk7XG5cbiAgICAvL3NldHMgcGxhY2VtZW50XG5cbiAgICB2YXIgdGV4dFNpemUgPSB0ZXh0Lm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5nZXRCQm94KCk7XG4gICAgfSksXG4gICAgICAgIHNoYXBlU2l6ZSA9IHNoYXBlcy5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgdmFyIGJib3ggPSBkLmdldEJCb3goKTtcbiAgICAgIHZhciBzdHJva2UgPSBzY2FsZSh0eXBlLmRhdGFbaV0pO1xuXG4gICAgICBpZiAoc2hhcGUgPT09IFwibGluZVwiICYmIG9yaWVudCA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgYmJveC5oZWlnaHQgPSBiYm94LmhlaWdodCArIHN0cm9rZTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09IFwibGluZVwiICYmIG9yaWVudCA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIGJib3gud2lkdGggPSBiYm94LndpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSk7XG4gICAgLy9jb25zb2xlLmxvZygnU0hBUEVTSVpFJylcbiAgICB2YXIgbWF4SCA9IGQzQXJyYXkubWF4KHNoYXBlU2l6ZSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmhlaWdodCArIGQueTtcbiAgICB9KSxcbiAgICAgICAgbWF4VyA9IGQzQXJyYXkubWF4KHNoYXBlU2l6ZSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLndpZHRoICsgZC54O1xuICAgIH0pO1xuXG4gICAgdmFyIGNlbGxUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dFRyYW5zID0gdm9pZCAwLFxuICAgICAgICB0ZXh0QWxpZ24gPSBsYWJlbEFsaWduID09IFwic3RhcnRcIiA/IDAgOiBsYWJlbEFsaWduID09IFwibWlkZGxlXCIgPyAwLjUgOiAxO1xuXG4gICAgLy9wb3NpdGlvbnMgY2VsbHMgYW5kIHRleHRcbiAgICBpZiAob3JpZW50ID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsU2l6ZSA9IHRleHRTaXplLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChkLmhlaWdodCwgc2hhcGVTaXplW2ldLmhlaWdodCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeSA9IHNoYXBlID09IFwiY2lyY2xlXCIgfHwgc2hhcGUgPT0gXCJsaW5lXCIgPyBzaGFwZVNpemVbMF0uaGVpZ2h0IC8gMiA6IDA7XG4gICAgICAgIGNlbGxUcmFucyA9IGZ1bmN0aW9uIGNlbGxUcmFucyhkLCBpKSB7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGQzQXJyYXkuc3VtKGNlbGxTaXplLnNsaWNlKDAsIGkpKTtcblxuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsICcgKyAoeSArIGhlaWdodCArIGkgKiBzaGFwZVBhZGRpbmcpICsgJyknO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRleHRUcmFucyA9IGZ1bmN0aW9uIHRleHRUcmFucyhkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoICcgKyAobWF4VyArIGxhYmVsT2Zmc2V0KSArICcsXFxuICAgICAgICAgICcgKyAoc2hhcGVTaXplW2ldLnkgKyBzaGFwZVNpemVbaV0uaGVpZ2h0IC8gMiArIDUpICsgJyknO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKG9yaWVudCA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIGNlbGxUcmFucyA9IGZ1bmN0aW9uIGNlbGxUcmFucyhkLCBpKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGQzQXJyYXkuc3VtKHNoYXBlU2l6ZS5zbGljZSgwLCBpKSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC53aWR0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB5ID0gc2hhcGUgPT0gXCJjaXJjbGVcIiB8fCBzaGFwZSA9PSBcImxpbmVcIiA/IG1heEggLyAyIDogMDtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArICh3aWR0aCArIGkgKiBzaGFwZVBhZGRpbmcpICsgJywgJyArIHkgKyAnKSc7XG4gICAgICB9O1xuXG4gICAgICB0ZXh0VHJhbnMgPSBmdW5jdGlvbiB0ZXh0VHJhbnMoZCwgaSkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSggJyArIChzaGFwZVNpemVbaV0ud2lkdGggKiB0ZXh0QWxpZ24gKyBzaGFwZVNpemVbaV0ueCkgKyAnLFxcbiAgICAgICAgICAgICAgJyArIChtYXhIICsgbGFiZWxPZmZzZXQpICsgJyknO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBoZWxwZXIuZDNfcGxhY2VtZW50KG9yaWVudCwgY2VsbCwgY2VsbFRyYW5zLCB0ZXh0LCB0ZXh0VHJhbnMsIGxhYmVsQWxpZ24pO1xuICAgIGhlbHBlci5kM190aXRsZShzdmcsIHRpdGxlLCBjbGFzc1ByZWZpeCwgdGl0bGVXaWR0aCk7XG5cbiAgICBjZWxsLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gIH1cblxuICBsZWdlbmQuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgIHNjYWxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5jZWxscyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VsbHM7XG4gICAgaWYgKF8ubGVuZ3RoID4gMSB8fCBfID49IDIpIHtcbiAgICAgIGNlbGxzID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2VsbEZpbHRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VsbEZpbHRlcjtcbiAgICBjZWxsRmlsdGVyID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZSA9IGZ1bmN0aW9uIChfLCBkKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgaWYgKF8gPT0gXCJyZWN0XCIgfHwgXyA9PSBcImNpcmNsZVwiIHx8IF8gPT0gXCJsaW5lXCIpIHtcbiAgICAgIHNoYXBlID0gXztcbiAgICAgIHBhdGggPSBkO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZVdpZHRoO1xuICAgIHNoYXBlV2lkdGggPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlUGFkZGluZztcbiAgICBzaGFwZVBhZGRpbmcgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVscztcbiAgICBsYWJlbHMgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsQWxpZ24gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsQWxpZ247XG4gICAgaWYgKF8gPT0gXCJzdGFydFwiIHx8IF8gPT0gXCJlbmRcIiB8fCBfID09IFwibWlkZGxlXCIpIHtcbiAgICAgIGxhYmVsQWxpZ24gPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbEZvcm1hdCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxGb3JtYXQ7XG4gICAgbGFiZWxGb3JtYXQgPSB0eXBlb2YgXyA9PT0gJ3N0cmluZycgPyBkM0Zvcm1hdC5mb3JtYXQoXykgOiBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsT2Zmc2V0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbE9mZnNldDtcbiAgICBsYWJlbE9mZnNldCA9ICtfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsRGVsaW1pdGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbERlbGltaXRlcjtcbiAgICBsYWJlbERlbGltaXRlciA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxXcmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbFdyYXA7XG4gICAgbGFiZWxXcmFwID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5vcmllbnQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBfID0gXy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChfID09IFwiaG9yaXpvbnRhbFwiIHx8IF8gPT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICBvcmllbnQgPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5hc2NlbmRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFzY2VuZGluZztcbiAgICBhc2NlbmRpbmcgPSAhIV87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2xhc3NQcmVmaXggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsYXNzUHJlZml4O1xuICAgIGNsYXNzUHJlZml4ID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgdGl0bGUgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnRpdGxlV2lkdGggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlV2lkdGg7XG4gICAgdGl0bGVXaWR0aCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gbGVnZW5kRGlzcGF0Y2hlci5vbi5hcHBseShsZWdlbmREaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGVnZW5kRGlzcGF0Y2hlciA/IGxlZ2VuZCA6IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBsZWdlbmQ7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbCgpIHtcblxuICB2YXIgc2NhbGUgPSBkM1NjYWxlLnNjYWxlTGluZWFyKCksXG4gICAgICBzaGFwZSA9IFwicGF0aFwiLFxuICAgICAgc2hhcGVXaWR0aCA9IDE1LFxuICAgICAgc2hhcGVIZWlnaHQgPSAxNSxcbiAgICAgIHNoYXBlUmFkaXVzID0gMTAsXG4gICAgICBzaGFwZVBhZGRpbmcgPSA1LFxuICAgICAgY2VsbHMgPSBbNV0sXG4gICAgICBjZWxsRmlsdGVyID0gdm9pZCAwLFxuICAgICAgbGFiZWxzID0gW10sXG4gICAgICBjbGFzc1ByZWZpeCA9IFwiXCIsXG4gICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICBsYWJlbEZvcm1hdCA9IGQzRm9ybWF0LmZvcm1hdChcIi4wMWZcIiksXG4gICAgICBsYWJlbEFsaWduID0gXCJtaWRkbGVcIixcbiAgICAgIGxhYmVsT2Zmc2V0ID0gMTAsXG4gICAgICBsYWJlbERlbGltaXRlciA9IFwidG9cIixcbiAgICAgIGxhYmVsV3JhcCA9IHZvaWQgMCxcbiAgICAgIG9yaWVudCA9IFwidmVydGljYWxcIixcbiAgICAgIGFzY2VuZGluZyA9IGZhbHNlLFxuICAgICAgdGl0bGVXaWR0aCA9IHZvaWQgMCxcbiAgICAgIGxlZ2VuZERpc3BhdGNoZXIgPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKFwiY2VsbG92ZXJcIiwgXCJjZWxsb3V0XCIsIFwiY2VsbGNsaWNrXCIpO1xuXG4gIGZ1bmN0aW9uIGxlZ2VuZChzdmcpIHtcblxuICAgIHZhciB0eXBlID0gaGVscGVyLmQzX2NhbGNUeXBlKHNjYWxlLCBhc2NlbmRpbmcsIGNlbGxzLCBsYWJlbHMsIGxhYmVsRm9ybWF0LCBsYWJlbERlbGltaXRlciksXG4gICAgICAgIGxlZ2VuZEcgPSBzdmcuc2VsZWN0QWxsKCdnJykuZGF0YShbc2NhbGVdKTtcblxuICAgIGlmIChjZWxsRmlsdGVyKSB7XG4gICAgICBoZWxwZXIuZDNfZmlsdGVyQ2VsbHModHlwZSwgY2VsbEZpbHRlcik7XG4gICAgfVxuXG4gICAgbGVnZW5kRy5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgY2xhc3NQcmVmaXggKyAnbGVnZW5kQ2VsbHMnKTtcblxuICAgIHZhciBjZWxsID0gc3ZnLnNlbGVjdCgnLicgKyBjbGFzc1ByZWZpeCArICdsZWdlbmRDZWxscycpLnNlbGVjdEFsbChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpLmRhdGEodHlwZS5kYXRhKTtcbiAgICB2YXIgY2VsbEVudGVyID0gY2VsbC5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpO1xuICAgIGNlbGxFbnRlci5hcHBlbmQoc2hhcGUpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwic3dhdGNoXCIpO1xuXG4gICAgdmFyIHNoYXBlcyA9IHN2Zy5zZWxlY3RBbGwoXCJnLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGwgXCIgKyBzaGFwZSk7XG5cbiAgICAvL2FkZCBldmVudCBoYW5kbGVyc1xuICAgIGhlbHBlci5kM19hZGRFdmVudHMoY2VsbEVudGVyLCBsZWdlbmREaXNwYXRjaGVyKTtcblxuICAgIC8vcmVtb3ZlIG9sZCBzaGFwZXNcbiAgICBjZWxsLmV4aXQoKS50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuXG4gICAgaGVscGVyLmQzX2RyYXdTaGFwZXMoc2hhcGUsIHNoYXBlcywgc2hhcGVIZWlnaHQsIHNoYXBlV2lkdGgsIHNoYXBlUmFkaXVzLCB0eXBlLmZlYXR1cmUpO1xuICAgIGhlbHBlci5kM19hZGRUZXh0KHN2ZywgY2VsbEVudGVyLCB0eXBlLmxhYmVscywgY2xhc3NQcmVmaXgsIGxhYmVsV3JhcCk7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIHRoZSBzZWxlY3Rpb24sIG90aGVyd2lzZSBjaGFuZ2VzIGluIHRoZSBsZWdlbmQgKGUuZy4gY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBhcmUgYXBwbGllZCBvbmx5IHRvIHRoZSBuZXcgY2VsbHMgYW5kIG5vdCB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBjZWxsID0gY2VsbEVudGVyLm1lcmdlKGNlbGwpO1xuXG4gICAgLy8gc2V0cyBwbGFjZW1lbnRcbiAgICB2YXIgdGV4dCA9IGNlbGwuc2VsZWN0QWxsKFwidGV4dFwiKSxcbiAgICAgICAgdGV4dFNpemUgPSB0ZXh0Lm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5nZXRCQm94KCk7XG4gICAgfSksXG4gICAgICAgIHNoYXBlU2l6ZSA9IHNoYXBlcy5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpO1xuICAgIH0pO1xuXG4gICAgdmFyIG1heEggPSBkM0FycmF5Lm1heChzaGFwZVNpemUsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5oZWlnaHQ7XG4gICAgfSksXG4gICAgICAgIG1heFcgPSBkM0FycmF5Lm1heChzaGFwZVNpemUsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC53aWR0aDtcbiAgICB9KTtcblxuICAgIHZhciBjZWxsVHJhbnMgPSB2b2lkIDAsXG4gICAgICAgIHRleHRUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dEFsaWduID0gbGFiZWxBbGlnbiA9PSBcInN0YXJ0XCIgPyAwIDogbGFiZWxBbGlnbiA9PSBcIm1pZGRsZVwiID8gMC41IDogMTtcblxuICAgIC8vcG9zaXRpb25zIGNlbGxzIGFuZCB0ZXh0XG4gICAgaWYgKG9yaWVudCA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbFNpemUgPSB0ZXh0U2l6ZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgobWF4SCwgZC5oZWlnaHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjZWxsVHJhbnMgPSBmdW5jdGlvbiBjZWxsVHJhbnMoZCwgaSkge1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBkM0FycmF5LnN1bShjZWxsU2l6ZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwgJyArIChoZWlnaHQgKyBpICogc2hhcGVQYWRkaW5nKSArICcgKSc7XG4gICAgICAgIH07XG4gICAgICAgIHRleHRUcmFucyA9IGZ1bmN0aW9uIHRleHRUcmFucyhkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoICcgKyAobWF4VyArIGxhYmVsT2Zmc2V0KSArICcsXFxuICAgICAgICAgICAgICAnICsgKHNoYXBlU2l6ZVtpXS55ICsgc2hhcGVTaXplW2ldLmhlaWdodCAvIDIgKyA1KSArICcpJztcbiAgICAgICAgfTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmIChvcmllbnQgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBjZWxsVHJhbnMgPSBmdW5jdGlvbiBjZWxsVHJhbnMoZCwgaSkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSggJyArIGkgKiAobWF4VyArIHNoYXBlUGFkZGluZykgKyAnLDApJztcbiAgICAgIH07XG4gICAgICB0ZXh0VHJhbnMgPSBmdW5jdGlvbiB0ZXh0VHJhbnMoZCwgaSkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSggJyArIChzaGFwZVNpemVbaV0ud2lkdGggKiB0ZXh0QWxpZ24gKyBzaGFwZVNpemVbaV0ueCkgKyAnLFxcbiAgICAgICAgICAgICAgJyArIChtYXhIICsgbGFiZWxPZmZzZXQpICsgJyknO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBoZWxwZXIuZDNfcGxhY2VtZW50KG9yaWVudCwgY2VsbCwgY2VsbFRyYW5zLCB0ZXh0LCB0ZXh0VHJhbnMsIGxhYmVsQWxpZ24pO1xuICAgIGhlbHBlci5kM190aXRsZShzdmcsIHRpdGxlLCBjbGFzc1ByZWZpeCwgdGl0bGVXaWR0aCk7XG4gICAgY2VsbC50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICB9XG5cbiAgbGVnZW5kLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZTtcbiAgICBzY2FsZSA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2VsbHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbGxzO1xuICAgIGlmIChfLmxlbmd0aCA+IDEgfHwgXyA+PSAyKSB7XG4gICAgICBjZWxscyA9IF87XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNlbGxGaWx0ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbGxGaWx0ZXI7XG4gICAgY2VsbEZpbHRlciA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGVQYWRkaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZVBhZGRpbmc7XG4gICAgc2hhcGVQYWRkaW5nID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbHM7XG4gICAgbGFiZWxzID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbEFsaWduID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbEFsaWduO1xuICAgIGlmIChfID09IFwic3RhcnRcIiB8fCBfID09IFwiZW5kXCIgfHwgXyA9PSBcIm1pZGRsZVwiKSB7XG4gICAgICBsYWJlbEFsaWduID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxGb3JtYXQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsRm9ybWF0O1xuICAgIGxhYmVsRm9ybWF0ID0gdHlwZW9mIF8gPT09ICdzdHJpbmcnID8gZDNGb3JtYXQuZm9ybWF0KF8pIDogXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbE9mZnNldCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxPZmZzZXQ7XG4gICAgbGFiZWxPZmZzZXQgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbERlbGltaXRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxEZWxpbWl0ZXI7XG4gICAgbGFiZWxEZWxpbWl0ZXIgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsV3JhcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxXcmFwO1xuICAgIGxhYmVsV3JhcCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgXyA9IF8udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoXyA9PSBcImhvcml6b250YWxcIiB8fCBfID09IFwidmVydGljYWxcIikge1xuICAgICAgb3JpZW50ID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuYXNjZW5kaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhc2NlbmRpbmc7XG4gICAgYXNjZW5kaW5nID0gISFfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNsYXNzUHJlZml4ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFzc1ByZWZpeDtcbiAgICBjbGFzc1ByZWZpeCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIHRpdGxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVdpZHRoO1xuICAgIHRpdGxlV2lkdGggPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLm9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IGxlZ2VuZERpc3BhdGNoZXIub24uYXBwbHkobGVnZW5kRGlzcGF0Y2hlciwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxlZ2VuZERpc3BhdGNoZXIgPyBsZWdlbmQgOiB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gbGVnZW5kO1xufVxuXG52YXIgdGhyZXNob2xkTGFiZWxzID0gZnVuY3Rpb24gdGhyZXNob2xkTGFiZWxzKF9yZWYpIHtcbiAgdmFyIGkgPSBfcmVmLmksXG4gICAgICBnZW5MZW5ndGggPSBfcmVmLmdlbkxlbmd0aCxcbiAgICAgIGdlbmVyYXRlZExhYmVscyA9IF9yZWYuZ2VuZXJhdGVkTGFiZWxzO1xuXG5cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVkTGFiZWxzW2ldLnJlcGxhY2UoJ05hTiB0bycsICdMZXNzIHRoYW4nKTtcbiAgfSBlbHNlIGlmIChpID09PSBnZW5MZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuICdNb3JlIHRoYW4gJyArIGdlbmVyYXRlZExhYmVsc1tnZW5MZW5ndGggLSAxXS5yZXBsYWNlKCcgdG8gTmFOJywgJycpO1xuICB9XG4gIHJldHVybiBnZW5lcmF0ZWRMYWJlbHNbaV07XG59O1xuXG52YXIgbGVnZW5kSGVscGVycyA9IHtcbiAgdGhyZXNob2xkTGFiZWxzOiB0aHJlc2hvbGRMYWJlbHNcbn07XG5cbnZhciBpbmRleCA9IHtcbiAgbGVnZW5kQ29sb3I6IGNvbG9yLFxuICBsZWdlbmRTaXplOiBzaXplLFxuICBsZWdlbmRTeW1ib2w6IHN5bWJvbCxcbiAgbGVnZW5kSGVscGVyczogbGVnZW5kSGVscGVyc1xufTtcblxuZXhwb3J0cy5sZWdlbmRDb2xvciA9IGNvbG9yO1xuZXhwb3J0cy5sZWdlbmRTaXplID0gc2l6ZTtcbmV4cG9ydHMubGVnZW5kU3ltYm9sID0gc3ltYm9sO1xuZXhwb3J0cy5sZWdlbmRIZWxwZXJzID0gbGVnZW5kSGVscGVycztcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGluZGV4O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXhSb2xsdXAuanMubWFwXG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUtZm9ybWF0LyBWZXJzaW9uIDIuMC41LiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLXRpbWUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXRpbWUnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzVGltZSkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG59XG5cbmZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG59XG5cbmZ1bmN0aW9uIG5ld1llYXIoeSkge1xuICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gIHZhciBmb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXIsXG4gICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciB1dGNGb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiSFwiOiBmb3JtYXRVVENIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdFVUQ0hvdXIxMixcbiAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRVVENNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdFVUQ01vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRVVENQZXJpb2QsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXIsXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgIFwiSVwiOiBwYXJzZUhvdXIyNCxcbiAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBwYXJzZU1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgIFwiV1wiOiBwYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcbiAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgIFwieVwiOiBwYXJzZVllYXIsXG4gICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICBcIiVcIjogcGFyc2VMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgZm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIsIGZvcm1hdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHBhZCxcbiAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkgZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKTtcblxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgIGVsc2UgcGFkID0gYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiO1xuICAgICAgICAgIGlmIChmb3JtYXQgPSBmb3JtYXRzW2NdKSBjID0gZm9ybWF0KGRhdGUsIHBhZCk7XG4gICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgbmV3RGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBkID0gbmV3WWVhcigxOTAwKSxcbiAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcgKz0gXCJcIiwgMCk7XG4gICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gVGhlIGFtLXBtIGZsYWcgaXMgMCBmb3IgQU0sIGFuZCAxIGZvciBQTS5cbiAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuXG4gICAgICAvLyBDb252ZXJ0IGRheS1vZi13ZWVrIGFuZCB3ZWVrLW9mLXllYXIgdG8gZGF5LW9mLXllYXIuXG4gICAgICBpZiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSB7XG4gICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgIHZhciBkYXkgPSBcIlpcIiBpbiBkID8gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpIDogbmV3RGF0ZShuZXdZZWFyKGQueSkpLmdldERheSgpO1xuICAgICAgICBkLm0gPSAwO1xuICAgICAgICBkLmQgPSBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF5ICsgNSkgJSA3IDogZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgdGltZSB6b25lIGlzIHNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRDIGFuZCB0aGVuXG4gICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgZC5IICs9IGQuWiAvIDEwMCB8IDA7XG4gICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICByZXR1cm4gbmV3RGF0ZShkKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgYyxcbiAgICAgICAgcGFyc2U7XG5cbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckF0KGkrKyk7XG4gICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gcGVyaW9kUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQucCA9IHBlcmlvZExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSBzaG9ydFdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gd2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0TW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gbW9udGhMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGVUaW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX3RpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgZm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIGxvY2FsRGF0ZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCB1dGNEYXRlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifTtcbnZhciBudW1iZXJSZSA9IC9eXFxzKlxcZCsvO1xudmFyIHBlcmNlbnRSZSA9IC9eJS87XG52YXIgcmVxdW90ZVJlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuXG5mdW5jdGlvbiBwYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLFxuICAgICAgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVxdW90ZShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UocmVxdW90ZVJlLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmUobmFtZXMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBuYW1lcy5tYXAocmVxdW90ZSkuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb29rdXAobmFtZXMpIHtcbiAgdmFyIG1hcCA9IHt9LCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBtYXBbbmFtZXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpO1xuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86XFw6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuWiA9IG5bMV0gPyAwIDogLShuWzJdICsgKG5bM10gfHwgXCIwMFwiKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZlllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZk1vbnRoKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIyNChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjEyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoMSArIGQzVGltZS50aW1lRGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSwgZCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZVN1bmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlcihkKSB7XG4gIHJldHVybiBkLmdldERheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZU1vbmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudXRjRGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNTdW5kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlcihkKSB7XG4gIHJldHVybiBkLmdldFVUQ0RheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjTW9uZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1llYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1pvbmUoKSB7XG4gIHJldHVybiBcIiswMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExpdGVyYWxQZXJjZW50KCkge1xuICByZXR1cm4gXCIlXCI7XG59XG5cbnZhciBsb2NhbGUkMTtcblxuXG5cblxuXG5kZWZhdWx0TG9jYWxlKHtcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXG4gIGRhdGU6IFwiJS1tLyUtZC8lWVwiLFxuICB0aW1lOiBcIiUtSTolTTolUyAlcFwiLFxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn0pO1xuXG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlJDEgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMudGltZUZvcm1hdCA9IGxvY2FsZSQxLmZvcm1hdDtcbiAgZXhwb3J0cy50aW1lUGFyc2UgPSBsb2NhbGUkMS5wYXJzZTtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBsb2NhbGUkMS51dGNGb3JtYXQ7XG4gIGV4cG9ydHMudXRjUGFyc2UgPSBsb2NhbGUkMS51dGNQYXJzZTtcbiAgcmV0dXJuIGxvY2FsZSQxO1xufVxuXG52YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nXG4gICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICA6IGV4cG9ydHMudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvTmF0aXZlKHN0cmluZykge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xufVxuXG52YXIgcGFyc2VJc28gPSArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIilcbiAgICA/IHBhcnNlSXNvTmF0aXZlXG4gICAgOiBleHBvcnRzLnV0Y1BhcnNlKGlzb1NwZWNpZmllcik7XG5cbmV4cG9ydHMudGltZUZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuZXhwb3J0cy50aW1lRm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xuZXhwb3J0cy5pc29Gb3JtYXQgPSBmb3JtYXRJc287XG5leHBvcnRzLmlzb1BhcnNlID0gcGFyc2VJc287XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUvIFZlcnNpb24gMS4wLjcuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHQwID0gbmV3IERhdGU7XG52YXIgdDEgPSBuZXcgRGF0ZTtcblxuZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCwgZmllbGQpIHtcblxuICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgfVxuXG4gIGludGVydmFsLmZsb29yID0gaW50ZXJ2YWw7XG5cbiAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBmbG9vcmkoZGF0ZSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGQwID0gaW50ZXJ2YWwoZGF0ZSksXG4gICAgICAgIGQxID0gaW50ZXJ2YWwuY2VpbChkYXRlKTtcbiAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgfTtcblxuICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICBzdGFydCA9IGludGVydmFsLmNlaWwoc3RhcnQpO1xuICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICBkbyByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpOyB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcClcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB7XG4gICAgICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKCsrc3RlcCA8PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgLTEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGVsc2Ugd2hpbGUgKC0tc3RlcCA+PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgKzEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIGludGVydmFsLmV2ZXJ5ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICByZXR1cm4gIWlzRmluaXRlKHN0ZXApIHx8ICEoc3RlcCA+IDApID8gbnVsbFxuICAgICAgICAgIDogIShzdGVwID4gMSkgPyBpbnRlcnZhbFxuICAgICAgICAgIDogaW50ZXJ2YWwuZmlsdGVyKGZpZWxkXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24oZCkgeyByZXR1cm4gZmllbGQoZCkgJSBzdGVwID09PSAwOyB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZCkgeyByZXR1cm4gaW50ZXJ2YWwuY291bnQoMCwgZCkgJSBzdGVwID09PSAwOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufVxuXG52YXIgbWlsbGlzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgLy8gbm9vcFxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbm1pbGxpc2Vjb25kLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICBrID0gTWF0aC5mbG9vcihrKTtcbiAgaWYgKCFpc0Zpbml0ZShrKSB8fCAhKGsgPiAwKSkgcmV0dXJuIG51bGw7XG4gIGlmICghKGsgPiAxKSkgcmV0dXJuIG1pbGxpc2Vjb25kO1xuICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBrKSAqIGspO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGspO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBrO1xuICB9KTtcbn07XG5cbnZhciBtaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZC5yYW5nZTtcblxudmFyIGR1cmF0aW9uU2Vjb25kID0gMWUzO1xudmFyIGR1cmF0aW9uTWludXRlID0gNmU0O1xudmFyIGR1cmF0aW9uSG91ciA9IDM2ZTU7XG52YXIgZHVyYXRpb25EYXkgPSA4NjRlNTtcbnZhciBkdXJhdGlvbldlZWsgPSA2MDQ4ZTU7XG5cbnZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvblNlY29uZCkgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25TZWNvbmQ7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbn0pO1xuXG52YXIgc2Vjb25kcyA9IHNlY29uZC5yYW5nZTtcblxudmFyIG1pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoZGF0ZSAvIGR1cmF0aW9uTWludXRlKSAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbk1pbnV0ZTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpO1xufSk7XG5cbnZhciBtaW51dGVzID0gbWludXRlLnJhbmdlO1xuXG52YXIgaG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlICUgZHVyYXRpb25Ib3VyO1xuICBpZiAob2Zmc2V0IDwgMCkgb2Zmc2V0ICs9IGR1cmF0aW9uSG91cjtcbiAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoKCtkYXRlIC0gb2Zmc2V0KSAvIGR1cmF0aW9uSG91cikgKiBkdXJhdGlvbkhvdXIgKyBvZmZzZXQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG59KTtcblxudmFyIGhvdXJzID0gaG91ci5yYW5nZTtcblxudmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXREYXRlKCkgLSAxO1xufSk7XG5cbnZhciBkYXlzID0gZGF5LnJhbmdlO1xuXG5mdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG52YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbnZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xudmFyIHR1ZXNkYXkgPSB3ZWVrZGF5KDIpO1xudmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG52YXIgdGh1cnNkYXkgPSB3ZWVrZGF5KDQpO1xudmFyIGZyaWRheSA9IHdlZWtkYXkoNSk7XG52YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG52YXIgc3VuZGF5cyA9IHN1bmRheS5yYW5nZTtcbnZhciBtb25kYXlzID0gbW9uZGF5LnJhbmdlO1xudmFyIHR1ZXNkYXlzID0gdHVlc2RheS5yYW5nZTtcbnZhciB3ZWRuZXNkYXlzID0gd2VkbmVzZGF5LnJhbmdlO1xudmFyIHRodXJzZGF5cyA9IHRodXJzZGF5LnJhbmdlO1xudmFyIGZyaWRheXMgPSBmcmlkYXkucmFuZ2U7XG52YXIgc2F0dXJkYXlzID0gc2F0dXJkYXkucmFuZ2U7XG5cbnZhciBtb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXREYXRlKDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldE1vbnRoKCkgLSBzdGFydC5nZXRNb250aCgpICsgKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbn0pO1xuXG52YXIgbW9udGhzID0gbW9udGgucmFuZ2U7XG5cbnZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnllYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xuXG52YXIgeWVhcnMgPSB5ZWFyLnJhbmdlO1xuXG52YXIgdXRjTWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ1NlY29uZHMoMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbn0pO1xuXG52YXIgdXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcblxudmFyIHV0Y0hvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpO1xufSk7XG5cbnZhciB1dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG5cbnZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgLSAxO1xufSk7XG5cbnZhciB1dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuXG5mdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbnZhciB1dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xudmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG52YXIgdXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG52YXIgdXRjV2VkbmVzZGF5ID0gdXRjV2Vla2RheSgzKTtcbnZhciB1dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG52YXIgdXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcbnZhciB1dGNTYXR1cmRheSA9IHV0Y1dlZWtkYXkoNik7XG5cbnZhciB1dGNTdW5kYXlzID0gdXRjU3VuZGF5LnJhbmdlO1xudmFyIHV0Y01vbmRheXMgPSB1dGNNb25kYXkucmFuZ2U7XG52YXIgdXRjVHVlc2RheXMgPSB1dGNUdWVzZGF5LnJhbmdlO1xudmFyIHV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXkucmFuZ2U7XG52YXIgdXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXkucmFuZ2U7XG52YXIgdXRjRnJpZGF5cyA9IHV0Y0ZyaWRheS5yYW5nZTtcbnZhciB1dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheS5yYW5nZTtcblxudmFyIHV0Y01vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0RhdGUoMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDTW9udGgoZGF0ZS5nZXRVVENNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0VVRDTW9udGgoKSAtIHN0YXJ0LmdldFVUQ01vbnRoKCkgKyAoZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNb250aCgpO1xufSk7XG5cbnZhciB1dGNNb250aHMgPSB1dGNNb250aC5yYW5nZTtcblxudmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxudXRjWWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG5cbnZhciB1dGNZZWFycyA9IHV0Y1llYXIucmFuZ2U7XG5cbmV4cG9ydHMudGltZUludGVydmFsID0gbmV3SW50ZXJ2YWw7XG5leHBvcnRzLnRpbWVNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy50aW1lTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG5leHBvcnRzLnRpbWVTZWNvbmQgPSBzZWNvbmQ7XG5leHBvcnRzLnRpbWVTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudXRjU2Vjb25kID0gc2Vjb25kO1xuZXhwb3J0cy51dGNTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudGltZU1pbnV0ZSA9IG1pbnV0ZTtcbmV4cG9ydHMudGltZU1pbnV0ZXMgPSBtaW51dGVzO1xuZXhwb3J0cy50aW1lSG91ciA9IGhvdXI7XG5leHBvcnRzLnRpbWVIb3VycyA9IGhvdXJzO1xuZXhwb3J0cy50aW1lRGF5ID0gZGF5O1xuZXhwb3J0cy50aW1lRGF5cyA9IGRheXM7XG5leHBvcnRzLnRpbWVXZWVrID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lV2Vla3MgPSBzdW5kYXlzO1xuZXhwb3J0cy50aW1lU3VuZGF5ID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lU3VuZGF5cyA9IHN1bmRheXM7XG5leHBvcnRzLnRpbWVNb25kYXkgPSBtb25kYXk7XG5leHBvcnRzLnRpbWVNb25kYXlzID0gbW9uZGF5cztcbmV4cG9ydHMudGltZVR1ZXNkYXkgPSB0dWVzZGF5O1xuZXhwb3J0cy50aW1lVHVlc2RheXMgPSB0dWVzZGF5cztcbmV4cG9ydHMudGltZVdlZG5lc2RheSA9IHdlZG5lc2RheTtcbmV4cG9ydHMudGltZVdlZG5lc2RheXMgPSB3ZWRuZXNkYXlzO1xuZXhwb3J0cy50aW1lVGh1cnNkYXkgPSB0aHVyc2RheTtcbmV4cG9ydHMudGltZVRodXJzZGF5cyA9IHRodXJzZGF5cztcbmV4cG9ydHMudGltZUZyaWRheSA9IGZyaWRheTtcbmV4cG9ydHMudGltZUZyaWRheXMgPSBmcmlkYXlzO1xuZXhwb3J0cy50aW1lU2F0dXJkYXkgPSBzYXR1cmRheTtcbmV4cG9ydHMudGltZVNhdHVyZGF5cyA9IHNhdHVyZGF5cztcbmV4cG9ydHMudGltZU1vbnRoID0gbW9udGg7XG5leHBvcnRzLnRpbWVNb250aHMgPSBtb250aHM7XG5leHBvcnRzLnRpbWVZZWFyID0geWVhcjtcbmV4cG9ydHMudGltZVllYXJzID0geWVhcnM7XG5leHBvcnRzLnV0Y01pbnV0ZSA9IHV0Y01pbnV0ZTtcbmV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZXM7XG5leHBvcnRzLnV0Y0hvdXIgPSB1dGNIb3VyO1xuZXhwb3J0cy51dGNIb3VycyA9IHV0Y0hvdXJzO1xuZXhwb3J0cy51dGNEYXkgPSB1dGNEYXk7XG5leHBvcnRzLnV0Y0RheXMgPSB1dGNEYXlzO1xuZXhwb3J0cy51dGNXZWVrID0gdXRjU3VuZGF5O1xuZXhwb3J0cy51dGNXZWVrcyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1N1bmRheTtcbmV4cG9ydHMudXRjU3VuZGF5cyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y01vbmRheSA9IHV0Y01vbmRheTtcbmV4cG9ydHMudXRjTW9uZGF5cyA9IHV0Y01vbmRheXM7XG5leHBvcnRzLnV0Y1R1ZXNkYXkgPSB1dGNUdWVzZGF5O1xuZXhwb3J0cy51dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXlzO1xuZXhwb3J0cy51dGNXZWRuZXNkYXkgPSB1dGNXZWRuZXNkYXk7XG5leHBvcnRzLnV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXlzO1xuZXhwb3J0cy51dGNUaHVyc2RheSA9IHV0Y1RodXJzZGF5O1xuZXhwb3J0cy51dGNUaHVyc2RheXMgPSB1dGNUaHVyc2RheXM7XG5leHBvcnRzLnV0Y0ZyaWRheSA9IHV0Y0ZyaWRheTtcbmV4cG9ydHMudXRjRnJpZGF5cyA9IHV0Y0ZyaWRheXM7XG5leHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjU2F0dXJkYXk7XG5leHBvcnRzLnV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5cztcbmV4cG9ydHMudXRjTW9udGggPSB1dGNNb250aDtcbmV4cG9ydHMudXRjTW9udGhzID0gdXRjTW9udGhzO1xuZXhwb3J0cy51dGNZZWFyID0gdXRjWWVhcjtcbmV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFycztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogKipbR2F1c3NpYW4gZXJyb3IgZnVuY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24pKipcbiAqXG4gKiBUaGUgYGVycm9yRnVuY3Rpb24oeC8oc2QgKiBNYXRoLnNxcnQoMikpKWAgaXMgdGhlIHByb2JhYmlsaXR5IHRoYXQgYSB2YWx1ZSBpbiBhXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uIHdpdGggc3RhbmRhcmQgZGV2aWF0aW9uIHNkIGlzIHdpdGhpbiB4IG9mIHRoZSBtZWFuLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG51bWVyaWNhbCBhcHByb3hpbWF0aW9uIHRvIHRoZSBleGFjdCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfSBlcnJvciBlc3RpbWF0aW9uXG4gKiBAZXhhbXBsZVxuICogZXJyb3JGdW5jdGlvbigxKS50b0ZpeGVkKDIpOyAvLyA9PiAnMC44NCdcbiAqL1xuZnVuY3Rpb24gZXJyb3JGdW5jdGlvbih4Lyo6IG51bWJlciAqLykvKjogbnVtYmVyICovIHtcbiAgICB2YXIgdCA9IDEgLyAoMSArIDAuNSAqIE1hdGguYWJzKHgpKTtcbiAgICB2YXIgdGF1ID0gdCAqIE1hdGguZXhwKC1NYXRoLnBvdyh4LCAyKSAtXG4gICAgICAgIDEuMjY1NTEyMjMgK1xuICAgICAgICAxLjAwMDAyMzY4ICogdCArXG4gICAgICAgIDAuMzc0MDkxOTYgKiBNYXRoLnBvdyh0LCAyKSArXG4gICAgICAgIDAuMDk2Nzg0MTggKiBNYXRoLnBvdyh0LCAzKSAtXG4gICAgICAgIDAuMTg2Mjg4MDYgKiBNYXRoLnBvdyh0LCA0KSArXG4gICAgICAgIDAuMjc4ODY4MDcgKiBNYXRoLnBvdyh0LCA1KSAtXG4gICAgICAgIDEuMTM1MjAzOTggKiBNYXRoLnBvdyh0LCA2KSArXG4gICAgICAgIDEuNDg4NTE1ODcgKiBNYXRoLnBvdyh0LCA3KSAtXG4gICAgICAgIDAuODIyMTUyMjMgKiBNYXRoLnBvdyh0LCA4KSArXG4gICAgICAgIDAuMTcwODcyNzcgKiBNYXRoLnBvdyh0LCA5KSk7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgICByZXR1cm4gMSAtIHRhdTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGF1IC0gMTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXJyb3JGdW5jdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogW1NpbXBsZSBsaW5lYXIgcmVncmVzc2lvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfbGluZWFyX3JlZ3Jlc3Npb24pXG4gKiBpcyBhIHNpbXBsZSB3YXkgdG8gZmluZCBhIGZpdHRlZCBsaW5lXG4gKiBiZXR3ZWVuIGEgc2V0IG9mIGNvb3JkaW5hdGVzLiBUaGlzIGFsZ29yaXRobSBmaW5kcyB0aGUgc2xvcGUgYW5kIHktaW50ZXJjZXB0IG9mIGEgcmVncmVzc2lvbiBsaW5lXG4gKiB1c2luZyB0aGUgbGVhc3Qgc3VtIG9mIHNxdWFyZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGF0YSBhbiBhcnJheSBvZiB0d28tZWxlbWVudCBvZiBhcnJheXMsXG4gKiBsaWtlIGBbWzAsIDFdLCBbMiwgM11dYFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgc2xvcGUgYW5kIGludGVyc2VjdCBvZiByZWdyZXNzaW9uIGxpbmVcbiAqIEBleGFtcGxlXG4gKiBsaW5lYXJSZWdyZXNzaW9uKFtbMCwgMF0sIFsxLCAxXV0pOyAvLyA9PiB7IG06IDEsIGI6IDAgfVxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uKGRhdGEvKjogQXJyYXk8QXJyYXk8bnVtYmVyPj4gKi8pLyo6IHsgbTogbnVtYmVyLCBiOiBudW1iZXIgfSAqLyB7XG5cbiAgICB2YXIgbSwgYjtcblxuICAgIC8vIFN0b3JlIGRhdGEgbGVuZ3RoIGluIGEgbG9jYWwgdmFyaWFibGUgdG8gcmVkdWNlXG4gICAgLy8gcmVwZWF0ZWQgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgLy9pZiB0aGVyZSdzIG9ubHkgb25lIHBvaW50LCBhcmJpdHJhcmlseSBjaG9vc2UgYSBzbG9wZSBvZiAwXG4gICAgLy9hbmQgYSB5LWludGVyY2VwdCBvZiB3aGF0ZXZlciB0aGUgeSBvZiB0aGUgaW5pdGlhbCBwb2ludCBpc1xuICAgIGlmIChkYXRhTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBiID0gZGF0YVswXVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbml0aWFsaXplIG91ciBzdW1zIGFuZCBzY29wZSB0aGUgYG1gIGFuZCBgYmBcbiAgICAgICAgLy8gdmFyaWFibGVzIHRoYXQgZGVmaW5lIHRoZSBsaW5lLlxuICAgICAgICB2YXIgc3VtWCA9IDAsIHN1bVkgPSAwLFxuICAgICAgICAgICAgc3VtWFggPSAwLCBzdW1YWSA9IDA7XG5cbiAgICAgICAgLy8gVXNlIGxvY2FsIHZhcmlhYmxlcyB0byBncmFiIHBvaW50IHZhbHVlc1xuICAgICAgICAvLyB3aXRoIG1pbmltYWwgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICAgICAgdmFyIHBvaW50LCB4LCB5O1xuXG4gICAgICAgIC8vIEdhdGhlciB0aGUgc3VtIG9mIGFsbCB4IHZhbHVlcywgdGhlIHN1bSBvZiBhbGxcbiAgICAgICAgLy8geSB2YWx1ZXMsIGFuZCB0aGUgc3VtIG9mIHheMiBhbmQgKHgqeSkgZm9yIGVhY2hcbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIG1hdGggbm90YXRpb24sIHRoZXNlIHdvdWxkIGJlIFNTX3gsIFNTX3ksIFNTX3h4LCBhbmQgU1NfeHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHggPSBwb2ludFswXTtcbiAgICAgICAgICAgIHkgPSBwb2ludFsxXTtcblxuICAgICAgICAgICAgc3VtWCArPSB4O1xuICAgICAgICAgICAgc3VtWSArPSB5O1xuXG4gICAgICAgICAgICBzdW1YWCArPSB4ICogeDtcbiAgICAgICAgICAgIHN1bVhZICs9IHggKiB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYG1gIGlzIHRoZSBzbG9wZSBvZiB0aGUgcmVncmVzc2lvbiBsaW5lXG4gICAgICAgIG0gPSAoKGRhdGFMZW5ndGggKiBzdW1YWSkgLSAoc3VtWCAqIHN1bVkpKSAvXG4gICAgICAgICAgICAoKGRhdGFMZW5ndGggKiBzdW1YWCkgLSAoc3VtWCAqIHN1bVgpKTtcblxuICAgICAgICAvLyBgYmAgaXMgdGhlIHktaW50ZXJjZXB0IG9mIHRoZSBsaW5lLlxuICAgICAgICBiID0gKHN1bVkgLyBkYXRhTGVuZ3RoKSAtICgobSAqIHN1bVgpIC8gZGF0YUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGJvdGggdmFsdWVzIGFzIGFuIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBtOiBtLFxuICAgICAgICBiOiBiXG4gICAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhclJlZ3Jlc3Npb247XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIEdpdmVuIHRoZSBvdXRwdXQgb2YgYGxpbmVhclJlZ3Jlc3Npb25gOiBhbiBvYmplY3RcbiAqIHdpdGggYG1gIGFuZCBgYmAgdmFsdWVzIGluZGljYXRpbmcgc2xvcGUgYW5kIGludGVyY2VwdCxcbiAqIHJlc3BlY3RpdmVseSwgZ2VuZXJhdGUgYSBsaW5lIGZ1bmN0aW9uIHRoYXQgdHJhbnNsYXRlc1xuICogeCB2YWx1ZXMgaW50byB5IHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWIgb2JqZWN0IHdpdGggYG1gIGFuZCBgYmAgbWVtYmVycywgcmVwcmVzZW50aW5nXG4gKiBzbG9wZSBhbmQgaW50ZXJzZWN0IG9mIGRlc2lyZWQgbGluZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBtZXRob2QgdGhhdCBjb21wdXRlcyB5LXZhbHVlIGF0IGFueSBnaXZlblxuICogeC12YWx1ZSBvbiB0aGUgbGluZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbCA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24oW1swLCAwXSwgWzEsIDFdXSkpO1xuICogbCgwKSAvLyA9IDBcbiAqIGwoMikgLy8gPSAyXG4gKiBsaW5lYXJSZWdyZXNzaW9uTGluZSh7IGI6IDAsIG06IDEgfSkoMSk7IC8vID0+IDFcbiAqIGxpbmVhclJlZ3Jlc3Npb25MaW5lKHsgYjogMSwgbTogMSB9KSgxKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uTGluZShtYi8qOiB7IGI6IG51bWJlciwgbTogbnVtYmVyIH0qLykvKjogRnVuY3Rpb24gKi8ge1xuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgYSBgeWAgdmFsdWUgZm9yIGVhY2hcbiAgICAvLyB4IHZhbHVlIGl0IGlzIGdpdmVuLCBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIGBiYCBhbmQgYGFgXG4gICAgLy8gdGhhdCB3ZSBqdXN0IGNvbXB1dGVkLlxuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBtYi5iICsgKG1iLm0gKiB4KTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHN1bSA9IHJlcXVpcmUoJy4vc3VtJyk7XG5cbi8qKlxuICogVGhlIG1lYW4sIF9hbHNvIGtub3duIGFzIGF2ZXJhZ2VfLFxuICogaXMgdGhlIHN1bSBvZiBhbGwgdmFsdWVzIG92ZXIgdGhlIG51bWJlciBvZiB2YWx1ZXMuXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhpcyBydW5zIG9uIGBPKG4pYCwgbGluZWFyIHRpbWUgaW4gcmVzcGVjdCB0byB0aGUgYXJyYXlcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gb25lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWFuXG4gKiBAZXhhbXBsZVxuICogbWVhbihbMCwgMTBdKTsgLy8gPT4gNVxuICovXG5mdW5jdGlvbiBtZWFuKHggLyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIC8vIFRoZSBtZWFuIG9mIG5vIG51bWJlcnMgaXMgbnVsbFxuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtKHgpIC8geC5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVhbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBxdWFudGlsZVNvcnRlZCA9IHJlcXVpcmUoJy4vcXVhbnRpbGVfc29ydGVkJyk7XG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCcuL3F1aWNrc2VsZWN0Jyk7XG5cbi8qKlxuICogVGhlIFtxdWFudGlsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUpOlxuICogdGhpcyBpcyBhIHBvcHVsYXRpb24gcXVhbnRpbGUsIHNpbmNlIHdlIGFzc3VtZSB0byBrbm93IHRoZSBlbnRpcmVcbiAqIGRhdGFzZXQgaW4gdGhpcyBsaWJyYXJ5LiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICogW1F1YW50aWxlcyBvZiBhIFBvcHVsYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUjUXVhbnRpbGVzX29mX2FfcG9wdWxhdGlvbilcbiAqIGFsZ29yaXRobSBmcm9tIHdpa2lwZWRpYS5cbiAqXG4gKiBTYW1wbGUgaXMgYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2YgbnVtYmVycyxcbiAqIGFuZCBwIGlzIGVpdGhlciBhIGRlY2ltYWwgbnVtYmVyIGZyb20gMCB0byAxIG9yIGFuIGFycmF5IG9mIGRlY2ltYWxcbiAqIG51bWJlcnMgZnJvbSAwIHRvIDEuXG4gKiBJbiB0ZXJtcyBvZiBhIGsvcSBxdWFudGlsZSwgcCA9IGsvcSAtIGl0J3MganVzdCBkZWFsaW5nIHdpdGggZnJhY3Rpb25zIG9yIGRlYWxpbmdcbiAqIHdpdGggZGVjaW1hbCB2YWx1ZXMuXG4gKiBXaGVuIHAgaXMgYW4gYXJyYXksIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlzIGFsc28gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYXBwcm9wcmlhdGVcbiAqIHF1YW50aWxlcyBpbiBpbnB1dCBvcmRlclxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHAgdGhlIGRlc2lyZWQgcXVhbnRpbGUsIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge251bWJlcn0gcXVhbnRpbGVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZShbMywgNiwgNywgOCwgOCwgOSwgMTAsIDEzLCAxNSwgMTYsIDIwXSwgMC41KTsgLy8gPT4gOVxuICovXG5mdW5jdGlvbiBxdWFudGlsZSh4IC8qOiBBcnJheTxudW1iZXI+ICovLCBwIC8qOiBBcnJheTxudW1iZXI+IHwgbnVtYmVyICovKSB7XG4gICAgdmFyIGNvcHkgPSB4LnNsaWNlKCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgICAvLyByZWFycmFuZ2UgZWxlbWVudHMgc28gdGhhdCBlYWNoIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIHJlcXVlc3RlZFxuICAgICAgICAvLyBxdWFudGlsZSBpcyBvbiBhIHBsYWNlIGl0IHdvdWxkIGJlIGlmIHRoZSBhcnJheSB3YXMgZnVsbHkgc29ydGVkXG4gICAgICAgIG11bHRpUXVhbnRpbGVTZWxlY3QoY29weSwgcCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0ZWQgcXVhbnRpbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcXVhbnRpbGVTb3J0ZWQoY29weSwgcFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IHF1YW50aWxlSW5kZXgoY29weS5sZW5ndGgsIHApO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChjb3B5LCBpZHgsIDAsIGNvcHkubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBxdWFudGlsZVNvcnRlZChjb3B5LCBwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlU2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoayAlIDEgPT09IDApIHtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgayA9IE1hdGguZmxvb3Ioayk7XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIGsgKyAxLCBrICsgMSwgcmlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbXVsdGlRdWFudGlsZVNlbGVjdChhcnIsIHApIHtcbiAgICB2YXIgaW5kaWNlcyA9IFswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHF1YW50aWxlSW5kZXgoYXJyLmxlbmd0aCwgcFtpXSkpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2goYXJyLmxlbmd0aCAtIDEpO1xuICAgIGluZGljZXMuc29ydChjb21wYXJlKTtcblxuICAgIHZhciBzdGFjayA9IFswLCBpbmRpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgciA9IE1hdGguY2VpbChzdGFjay5wb3AoKSk7XG4gICAgICAgIHZhciBsID0gTWF0aC5mbG9vcihzdGFjay5wb3AoKSk7XG4gICAgICAgIGlmIChyIC0gbCA8PSAxKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IoKGwgKyByKSAvIDIpO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChhcnIsIGluZGljZXNbbV0sIGluZGljZXNbbF0sIGluZGljZXNbcl0pO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobCwgbSwgbSwgcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlSW5kZXgobGVuIC8qOiBudW1iZXIgKi8sIHAgLyo6IG51bWJlciAqLykvKjpudW1iZXIqLyB7XG4gICAgdmFyIGlkeCA9IGxlbiAqIHA7XG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgaW5kZXhcbiAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG4gICAgfSBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMCwgZGlyZWN0bHkgcmV0dXJuIHRoZSBmaXJzdCBpbmRleFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgaW5kZXggaXMgbm90IGludGVnZXIsIHJldHVybiB0aGUgbmV4dCBpbmRleCBpbiBhcnJheVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGlkeCkgLSAxO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHJldHVybiB0aGUgbWlkZGxlIG9mIHR3byBpbmRpY2VzXG4gICAgICAgIC8vIGFyb3VuZCBxdWFudGlsZSB0byBpbmRpY2F0ZSB0aGF0IHdlIG5lZWQgYW4gYXZlcmFnZSB2YWx1ZSBvZiB0aGUgdHdvXG4gICAgICAgIHJldHVybiBpZHggLSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgaW5kZXhcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgaW5kZXhcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVhbnRpbGU7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHF1YW50aWxlczogd2hlbiB5b3Uga25vd1xuICogdGhhdCB0aGUgb3JkZXIgaXMgc29ydGVkLCB5b3UgZG9uJ3QgbmVlZCB0byByZS1zb3J0IGl0LCBhbmQgdGhlIGNvbXB1dGF0aW9uc1xuICogYXJlIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gcCBkZXNpcmVkIHF1YW50aWxlOiBhIG51bWJlciBiZXR3ZWVuIDAgdG8gMSwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBxdWFudGlsZSB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHAgaXggb3V0c2lkZSBvZiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDFcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVTb3J0ZWQoWzMsIDYsIDcsIDgsIDgsIDksIDEwLCAxMywgMTUsIDE2LCAyMF0sIDAuNSk7IC8vID0+IDlcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQoeCAvKjogQXJyYXk8bnVtYmVyPiAqLywgcCAvKjogbnVtYmVyICovKS8qOm51bWJlciovIHtcbiAgICB2YXIgaWR4ID0geC5sZW5ndGggKiBwO1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3F1YW50aWxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50LicpO1xuICAgIH0gZWxzZSBpZiAocCA8IDAgfHwgcCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxdWFudGlsZXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEnKTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFt4Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIDAsIGRpcmVjdGx5IHJldHVybiB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFswXTtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgcCBpcyBub3QgaW50ZWdlciwgcmV0dXJuIHRoZSBuZXh0IGVsZW1lbnQgaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHhbTWF0aC5jZWlsKGlkeCkgLSAxXTtcbiAgICB9IGVsc2UgaWYgKHgubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhpcyBudW1iZXJcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHZhbHVlLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgcmV0dXJuICh4W2lkeCAtIDFdICsgeFtpZHhdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgdmFsdWVcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgeCB2YWx1ZSBhdCB0aGUgaW5kZXguXG4gICAgICAgIHJldHVybiB4W2lkeF07XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YW50aWxlU29ydGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBxdWlja3NlbGVjdDtcblxuLyoqXG4gKiBSZWFycmFuZ2UgaXRlbXMgaW4gYGFycmAgc28gdGhhdCBhbGwgaXRlbXMgaW4gYFtsZWZ0LCBrXWAgcmFuZ2UgYXJlIHRoZSBzbWFsbGVzdC5cbiAqIFRoZSBga2AtdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIGAoayAtIGxlZnQgKyAxKWAtdGggc21hbGxlc3QgdmFsdWUgaW4gYFtsZWZ0LCByaWdodF1gLlxuICpcbiAqIEltcGxlbWVudHMgRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxveWQtUml2ZXN0X2FsZ29yaXRobVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFyciBpbnB1dCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGsgcGl2b3QgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCByaWdodCBpbmRleFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXJyID0gWzY1LCAyOCwgNTksIDMzLCAyMSwgNTYsIDIyLCA5NSwgNTAsIDEyLCA5MCwgNTMsIDI4LCA3NywgMzldO1xuICogcXVpY2tzZWxlY3QoYXJyLCA4KTtcbiAqIC8vID0gWzM5LCAyOCwgMjgsIDMzLCAyMSwgMTIsIDIyLCA1MCwgNTMsIDU2LCA1OSwgNjUsIDkwLCA3NywgOTVdXG4gKi9cbmZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciAvKjogQXJyYXk8bnVtYmVyPiAqLywgayAvKjogbnVtYmVyICovLCBsZWZ0IC8qOiBudW1iZXIgKi8sIHJpZ2h0IC8qOiBudW1iZXIgKi8pIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCAwO1xuICAgIHJpZ2h0ID0gcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKTtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgLy8gNjAwIGFuZCAwLjUgYXJlIGFyYml0cmFyeSBjb25zdGFudHMgY2hvc2VuIGluIHRoZSBvcmlnaW5hbCBwYXBlciB0byBtaW5pbWl6ZSBleGVjdXRpb24gdGltZVxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbik7XG4gICAgICAgICAgICBpZiAobSAtIG4gLyAyIDwgMCkgc2QgKj0gLTE7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChhcnJbcmlnaHRdID4gdCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChhcnJbaV0gPCB0KSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2pdID4gdCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycltsZWZ0XSA9PT0gdCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBzYW1wbGVDb3ZhcmlhbmNlID0gcmVxdWlyZSgnLi9zYW1wbGVfY292YXJpYW5jZScpO1xudmFyIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uID0gcmVxdWlyZSgnLi9zYW1wbGVfc3RhbmRhcmRfZGV2aWF0aW9uJyk7XG5cbi8qKlxuICogVGhlIFtjb3JyZWxhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db3JyZWxhdGlvbl9hbmRfZGVwZW5kZW5jZSkgaXNcbiAqIGEgbWVhc3VyZSBvZiBob3cgY29ycmVsYXRlZCB0d28gZGF0YXNldHMgYXJlLCBiZXR3ZWVuIC0xIGFuZCAxXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGZpcnN0IGlucHV0XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHkgc2Vjb25kIGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzYW1wbGUgY29ycmVsYXRpb25cbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVDb3JyZWxhdGlvbihbMSwgMiwgMywgNCwgNSwgNl0sIFsyLCAyLCAzLCA0LCA1LCA2MF0pLnRvRml4ZWQoMik7XG4gKiAvLyA9PiAnMC42OSdcbiAqL1xuZnVuY3Rpb24gc2FtcGxlQ29ycmVsYXRpb24oeC8qOiBBcnJheTxudW1iZXI+ICovLCB5Lyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIHZhciBjb3YgPSBzYW1wbGVDb3ZhcmlhbmNlKHgsIHkpLFxuICAgICAgICB4c3RkID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeCksXG4gICAgICAgIHlzdGQgPSBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih5KTtcblxuICAgIHJldHVybiBjb3YgLyB4c3RkIC8geXN0ZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVDb3JyZWxhdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBtZWFuID0gcmVxdWlyZSgnLi9tZWFuJyk7XG5cbi8qKlxuICogW1NhbXBsZSBjb3ZhcmlhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYW1wbGVfbWVhbl9hbmRfc2FtcGxlQ292YXJpYW5jZSkgb2YgdHdvIGRhdGFzZXRzOlxuICogaG93IG11Y2ggZG8gdGhlIHR3byBkYXRhc2V0cyBtb3ZlIHRvZ2V0aGVyP1xuICogeCBhbmQgeSBhcmUgdHdvIGRhdGFzZXRzLCByZXByZXNlbnRlZCBhcyBhcnJheXMgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBzYW1wbGUgb2YgdHdvIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geSBhIHNhbXBsZSBvZiB0d28gb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggYW5kIHkgZG8gbm90IGhhdmUgZXF1YWwgbGVuZ3Roc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggb3IgeSBoYXZlIGxlbmd0aCBvZiBvbmUgb3IgbGVzc1xuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIGNvdmFyaWFuY2VcbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVDb3ZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1LCA2XSwgWzYsIDUsIDQsIDMsIDIsIDFdKTsgLy8gPT4gLTMuNVxuICovXG5mdW5jdGlvbiBzYW1wbGVDb3ZhcmlhbmNlKHggLyo6QXJyYXk8bnVtYmVyPiovLCB5IC8qOkFycmF5PG51bWJlcj4qLykvKjpudW1iZXIqLyB7XG5cbiAgICAvLyBUaGUgdHdvIGRhdGFzZXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggd2hpY2ggbXVzdCBiZSBtb3JlIHRoYW4gMVxuICAgIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIHNhbXBsZXMgd2l0aCBlcXVhbCBsZW5ndGhzJyk7XG4gICAgfVxuXG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzIGluIGVhY2ggc2FtcGxlJyk7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBtZWFuIG9mIGVhY2ggZGF0YXNldCBzbyB0aGF0IHdlIGNhbiBqdWRnZSBlYWNoXG4gICAgLy8gdmFsdWUgb2YgdGhlIGRhdGFzZXQgZmFpcmx5IGFzIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIG1lYW4uIHRoaXNcbiAgICAvLyB3YXksIGlmIG9uZSBkYXRhc2V0IGlzIFsxLCAyLCAzXSBhbmQgWzIsIDMsIDRdLCB0aGVpciBjb3ZhcmlhbmNlXG4gICAgLy8gZG9lcyBub3Qgc3VmZmVyIGJlY2F1c2Ugb2YgdGhlIGRpZmZlcmVuY2UgaW4gYWJzb2x1dGUgdmFsdWVzXG4gICAgdmFyIHhtZWFuID0gbWVhbih4KSxcbiAgICAgICAgeW1lYW4gPSBtZWFuKHkpLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBvZiB2YWx1ZXMsIHRoZSBjb3ZhcmlhbmNlIGluY3JlYXNlcyB3aGVuIHRoZWlyXG4gICAgLy8gZGlmZmVyZW5jZSBmcm9tIHRoZSBtZWFuIGlzIGFzc29jaWF0ZWQgLSBpZiBib3RoIGFyZSB3ZWxsIGFib3ZlXG4gICAgLy8gb3IgaWYgYm90aCBhcmUgd2VsbCBiZWxvd1xuICAgIC8vIHRoZSBtZWFuLCB0aGUgY292YXJpYW5jZSBpbmNyZWFzZXMgc2lnbmlmaWNhbnRseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9ICh4W2ldIC0geG1lYW4pICogKHlbaV0gLSB5bWVhbik7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIHRoZSBjb3ZhcmlhbmNlIGlzIHdlaWdodGVkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGRhdGFzZXRzLlxuICAgIHJldHVybiBzdW0gLyBiZXNzZWxzQ29ycmVjdGlvbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVDb3ZhcmlhbmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHNhbXBsZVZhcmlhbmNlID0gcmVxdWlyZSgnLi9zYW1wbGVfdmFyaWFuY2UnKTtcblxuLyoqXG4gKiBUaGUgW3N0YW5kYXJkIGRldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9kZXZpYXRpb24pXG4gKiBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhcmlhbmNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dCBhcnJheVxuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvblxuICogQGV4YW1wbGVcbiAqIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKFsyLCA0LCA0LCA0LCA1LCA1LCA3LCA5XSkudG9GaXhlZCgyKTtcbiAqIC8vID0+ICcyLjE0J1xuICovXG5mdW5jdGlvbiBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih4Lyo6QXJyYXk8bnVtYmVyPiovKS8qOm51bWJlciovIHtcbiAgICAvLyBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIG5vIG51bWJlcnMgaXMgbnVsbFxuICAgIHZhciBzYW1wbGVWYXJpYW5jZVggPSBzYW1wbGVWYXJpYW5jZSh4KTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHNhbXBsZVZhcmlhbmNlWCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG52YXIgc3VtTnRoUG93ZXJEZXZpYXRpb25zID0gcmVxdWlyZSgnLi9zdW1fbnRoX3Bvd2VyX2RldmlhdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgW3NhbXBsZSB2YXJpYW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFyaWFuY2UjU2FtcGxlX3ZhcmlhbmNlKVxuICogaXMgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbi4gVGhlIHNhbXBsZSB2YXJpYW5jZVxuICogaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHRoZSB2YXJpYW5jZSBieSB0aGUgdXNhZ2Ugb2YgW0Jlc3NlbCdzIENvcnJlY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jlc3NlbCdzX2NvcnJlY3Rpb24pOlxuICogaW5zdGVhZCBvZiBkaXZpZGluZyB0aGUgc3VtIG9mIHNxdWFyZWQgZGV2aWF0aW9ucyBieSB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCxcbiAqIGl0IGlzIGRpdmlkZWQgYnkgdGhlIGxlbmd0aCBtaW51cyBvbmUuIFRoaXMgY29ycmVjdHMgdGhlIGJpYXMgaW4gZXN0aW1hdGluZ1xuICogYSB2YWx1ZSBmcm9tIGEgc2V0IHRoYXQgeW91IGRvbid0IGtub3cgaWYgZnVsbC5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICogKiBbV29sZnJhbSBNYXRoV29ybGQgb24gU2FtcGxlIFZhcmlhbmNlXShodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL1NhbXBsZVZhcmlhbmNlLmh0bWwpXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIHR3byBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHNhbXBsZSB2YXJpYW5jZVxuICogQGV4YW1wbGVcbiAqIHNhbXBsZVZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1XSk7IC8vID0+IDIuNVxuICovXG5mdW5jdGlvbiBzYW1wbGVWYXJpYW5jZSh4IC8qOiBBcnJheTxudW1iZXI+ICovKS8qOm51bWJlciovIHtcbiAgICAvLyBUaGUgdmFyaWFuY2Ugb2Ygbm8gbnVtYmVycyBpcyBudWxsXG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NhbXBsZVZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBkYXRhIHBvaW50cycpO1xuICAgIH1cblxuICAgIHZhciBzdW1TcXVhcmVkRGV2aWF0aW9uc1ZhbHVlID0gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgsIDIpO1xuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIEZpbmQgdGhlIG1lYW4gdmFsdWUgb2YgdGhhdCBsaXN0XG4gICAgcmV0dXJuIHN1bVNxdWFyZWREZXZpYXRpb25zVmFsdWUgLyBiZXNzZWxzQ29ycmVjdGlvbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVWYXJpYW5jZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciB2YXJpYW5jZSA9IHJlcXVpcmUoJy4vdmFyaWFuY2UnKTtcblxuLyoqXG4gKiBUaGUgW3N0YW5kYXJkIGRldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9kZXZpYXRpb24pXG4gKiBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhcmlhbmNlLiBUaGlzIGlzIGFsc28ga25vd24gYXMgdGhlIHBvcHVsYXRpb25cbiAqIHN0YW5kYXJkIGRldmlhdGlvbi4gSXQncyB1c2VmdWwgZm9yIG1lYXN1cmluZyB0aGUgYW1vdW50XG4gKiBvZiB2YXJpYXRpb24gb3IgZGlzcGVyc2lvbiBpbiBhIHNldCBvZiB2YWx1ZXMuXG4gKlxuICogU3RhbmRhcmQgZGV2aWF0aW9uIGlzIG9ubHkgYXBwcm9wcmlhdGUgZm9yIGZ1bGwtcG9wdWxhdGlvbiBrbm93bGVkZ2U6IGZvclxuICogc2FtcGxlcyBvZiBhIHBvcHVsYXRpb24sIHtAbGluayBzYW1wbGVTdGFuZGFyZERldmlhdGlvbn0gaXNcbiAqIG1vcmUgYXBwcm9wcmlhdGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBleGFtcGxlXG4gKiB2YXJpYW5jZShbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pOyAvLyA9PiA0XG4gKiBzdGFuZGFyZERldmlhdGlvbihbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pOyAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkRGV2aWF0aW9uKHggLyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIHYgPSB2YXJpYW5jZSh4KTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YW5kYXJkRGV2aWF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxuLyoqXG4gKiBPdXIgZGVmYXVsdCBzdW0gaXMgdGhlIFtLYWhhbi1CYWJ1c2thIGFsZ29yaXRobV0oaHR0cHM6Ly9wZGZzLnNlbWFudGljc2Nob2xhci5vcmcvMTc2MC83ZDQ2N2NkYTFkMDI3N2FkMjcyZGViMjExMzUzMzEzMWRjMDkucGRmKS5cbiAqIFRoaXMgbWV0aG9kIGlzIGFuIGltcHJvdmVtZW50IG92ZXIgdGhlIGNsYXNzaWNhbFxuICogW0thaGFuIHN1bW1hdGlvbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0thaGFuX3N1bW1hdGlvbl9hbGdvcml0aG0pLlxuICogSXQgYWltcyBhdCBjb21wdXRpbmcgdGhlIHN1bSBvZiBhIGxpc3Qgb2YgbnVtYmVycyB3aGlsZSBjb3JyZWN0aW5nIGZvclxuICogZmxvYXRpbmctcG9pbnQgZXJyb3JzLiBUcmFkaXRpb25hbGx5LCBzdW1zIGFyZSBjYWxjdWxhdGVkIGFzIG1hbnlcbiAqIHN1Y2Nlc3NpdmUgYWRkaXRpb25zLCBlYWNoIG9uZSB3aXRoIGl0cyBvd24gZmxvYXRpbmctcG9pbnQgcm91bmRvZmYuIFRoZXNlXG4gKiBsb3NzZXMgaW4gcHJlY2lzaW9uIGFkZCB1cCBhcyB0aGUgbnVtYmVyIG9mIG51bWJlcnMgaW5jcmVhc2VzLiBUaGlzIGFsdGVybmF0aXZlXG4gKiBhbGdvcml0aG0gaXMgbW9yZSBhY2N1cmF0ZSB0aGFuIHRoZSBzaW1wbGUgd2F5IG9mIGNhbGN1bGF0aW5nIHN1bXMgYnkgc2ltcGxlXG4gKiBhZGRpdGlvbi5cbiAqXG4gKiBUaGlzIHJ1bnMgb24gYE8obilgLCBsaW5lYXIgdGltZSBpbiByZXNwZWN0IHRvIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gc3VtIG9mIGFsbCBpbnB1dCBudW1iZXJzXG4gKiBAZXhhbXBsZVxuICogc3VtKFsxLCAyLCAzXSk7IC8vID0+IDZcbiAqL1xuZnVuY3Rpb24gc3VtKHgvKjogQXJyYXk8bnVtYmVyPiAqLykvKjogbnVtYmVyICovIHtcblxuICAgIC8vIElmIHRoZSBhcnJheSBpcyBlbXB0eSwgd2UgbmVlZG4ndCBib3RoZXIgY29tcHV0aW5nIGl0cyBzdW1cbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHRoZSBzdW0gYXMgdGhlIGZpcnN0IG51bWJlciBpbiB0aGUgYXJyYXlcbiAgICB2YXIgc3VtID0geFswXTtcblxuICAgIC8vIEtlZXBpbmcgdHJhY2sgb2YgdGhlIGZsb2F0aW5nLXBvaW50IGVycm9yIGNvcnJlY3Rpb25cbiAgICB2YXIgY29ycmVjdGlvbiA9IDA7XG5cbiAgICB2YXIgdHJhbnNpdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFuc2l0aW9uID0gc3VtICsgeFtpXTtcblxuICAgICAgICAvLyBIZXJlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjb3JyZWN0aW9uIGluIGEgZGlmZmVyZW50IGZhc2hpb25cbiAgICAgICAgLy8gaWYgdGhlIG5ldyBhYnNvbHV0ZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGFic29sdXRlIHN1bVxuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA+PSBNYXRoLmFicyh4W2ldKSkge1xuICAgICAgICAgICAgY29ycmVjdGlvbiArPSAoKHN1bSAtIHRyYW5zaXRpb24pICsgeFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3JyZWN0aW9uICs9ICgoeFtpXSAtIHRyYW5zaXRpb24pICsgc3VtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSA9IHRyYW5zaXRpb247XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuaW5nIHRoZSBjb3JyZWN0ZWQgc3VtXG4gICAgcmV0dXJuIHN1bSArIGNvcnJlY3Rpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIG1lYW4gPSByZXF1aXJlKCcuL21lYW4nKTtcblxuLyoqXG4gKiBUaGUgc3VtIG9mIGRldmlhdGlvbnMgdG8gdGhlIE50aCBwb3dlci5cbiAqIFdoZW4gbj0yIGl0J3MgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMuXG4gKiBXaGVuIG49MyBpdCdzIHRoZSBzdW0gb2YgY3ViZWQgZGV2aWF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIHBvd2VyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzdW0gb2YgbnRoIHBvd2VyIGRldmlhdGlvbnNcbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5wdXQgPSBbMSwgMiwgM107XG4gKiAvLyBzaW5jZSB0aGUgdmFyaWFuY2Ugb2YgYSBzZXQgaXMgdGhlIG1lYW4gc3F1YXJlZFxuICogLy8gZGV2aWF0aW9ucywgd2UgY2FuIGNhbGN1bGF0ZSB0aGF0IHdpdGggc3VtTnRoUG93ZXJEZXZpYXRpb25zOlxuICogdmFyIHZhcmlhbmNlID0gc3VtTnRoUG93ZXJEZXZpYXRpb25zKGlucHV0KSAvIGlucHV0Lmxlbmd0aDtcbiAqL1xuZnVuY3Rpb24gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgvKjogQXJyYXk8bnVtYmVyPiAqLywgbi8qOiBudW1iZXIgKi8pLyo6bnVtYmVyKi8ge1xuICAgIHZhciBtZWFuVmFsdWUgPSBtZWFuKHgpLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICB0ZW1wVmFsdWUsXG4gICAgICAgIGk7XG5cbiAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbjogd2hlbiBuIGlzIDIgKHdlJ3JlIGNvbXB1dGluZyBhIG51bWJlciBzcXVhcmVkKSxcbiAgICAvLyBtdWx0aXBseWluZyB0aGUgbnVtYmVyIGJ5IGl0c2VsZiBpcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHVzaW5nXG4gICAgLy8gdGhlIE1hdGgucG93IG1ldGhvZC5cbiAgICBpZiAobiA9PT0gMikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFZhbHVlID0geFtpXSAtIG1lYW5WYWx1ZTtcbiAgICAgICAgICAgIHN1bSArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IE1hdGgucG93KHhbaV0gLSBtZWFuVmFsdWUsIG4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdW1OdGhQb3dlckRldmlhdGlvbnM7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG52YXIgc3VtTnRoUG93ZXJEZXZpYXRpb25zID0gcmVxdWlyZSgnLi9zdW1fbnRoX3Bvd2VyX2RldmlhdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgW3ZhcmlhbmNlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhcmlhbmNlKVxuICogaXMgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbi5cbiAqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHZhcmlhbmNlLCBub3Qgc2FtcGxlIHZhcmlhbmNlOlxuICogc2VlIHRoZSBgc2FtcGxlVmFyaWFuY2VgIG1ldGhvZCBpZiB5b3Ugd2FudCBhIHNhbXBsZSBtZWFzdXJlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHBvcHVsYXRpb24gb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhcmlhbmNlOiBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLlxuICogemVybyBpbmRpY2F0ZXMgdGhhdCBhbGwgdmFsdWVzIGFyZSBpZGVudGljYWwuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCdzIGxlbmd0aCBpcyAwXG4gKiBAZXhhbXBsZVxuICogdmFyaWFuY2UoWzEsIDIsIDMsIDQsIDUsIDZdKTsgLy8gPT4gMi45MTY2NjY2NjY2NjY2NjY1XG4gKi9cbmZ1bmN0aW9uIHZhcmlhbmNlKHgvKjogQXJyYXk8bnVtYmVyPiAqLykvKjpudW1iZXIqLyB7XG4gICAgLy8gVGhlIHZhcmlhbmNlIG9mIG5vIG51bWJlcnMgaXMgbnVsbFxuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50Jyk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgbWVhbiBvZiBzcXVhcmVkIGRldmlhdGlvbnMgYmV0d2VlbiB0aGVcbiAgICAvLyBtZWFuIHZhbHVlIGFuZCBlYWNoIHZhbHVlLlxuICAgIHJldHVybiBzdW1OdGhQb3dlckRldmlhdGlvbnMoeCwgMikgLyB4Lmxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YXJpYW5jZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogVGhlIFtaLVNjb3JlLCBvciBTdGFuZGFyZCBTY29yZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9zY29yZSkuXG4gKlxuICogVGhlIHN0YW5kYXJkIHNjb3JlIGlzIHRoZSBudW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBhbiBvYnNlcnZhdGlvblxuICogb3IgZGF0dW0gaXMgYWJvdmUgb3IgYmVsb3cgdGhlIG1lYW4uIFRodXMsIGEgcG9zaXRpdmUgc3RhbmRhcmQgc2NvcmVcbiAqIHJlcHJlc2VudHMgYSBkYXR1bSBhYm92ZSB0aGUgbWVhbiwgd2hpbGUgYSBuZWdhdGl2ZSBzdGFuZGFyZCBzY29yZVxuICogcmVwcmVzZW50cyBhIGRhdHVtIGJlbG93IHRoZSBtZWFuLiBJdCBpcyBhIGRpbWVuc2lvbmxlc3MgcXVhbnRpdHlcbiAqIG9idGFpbmVkIGJ5IHN1YnRyYWN0aW5nIHRoZSBwb3B1bGF0aW9uIG1lYW4gZnJvbSBhbiBpbmRpdmlkdWFsIHJhd1xuICogc2NvcmUgYW5kIHRoZW4gZGl2aWRpbmcgdGhlIGRpZmZlcmVuY2UgYnkgdGhlIHBvcHVsYXRpb24gc3RhbmRhcmRcbiAqIGRldmlhdGlvbi5cbiAqXG4gKiBUaGUgei1zY29yZSBpcyBvbmx5IGRlZmluZWQgaWYgb25lIGtub3dzIHRoZSBwb3B1bGF0aW9uIHBhcmFtZXRlcnM7XG4gKiBpZiBvbmUgb25seSBoYXMgYSBzYW1wbGUgc2V0LCB0aGVuIHRoZSBhbmFsb2dvdXMgY29tcHV0YXRpb24gd2l0aFxuICogc2FtcGxlIG1lYW4gYW5kIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24geWllbGRzIHRoZVxuICogU3R1ZGVudCdzIHQtc3RhdGlzdGljLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0gbWVhblxuICogQHBhcmFtIHtudW1iZXJ9IHN0YW5kYXJkRGV2aWF0aW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHogc2NvcmVcbiAqIEBleGFtcGxlXG4gKiB6U2NvcmUoNzgsIDgwLCA1KTsgLy8gPT4gLTAuNFxuICovXG5mdW5jdGlvbiB6U2NvcmUoeC8qOm51bWJlciovLCBtZWFuLyo6bnVtYmVyKi8sIHN0YW5kYXJkRGV2aWF0aW9uLyo6bnVtYmVyKi8pLyo6bnVtYmVyKi8ge1xuICAgIHJldHVybiAoeCAtIG1lYW4pIC8gc3RhbmRhcmREZXZpYXRpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gelNjb3JlO1xuIiwiaW1wb3J0IHtDaGFydFdpdGhDb2xvckdyb3VwcywgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWd9IGZyb20gXCIuL2NoYXJ0LXdpdGgtY29sb3ItZ3JvdXBzXCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHtMZWdlbmR9IGZyb20gXCIuL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIEJhckNoYXJ0Q29uZmlnIGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWcge1xuXG4gICAgc3ZnQ2xhc3MgPSB0aGlzLmNzc0NsYXNzUHJlZml4ICsgJ2Jhci1jaGFydCc7XG4gICAgc2hvd0xlZ2VuZCA9IHRydWU7XG4gICAgc2hvd1Rvb2x0aXAgPSB0cnVlO1xuICAgIHggPSB7Ly8gWCBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgbGFiZWxcbiAgICAgICAga2V5OiAwLFxuICAgICAgICB2YWx1ZTogKGQsIGtleSkgPT4gVXRpbHMuaXNOdW1iZXIoZCkgPyBkIDogZFtrZXldLCAvLyB4IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIHNjYWxlOiBcIm9yZGluYWxcIixcbiAgICAgICAgb3JpZW50OiBcImJvdHRvbVwiLFxuICAgICAgICB0aWNrczogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgeSA9IHsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIGtleTogMSxcbiAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IFV0aWxzLmlzTnVtYmVyKGQpID8gZCA6IGRba2V5XSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgbGFiZWwsXG4gICAgICAgIG9yaWVudDogXCJsZWZ0XCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiXG4gICAgfTtcbiAgICB0cmFuc2l0aW9uID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcztcblxuICAgICAgICBpZiAoY3VzdG9tKSB7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJhckNoYXJ0IGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHMge1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgQmFyQ2hhcnRDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBCYXJDaGFydENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpIHtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdGhpcy5wbG90LnggPSB7fTtcbiAgICAgICAgdGhpcy5wbG90LnkgPSB7fTtcblxuICAgICAgICB0aGlzLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuICAgICAgICB0aGlzLnNldHVwWCgpO1xuICAgICAgICB0aGlzLnNldHVwR3JvdXBTdGFja3MoKTtcbiAgICAgICAgdGhpcy5zZXR1cFlEb21haW4oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIHNldHVwWCgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueDtcblxuICAgICAgICAvKiAqXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICoqL1xuICAgICAgICB4LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlKGQsIGNvbmYua2V5KTtcbiAgICAgICAgeC5zY2FsZSA9IGQzLnNjYWxlQmFuZCgpLnJhbmdlKFswLCBwbG90LndpZHRoXSkucGFkZGluZ0lubmVyKC4wOCk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuXG4gICAgICAgIHguYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHguc2NhbGUpO1xuICAgICAgICBpZiAoY29uZi50aWNrcykge1xuICAgICAgICAgICAgeC5heGlzLnRpY2tzKGNvbmYudGlja3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmNvbmZpZy5zZXJpZXMpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IGQzLm1hcChkYXRhLCB4LnZhbHVlKS5rZXlzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSBkMy5tYXAoZGF0YVswXS52YWx1ZXMsIHgudmFsdWUpLmtleXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QueC5zY2FsZS5kb21haW4oZG9tYWluKTtcblxuICAgIH07XG5cbiAgICBzZXR1cFkoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB5ID0gcGxvdC55O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHkudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuICAgICAgICB5LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi5zY2FsZSkucmFuZ2UoW3Bsb3QuaGVpZ2h0LCAwXSk7XG4gICAgICAgIHkubWFwID0gZCA9PiB5LnNjYWxlKHkudmFsdWUoZCkpO1xuXG4gICAgICAgIHkuYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHkuc2NhbGUpO1xuXG4gICAgfTtcblxuICAgIHNldHVwWURvbWFpbigpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIHZhciB5U3RhY2tNYXggPSBkMy5tYXgocGxvdC5sYXllcnMsIGxheWVyID0+IGQzLm1heChsYXllci5wb2ludHMsIGQgPT4gZC55MCArIGQueSkpO1xuXG5cbiAgICAgICAgLy8gdmFyIG1pbiA9IGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueS52YWx1ZSkpO1xuICAgICAgICB2YXIgbWF4ID0geVN0YWNrTWF4O1xuICAgICAgICBkb21haW4gPSBbMCwgbWF4XTtcblxuICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCcgcGxvdC55LnNjYWxlLmRvbWFpbicsIHBsb3QueS5zY2FsZS5kb21haW4oKSk7XG4gICAgfVxuXG4gICAgc2V0dXBHcm91cFN0YWNrcygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmdyb3VwRGF0YSgpO1xuXG4gICAgICAgIHZhciB5MHMgPSBbXTtcbiAgICAgICAgdGhpcy5wbG90Lmdyb3VwZWREYXRhLmZvckVhY2gocz0+IHtcbiAgICAgICAgICAgIHMucG9pbnRzID0gcy52YWx1ZXMubWFwKHY9PnNlbGYubWFwVG9Qb2ludCh2KSk7XG4gICAgICAgICAgICBzLnBvaW50cy5mb3JFYWNoKChwLCBpKT0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlkwID0geTBzW2ldO1xuICAgICAgICAgICAgICAgIGlmKCFwcmV2WTApIHByZXZZMCA9IDA7XG4gICAgICAgICAgICAgICAgcC55MCA9IHByZXZZMDtcbiAgICAgICAgICAgICAgICB5MHNbaV0gPSBwLnkrcHJldlkwO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGxvdC5sYXllcnMgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG5cbiAgICB9XG5cbiAgICBtYXBUb1BvaW50KHZhbHVlKSB7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcGxvdC54LnZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQocGxvdC55LnZhbHVlKHZhbHVlKSlcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZHJhd0F4aXNYKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy54O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzLXgnKSArIFwiLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpICsgKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nICsgc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIHBsb3QuaGVpZ2h0ICsgXCIpXCIpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC54LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiICsgc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHBsb3Qud2lkdGggLyAyKSArIFwiLFwiICsgKHBsb3QubWFyZ2luLmJvdHRvbSkgKyBcIilcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCItMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICBkcmF3QXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpICsgXCIuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzJykgKyAoc2VsZi5jb25maWcuZ3VpZGVzID8gJycgOiAnLicgKyBzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC55LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiICsgc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLXBsb3QubWFyZ2luLmxlZnQgKyBcIixcIiArIChwbG90LmhlaWdodCAvIDIpICsgXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuXG4gICAgZHJhd0JhcnMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2xheWVycycsIHBsb3QubGF5ZXJzKTtcblxuICAgICAgICB2YXIgbGF5ZXJDbGFzcyA9IHRoaXMucHJlZml4Q2xhc3MoXCJsYXllclwiKTtcblxuICAgICAgICB2YXIgYmFyQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKFwiYmFyXCIpO1xuICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiICsgbGF5ZXJDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHBsb3QubGF5ZXJzKTtcblxuICAgICAgICB2YXIgbGF5ZXJNZXJnZSA9IGxheWVyLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBsYXllckNsYXNzKS5tZXJnZShsYXllcik7XG5cbiAgICAgICAgdmFyIGJhciA9IGxheWVyTWVyZ2Uuc2VsZWN0QWxsKFwiLlwiICsgYmFyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShkID0+IGQucG9pbnRzKTtcblxuICAgICAgICB2YXIgYmFyRW50ZXIgPSBiYXIuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGJhckNsYXNzKTtcbiAgICAgICAgdmFyIGJhclJlY3RFbnRlciA9IGJhckVudGVyLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAxKTtcbiAgICAgICAgdmFyIGJhck1lcmdlID0gYmFyRW50ZXIubWVyZ2UoYmFyKTtcblxuICAgICAgICB2YXIgYmFyUmVjdCA9IGJhck1lcmdlLnNlbGVjdChcInJlY3RcIik7XG5cbiAgICAgICAgdmFyIGJhclJlY3RUID0gYmFyUmVjdDtcbiAgICAgICAgdmFyIGJhclQgPSBiYXJNZXJnZTtcbiAgICAgICAgdmFyIGxheWVyVCA9IGxheWVyTWVyZ2U7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGJhclJlY3RUID0gYmFyUmVjdC50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICBiYXJUID0gYmFyTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgbGF5ZXJUID0gbGF5ZXJNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXJFbnRlci5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBwbG90Lnguc2NhbGUoZC54KSArIFwiLFwiICsgKHBsb3QueS5zY2FsZShkLnkwKSkgKyBcIilcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB5RG9tYWluID0gcGxvdC55LnNjYWxlLmRvbWFpbigpO1xuICAgICAgICBiYXJULmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHBsb3QueC5zY2FsZShkLngpICsgXCIsXCIgKyAocGxvdC55LnNjYWxlKGQueTAgKyBkLnkpKSArIFwiKVwiO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFyUmVjdEVudGVyXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgICBiYXJSZWN0VFxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+IHBsb3QueS5zY2FsZShkLnkwKSAtIHBsb3QueS5zY2FsZShkLnkwICsgZC55IC0geURvbWFpblswXSkpO1xuXG5cbiAgICAgICAgaWYgKHRoaXMucGxvdC5zZXJpZXNDb2xvcikge1xuICAgICAgICAgICAgbGF5ZXJUXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIHRoaXMucGxvdC5zZXJpZXNDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICBiYXJNZXJnZS5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGQueSk7XG4gICAgICAgICAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgYmFyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUobmV3RGF0YSkge1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG4gICAgICAgIHRoaXMuZHJhd0F4aXNYKCk7XG4gICAgICAgIHRoaXMuZHJhd0F4aXNZKCk7XG4gICAgICAgIHRoaXMuZHJhd0JhcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxufVxuIiwiaW1wb3J0IHtDaGFydCwgQ2hhcnRDb25maWd9IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIEJveFBsb3RCYXNlQ29uZmlnIGV4dGVuZHMgQ2hhcnRDb25maWd7XG5cbiAgICBzdmdDbGFzcyA9IHRoaXMuY3NzQ2xhc3NQcmVmaXggKyAnYm94LXBsb3QnO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTtcbiAgICB4ID0gey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsXG4gICAgICAgIHZhbHVlOiBzID0+IHMua2V5LCAvLyB4IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIGd1aWRlczogZmFsc2UsIC8vc2hvdyBheGlzIGd1aWRlc1xuICAgICAgICBvcmllbnQ6ICdib3R0b20nLFxuXG4gICAgfTtcbiAgICB5ID0gey8vIFkgYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICB2YWx1ZTogZCA9PiBkLCAvLyB5IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBvcmllbnQ6ICdsZWZ0JyxcbiAgICAgICAgZG9tYWluTWFyZ2luOiAwLjEsXG4gICAgICAgIGd1aWRlczogdHJ1ZSAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICB9O1xuICAgIFExID0gZCA9PiBkLnZhbHVlcy5RMTtcbiAgICBRMiA9IGQgPT4gZC52YWx1ZXMuUTI7XG4gICAgUTMgPSBkID0+IGQudmFsdWVzLlEzO1xuICAgIFdsID0gZCA9PiBkLnZhbHVlcy53aGlza2VyTG93O1xuICAgIFdoID0gZCA9PiBkLnZhbHVlcy53aGlza2VySGlnaDtcbiAgICBvdXRsaWVycz0gZD0+IGQudmFsdWVzLm91dGxpZXJzO1xuICAgIG91dGxpZXJWYWx1ZSA9IChkLGkpPT4gZDtcbiAgICBvdXRsaWVyTGFiZWwgPSAoZCxpKT0+IGQ7XG4gICAgbWluQm94V2lkdGggPSAzNTtcbiAgICBtYXhCb3hXaWR0aCA9IDEwMDtcblxuICAgIHRyYW5zaXRpb24gPSB0cnVlO1xuICAgIGNvbG9yID0gIHVuZGVmaW5lZDsvLyBzdHJpbmcgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIGNvbG9yJ3MgdmFsdWUgZm9yIGNvbG9yIHNjYWxlXG4gICAgZDNDb2xvckNhdGVnb3J5PSAnY2F0ZWdvcnkxMCc7XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZihjdXN0b20pe1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCb3hQbG90QmFzZSBleHRlbmRzIENoYXJ0e1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgQm94UGxvdEJhc2VDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZyl7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IEJveFBsb3RCYXNlQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGluaXRQbG90KCl7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHN1cGVyLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnBsb3QueCA9IHt9O1xuICAgICAgICB0aGlzLnBsb3QueSA9IHt9O1xuXG4gICAgICAgIHRoaXMucGxvdC5kYXRhID0gdGhpcy5nZXREYXRhVG9QbG90KCk7XG4gICAgICAgIHRoaXMuc2V0dXBZKCk7XG4gICAgICAgIHRoaXMuc2V0dXBYKCk7XG5cbiAgICAgICAgdGhpcy5zZXR1cENvbG9yKCk7XG5cbiAgICB9XG5cbiAgICBnZXREYXRhVG9QbG90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIHNldHVwWCgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueDtcblxuICAgICAgICB4LnZhbHVlID0gY29uZi52YWx1ZTtcbiAgICAgICAgeC5zY2FsZSA9IGQzLnNjYWxlQmFuZCgpLnJhbmdlKFswLCBwbG90LndpZHRoXSk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuXG4gICAgICAgIHguYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHguc2NhbGUpO1xuICAgICAgICBpZihjb25mLmd1aWRlcyl7XG4gICAgICAgICAgICB4LmF4aXMudGlja1NpemUoLXBsb3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tYWluID0gZGF0YS5tYXAoeC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB5LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlLmNhbGwodGhpcy5jb25maWcsIGQpO1xuICAgICAgICB5LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi5zY2FsZSkucmFuZ2UoW3Bsb3QuaGVpZ2h0LCAwXSk7XG4gICAgICAgIHkubWFwID0gZCA9PiB5LnNjYWxlKHkudmFsdWUoZCkpO1xuXG4gICAgICAgIHkuYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHkuc2NhbGUpO1xuICAgICAgICBpZiAoY29uZi50aWNrcykge1xuICAgICAgICAgICAgeS5heGlzLnRpY2tzKGNvbmYudGlja3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGNvbmYuZ3VpZGVzKXtcbiAgICAgICAgICAgIHkuYXhpcy50aWNrU2l6ZSgtcGxvdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR1cFlEb21haW4oKTtcbiAgICB9O1xuXG4gICAgc2V0dXBZRG9tYWluKCkge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZGF0YTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB2YXIgdmFsdWVzID0gW10sIHlNaW4sIHlNYXg7XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgbGV0IHExID0gYy5RMShkKSwgXG4gICAgICAgICAgICAgICAgcTMgPSBjLlEzKGQpLCBcbiAgICAgICAgICAgICAgICB3bCA9IGMuV2woZCksIFxuICAgICAgICAgICAgICAgIHdoID0gYy5XaChkKSxcbiAgICAgICAgICAgICAgICBvdXRsaWVycyA9IGMub3V0bGllcnMoZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvdXRsaWVycykge1xuICAgICAgICAgICAgICAgIG91dGxpZXJzLmZvckVhY2goZnVuY3Rpb24gKG8sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goYy5vdXRsaWVyVmFsdWUobywgaSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdsKSB7IHZhbHVlcy5wdXNoKHdsKSB9XG4gICAgICAgICAgICBpZiAocTEpIHsgdmFsdWVzLnB1c2gocTEpIH1cbiAgICAgICAgICAgIGlmIChxMykgeyB2YWx1ZXMucHVzaChxMykgfVxuICAgICAgICAgICAgaWYgKHdoKSB7IHZhbHVlcy5wdXNoKHdoKSB9XG4gICAgICAgIH0pO1xuICAgICAgICB5TWluID0gZDMubWluKHZhbHVlcyk7XG4gICAgICAgIHlNYXggPSBkMy5tYXgodmFsdWVzKTtcbiAgICAgICAgdmFyIG1hcmdpbiA9ICh5TWF4LXlNaW4pKiB0aGlzLmNvbmZpZy55LmRvbWFpbk1hcmdpbjtcbiAgICAgICAgeU1pbi09bWFyZ2luO1xuICAgICAgICB5TWF4Kz1tYXJnaW47XG4gICAgICAgIHZhciBkb21haW4gPSBbIHlNaW4sIHlNYXggXSA7XG5cbiAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgIH1cblxuICAgIGRyYXdBeGlzWCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueDtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy14JykgKyBcIi5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSArIChheGlzQ29uZi5ndWlkZXMgPyAnJyA6ICcuJyArIHNlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKTtcblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueC5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIitzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIChwbG90LndpZHRoLzIpICtcIixcIisgKHBsb3QubWFyZ2luLmJvdHRvbSkgK1wiKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi0xZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi5sYWJlbCk7XG4gICAgfTtcblxuICAgIGRyYXdBeGlzWSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy15JykgKyBcIi5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSArIChheGlzQ29uZi5ndWlkZXMgPyAnJyA6ICcuJyArIHNlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSk7XG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnkuYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAtcGxvdC5tYXJnaW4ubGVmdCArIFwiLFwiICsgKHBsb3QuaGVpZ2h0IC8gMikgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgZHJhd0JveFBsb3RzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBwbG90ID0gc2VsZi5wbG90LFxuICAgICAgICAgICAgY29uZmlnID0gc2VsZi5jb25maWcsXG4gICAgICAgICAgICBib3hwbG90Q2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiYm94cGxvdC1pdGVtXCIpXG4gICAgICAgIFxuICAgICAgICB2YXIgYm94cGxvdHMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKCcuJytib3hwbG90Q2xhc3MpLmRhdGEocGxvdC5kYXRhKTtcbiAgICAgICAgdmFyIGJveHBsb3RFbnRlciA9IGJveHBsb3RzLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYm94cGxvdENsYXNzKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpO1xuXG4gICAgICAgIHZhciBib3hwbG90c01lcmdlID0gYm94cGxvdEVudGVyLm1lcmdlKGJveHBsb3RzKTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gMTAwMDtcbiAgICAgICAgdmFyIGJveHBsb3RzVCA9IGJveHBsb3RzTWVyZ2U7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGJveHBsb3RzVCA9IGJveHBsb3RzTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgYm94cGxvdHNULmRlbGF5KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSAqIGR1cmF0aW9uIC8gcGxvdC5kYXRhLmxlbmd0aCB9KVxuICAgICAgICB9XG5cbiAgICAgICAgYm94cGxvdHNUXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBwbG90LmNvbG9yKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDAuNzUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQsaSkgPT4ndHJhbnNsYXRlKCcgKyAocGxvdC54Lm1hcChkLGkpICsgcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC4wNSkgKyAnLCAwKScpXG4gICAgICAgIGJveHBsb3RzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgYm94V2lkdGggPSAhY29uZmlnLm1heEJveFdpZHRoID8gcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC45IDogTWF0aC5taW4oY29uZmlnLm1heEJveFdpZHRoLCBNYXRoLm1heChjb25maWcubWluQm94V2lkdGgsIHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuOSkpO1xuICAgICAgICB2YXIgYm94TGVmdCAgPSBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjQ1IC0gYm94V2lkdGgvMjtcbiAgICAgICAgdmFyIGJveFJpZ2h0ID0gcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC40NSArIGJveFdpZHRoLzI7XG5cbiAgICAgICAgdmFyIGJveENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImJveFwiKTtcblxuICAgICAgICBib3hwbG90RW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGJveENsYXNzKVxuICAgICAgICAgICAgLy8gdG9vbHRpcCBldmVudHNcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSAnUTM6ICcrY29uZmlnLlEzKGQsaSkrJzxici8+UTI6ICcrY29uZmlnLlEyKGQsaSkrJzxici8+UTE6ICcrY29uZmlnLlExKGQsaSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChodG1sKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGJveFJlY3RzID0gYm94cGxvdHNNZXJnZS5zZWxlY3QoJ3JlY3QuJytib3hDbGFzcyk7XG5cbiAgICAgICAgdmFyIGJveFJlY3RzVCA9IGJveFJlY3RzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYm94UmVjdHNUID0gYm94UmVjdHMudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYm94UmVjdHNULmF0dHIoJ3knLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoY29uZmlnLlEzKGQpKSlcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGJveFdpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBib3hMZWZ0IClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZCxpKSA9PiBNYXRoLmFicyhwbG90Lnkuc2NhbGUoY29uZmlnLlEzKGQpKSAtIHBsb3QueS5zY2FsZShjb25maWcuUTEoZCkpKSB8fCAxKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBwbG90LmNvbG9yKTtcblxuICAgICAgICAvLyBtZWRpYW4gbGluZVxuICAgICAgICB2YXIgbWVkaWFuQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKCdtZWRpYW4nKTtcbiAgICAgICAgYm94cGxvdEVudGVyLmFwcGVuZCgnbGluZScpLmF0dHIoJ2NsYXNzJywgbWVkaWFuQ2xhc3MpO1xuXG4gICAgICAgIHZhciBtZWRpYW5MaW5lID0gYm94cGxvdHNNZXJnZS5zZWxlY3QoJ2xpbmUuJyttZWRpYW5DbGFzcyk7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBtZWRpYW5MaW5lID0gbWVkaWFuTGluZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFuTGluZVxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgYm94TGVmdClcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIChkLGkpID0+IHBsb3QueS5zY2FsZShjb25maWcuUTIoZCkpKVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgYm94UmlnaHQpXG4gICAgICAgICAgICAuYXR0cigneTInLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoY29uZmlnLlEyKGQpKSk7XG5cblxuICAgICAgICAvL3doaXNrZXJzXG5cbiAgICAgICAgdmFyIHdoaXNrZXJDbGFzcz0gc2VsZi5wcmVmaXhDbGFzcyhcIndoaXNrZXJcIiksXG4gICAgICAgICAgICB0aWNrQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiYm94cGxvdC10aWNrXCIpO1xuXG4gICAgICAgIHZhciB3aGlza2VycyA9IFt7a2V5OiAnbG93JywgdmFsdWU6IGNvbmZpZy5XbH0sIHtrZXk6ICdoaWdoJywgdmFsdWU6IGNvbmZpZy5XaH1dO1xuXG4gICAgICAgIGJveHBsb3RFbnRlci5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgdmFyIGJveCA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgICAgICAgICAgd2hpc2tlcnMuZm9yRWFjaChmPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmLnZhbHVlKGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJveC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBwbG90LmNvbG9yKGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCB3aGlza2VyQ2xhc3MrJyAnICsgYm94cGxvdENsYXNzKyctJytmLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJveC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBwbG90LmNvbG9yKGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCB0aWNrQ2xhc3MrJyAnICsgYm94cGxvdENsYXNzKyctJytmLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaXNrZXJzLmZvckVhY2goZiA9PiB7XG4gICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSAoZi5rZXkgPT09ICdsb3cnKSA/IGNvbmZpZy5RMSA6IGNvbmZpZy5RMztcblxuICAgICAgICAgICAgdmFyIHdoaXNrZXIgPSBib3hwbG90c01lcmdlLnNlbGVjdCgnLicrd2hpc2tlckNsYXNzKycuJytib3hwbG90Q2xhc3MrJy0nK2Yua2V5KTtcbiAgICAgICAgICAgIHZhciB0aWNrID0gYm94cGxvdHNNZXJnZS5zZWxlY3QoJy4nK3RpY2tDbGFzcysnLicrYm94cGxvdENsYXNzKyctJytmLmtleSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHdoaXNrZXIgPSB3aGlza2VyLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aWNrPXRpY2sudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpc2tlclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuNDUgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIChkLGkpID0+IHBsb3QueS5zY2FsZShmLnZhbHVlKGQpKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjQ1IClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoZW5kcG9pbnQoZCkpKTtcblxuICAgICAgICAgICAgdGlja1xuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGJveExlZnQgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIChkLGkpID0+IHBsb3QueS5zY2FsZShmLnZhbHVlKGQpKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBib3hSaWdodCApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGYudmFsdWUoZCkpKTtcblxuICAgICAgICAgICAgYm94cGxvdEVudGVyLnNlbGVjdEFsbCgnLicrYm94cGxvdENsYXNzKyctJytmLmtleSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGYudmFsdWUoZCkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBvdXRsaWVyc1xuICAgICAgICB2YXIgb3V0bGllckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcIm91dGxpZXJcIik7XG4gICAgICAgIHZhciBvdXRsaWVycyA9IGJveHBsb3RzTWVyZ2Uuc2VsZWN0QWxsKCcuJytvdXRsaWVyQ2xhc3MpLmRhdGEoKGQsaSkgPT4gY29uZmlnLm91dGxpZXJzKGQsaSkgfHwgW10pO1xuXG4gICAgICAgIHZhciBvdXRsaWVyRW50ZXJDaXJjbGUgPSBvdXRsaWVycy5lbnRlcigpLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIG91dGxpZXJDbGFzcylcbiAgICAgICAgICAgIC5zdHlsZSgnei1pbmRleCcsIDkwMDApO1xuXG4gICAgICAgIG91dGxpZXJFbnRlckNpcmNsZVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSwgaikge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Rvb2x0aXAoY29uZmlnLm91dGxpZXJMYWJlbChkLGkpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZCwgaSwgaikge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb3V0bGllcnNNZXJnZSA9IG91dGxpZXJFbnRlckNpcmNsZS5tZXJnZShvdXRsaWVycyk7XG4gICAgICAgIHZhciBvdXRsaWVyc1QgPSBvdXRsaWVyc01lcmdlO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgb3V0bGllcnNUID0gb3V0bGllcnNNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0bGllcnNUXG4gICAgICAgICAgICAuYXR0cignY3gnLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjQ1KVxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGNvbmZpZy5vdXRsaWVyVmFsdWUoZCxpKSkpXG4gICAgICAgICAgICAuYXR0cigncicsICczJyk7XG4gICAgICAgIG91dGxpZXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIH1cblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWCgpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWSgpO1xuICAgICAgICB0aGlzLmRyYXdCb3hQbG90cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgc2V0dXBDb2xvcigpIHtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBpZihjb25mLmQzQ29sb3JDYXRlZ29yeSl7XG4gICAgICAgICAgICB2YXIgY29sb3JTY2hlbWVDYXRlZ29yeSA9ICdzY2hlbWUnK1V0aWxzLmNhcGl0YWxpemVGaXJzdExldHRlcihjb25mLmQzQ29sb3JDYXRlZ29yeSk7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSA9IGQzLnNjYWxlT3JkaW5hbChkM1tjb2xvclNjaGVtZUNhdGVnb3J5XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yVmFsdWUgPSBjb25mLmNvbG9yO1xuICAgICAgICBpZiAoY29sb3JWYWx1ZSAmJiB0eXBlb2YgY29sb3JWYWx1ZSA9PT0gJ3N0cmluZycgfHwgY29sb3JWYWx1ZSBpbnN0YW5jZW9mIFN0cmluZyl7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY29sb3IgPSBjb2xvclZhbHVlO1xuICAgICAgICB9ZWxzZSBpZih0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuY29sb3JWYWx1ZT1jb2xvclZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gZCA9PiAgc2VsZi5wbG90LmNvbG9yQ2F0ZWdvcnkodGhpcy5wbG90LngudmFsdWUoZCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHtCb3hQbG90QmFzZSwgQm94UGxvdEJhc2VDb25maWd9IGZyb20gXCIuL2JveC1wbG90LWJhc2VcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge1N0YXRpc3RpY3NVdGlsc30gZnJvbSAnLi9zdGF0aXN0aWNzLXV0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIEJveFBsb3RDb25maWcgZXh0ZW5kcyBCb3hQbG90QmFzZUNvbmZpZ3tcblxuICAgIHN2Z0NsYXNzID0gdGhpcy5jc3NDbGFzc1ByZWZpeCArICdib3gtcGxvdCc7XG4gICAgc2hvd0xlZ2VuZCA9IHRydWU7XG4gICAgc2hvd1Rvb2x0aXAgPSB0cnVlO1xuICAgIHkgPSB7Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRoaXMueS5rZXk9PT11bmRlZmluZWQgPyBkIDogZFt0aGlzLnkua2V5XX0gLCAvLyB5IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBvcmllbnQ6ICdsZWZ0JyxcbiAgICAgICAgZG9tYWluTWFyZ2luOiAwLjEsXG4gICAgICAgIGd1aWRlczogdHJ1ZSAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICB9O1xuICAgIHNlcmllcyA9IGZhbHNlO1xuICAgIGdyb3Vwcz17XG4gICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZCkgeyByZXR1cm4gdGhpcy5ncm91cHMua2V5PT09dW5kZWZpbmVkID8gJycgOiBkW3RoaXMuZ3JvdXBzLmtleV19ICAsIC8vIGdyb3VwaW5nIHZhbHVlIGFjY2Vzc29yLFxuICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgZGlzcGxheVZhbHVlOiB1bmRlZmluZWQgLy8gb3B0aW9uYWwgZnVuY3Rpb24gcmV0dXJuaW5nIGRpc3BsYXkgdmFsdWUgKHNlcmllcyBsYWJlbCkgZm9yIGdpdmVuIGdyb3VwIHZhbHVlLCBvciBvYmplY3QvYXJyYXkgbWFwcGluZyB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgfTtcbiAgICB0dWtleT0gZmFsc2U7XG4gICAgXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJveFBsb3QgZXh0ZW5kcyBCb3hQbG90QmFzZXtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEJveFBsb3RDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZyl7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IEJveFBsb3RDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgZ2V0RGF0YVRvUGxvdCgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb25mID0gc2VsZi5jb25maWc7XG4gICAgICAgIHNlbGYucGxvdC5ncm91cGluZ0VuYWJsZWQgPSB0aGlzLmlzR3JvdXBpbmdFbmFibGVkKCk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGlmKCFzZWxmLnBsb3QuZ3JvdXBpbmdFbmFibGVkICl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEgPSAgW3tcbiAgICAgICAgICAgICAgICBrZXk6ICcnLFxuICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBzZWxmLnBsb3QuZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmKHNlbGYuY29uZmlnLnNlcmllcyl7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gIGRhdGEubWFwKHM9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJue1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzLmxhYmVsIHx8IHMua2V5IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBzLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBWYWx1ZSA9IGQgPT4gY29uZi5ncm91cHMudmFsdWUuY2FsbChjb25mLCBkKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEgPSBkMy5uZXN0KCkua2V5KHRoaXMucGxvdC5ncm91cFZhbHVlKS5lbnRyaWVzKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldERpc3BsYXlWYWx1ZT0gayA9PiBrO1xuICAgICAgICAgICAgICAgIGlmKHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICBpZihVdGlscy5pc0Z1bmN0aW9uKHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldERpc3BsYXlWYWx1ZSA9IGs9PnNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUoaykgfHwgaztcbiAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoVXRpbHMuaXNPYmplY3Qoc2VsZi5jb25maWcuZ3JvdXBzLmRpc3BsYXlWYWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RGlzcGxheVZhbHVlID0gayA9PiBzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlW2tdIHx8IGs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhLmZvckVhY2goZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGcua2V5ID0gZ2V0RGlzcGxheVZhbHVlKGcua2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5wbG90LmRhdGFMZW5ndGggPSBkMy5zdW0odGhpcy5wbG90Lmdyb3VwZWREYXRhLCBzPT5zLnZhbHVlcy5sZW5ndGgpO1xuICAgICAgICB9XG5cblxuICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEuZm9yRWFjaChzPT57XG4gICAgICAgICAgICBpZighQXJyYXkuaXNBcnJheShzLnZhbHVlcykpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHMudmFsdWVzLm1hcChkPT5wYXJzZUZsb2F0KHNlbGYuY29uZmlnLnkudmFsdWUuY2FsbChzZWxmLmNvbmZpZywgZCkpKTtcbiAgICAgICAgICAgIHMudmFsdWVzLlExID0gU3RhdGlzdGljc1V0aWxzLnF1YW50aWxlKHZhbHVlcywgMC4yNSk7XG4gICAgICAgICAgICBzLnZhbHVlcy5RMiA9IFN0YXRpc3RpY3NVdGlscy5xdWFudGlsZSh2YWx1ZXMsIDAuNSk7XG4gICAgICAgICAgICBzLnZhbHVlcy5RMyA9IFN0YXRpc3RpY3NVdGlscy5xdWFudGlsZSh2YWx1ZXMsIDAuNzUpO1xuICAgICAgICAgICAgdmFyIElRUiA9ICBzLnZhbHVlcy5RMyAtIHMudmFsdWVzLlExO1xuXG4gICAgICAgICAgICBpZighc2VsZi5jb25maWcudHVrZXkpe1xuICAgICAgICAgICAgICAgIHMudmFsdWVzLndoaXNrZXJMb3cgPSBkMy5taW4odmFsdWVzKTtcbiAgICAgICAgICAgICAgICBzLnZhbHVlcy53aGlza2VySGlnaCA9IGQzLm1heCh2YWx1ZXMpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcy52YWx1ZXMud2hpc2tlckxvdyA9IHMudmFsdWVzLlExIC0gMS41KklRUjtcbiAgICAgICAgICAgICAgICBzLnZhbHVlcy53aGlza2VySGlnaCA9IHMudmFsdWVzLlEzICsgMS41KklRUjtcbiAgICAgICAgICAgICAgICBzLnZhbHVlcy5vdXRsaWVycyA9IHZhbHVlcy5maWx0ZXIoZD0+IGQ8cy52YWx1ZXMud2hpc2tlckxvdyB8fCBkPnMudmFsdWVzLndoaXNrZXJIaWdoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYucGxvdC5ncm91cGVkRGF0YTtcbiAgICB9XG5cbiAgICBpc0dyb3VwaW5nRW5hYmxlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2VyaWVzIHx8ICEhKHRoaXMuY29uZmlnLmdyb3VwcyAmJiB0aGlzLmNvbmZpZy5ncm91cHMudmFsdWUpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7TGVnZW5kfSBmcm9tIFwiLi9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBDaGFydFdpdGhDb2xvckdyb3Vwc0NvbmZpZyBleHRlbmRzIENoYXJ0Q29uZmlne1xuXG4gICAgc2hvd0xlZ2VuZD10cnVlO1xuICAgIGZvcmNlTGVnZW5kPWZhbHNlO1xuICAgIGxlZ2VuZD17XG4gICAgICAgIHdpZHRoOiA4MCxcbiAgICAgICAgbWFyZ2luOiAxMCxcbiAgICAgICAgc2hhcGVXaWR0aDogMjBcbiAgICB9O1xuICAgIGdyb3Vwcz17XG4gICAgICAgIGtleTogMixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbdGhpcy5ncm91cHMua2V5XX0gICwgLy8gZ3JvdXBpbmcgdmFsdWUgYWNjZXNzb3IsXG4gICAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgICBkaXNwbGF5VmFsdWU6IHVuZGVmaW5lZCAvLyBvcHRpb25hbCBmdW5jdGlvbiByZXR1cm5pbmcgZGlzcGxheSB2YWx1ZSAoc2VyaWVzIGxhYmVsKSBmb3IgZ2l2ZW4gZ3JvdXAgdmFsdWUsIG9yIG9iamVjdC9hcnJheSBtYXBwaW5nIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICB9O1xuICAgIHNlcmllcyA9IGZhbHNlO1xuICAgIGNvbG9yID0gIHVuZGVmaW5lZDsvLyBzdHJpbmcgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIGNvbG9yJ3MgdmFsdWUgZm9yIGNvbG9yIHNjYWxlXG4gICAgZDNDb2xvckNhdGVnb3J5PSAnY2F0ZWdvcnkxMCc7XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZihjdXN0b20pe1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDaGFydFdpdGhDb2xvckdyb3VwcyBleHRlbmRzIENoYXJ0e1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZyl7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGluaXRQbG90KCl7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG5cbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcbiAgICAgICBcbiAgICAgICAgdGhpcy5wbG90LnNob3dMZWdlbmQgPSBjb25mLnNob3dMZWdlbmQ7XG4gICAgICAgIHRoaXMuc2V0dXBHcm91cHMoKTtcbiAgICAgICAgdGhpcy5wbG90LmRhdGEgPSB0aGlzLmdldERhdGFUb1Bsb3QoKTtcbiAgICAgICAgdGhpcy5ncm91cERhdGEoKTtcblxuICAgICAgICBpZih0aGlzLnBsb3Quc2hvd0xlZ2VuZCl7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeTtcbiAgICAgICAgICAgIGlmKCFzY2FsZS5kb21haW4oKSB8fCAhdGhpcy5jb25maWcuZm9yY2VMZWdlbmQgJiYgc2NhbGUuZG9tYWluKCkubGVuZ3RoPDIpe1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5zaG93TGVnZW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QubWFyZ2luLnJpZ2h0ID0gY29uZi5tYXJnaW4ucmlnaHQgKyBjb25mLmxlZ2VuZC53aWR0aCtjb25mLmxlZ2VuZC5tYXJnaW4qMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpc0dyb3VwaW5nRW5hYmxlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2VyaWVzIHx8ICEhKHRoaXMuY29uZmlnLmdyb3VwcyAmJiB0aGlzLmNvbmZpZy5ncm91cHMudmFsdWUpO1xuICAgIH1cblxuICAgIGNvbXB1dGVHcm91cENvbG9yRG9tYWluKCl7XG4gICAgICAgIHZhciBtYXAgPSBkMy5zZXQodGhpcy5kYXRhLCBkID0+IHRoaXMucGxvdC5ncm91cFZhbHVlKGQpKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1hcCkubWFwKGQ9Pm1hcFtkXSk7XG4gICAgfVxuXG4gICAgc2V0dXBHcm91cHMoKSB7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdGhpcy5wbG90Lmdyb3VwaW5nRW5hYmxlZCA9IHRoaXMuaXNHcm91cGluZ0VuYWJsZWQoKTtcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xuICAgICAgICBpZih0aGlzLnBsb3QuZ3JvdXBpbmdFbmFibGVkKXtcbiAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cFRvTGFiZWwgPSB7fTtcbiAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLnNlcmllcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90Lmdyb3VwVmFsdWUgPSBzID0+IHMua2V5O1xuICAgICAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuY29tcHV0ZUdyb3VwQ29sb3JEb21haW4oKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKHM9PntcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwVG9MYWJlbFtzLmtleV0gPSBzLmxhYmVsfHxzLmtleTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90Lmdyb3VwVmFsdWUgPSBkID0+IGNvbmYuZ3JvdXBzLnZhbHVlLmNhbGwoY29uZiwgZCk7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gdGhpcy5jb21wdXRlR3JvdXBDb2xvckRvbWFpbigpO1xuICAgICAgICAgICAgICAgIHZhciBnZXRMYWJlbD0gayA9PiBrO1xuICAgICAgICAgICAgICAgIGlmKHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUpe1xuICAgICAgICAgICAgICAgICAgICBpZihVdGlscy5pc0Z1bmN0aW9uKHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExhYmVsID0gaz0+c2VsZi5jb25maWcuZ3JvdXBzLmRpc3BsYXlWYWx1ZShrKSB8fCBrO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZihVdGlscy5pc09iamVjdChzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMYWJlbCA9IGsgPT4gc2VsZi5jb25maWcuZ3JvdXBzLmRpc3BsYXlWYWx1ZVtrXSB8fCBrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbWFpbi5mb3JFYWNoKGs9PntcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwVG9MYWJlbFtrXSA9IGdldExhYmVsKGspO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLnBsb3QuZ3JvdXBWYWx1ZSA9IGQgPT4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsb3QuZ3JvdXBDb2xvckRvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgaWYoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpe1xuICAgICAgICAgICAgdmFyIGNvbG9yU2NoZW1lQ2F0ZWdvcnkgPSAnc2NoZW1lJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkgPSBkMy5zY2FsZU9yZGluYWwoZDNbY29sb3JTY2hlbWVDYXRlZ29yeV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvclZhbHVlID0gY29uZi5jb2xvcjtcblxuICAgICAgICBpZiAoY29sb3JWYWx1ZSl7XG4gICAgICAgICAgICBpZih0eXBlb2YgY29sb3JWYWx1ZSA9PT0gJ3N0cmluZycgfHwgY29sb3JWYWx1ZSBpbnN0YW5jZW9mIFN0cmluZyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gY29sb3JWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3Quc2VyaWVzQ29sb3IgPSB0aGlzLnBsb3QuY29sb3I7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY29sb3IgPSBjb2xvclZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5zZXJpZXNDb2xvciA9IHRoaXMucGxvdC5jb2xvcjtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBkb21haW4ubWFwKHY9PnRoaXMucGxvdC5zZXJpZXNDb2xvcih7a2V5OiB2fSkpO1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvckNhdGVnb3J5ID0gZDMuc2NhbGVPcmRpbmFsKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeS5kb21haW4oZG9tYWluKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1lbHNlIGlmKHRoaXMucGxvdC5jb2xvckNhdGVnb3J5KXtcbiAgICAgICAgICAgIHNlbGYucGxvdC5jb2xvclZhbHVlPWNvbG9yVmFsdWU7XG4gICAgICAgICAgICBzZWxmLnBsb3QuY29sb3JDYXRlZ29yeS5kb21haW4oZG9tYWluKTtcblxuICAgICAgICAgICAgdGhpcy5wbG90LnNlcmllc0NvbG9yID0gcyA9PiAgc2VsZi5wbG90LmNvbG9yQ2F0ZWdvcnkocy5rZXkpO1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gZCA9PiAgc2VsZi5wbG90LmNvbG9yQ2F0ZWdvcnkodGhpcy5wbG90Lmdyb3VwVmFsdWUoZCkpO1xuICAgICAgICAgICAgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gdGhpcy5wbG90LnNlcmllc0NvbG9yID0gcz0+ICdibGFjaydcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZ3JvdXBEYXRhKCl7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIGlmKCFzZWxmLnBsb3QuZ3JvdXBpbmdFbmFibGVkICl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEgPSAgW3tcbiAgICAgICAgICAgICAgICBrZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBzZWxmLnBsb3QuZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9ZWxzZXtcblxuICAgICAgICAgICAgaWYoc2VsZi5jb25maWcuc2VyaWVzKXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEgPSAgZGF0YS5tYXAocz0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm57XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHMua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHMubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHMudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cGVkRGF0YSA9IGQzLm5lc3QoKS5rZXkodGhpcy5wbG90Lmdyb3VwVmFsdWUpLmVudHJpZXMoZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhLmZvckVhY2goZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGcubGFiZWwgPSBzZWxmLnBsb3QuZ3JvdXBUb0xhYmVsW2cua2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5wbG90LmRhdGFMZW5ndGggPSBkMy5zdW0odGhpcy5wbG90Lmdyb3VwZWREYXRhLCBzPT5zLnZhbHVlcy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5wbG90LnNlcmllc0NvbG9yXG5cbiAgICB9XG5cbiAgICBnZXREYXRhVG9QbG90KCl7XG4gICAgICAgIGlmKCF0aGlzLnBsb3QuZ3JvdXBpbmdFbmFibGVkIHx8ICF0aGlzLmVuYWJsZWRHcm91cHMpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmZpbHRlcihkID0+IHRoaXMuZW5hYmxlZEdyb3Vwcy5pbmRleE9mKHRoaXMucGxvdC5ncm91cFZhbHVlKGQpKT4tMSk7XG4gICAgfVxuXG5cblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB1cGRhdGVMZWdlbmQoKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPXRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHBsb3QuY29sb3JDYXRlZ29yeTtcblxuICAgICAgICBpZighc2NhbGUuZG9tYWluKCkgfHwgIXRoaXMuY29uZmlnLmZvcmNlTGVnZW5kICYmIHNjYWxlLmRvbWFpbigpLmxlbmd0aDwyKXtcbiAgICAgICAgICAgIHBsb3Quc2hvd0xlZ2VuZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXBsb3Quc2hvd0xlZ2VuZCl7XG4gICAgICAgICAgICBpZihwbG90LmxlZ2VuZCAmJiBwbG90LmxlZ2VuZC5jb250YWluZXIpe1xuICAgICAgICAgICAgICAgIHBsb3QubGVnZW5kLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGxlZ2VuZFggPSB0aGlzLnBsb3Qud2lkdGggKyB0aGlzLmNvbmZpZy5sZWdlbmQubWFyZ2luO1xuICAgICAgICB2YXIgbGVnZW5kWSA9IHRoaXMuY29uZmlnLmxlZ2VuZC5tYXJnaW47XG5cbiAgICAgICAgcGxvdC5sZWdlbmQgPSBuZXcgTGVnZW5kKHRoaXMuc3ZnLCB0aGlzLnN2Z0csIHNjYWxlLCBsZWdlbmRYLCBsZWdlbmRZKTtcblxuICAgICAgICBwbG90LmxlZ2VuZENvbG9yID0gcGxvdC5sZWdlbmQuY29sb3IoKVxuICAgICAgICAgICAgLnNoYXBlV2lkdGgodGhpcy5jb25maWcubGVnZW5kLnNoYXBlV2lkdGgpXG4gICAgICAgICAgICAub3JpZW50KCd2ZXJ0aWNhbCcpXG4gICAgICAgICAgICAuc2NhbGUoc2NhbGUpXG4gICAgICAgICAgICAubGFiZWxXcmFwKHRoaXMuY29uZmlnLmxlZ2VuZC53aWR0aClcbiAgICAgICAgICAgIC5sYWJlbHMoc2NhbGUuZG9tYWluKCkubWFwKHY9PnBsb3QuZ3JvdXBUb0xhYmVsW3ZdKSk7XG5cblxuICAgICAgICBwbG90LmxlZ2VuZENvbG9yLm9uKCdjZWxsY2xpY2snLCBjPT4gc2VsZi5vbkxlZ2VuZENlbGxDbGljayhjKSk7XG4gICAgICAgIFxuICAgICAgICBwbG90LmxlZ2VuZC5jb250YWluZXJcbiAgICAgICAgICAgIC5jYWxsKHBsb3QubGVnZW5kQ29sb3IpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kQ2VsbFN0YXR1c2VzKCk7XG4gICAgfVxuXG4gICAgb25MZWdlbmRDZWxsQ2xpY2soY2VsbFZhbHVlKXtcbiAgICAgICAgdGhpcy51cGRhdGVFbmFibGVkR3JvdXBzKGNlbGxWYWx1ZSk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICB1cGRhdGVMZWdlbmRDZWxsU3RhdHVzZXMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5wbG90LmxlZ2VuZC5jb250YWluZXIuc2VsZWN0QWxsKFwiZy5jZWxsXCIpLmVhY2goZnVuY3Rpb24oY2VsbCl7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHNlbGYuZW5hYmxlZEdyb3VwcyAmJiBzZWxmLmVuYWJsZWRHcm91cHMuaW5kZXhPZihjZWxsKTwwO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoXCJvZGMtZGlzYWJsZWRcIiwgaXNEaXNhYmxlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZUVuYWJsZWRHcm91cHMoY2VsbFZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkR3JvdXBzKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWRHcm91cHMgPSB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeS5kb21haW4oKS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZW5hYmxlZEdyb3Vwcy5pbmRleE9mKGNlbGxWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkR3JvdXBzLnB1c2goY2VsbFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZEdyb3Vwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRHcm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWRHcm91cHMgPSB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeS5kb21haW4oKS5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBzZXREYXRhKGRhdGEpe1xuICAgICAgICBzdXBlci5zZXREYXRhKGRhdGEpO1xuICAgICAgICB0aGlzLmVuYWJsZWRHcm91cHMgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCJpbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIENoYXJ0Q29uZmlnIHtcbiAgICBjc3NDbGFzc1ByZWZpeCA9IFwib2RjLVwiO1xuICAgIHN2Z0NsYXNzID0gdGhpcy5jc3NDbGFzc1ByZWZpeCArICdtdy1kMy1jaGFydCc7XG4gICAgd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIG1hcmdpbiA9IHtcbiAgICAgICAgbGVmdDogNTAsXG4gICAgICAgIHJpZ2h0OiAzMCxcbiAgICAgICAgdG9wOiAzMCxcbiAgICAgICAgYm90dG9tOiA1MFxuICAgIH07XG4gICAgc2hvd1Rvb2x0aXAgPSBmYWxzZTtcbiAgICB0cmFuc2l0aW9uID0gdHJ1ZTtcblxuICAgIHRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRpdGxlU2l6ZT0yMDtcbiAgICB0aXRsZU1hcmdpbj17XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0b3A6IDE1LFxuICAgICAgICBib3R0b206IDIwXG4gICAgfTtcblxuICAgIHN1YnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHN1YnRpdGxlU2l6ZT0xNDtcbiAgICBzdWJ0aXRsZU1hcmdpbj17XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0b3A6IDEwLFxuICAgICAgICBib3R0b206IDIwXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSkge1xuICAgICAgICBpZiAoY3VzdG9tKSB7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5leHBvcnQgY2xhc3MgQ2hhcnQge1xuICAgIHV0aWxzID0gVXRpbHM7XG4gICAgYmFzZUNvbnRhaW5lcjtcbiAgICBzdmc7XG4gICAgY29uZmlnO1xuICAgIHBsb3QgPSB7XG4gICAgICAgIG1hcmdpbjoge31cbiAgICB9O1xuICAgIF9hdHRhY2hlZCA9IHt9O1xuICAgIF9sYXllcnMgPSB7fTtcbiAgICBfZXZlbnRzID0ge307XG4gICAgX2lzQXR0YWNoZWQ7XG4gICAgX2lzSW5pdGlhbGl6ZWQ9ZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKGJhc2UsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9pZCA9IFV0aWxzLmd1aWQoKTtcbiAgICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IGJhc2UgaW5zdGFuY2VvZiBDaGFydDtcblxuICAgICAgICB0aGlzLmJhc2VDb250YWluZXIgPSBiYXNlO1xuXG4gICAgICAgIHRoaXMuc2V0Q29uZmlnKGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5wb3N0SW5pdCgpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gbmV3IENoYXJ0Q29uZmlnKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRDb25maWdBY2Nlc3NvcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5pbml0UGxvdCgpO1xuICAgICAgICBzZWxmLmluaXRTdmcoKTtcblxuICAgICAgICBpZighdGhpcy5faXNJbml0aWFsaXplZCl7XG4gICAgICAgICAgICBzZWxmLmluaXRUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5kcmF3KCk7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQ9dHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVkcmF3KCl7XG4gICAgICAgIHRoaXMuaW5pdENvbmZpZ0FjY2Vzc29ycyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIHBvc3RJbml0KCl7XG5cbiAgICB9XG5cbiAgICBpbml0U3ZnKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB2YXIgbWFyZ2luID0gc2VsZi5wbG90Lm1hcmdpbjtcbiAgICAgICAgdmFyIHdpZHRoID0gc2VsZi5zdmdXaWR0aCA9IHNlbGYucGxvdC53aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gc2VsZi5zdmdIZWlnaHQgPSAgc2VsZi5wbG90LmhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tO1xuICAgICAgICB2YXIgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGlmKCFzZWxmLl9pc0F0dGFjaGVkKXtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9pc0luaXRpYWxpemVkKXtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZi5iYXNlQ29udGFpbmVyKS5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnN2ZyA9IGQzLnNlbGVjdChzZWxmLmJhc2VDb250YWluZXIpLnNlbGVjdE9yQXBwZW5kKFwic3ZnXCIpLmNsYXNzZWQoY29uZmlnLnN2Z0NsYXNzLCB0cnVlKTtcblxuICAgICAgICAgICAgc2VsZi5zdmdcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgICAgICAgICAuYXR0cihcInZpZXdCb3hcIiwgXCIwIDAgXCIgKyBcIiBcIiArIHdpZHRoICsgXCIgXCIgKyBoZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwieE1pZFlNaWQgbWVldFwiKVxuICAgICAgICAgICAgc2VsZi5zdmdHID0gc2VsZi5zdmcuc2VsZWN0T3JBcHBlbmQoXCJnLm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc2VsZi5iYXNlQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHNlbGYuc3ZnID0gc2VsZi5iYXNlQ29udGFpbmVyLnN2ZztcbiAgICAgICAgICAgIHNlbGYuc3ZnRyA9IHNlbGYuc3ZnLnNlbGVjdE9yQXBwZW5kKFwiZy5tYWluLWdyb3VwLlwiK2NvbmZpZy5zdmdDbGFzcylcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3ZnRy5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgaWYgKCFjb25maWcud2lkdGggfHwgY29uZmlnLmhlaWdodCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHdpbmRvdylcbiAgICAgICAgICAgICAgICAub24oXCJyZXNpemUuXCIrc2VsZi5faWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBzZWxmLmNvbmZpZy50cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy50cmFuc2l0aW9uPWZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCl7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLmJhc2VDb250YWluZXIpLnNlbGVjdEFsbChcIipcIikucmVtb3ZlKCk7XG4gICAgICAgIGQzLnNlbGVjdCh3aW5kb3cpLm9uKFwicmVzaXplLlwiICsgdGhpcy5faWQsIG51bGwpO1xuICAgIH1cblxuICAgIGluaXRUb29sdGlwKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dUb29sdGlwKSB7XG4gICAgICAgICAgICBpZighc2VsZi5faXNBdHRhY2hlZCApe1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC50b29sdGlwID0gZDMuc2VsZWN0KFwiYm9keVwiKS5zZWxlY3RPckFwcGVuZCgnZGl2Licrc2VsZi5jb25maWcuY3NzQ2xhc3NQcmVmaXgrJ3Rvb2x0aXAnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90LnRvb2x0aXA9IHNlbGYuYmFzZUNvbnRhaW5lci5wbG90LnRvb2x0aXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBzZWxmLnBsb3QudG9vbHRpcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0UGxvdCgpIHtcbiAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMuY29uZmlnLm1hcmdpbjtcbiAgICAgICAgdGhpcy5wbG90ID0gdGhpcy5wbG90IHx8IHt9O1xuICAgICAgICB0aGlzLnBsb3QubWFyZ2luID0ge1xuICAgICAgICAgICAgdG9wOiBtYXJnaW4udG9wLFxuICAgICAgICAgICAgYm90dG9tOiBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgICAgbGVmdDogbWFyZ2luLmxlZnQsXG4gICAgICAgICAgICByaWdodDogbWFyZ2luLnJpZ2h0XG4gICAgICAgIH07XG5cblxuICAgICAgICB2YXIgdGl0bGVNYXJnaW5TaXplID0gMDtcbiAgICAgICAgaWYodGhpcy5jb25maWcudGl0bGUpe1xuICAgICAgICAgICAgdGl0bGVNYXJnaW5TaXplPSB0aGlzLmNvbmZpZy50aXRsZVNpemUrdGhpcy5jb25maWcudGl0bGVNYXJnaW4udG9wO1xuICAgICAgICAgICAgaWYoIXRoaXMuY29uZmlnLnN1YnRpdGxlKXtcbiAgICAgICAgICAgICAgICB0aXRsZU1hcmdpblNpemUgKz0gdGhpcy5jb25maWcudGl0bGVNYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBsb3QubWFyZ2luLnRvcD1NYXRoLm1heCh0aGlzLnBsb3QubWFyZ2luLnRvcCx0aXRsZU1hcmdpblNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5jb25maWcuc3VidGl0bGUpe1xuXG4gICAgICAgICAgICB0aGlzLnBsb3QubWFyZ2luLnRvcD1NYXRoLm1heCh0aGlzLnBsb3QubWFyZ2luLnRvcCwgdGl0bGVNYXJnaW5TaXplK3RoaXMuY29uZmlnLnN1YnRpdGxlTWFyZ2luLnRvcCt0aGlzLmNvbmZpZy5zdWJ0aXRsZVNpemUrdGhpcy5jb25maWcuc3VidGl0bGVNYXJnaW4uYm90dG9tKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRpdGxlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3VidGl0bGUoKTtcblxuICAgICAgICB2YXIgbGF5ZXJOYW1lLCBhdHRhY2htZW50RGF0YTtcbiAgICAgICAgZm9yICh2YXIgYXR0YWNobWVudE5hbWUgaW4gdGhpcy5fYXR0YWNoZWQpIHtcblxuICAgICAgICAgICAgYXR0YWNobWVudERhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFthdHRhY2htZW50TmFtZV0udXBkYXRlKGF0dGFjaG1lbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGVUaXRsZSgpIHtcbiAgICAgICAgdmFyIHRpdGxlQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKCdwbG90LXRpdGxlJyk7XG4gICAgICAgIGlmKCF0aGlzLmNvbmZpZy50aXRsZSl7XG4gICAgICAgICAgICB0aGlzLnN2Zy5zZWxlY3QoXCJ0ZXh0LlwiK3RpdGxlQ2xhc3MpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdmcuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiK3RpdGxlQ2xhc3MpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgKHRoaXMuc3ZnV2lkdGgvMikgK1wiLFwiKyAodGhpcy5jb25maWcudGl0bGVNYXJnaW4udG9wKSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMC41ZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImNlbnRyYWxcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCB0aGlzLmNvbmZpZy50aXRsZVNpemUrXCJweFwiKVxuICAgICAgICAgICAgLnRleHQodGhpcy5jb25maWcudGl0bGUpO1xuICAgIH1cblxuICAgIHVwZGF0ZVN1YnRpdGxlKCkge1xuICAgICAgICB2YXIgc3VidGl0bGVDbGFzcyA9IHRoaXMucHJlZml4Q2xhc3MoJ3Bsb3Qtc3VidGl0bGUnKTtcbiAgICAgICAgaWYoIXRoaXMuY29uZmlnLnN1YnRpdGxlKXtcbiAgICAgICAgICAgIHRoaXMuc3ZnLnNlbGVjdChcInRleHQuXCIrc3VidGl0bGVDbGFzcykucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeSA9IHRoaXMuY29uZmlnLnN1YnRpdGxlTWFyZ2luLnRvcDtcbiAgICAgICAgaWYodGhpcy5jb25maWcudGl0bGUpe1xuICAgICAgICAgICAgeSs9dGhpcy5jb25maWcudGl0bGVNYXJnaW4udG9wK3RoaXMuY29uZmlnLnRpdGxlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIitzdWJ0aXRsZUNsYXNzKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrICh0aGlzLnN2Z1dpZHRoLzIpICtcIixcIisgKHkpICtcIilcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIwLjVlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRvbWluYW50LWJhc2VsaW5lXCIsIFwiY2VudHJhbFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIHRoaXMuY29uZmlnLnN1YnRpdGxlU2l6ZStcInB4XCIpXG4gICAgICAgICAgICAudGV4dCh0aGlzLmNvbmZpZy5zdWJ0aXRsZSk7XG4gICAgfVxuXG4gICAgZHJhdyhkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKGRhdGEpO1xuXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBvciByZXRyaWV2ZSBhbiBcImF0dGFjaG1lbnRcIiBDaGFydC4gVGhlIFwiYXR0YWNobWVudFwiIGNoYXJ0J3MgYGRyYXdgXG4gICAgICogbWV0aG9kIHdpbGwgYmUgaW52b2tlZCB3aGVuZXZlciB0aGUgY29udGFpbmluZyBjaGFydCdzIGBkcmF3YCBtZXRob2QgaXNcbiAgICAgKiBpbnZva2VkLlxuICAgICAqXG4gICAgICogQGV4dGVybmFsRXhhbXBsZSBjaGFydC1hdHRhY2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRhY2htZW50TmFtZSBOYW1lIG9mIHRoZSBhdHRhY2htZW50XG4gICAgICogQHBhcmFtIHtDaGFydH0gW2NoYXJ0XSBDaGFydCB0byByZWdpc3RlciBhcyBhIG1peCBpbiBvZiB0aGlzIGNoYXJ0LiBXaGVuXG4gICAgICogICAgICAgIHVuc3BlY2lmaWVkLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgYXR0YWNobWVudCBwcmV2aW91c2x5XG4gICAgICogICAgICAgIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGBhdHRhY2htZW50TmFtZWAgKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2hhcnR9IFJlZmVyZW5jZSB0byB0aGlzIGNoYXJ0IChjaGFpbmFibGUpLlxuICAgICAqL1xuICAgIGF0dGFjaChhdHRhY2htZW50TmFtZSwgY2hhcnQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hlZFthdHRhY2htZW50TmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hdHRhY2hlZFthdHRhY2htZW50TmFtZV0gPSBjaGFydDtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBcblxuICAgIC8vQm9ycm93ZWQgZnJvbSBkMy5jaGFydFxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFuIGV2ZW50IHRyaWdnZXJlZCBvbiB0aGUgY2hhcnQuIFNlZSB7QGxpbmtcbiAgICAgICAgKiBDaGFydCNvbmNlfSB0byBzdWJzY3JpYmUgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhbiBldmVudCBmb3Igb25lIG9jY3VyZW5jZS5cbiAgICAgKlxuICAgICAqIEBleHRlcm5hbEV4YW1wbGUge3J1bm5hYmxlfSBjaGFydC1vblxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnRIYW5kbGVyfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50XG4gICAgICogICAgICAgIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gVmFsdWUgdG8gc2V0IGFzIGB0aGlzYCB3aGVuIGludm9raW5nIHRoZVxuICAgICAqICAgICAgICBgY2FsbGJhY2tgLiBEZWZhdWx0cyB0byB0aGUgY2hhcnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2hhcnR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY2hhcnQgKGNoYWluYWJsZSkuXG4gICAgICovXG4gICAgb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0IHx8IHRoaXMsXG4gICAgICAgICAgICBfY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vQm9ycm93ZWQgZnJvbSBkMy5jaGFydFxuICAgIC8qKlxuICAgICAqXG4gICAgICogU3Vic2NyaWJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIHRoZSBjaGFydC4gVGhpc1xuICAgICAqIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhdCB0aGUgbmV4dCBvY2N1cmFuY2Ugb2YgdGhlIGV2ZW50IGFuZCBpbW1lZGlhdGVseVxuICAgICAqIHVuc3Vic2NyaWJlZC4gU2VlIHtAbGluayBDaGFydCNvbn0gdG8gc3Vic2NyaWJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYW5cbiAgICAgKiBldmVudCBpbmRlZmluaXRlbHkuXG4gICAgICpcbiAgICAgKiBAZXh0ZXJuYWxFeGFtcGxlIHtydW5uYWJsZX0gY2hhcnQtb25jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnRIYW5kbGVyfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50XG4gICAgICogICAgICAgIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gVmFsdWUgdG8gc2V0IGFzIGB0aGlzYCB3aGVuIGludm9raW5nIHRoZVxuICAgICAqICAgICAgICBgY2FsbGJhY2tgLiBEZWZhdWx0cyB0byB0aGUgY2hhcnQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDaGFydH0gQSByZWZlcmVuY2UgdG8gdGhpcyBjaGFydCAoY2hhaW5hYmxlKVxuICAgICAqL1xuICAgIG9uY2UobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfVxuXG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSBvbmUgb3IgbW9yZSBjYWxsYmFjayBmdW5jdGlvbnMgZnJvbSBhbiBldmVudCB0cmlnZ2VyZWQgb24gdGhlXG4gICAgICogY2hhcnQuIFdoZW4gbm8gYXJndW1lbnRzIGFyZSBzcGVjaWZpZWQsICphbGwqIGhhbmRsZXJzIHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxuICAgICAqIFdoZW4gb25seSBhIGBuYW1lYCBpcyBzcGVjaWZpZWQsIGFsbCBoYW5kbGVycyBzdWJzY3JpYmVkIHRvIHRoYXQgZXZlbnQgd2lsbFxuICAgICAqIGJlIHVuc3Vic2NyaWJlZC4gV2hlbiBhIGBuYW1lYCBhbmQgYGNhbGxiYWNrYCBhcmUgc3BlY2lmaWVkLCBvbmx5IHRoYXRcbiAgICAgKiBmdW5jdGlvbiB3aWxsIGJlIHVuc3Vic2NyaWJlZCBmcm9tIHRoYXQgZXZlbnQuIFdoZW4gYSBgbmFtZWAgYW5kIGBjb250ZXh0YFxuICAgICAqIGFyZSBzcGVjaWZpZWQgKGJ1dCBgY2FsbGJhY2tgIGlzIG9taXR0ZWQpLCBhbGwgZXZlbnRzIGJvdW5kIHRvIHRoZSBnaXZlblxuICAgICAqIGV2ZW50IHdpdGggdGhlIGdpdmVuIGNvbnRleHQgd2lsbCBiZSB1bnN1YnNjcmliZWQuXG4gICAgICpcbiAgICAgKiBAZXh0ZXJuYWxFeGFtcGxlIHtydW5uYWJsZX0gY2hhcnQtb2ZmXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIHVuc3Vic2NyaWJlZFxuICAgICAqIEBwYXJhbSB7Q2hhcnRFdmVudEhhbmRsZXJ9IFtjYWxsYmFja10gRnVuY3Rpb24gdG8gYmUgdW5zdWJzY3JpYmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0cyB0byBiZSB1bnN1YnNjcmliZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0NoYXJ0fSBBIHJlZmVyZW5jZSB0byB0aGlzIGNoYXJ0IChjaGFpbmFibGUpLlxuICAgICAqL1xuXG4gICAgb2ZmKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBuYW1lcywgbiwgZXZlbnRzLCBldmVudCwgaSwgajtcblxuICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50c1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBuYW1lXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggd2hhdGV2ZXIgY29tYmluYXRpb24gb2YgbmFtZSwgY29udGV4dFxuICAgICAgICAvLyBhbmQgY2FsbGJhY2suXG4gICAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50cyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbiA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25dO1xuICAgICAgICAgICAgaiA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbal07XG4gICAgICAgICAgICAgICAgaWYgKChjYWxsYmFjayAmJiBjYWxsYmFjayA9PT0gZXZlbnQuY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAgIChjb250ZXh0ICYmIGNvbnRleHQgPT09IGV2ZW50LmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vQm9ycm93ZWQgZnJvbSBkMy5jaGFydFxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYW4gZXZlbnQgb24gdGhpcyBjaGFydCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gICAgICpcbiAgICAgKiBAZXh0ZXJuYWxFeGFtcGxlIHtydW5uYWJsZX0gY2hhcnQtdHJpZ2dlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcHVibGlzaFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzIFZhbHVlcyB3aXRoIHdoaWNoIHRvIGludm9rZSB0aGUgcmVnaXN0ZXJlZFxuICAgICAqICAgICAgICBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2hhcnR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY2hhcnQgKGNoYWluYWJsZSkuXG4gICAgICovXG4gICAgdHJpZ2dlcihuYW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXTtcbiAgICAgICAgdmFyIGksIGV2O1xuXG4gICAgICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV2ID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgIGV2LmNhbGxiYWNrLmFwcGx5KGV2LmNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBnZXRCYXNlQ29udGFpbmVyKCl7XG4gICAgICAgIGlmKHRoaXMuX2lzQXR0YWNoZWQpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNvbnRhaW5lci5zdmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQzLnNlbGVjdCh0aGlzLmJhc2VDb250YWluZXIpO1xuICAgIH1cblxuICAgIGdldEJhc2VDb250YWluZXJOb2RlKCl7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzZUNvbnRhaW5lcigpLm5vZGUoKTtcbiAgICB9XG5cbiAgICBwcmVmaXhDbGFzcyhjbGF6eiwgYWRkRG90KXtcbiAgICAgICAgcmV0dXJuIGFkZERvdD8gJy4nOiAnJyt0aGlzLmNvbmZpZy5jc3NDbGFzc1ByZWZpeCtjbGF6ejtcbiAgICB9XG4gICAgY29tcHV0ZVBsb3RTaXplKCkge1xuICAgICAgICB0aGlzLnBsb3Qud2lkdGggPSBVdGlscy5hdmFpbGFibGVXaWR0aCh0aGlzLmNvbmZpZy53aWR0aCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIHRoaXMucGxvdC5tYXJnaW4pO1xuICAgICAgICB0aGlzLnBsb3QuaGVpZ2h0ID0gVXRpbHMuYXZhaWxhYmxlSGVpZ2h0KHRoaXMuY29uZmlnLmhlaWdodCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIHRoaXMucGxvdC5tYXJnaW4pO1xuICAgIH1cblxuICAgIHRyYW5zaXRpb25FbmFibGVkKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkICYmIHRoaXMuY29uZmlnLnRyYW5zaXRpb247XG4gICAgfVxuXG4gICAgc2hvd1Rvb2x0aXAoaHRtbCl7XG4gICAgICAgIGlmKCF0aGlzLnBsb3QudG9vbHRpcCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbG90LnRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMjAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAuOSk7XG4gICAgICAgIHRoaXMucGxvdC50b29sdGlwLmh0bWwoaHRtbClcbiAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgKGQzLmV2ZW50LnBhZ2VYICsgNSkgKyBcInB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgKGQzLmV2ZW50LnBhZ2VZIC0gMjgpICsgXCJweFwiKTtcbiAgICB9XG5cbiAgICBoaWRlVG9vbHRpcCgpe1xuICAgICAgICBpZighdGhpcy5wbG90LnRvb2x0aXApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxvdC50b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgfVxuXG4gICAgaW5pdENvbmZpZ0FjY2Vzc29ycyhjbGVhbikge1xuICAgICAgICBpZihjbGVhbil7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVByb3BlcnR5QWNjZXNzb3JzKHRoaXMsdGhpcywgdGhpcy5jb25maWcsIFwiJFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRQcm9wZXJ0eUFjY2Vzc29ycyh0aGlzLHRoaXMsIHRoaXMuY29uZmlnLCBcIiRcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlUHJvcGVydHlBY2Nlc3NvcnMoYmluZFRvLHJldHVybk9iaiwgc291cmNlLCBwcmVmaXgpIHtcbiAgICAgICAgdmFyIHNlbGYgID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmKCFzb3VyY2UuaGFzT3duUHJvcGVydHkoaSkpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYmluZFRvW3ByZWZpeCArIGldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFByb3BlcnR5QWNjZXNzb3JzKGJpbmRUbyxyZXR1cm5PYmosIHNvdXJjZSwgcHJlZml4LCByZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIHNlbGYgID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmKCFzb3VyY2UuaGFzT3duUHJvcGVydHkoaSkpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWNjZXNzb3IgPSBzZWxmLmluaXRQcm9wZXJ0eUFjY2Vzc29yKGJpbmRUbyxyZXR1cm5PYmosIHNvdXJjZSwgaSwgcHJlZml4KTtcblxuICAgICAgICAgICAgaWYocmVjdXJzaXZlICYmIFV0aWxzLmlzT2JqZWN0Tm90QXJyYXkoc291cmNlW2ldKSl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0UHJvcGVydHlBY2Nlc3NvcnMoYWNjZXNzb3IsIGJpbmRUbywgc291cmNlW2ldLCBwcmVmaXgsIHJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRQcm9wZXJ0eUFjY2Vzc29yKGJpbmRUbywgcmV0dXJuT2JqLCBzb3VyY2UsIHByb3BlcnR5S2V5LCBwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRUb1twcmVmaXggKyBwcm9wZXJ0eUtleV0gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVtwcm9wZXJ0eUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHlLZXldID0gXztcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbn1cbiIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7U3RhdGlzdGljc1V0aWxzfSBmcm9tICcuL3N0YXRpc3RpY3MtdXRpbHMnXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSAnLi9sZWdlbmQnXG5pbXBvcnQge1NjYXR0ZXJQbG90fSBmcm9tICcuL3NjYXR0ZXJwbG90J1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIENvcnJlbGF0aW9uTWF0cml4Q29uZmlnIGV4dGVuZHMgQ2hhcnRDb25maWcge1xuXG4gICAgc3ZnQ2xhc3MgPSB0aGlzLmNzc0NsYXNzUHJlZml4Kydjb3JyZWxhdGlvbi1tYXRyaXgnO1xuICAgIGd1aWRlcyA9IGZhbHNlOyAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICBzaG93VG9vbHRpcCA9IHRydWU7IC8vc2hvdyB0b29sdGlwIG9uIGRvdCBob3ZlclxuICAgIHNob3dMZWdlbmQgPSB0cnVlO1xuICAgIGhpZ2hsaWdodExhYmVscyA9IHRydWU7XG4gICAgcm90YXRlTGFiZWxzWCA9IHRydWU7XG4gICAgcm90YXRlTGFiZWxzWSA9IHRydWU7XG4gICAgdmFyaWFibGVzID0ge1xuICAgICAgICBsYWJlbHM6IHVuZGVmaW5lZCxcbiAgICAgICAga2V5czogW10sIC8vb3B0aW9uYWwgYXJyYXkgb2YgdmFyaWFibGUga2V5c1xuICAgICAgICB2YWx1ZTogKGQsIHZhcmlhYmxlS2V5KSA9PiBwYXJzZUZsb2F0KGRbdmFyaWFibGVLZXldKSwgLy8gdmFyaWFibGUgdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgc2NhbGU6IFwib3JkaW5hbFwiXG4gICAgfTtcbiAgICBjb3JyZWxhdGlvbiA9IHtcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIGRvbWFpbjogWy0xLCAtMC43NSwgLTAuNSwgMCwgMC41LCAwLjc1LCAxXSxcbiAgICAgICAgcmFuZ2U6IFtcImRhcmtibHVlXCIsIFwiYmx1ZVwiLCBcImxpZ2h0c2t5Ymx1ZVwiLCBcIndoaXRlXCIsIFwib3JhbmdlcmVkXCIsIFwiY3JpbXNvblwiLCBcImRhcmtyZWRcIl0sXG4gICAgICAgIHZhbHVlOiAoeFZhbHVlcywgeVZhbHVlcykgPT4gU3RhdGlzdGljc1V0aWxzLnNhbXBsZUNvcnJlbGF0aW9uKHhWYWx1ZXMsIHlWYWx1ZXMpXG5cbiAgICB9O1xuICAgIGNlbGwgPSB7XG4gICAgICAgIHNoYXBlOiBcImVsbGlwc2VcIiwgLy9wb3NzaWJsZSB2YWx1ZXM6IHJlY3QsIGNpcmNsZSwgZWxsaXBzZVxuICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgIHNpemVNaW46IDE1LFxuICAgICAgICBzaXplTWF4OiAyNTAsXG4gICAgICAgIHBhZGRpbmc6IDFcbiAgICB9O1xuICAgIG1hcmdpbiA9IHtcbiAgICAgICAgbGVmdDogNjAsXG4gICAgICAgIHJpZ2h0OiA1MCxcbiAgICAgICAgdG9wOiAzMCxcbiAgICAgICAgYm90dG9tOiA2MFxuICAgIH07XG4gICAgZ3JvdXBzPXtcbiAgICAgICAga2V5OiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29ycmVsYXRpb25NYXRyaXggZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBDb3JyZWxhdGlvbk1hdHJpeENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IENvcnJlbGF0aW9uTWF0cml4Q29uZmlnKGNvbmZpZykpO1xuXG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMuY29uZmlnLm1hcmdpbjtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB0aGlzLnBsb3QueCA9IHt9O1xuICAgICAgICB0aGlzLnBsb3QuY29ycmVsYXRpb24gPSB7XG4gICAgICAgICAgICBtYXRyaXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlbGxzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2xvcjoge30sXG4gICAgICAgICAgICBzaGFwZToge31cbiAgICAgICAgfTtcblxuXG4gICAgICAgIHRoaXMuc2V0dXBWYXJpYWJsZXMoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gY29uZi53aWR0aDtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyTm9kZSA9IHRoaXMuZ2V0QmFzZUNvbnRhaW5lck5vZGUoKTtcbiAgICAgICAgdGhpcy5wbG90LnBsYWNlaG9sZGVyTm9kZSA9IHBsYWNlaG9sZGVyTm9kZTtcblxuICAgICAgICB2YXIgcGFyZW50V2lkdGggPSBwbGFjZWhvbGRlck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGlmICh3aWR0aCkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucGxvdC5jZWxsU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5jZWxsU2l6ZSA9IE1hdGgubWF4KGNvbmYuY2VsbC5zaXplTWluLCBNYXRoLm1pbihjb25mLmNlbGwuc2l6ZU1heCwgKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpIC8gdGhpcy5wbG90LnZhcmlhYmxlcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxTaXplID0gdGhpcy5jb25maWcuY2VsbC5zaXplO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucGxvdC5jZWxsU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5jZWxsU2l6ZSA9IE1hdGgubWF4KGNvbmYuY2VsbC5zaXplTWluLCBNYXRoLm1pbihjb25mLmNlbGwuc2l6ZU1heCwgKHBhcmVudFdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpIC8gdGhpcy5wbG90LnZhcmlhYmxlcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLnBsb3QuY2VsbFNpemUgKiB0aGlzLnBsb3QudmFyaWFibGVzLmxlbmd0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwbGFjZWhvbGRlck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbG90LndpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgdGhpcy5wbG90LmhlaWdodCA9IHRoaXMucGxvdC53aWR0aDtcblxuICAgICAgICB0aGlzLnNldHVwVmFyaWFibGVzU2NhbGVzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBDb3JyZWxhdGlvblNjYWxlcygpO1xuICAgICAgICB0aGlzLnNldHVwQ29ycmVsYXRpb25NYXRyaXgoKTtcblxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwVmFyaWFibGVzU2NhbGVzKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy52YXJpYWJsZXM7XG5cbiAgICAgICAgLyogKlxuICAgICAgICAgKiB2YWx1ZSBhY2Nlc3NvciAtIHJldHVybnMgdGhlIHZhbHVlIHRvIGVuY29kZSBmb3IgYSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICAgICAgICogc2NhbGUgLSBtYXBzIHZhbHVlIHRvIGEgdmlzdWFsIGRpc3BsYXkgZW5jb2RpbmcsIHN1Y2ggYXMgYSBwaXhlbCBwb3NpdGlvbi5cbiAgICAgICAgICogbWFwIGZ1bmN0aW9uIC0gbWFwcyBmcm9tIGRhdGEgdmFsdWUgdG8gZGlzcGxheSB2YWx1ZVxuICAgICAgICAgKiBheGlzIC0gc2V0cyB1cCBheGlzXG4gICAgICAgICAqKi9cbiAgICAgICAgeC52YWx1ZSA9IGNvbmYudmFsdWU7XG4gICAgICAgIHguc2NhbGUgPSBkMy5zY2FsZUJhbmQoKS5yYW5nZShbcGxvdC53aWR0aCwgMF0pO1xuICAgICAgICB4Lm1hcCA9IGQgPT4geC5zY2FsZSh4LnZhbHVlKGQpKTtcblxuICAgIH07XG5cbiAgICBzZXR1cENvcnJlbGF0aW9uU2NhbGVzKCkge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIGNvcnJDb25mID0gdGhpcy5jb25maWcuY29ycmVsYXRpb247XG5cbiAgICAgICAgcGxvdC5jb3JyZWxhdGlvbi5jb2xvci5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvcnJDb25mLnNjYWxlKS5kb21haW4oY29yckNvbmYuZG9tYWluKS5yYW5nZShjb3JyQ29uZi5yYW5nZSk7XG4gICAgICAgIHZhciBzaGFwZSA9IHBsb3QuY29ycmVsYXRpb24uc2hhcGUgPSB7fTtcblxuICAgICAgICB2YXIgY2VsbENvbmYgPSB0aGlzLmNvbmZpZy5jZWxsO1xuICAgICAgICBzaGFwZS50eXBlID0gY2VsbENvbmYuc2hhcGU7XG5cbiAgICAgICAgdmFyIHNoYXBlU2l6ZSA9IHBsb3QuY2VsbFNpemUgLSBjZWxsQ29uZi5wYWRkaW5nICogMjtcbiAgICAgICAgaWYgKHNoYXBlLnR5cGUgPT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgIHZhciByYWRpdXNNYXggPSBzaGFwZVNpemUgLyAyO1xuICAgICAgICAgICAgc2hhcGUucmFkaXVzU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgMV0pLnJhbmdlKFsyLCByYWRpdXNNYXhdKTtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1cyA9IGM9PiBzaGFwZS5yYWRpdXNTY2FsZShNYXRoLmFicyhjLnZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUudHlwZSA9PSAnZWxsaXBzZScpIHtcbiAgICAgICAgICAgIHZhciByYWRpdXNNYXggPSBzaGFwZVNpemUgLyAyO1xuICAgICAgICAgICAgc2hhcGUucmFkaXVzU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgMV0pLnJhbmdlKFtyYWRpdXNNYXgsIDJdKTtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1c1ggPSBjPT4gc2hhcGUucmFkaXVzU2NhbGUoTWF0aC5hYnMoYy52YWx1ZSkpO1xuICAgICAgICAgICAgc2hhcGUucmFkaXVzWSA9IHJhZGl1c01heDtcblxuICAgICAgICAgICAgc2hhcGUucm90YXRlVmFsID0gdiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT0gMCkgcmV0dXJuIFwiMFwiO1xuICAgICAgICAgICAgICAgIGlmICh2IDwgMCkgcmV0dXJuIFwiLTQ1XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiNDVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlLnR5cGUgPT0gJ3JlY3QnKSB7XG4gICAgICAgICAgICBzaGFwZS5zaXplID0gc2hhcGVTaXplO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIHNldHVwVmFyaWFibGVzKCkge1xuXG4gICAgICAgIHZhciB2YXJpYWJsZXNDb25mID0gdGhpcy5jb25maWcudmFyaWFibGVzO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgcGxvdC5kb21haW5CeVZhcmlhYmxlID0ge307XG4gICAgICAgIHBsb3QudmFyaWFibGVzID0gdmFyaWFibGVzQ29uZi5rZXlzO1xuICAgICAgICBpZiAoIXBsb3QudmFyaWFibGVzIHx8ICFwbG90LnZhcmlhYmxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBsb3QudmFyaWFibGVzID0gVXRpbHMuaW5mZXJWYXJpYWJsZXMoZGF0YSwgdGhpcy5jb25maWcuZ3JvdXBzLmtleSwgdGhpcy5jb25maWcuaW5jbHVkZUluUGxvdCk7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90LmxhYmVscyA9IFtdO1xuICAgICAgICBwbG90LmxhYmVsQnlWYXJpYWJsZSA9IHt9O1xuICAgICAgICBwbG90LnZhcmlhYmxlcy5mb3JFYWNoKCh2YXJpYWJsZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHBsb3QuZG9tYWluQnlWYXJpYWJsZVt2YXJpYWJsZUtleV0gPSBkMy5leHRlbnQoZGF0YSwgKGQpID0+IHZhcmlhYmxlc0NvbmYudmFsdWUoZCwgdmFyaWFibGVLZXkpKTtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHZhcmlhYmxlS2V5O1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlc0NvbmYubGFiZWxzICYmIHZhcmlhYmxlc0NvbmYubGFiZWxzLmxlbmd0aCA+IGluZGV4KSB7XG5cbiAgICAgICAgICAgICAgICBsYWJlbCA9IHZhcmlhYmxlc0NvbmYubGFiZWxzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsb3QubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgcGxvdC5sYWJlbEJ5VmFyaWFibGVbdmFyaWFibGVLZXldID0gbGFiZWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHBsb3QubGFiZWxCeVZhcmlhYmxlKTtcblxuICAgIH07XG5cblxuICAgIHNldHVwQ29ycmVsYXRpb25NYXRyaXgoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLnBsb3QuY29ycmVsYXRpb24ubWF0cml4ID0gW107XG4gICAgICAgIHZhciBtYXRyaXhDZWxscyA9IHRoaXMucGxvdC5jb3JyZWxhdGlvbi5tYXRyaXguY2VsbHMgPSBbXTtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG5cbiAgICAgICAgdmFyIHZhcmlhYmxlVG9WYWx1ZXMgPSB7fTtcbiAgICAgICAgcGxvdC52YXJpYWJsZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuXG4gICAgICAgICAgICB2YXJpYWJsZVRvVmFsdWVzW3ZdID0gZGF0YS5tYXAoZD0+cGxvdC54LnZhbHVlKGQsIHYpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGxvdC52YXJpYWJsZXMuZm9yRWFjaCgodjEsIGkpID0+IHtcbiAgICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICAgIG1hdHJpeC5wdXNoKHJvdyk7XG5cbiAgICAgICAgICAgIHBsb3QudmFyaWFibGVzLmZvckVhY2goKHYyLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnIgPSAxO1xuICAgICAgICAgICAgICAgIGlmICh2MSAhPSB2Mikge1xuICAgICAgICAgICAgICAgICAgICBjb3JyID0gc2VsZi5jb25maWcuY29ycmVsYXRpb24udmFsdWUodmFyaWFibGVUb1ZhbHVlc1t2MV0sIHZhcmlhYmxlVG9WYWx1ZXNbdjJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1ZhcjogdjEsXG4gICAgICAgICAgICAgICAgICAgIGNvbFZhcjogdjIsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogaSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiBqLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29yclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcm93LnB1c2goY2VsbCk7XG5cbiAgICAgICAgICAgICAgICBtYXRyaXhDZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICB1cGRhdGUobmV3RGF0YSkge1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG4gICAgICAgIC8vIHRoaXMudXBkYXRlXG4gICAgICAgIHRoaXMudXBkYXRlQ2VsbHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYXJpYWJsZUxhYmVscygpO1xuXG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGVnZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdXBkYXRlVmFyaWFibGVMYWJlbHMoKSB7XG4gICAgICAgIHRoaXMucGxvdC5sYWJlbENsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcImxhYmVsXCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNYKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXhpc1koKTtcbiAgICB9XG5cbiAgICB1cGRhdGVBeGlzWCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGxhYmVsQ2xhc3MgPSBwbG90LmxhYmVsQ2xhc3M7XG4gICAgICAgIHZhciBsYWJlbFhDbGFzcyA9IGxhYmVsQ2xhc3MgKyBcIi14XCI7XG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgbGFiZWxYQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnZhcmlhYmxlcywgKGQsIGkpPT5pKTtcblxuICAgICAgICB2YXIgbGFiZWxzTWVyZ2UgPSBsYWJlbHMuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gbGFiZWxDbGFzcyArIFwiIFwiICsgbGFiZWxYQ2xhc3MgKyBcIiBcIiArIGxhYmVsWENsYXNzICsgXCItXCIgKyBpKS5tZXJnZShsYWJlbHMpO1xuXG4gICAgICAgIGxhYmVsc01lcmdlXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IGkgKiBwbG90LmNlbGxTaXplICsgcGxvdC5jZWxsU2l6ZSAvIDIpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgcGxvdC5oZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcImR4XCIsIC0yKVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCA1KVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuXG4gICAgICAgICAgICAvLyAuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwiaGFuZ2luZ1wiKVxuICAgICAgICAgICAgLnRleHQodj0+cGxvdC5sYWJlbEJ5VmFyaWFibGVbdl0pO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5yb3RhdGVMYWJlbHNYKSB7XG4gICAgICAgICAgICBsYWJlbHNNZXJnZS5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInJvdGF0ZSgtNDUsIFwiICsgKGkgKiBwbG90LmNlbGxTaXplICsgcGxvdC5jZWxsU2l6ZSAvIDIgICkgKyBcIiwgXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFdpZHRoID0gc2VsZi5jb21wdXRlWEF4aXNMYWJlbHNXaWR0aCgpO1xuICAgICAgICBsYWJlbHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgVXRpbHMucGxhY2VUZXh0V2l0aEVsbGlwc2lzQW5kVG9vbHRpcChkMy5zZWxlY3QodGhpcyksIGxhYmVsLCBtYXhXaWR0aCwgc2VsZi5jb25maWcuc2hvd1Rvb2x0aXAgPyBzZWxmLnBsb3QudG9vbHRpcCA6IGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGFiZWxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVBeGlzWSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGxhYmVsQ2xhc3MgPSBwbG90LmxhYmVsQ2xhc3M7XG4gICAgICAgIHZhciBsYWJlbFlDbGFzcyA9IHBsb3QubGFiZWxDbGFzcyArIFwiLXlcIjtcbiAgICAgICAgdmFyIGxhYmVscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgbGFiZWxZQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnZhcmlhYmxlcyk7XG5cbiAgICAgICAgdmFyIGxhYmVsc01lcmdlID0gbGFiZWxzLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKS5tZXJnZShsYWJlbHMpO1xuXG4gICAgICAgIGxhYmVsc01lcmdlXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAoZCwgaSkgPT4gaSAqIHBsb3QuY2VsbFNpemUgKyBwbG90LmNlbGxTaXplIC8gMilcbiAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgLTIpXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBsYWJlbENsYXNzICsgXCIgXCIgKyBsYWJlbFlDbGFzcyArIFwiIFwiICsgbGFiZWxZQ2xhc3MgKyBcIi1cIiArIGkpXG4gICAgICAgICAgICAvLyAuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwiaGFuZ2luZ1wiKVxuICAgICAgICAgICAgLnRleHQodj0+cGxvdC5sYWJlbEJ5VmFyaWFibGVbdl0pO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5yb3RhdGVMYWJlbHNZKSB7XG4gICAgICAgICAgICBsYWJlbHNNZXJnZVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInJvdGF0ZSgtNDUsIFwiICsgMCArIFwiLCBcIiArIChpICogcGxvdC5jZWxsU2l6ZSArIHBsb3QuY2VsbFNpemUgLyAyKSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4V2lkdGggPSBzZWxmLmNvbXB1dGVZQXhpc0xhYmVsc1dpZHRoKCk7XG4gICAgICAgIGxhYmVsc01lcmdlLmVhY2goZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgICAgICBVdGlscy5wbGFjZVRleHRXaXRoRWxsaXBzaXNBbmRUb29sdGlwKGQzLnNlbGVjdCh0aGlzKSwgbGFiZWwsIG1heFdpZHRoLCBzZWxmLmNvbmZpZy5zaG93VG9vbHRpcCA/IHNlbGYucGxvdC50b29sdGlwIDogZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGNvbXB1dGVZQXhpc0xhYmVsc1dpZHRoKCkge1xuICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLnBsb3QubWFyZ2luLmxlZnQ7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcucm90YXRlTGFiZWxzWSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF4V2lkdGggKj0gVXRpbHMuU1FSVF8yO1xuICAgICAgICB2YXIgZm9udFNpemUgPSAxMTsgLy90b2RvIGNoZWNrIGFjdHVhbCBmb250IHNpemVcbiAgICAgICAgbWF4V2lkdGggLT0gZm9udFNpemUgLyAyO1xuXG4gICAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9XG5cbiAgICBjb21wdXRlWEF4aXNMYWJlbHNXaWR0aChvZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5yb3RhdGVMYWJlbHNYKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbG90LmNlbGxTaXplIC0gMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMucGxvdC5tYXJnaW4uYm90dG9tO1xuICAgICAgICBzaXplICo9IFV0aWxzLlNRUlRfMjtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gMTE7IC8vdG9kbyBjaGVjayBhY3R1YWwgZm9udCBzaXplXG4gICAgICAgIHNpemUgLT0gZm9udFNpemUgLyAyO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICB1cGRhdGVDZWxscygpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgY2VsbENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImNlbGxcIik7XG4gICAgICAgIHZhciBjZWxsU2hhcGUgPSBwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnR5cGU7XG5cbiAgICAgICAgdmFyIGNlbGxzID0gc2VsZi5zdmdHLnNlbGVjdEFsbChcImcuXCIgKyBjZWxsQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LmNvcnJlbGF0aW9uLm1hdHJpeC5jZWxscyk7XG5cbiAgICAgICAgdmFyIGNlbGxzRW50ZXIgPSBjZWxscy5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKGNlbGxDbGFzcywgdHJ1ZSk7XG4gICAgICAgIHZhciBjZWxsc01lcmdlID0gY2VsbHNFbnRlci5tZXJnZShjZWxscyk7XG4gICAgICAgIGNlbGxzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCBjPT4gXCJ0cmFuc2xhdGUoXCIgKyAocGxvdC5jZWxsU2l6ZSAqIGMuY29sICsgcGxvdC5jZWxsU2l6ZSAvIDIpICsgXCIsXCIgKyAocGxvdC5jZWxsU2l6ZSAqIGMucm93ICsgcGxvdC5jZWxsU2l6ZSAvIDIpICsgXCIpXCIpO1xuXG4gICAgICAgIGNlbGxzTWVyZ2UuY2xhc3NlZChzZWxmLmNvbmZpZy5jc3NDbGFzc1ByZWZpeCArIFwic2VsZWN0YWJsZVwiLCAhIXNlbGYuc2NhdHRlclBsb3QpO1xuXG4gICAgICAgIHZhciBzZWxlY3RvciA9IFwiKjpub3QoLmNlbGwtc2hhcGUtXCIgKyBjZWxsU2hhcGUgKyBcIilcIjtcblxuICAgICAgICB2YXIgd3JvbmdTaGFwZXMgPSBjZWxscy5zZWxlY3RBbGwoc2VsZWN0b3IpO1xuICAgICAgICB3cm9uZ1NoYXBlcy5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgc2hhcGVzID0gY2VsbHNNZXJnZS5zZWxlY3RPckFwcGVuZChjZWxsU2hhcGUgKyBcIi5jZWxsLXNoYXBlLVwiICsgY2VsbFNoYXBlKTtcblxuICAgICAgICBpZiAocGxvdC5jb3JyZWxhdGlvbi5zaGFwZS50eXBlID09ICdjaXJjbGUnKSB7XG5cbiAgICAgICAgICAgIHNoYXBlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCBwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnJhZGl1cylcbiAgICAgICAgICAgICAgICAuYXR0cihcImN4XCIsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnR5cGUgPT0gJ2VsbGlwc2UnKSB7XG4gICAgICAgICAgICAvLyBjZWxscy5hdHRyKFwidHJhbnNmb3JtXCIsIGM9PiBcInRyYW5zbGF0ZSgzMDAsMTUwKSByb3RhdGUoXCIrcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5yb3RhdGVWYWwoYy52YWx1ZSkrXCIpXCIpO1xuICAgICAgICAgICAgc2hhcGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJyeFwiLCBwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnJhZGl1c1gpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJyeVwiLCBwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnJhZGl1c1kpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgMClcblxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGM9PiBcInJvdGF0ZShcIiArIHBsb3QuY29ycmVsYXRpb24uc2hhcGUucm90YXRlVmFsKGMudmFsdWUpICsgXCIpXCIpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAocGxvdC5jb3JyZWxhdGlvbi5zaGFwZS50eXBlID09ICdyZWN0Jykge1xuICAgICAgICAgICAgc2hhcGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnNpemUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5zaXplKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCAtcGxvdC5jZWxsU2l6ZSAvIDIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIC1wbG90LmNlbGxTaXplIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgc2hhcGVzLnN0eWxlKFwiZmlsbFwiLCBjPT4gcGxvdC5jb3JyZWxhdGlvbi5jb2xvci5zY2FsZShjLnZhbHVlKSk7XG5cbiAgICAgICAgdmFyIG1vdXNlb3ZlckNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgbW91c2VvdXRDYWxsYmFja3MgPSBbXTtcblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG5cbiAgICAgICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5wdXNoKGM9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBjLnZhbHVlO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Rvb2x0aXAoaHRtbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbW91c2VvdXRDYWxsYmFja3MucHVzaChjPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5oaWdobGlnaHRMYWJlbHMpIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHRDbGFzcyA9IHNlbGYuY29uZmlnLmNzc0NsYXNzUHJlZml4ICsgXCJoaWdobGlnaHRcIjtcbiAgICAgICAgICAgIHZhciB4TGFiZWxDbGFzcyA9IGM9PnBsb3QubGFiZWxDbGFzcyArIFwiLXgtXCIgKyBjLmNvbDtcbiAgICAgICAgICAgIHZhciB5TGFiZWxDbGFzcyA9IGM9PnBsb3QubGFiZWxDbGFzcyArIFwiLXktXCIgKyBjLnJvdztcblxuXG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MucHVzaChjPT4ge1xuXG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB4TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB5TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goYz0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIHhMYWJlbENsYXNzKGMpKS5jbGFzc2VkKGhpZ2hsaWdodENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB5TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNlbGxzTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgYyA9PiB7XG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjaz0+Y2FsbGJhY2soYykpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgYyA9PiB7XG4gICAgICAgICAgICAgICAgbW91c2VvdXRDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjaz0+Y2FsbGJhY2soYykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY2VsbHNNZXJnZS5vbihcImNsaWNrXCIsIGM9PiB7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJjZWxsLXNlbGVjdGVkXCIsIGMpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cblxuICAgIHVwZGF0ZUxlZ2VuZCgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIGxlZ2VuZFggPSB0aGlzLnBsb3Qud2lkdGggKyAxMDtcbiAgICAgICAgdmFyIGxlZ2VuZFkgPSAwO1xuICAgICAgICB2YXIgYmFyV2lkdGggPSAxMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IHRoaXMucGxvdC5oZWlnaHQgLSAyO1xuICAgICAgICB2YXIgc2NhbGUgPSBwbG90LmNvcnJlbGF0aW9uLmNvbG9yLnNjYWxlO1xuXG4gICAgICAgIHBsb3QubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLnN2ZywgdGhpcy5zdmdHLCBzY2FsZSwgbGVnZW5kWCwgbGVnZW5kWSkubGluZWFyR3JhZGllbnRCYXIoYmFyV2lkdGgsIGJhckhlaWdodCk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIGF0dGFjaFNjYXR0ZXJQbG90KGNvbnRhaW5lclNlbGVjdG9yLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXG4gICAgICAgIHZhciBzY2F0dGVyUGxvdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGhlaWdodDogc2VsZi5wbG90LmhlaWdodCArIHNlbGYuY29uZmlnLm1hcmdpbi50b3AgKyBzZWxmLmNvbmZpZy5tYXJnaW4uYm90dG9tLFxuICAgICAgICAgICAgd2lkdGg6IHNlbGYucGxvdC5oZWlnaHQgKyBzZWxmLmNvbmZpZy5tYXJnaW4udG9wICsgc2VsZi5jb25maWcubWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgIGdyb3Vwczoge1xuICAgICAgICAgICAgICAgIGtleTogc2VsZi5jb25maWcuZ3JvdXBzLmtleSxcbiAgICAgICAgICAgICAgICBsYWJlbDogc2VsZi5jb25maWcuZ3JvdXBzLmxhYmVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ3VpZGVzOiB0cnVlLFxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLnNjYXR0ZXJQbG90ID0gdHJ1ZTtcblxuICAgICAgICBzY2F0dGVyUGxvdENvbmZpZyA9IFV0aWxzLmRlZXBFeHRlbmQoc2NhdHRlclBsb3RDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy5vbihcImNlbGwtc2VsZWN0ZWRcIiwgYz0+IHtcblxuXG4gICAgICAgICAgICBzY2F0dGVyUGxvdENvbmZpZy54ID0ge1xuICAgICAgICAgICAgICAgIGtleTogYy5yb3dWYXIsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHNlbGYucGxvdC5sYWJlbEJ5VmFyaWFibGVbYy5yb3dWYXJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NhdHRlclBsb3RDb25maWcueSA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IGMuY29sVmFyLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBzZWxmLnBsb3QubGFiZWxCeVZhcmlhYmxlW2MuY29sVmFyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNjYXR0ZXJQbG90ICYmIHNlbGYuc2NhdHRlclBsb3QgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjYXR0ZXJQbG90LnNldENvbmZpZyhzY2F0dGVyUGxvdENvbmZpZykuaW5pdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjYXR0ZXJQbG90ID0gbmV3IFNjYXR0ZXJQbG90KGNvbnRhaW5lclNlbGVjdG9yLCBzZWxmLmRhdGEsIHNjYXR0ZXJQbG90Q29uZmlnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaChcIlNjYXR0ZXJQbG90XCIsIHNlbGYuc2NhdHRlclBsb3QpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgfSk7XG5cblxuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBEM0V4dGVuc2lvbnMge1xuXG4gICAgc3RhdGljIGV4dGVuZCgpIHtcblxuICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLmVudGVyLnByb3RvdHlwZS5pbnNlcnRTZWxlY3RvciA9XG4gICAgICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLmluc2VydFNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRDNFeHRlbnNpb25zLmluc2VydFNlbGVjdG9yKHRoaXMsIHNlbGVjdG9yLCBiZWZvcmUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLmVudGVyLnByb3RvdHlwZS5hcHBlbmRTZWxlY3RvciA9XG4gICAgICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLmFwcGVuZFNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5hcHBlbmRTZWxlY3Rvcih0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUuZW50ZXIucHJvdG90eXBlLnNlbGVjdE9yQXBwZW5kID1cbiAgICAgICAgICAgIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0T3JBcHBlbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRDNFeHRlbnNpb25zLnNlbGVjdE9yQXBwZW5kKHRoaXMsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5lbnRlci5wcm90b3R5cGUuc2VsZWN0T3JJbnNlcnQgPVxuICAgICAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3RPckluc2VydCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5zZWxlY3RPckluc2VydCh0aGlzLCBzZWxlY3RvciwgYmVmb3JlKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgIH1cblxuICAgIHN0YXRpYyBpbnNlcnRPckFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IsIG9wZXJhdGlvbiwgYmVmb3JlKSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdG9yUGFydHMgPSBzZWxlY3Rvci5zcGxpdCgvKFtcXC5cXCNdKS8pO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHBhcmVudFtvcGVyYXRpb25dKHNlbGVjdG9yUGFydHMuc2hpZnQoKSwgYmVmb3JlKTsvL1wiOmZpcnN0LWNoaWxkXCJcblxuICAgICAgICB3aGlsZSAoc2VsZWN0b3JQYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JNb2RpZmllciA9IHNlbGVjdG9yUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rvckl0ZW0gPSBzZWxlY3RvclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JNb2RpZmllciA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5jbGFzc2VkKHNlbGVjdG9ySXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yTW9kaWZpZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuYXR0cignaWQnLCBzZWxlY3Rvckl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnNlcnRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBiZWZvcmUpIHtcbiAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5pbnNlcnRPckFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IsIFwiaW5zZXJ0XCIsIGJlZm9yZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5pbnNlcnRPckFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IsIFwiYXBwZW5kXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3RPckFwcGVuZChwYXJlbnQsIHNlbGVjdG9yLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBwYXJlbnQuc2VsZWN0KHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSgpKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5hcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yKTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfTtcblxuICAgIHN0YXRpYyBzZWxlY3RPckluc2VydChwYXJlbnQsIHNlbGVjdG9yLCBiZWZvcmUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHBhcmVudC5zZWxlY3Qoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuaW5zZXJ0U2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGQzIiwiaW1wb3J0IHtDaGFydCwgQ2hhcnRDb25maWd9IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIERpdmVyZ2luZ1N0YWNrZWRCYXJDaGFydENvbmZpZyBleHRlbmRzIENoYXJ0Q29uZmlne1xuXG4gICAgc3ZnQ2xhc3MgPSB0aGlzLmNzc0NsYXNzUHJlZml4ICsgJ2RpdmVyZ2luZy1zdGFja2VkLWJhci1jaGFydCc7XG4gICAgc2hvd1Rvb2x0aXAgPSB0cnVlO1xuICAgIHggPSB7Ly8gWCBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgbGFiZWxcbiAgICAgICAgdmFsdWU6IGQgPT4gZC52YWx1ZXMsIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgZ3VpZGVzOiB0cnVlLCAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICAgICAgb3JpZW50OiAndG9wJyxcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4wMixcbiAgICB9O1xuICAgIHkgPSB7Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIHZhbHVlOiBkID0+IGQua2V5LCAvLyB5IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIHNjYWxlOiBcIm9yZGluYWxcIixcbiAgICAgICAgb3JpZW50OiAnbGVmdCcsXG4gICAgICAgIGd1aWRlczogdHJ1ZSAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICB9O1xuXG4gICAgdHJhbnNpdGlvbiA9IHRydWU7XG4gICAgY29sb3IgPSAgdW5kZWZpbmVkOy8vIHN0cmluZyBvciBmdW5jdGlvbiByZXR1cm5pbmcgY29sb3IncyB2YWx1ZSBmb3IgY29sb3Igc2NhbGVcbiAgICBkM0NvbG9yQ2F0ZWdvcnk9ICdjYXRlZ29yeTEwJztcblxuICAgIGNvbG9yUmFuZ2UgPSB1bmRlZmluZWQ7XG5cbiAgICBjYXRlZ29yeU5hbWVzID0gdW5kZWZpbmVkO1xuICAgIG1pZGRsZVZhbHVlID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEaXZlcmdpbmdTdGFja2VkQmFyQ2hhcnQgZXh0ZW5kcyBDaGFydHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IERpdmVyZ2luZ1N0YWNrZWRCYXJDaGFydENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKXtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgRGl2ZXJnaW5nU3RhY2tlZEJhckNoYXJ0Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGluaXRQbG90KCl7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHN1cGVyLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnBsb3QueCA9IHt9O1xuICAgICAgICB0aGlzLnBsb3QueSA9IHt9O1xuXG4gICAgICAgIHRoaXMucGxvdC5kYXRhID0gdGhpcy5nZXREYXRhVG9QbG90KCk7XG4gICAgICAgIHRoaXMuc2V0dXBZKCk7XG4gICAgICAgIHRoaXMuc2V0dXBYKCk7XG5cbiAgICAgICAgdGhpcy5zZXR1cENvbG9yKCk7XG5cbiAgICB9XG5cbiAgICBnZXREYXRhVG9QbG90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIHNldHVwWCgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueDtcblxuICAgICAgICB4LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlLmNhbGwodGhpcy5jb25maWcsIGQpO1xuICAgICAgICB4LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi5zY2FsZSkucmFuZ2VSb3VuZChbMCwgcGxvdC53aWR0aF0pO1xuICAgICAgICB4Lm1hcCA9IGQgPT4geC5zY2FsZSh4LnZhbHVlKGQpKTtcblxuICAgICAgICB4LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB4LnNjYWxlKTtcbiAgICAgICAgaWYoY29uZi5ndWlkZXMpe1xuICAgICAgICAgICAgeC5heGlzLnRpY2tTaXplKC1wbG90LmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuXG5cbiAgICAgICAgcGxvdC5jYXRlZ29yeU5hbWVzID0gdGhpcy5jb25maWcuY2F0ZWdvcnlOYW1lcztcblxuICAgICAgICBwbG90Lm5ldXRyYWxJbmRleCA9IE1hdGguZmxvb3IocGxvdC5jYXRlZ29yeU5hbWVzLmxlbmd0aC8yKTtcblxuICAgICAgICBwbG90LnJvd3MgPSBkYXRhLm1hcChkPT4ge1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsVmFsdWVzID0geC52YWx1ZShkKTtcbiAgICAgICAgICAgIGxldCB4MCA9IHRoaXMuY29uZmlnLm1pZGRsZVZhbHVlIC0gZDMuc3VtKG9yaWdpbmFsVmFsdWVzLm1hcCgodixpKSA9PiAgaSA8IHBsb3QubmV1dHJhbEluZGV4ID8gdiA6IDAgKSk7XG4gICAgICAgICAgICBpZiAocGxvdC5jYXRlZ29yeU5hbWVzLmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgeDAgKz0gLTEgKiBvcmlnaW5hbFZhbHVlc1twbG90Lm5ldXRyYWxJbmRleF0vMjtcblxuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IG9yaWdpbmFsVmFsdWVzLm1hcCgodiwgaSkgPT4gaTxwbG90Lm5ldXRyYWxJbmRleCA/IHRoaXMuY29uZmlnLm1pZGRsZVZhbHVlIC0gdiA6IHRoaXMuY29uZmlnLm1pZGRsZVZhbHVlICsgdik7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBkMy5zdW0ob3JpZ2luYWxWYWx1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXR1bTogZCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFZhbHVlczogb3JpZ2luYWxWYWx1ZXMsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgbWluOiB4MCxcbiAgICAgICAgICAgICAgICBtYXg6IHgwK3RvdGFsLFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICAgICAgICAgICAgICBib3hlczogdmFsdWVzLm1hcCgodiwgaSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBsb3QuY2F0ZWdvcnlOYW1lc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwOiB4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiB4MCs9b3JpZ2luYWxWYWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBvcmlnaW5hbFZhbHVlc1tpXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGRvbWFpbjtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9tYWluID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSBkMy5leHRlbnQoW10uY29uY2F0KC4uLnBsb3Qucm93cy5tYXAoYj0+W2IubWluLCBiLm1heF0pKSk7XG4gICAgICAgICAgICBsZXQgbWFyZ2luID0gKGRvbWFpblsxXS1kb21haW5bMF0pKiBjb25mLmRvbWFpbk1hcmdpbjtcbiAgICAgICAgICAgIGRvbWFpblswXS09bWFyZ2luO1xuICAgICAgICAgICAgZG9tYWluWzFdKz1tYXJnaW47XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgICB9O1xuXG5cbiAgICBzZXR1cFkoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB5ID0gcGxvdC55O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHkudmFsdWUgPSBkID0+IGNvbmYudmFsdWUuY2FsbCh0aGlzLmNvbmZpZywgZCk7XG4gICAgICAgIHkuc2NhbGUgPSBkMy5zY2FsZUJhbmQoKS5yYW5nZShbMCwgcGxvdC5oZWlnaHRdKS5wYWRkaW5nKC4zKTtcbiAgICAgICAgeS5tYXAgPSBkID0+IHkuc2NhbGUoeS52YWx1ZShkKSk7XG5cbiAgICAgICAgeS5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeS5zY2FsZSk7XG4gICAgICAgIGlmIChjb25mLnRpY2tzKSB7XG4gICAgICAgICAgICB5LmF4aXMudGlja3MoY29uZi50aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY29uZi5ndWlkZXMpe1xuICAgICAgICAgICAgeS5heGlzLnRpY2tTaXplKC1wbG90LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldHVwWURvbWFpbigpO1xuICAgIH07XG5cbiAgICBzZXR1cFlEb21haW4oKSB7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHZhciBkb21haW4gPSBkYXRhLm1hcChwbG90LnkudmFsdWUpIDtcblxuICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgfVxuXG4gICAgZHJhd0F4aXNYKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy54O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzLXgnKSArIFwiLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpICsgKGF4aXNDb25mLmd1aWRlcyA/ICcnIDogJy4nICsgc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKVxuXG4gICAgICAgIGlmKGF4aXNDb25mLm9yaWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC54LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiK3NlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgKHBsb3Qud2lkdGgvMikgK1wiLFwiKyAocGxvdC5tYXJnaW4uYm90dG9tKSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLmxhYmVsKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNZKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzLXknKSArIFwiLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpICsgKGF4aXNDb25mLmd1aWRlcyA/ICcnIDogJy4nICsgc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKTtcblxuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC55LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiICsgc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLXBsb3QubWFyZ2luLmxlZnQgKyBcIixcIiArIChwbG90LmhlaWdodCAvIDIpICsgXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIGRyYXdCYXJzKCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBwbG90ID0gc2VsZi5wbG90LFxuICAgICAgICAgICAgY29uZmlnID0gc2VsZi5jb25maWc7XG5cbiAgICAgICAgbGV0IHJvd0NsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcInJvd1wiKTtcbiAgICAgICAgbGV0IHJvd3MgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiKyByb3dDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHBsb3Qucm93cyk7XG5cbiAgICAgICAgbGV0IHJvd0VudGVyID0gcm93cy5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKFwiZy5cIityb3dDbGFzcyk7XG5cbiAgICAgICAgbGV0IHJvd01lcmdlID0gcm93RW50ZXIubWVyZ2Uocm93cylcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoMCxcIiArIHBsb3QueS5tYXAoZC5kYXR1bSkgKyBcIilcIik7XG5cbiAgICAgICAgcm93cy5leGl0KCkucmVtb3ZlKCk7XG5cblxuICAgICAgICBsZXQgYmFyQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiYmFyXCIpO1xuXG4gICAgICAgIGxldCBiYXJzID0gcm93TWVyZ2Uuc2VsZWN0QWxsKFwiZy5cIisgYmFyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkLmJveGVzOyB9KTtcbiAgICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGJhcnNFbnRlciA9IGJhcnMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgYmFyQ2xhc3MpO1xuXG4gICAgICAgIGJhcnNFbnRlci5hcHBlbmQoXCJyZWN0XCIpO1xuICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuICAgICAgICBsZXQgYmFyc00gPSAgYmFyc0VudGVyLm1lcmdlKGJhcnMpO1xuXG4gICAgICAgIGJhcnNNLnNlbGVjdChcInJlY3RcIikuYXR0cihcImhlaWdodFwiLCBwbG90Lnkuc2NhbGUuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PnBsb3QueC5zY2FsZShkLngwKSlcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiBwbG90Lnguc2NhbGUoZC54MSkgLSBwbG90Lnguc2NhbGUoZC54MCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiBwbG90LmNvbG9yKGQubmFtZSwgaSkpO1xuXG4gICAgICAgIGJhcnNNLnNlbGVjdChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBkID0+IHBsb3QueC5zY2FsZShkLngwKSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBwbG90Lnkuc2NhbGUuYmFuZHdpZHRoKCkvMilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIwLjVlbVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBkPT4ocGxvdC54LnNjYWxlKGQueDEpLXBsb3QueC5zY2FsZShkLngwKSkvMilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChkID0+IGQub3JpZ2luYWxWYWx1ZSAhPT0gMCAmJiAoZC54MS1kLngwKT4wLjA0ID8gZC5vcmlnaW5hbFZhbHVlIDogXCJcIik7XG5cbiAgICAgICAgc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwibGluZS5cIitzZWxmLnByZWZpeENsYXNzKFwibWlkZGxlLWxpbmVcIikpXG4gICAgICAgICAgICAuYXR0cihcIngxXCIsIHBsb3QueC5zY2FsZShzZWxmLmNvbmZpZy5taWRkbGVWYWx1ZSkpXG4gICAgICAgICAgICAuYXR0cihcInkxXCIsIDApXG4gICAgICAgICAgICAuYXR0cihcIngyXCIsIHBsb3QueC5zY2FsZShzZWxmLmNvbmZpZy5taWRkbGVWYWx1ZSkpXG4gICAgICAgICAgICAuYXR0cihcInkyXCIsIHBsb3QuaGVpZ2h0KTtcblxuICAgIH1cblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWCgpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWSgpO1xuICAgICAgICB0aGlzLmRyYXdCYXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBzZXR1cENvbG9yKCkge1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIGlmKGNvbmYuZDNDb2xvckNhdGVnb3J5KXtcbiAgICAgICAgICAgIHZhciBjb2xvclNjaGVtZUNhdGVnb3J5ID0gJ3NjaGVtZScrVXRpbHMuY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGNvbmYuZDNDb2xvckNhdGVnb3J5KTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvckNhdGVnb3J5ID0gZDMuc2NhbGVPcmRpbmFsKGQzW2NvbG9yU2NoZW1lQ2F0ZWdvcnldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xvclZhbHVlID0gY29uZi5jb2xvcjtcbiAgICAgICAgaWYgKGNvbG9yVmFsdWUgJiYgdHlwZW9mIGNvbG9yVmFsdWUgPT09ICdzdHJpbmcnIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpe1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gY29sb3JWYWx1ZTtcbiAgICAgICAgfWVsc2UgaWYgKGNvbmYuY29sb3JSYW5nZSl7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY29sb3IgPSBVdGlscy5jcmVhdGVTY2FsZShcIm9yZGluYWxcIikuZG9tYWluKHRoaXMucGxvdC5jYXRlZ29yeU5hbWVzKS5yYW5nZShjb25mLmNvbG9yUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkpe1xuICAgICAgICAgICAgc2VsZi5wbG90LmNvbG9yVmFsdWU9Y29sb3JWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IHRoaXMucGxvdC5jb2xvckNhdGVnb3J5XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7SGVhdG1hcCwgSGVhdG1hcENvbmZpZ30gZnJvbSBcIi4vaGVhdG1hcFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7U3RhdGlzdGljc1V0aWxzfSBmcm9tICcuL3N0YXRpc3RpY3MtdXRpbHMnXG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgSGVhdG1hcFRpbWVTZXJpZXNDb25maWcgZXh0ZW5kcyBIZWF0bWFwQ29uZmlnIHtcbiAgICB4ID0ge1xuICAgICAgICBmaWxsTWlzc2luZzogZmFsc2UsIC8vIGZpbGwgbWlzc2luZyB2YWx1ZXMgdXNpbmcgaW50ZXJ2YWwgYW5kIGludGVydmFsU3RlcFxuICAgICAgICBpbnRlcnZhbDogdW5kZWZpbmVkLCAvL3VzZWQgaW4gZmlsbGluZyBtaXNzaW5nIHRpY2tzXG4gICAgICAgIGludGVydmFsU3RlcDogMSxcbiAgICAgICAgZm9ybWF0OiB1bmRlZmluZWQsIC8vaW5wdXQgZGF0YSBkMyB0aW1lIGZvcm1hdFxuICAgICAgICBkaXNwbGF5Rm9ybWF0OiB1bmRlZmluZWQsLy9kMyB0aW1lIGZvcm1hdCBmb3IgZGlzcGxheVxuICAgICAgICBpbnRlcnZhbFRvRm9ybWF0czogWyAvL3VzZWQgdG8gZ3Vlc3MgaW50ZXJ2YWwgYW5kIGZvcm1hdFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICBmb3JtYXRzOiBbXCIlWVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbW9udGgnLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcIiVZLSVtXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdkYXknLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcIiVZLSVtLSVkXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdob3VyJyxcbiAgICAgICAgICAgICAgICBmb3JtYXRzOiBbJyVIJywgJyVZLSVtLSVkICVIJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgZm9ybWF0czogWyclSDolTScsICclWS0lbS0lZCAlSDolTSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzZWNvbmQnLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFsnJUg6JU06JVMnLCAnJVktJW0tJWQgJUg6JU06JVMnXVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuXG4gICAgICAgIHNvcnRDb21wYXJhdG9yOiBmdW5jdGlvbiBzb3J0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNTdHJpbmcoYSkgPyAgYS5sb2NhbGVDb21wYXJlKGIpIDogIGEgLSBiO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgeiA9IHtcbiAgICAgICAgZmlsbE1pc3Npbmc6IHRydWUgLy8gZmlpbGwgbWlzc2luZyB2YWx1ZXMgd2l0aCBuZWFyZXN0IHByZXZpb3VzIHZhbHVlXG4gICAgfTtcblxuICAgIGxlZ2VuZCA9IHtcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodiAvIDEwMDAwMDAgPj0gMSkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IFwiIE1cIjtcbiAgICAgICAgICAgICAgICB2ID0gTnVtYmVyKHYgLyAxMDAwMDAwKS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5mID0gSW50bC5OdW1iZXJGb3JtYXQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZi5mb3JtYXQodikgKyBzdWZmaXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgSGVhdG1hcFRpbWVTZXJpZXMgZXh0ZW5kcyBIZWF0bWFwIHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEhlYXRtYXBUaW1lU2VyaWVzQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgSGVhdG1hcFRpbWVTZXJpZXNDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG5cbiAgICBzZXR1cFZhbHVlc0JlZm9yZUdyb3Vwc1NvcnQoKSB7XG5cbiAgICAgICAgdGhpcy5wbG90LngudGltZUZvcm1hdCA9IHRoaXMuY29uZmlnLnguZm9ybWF0O1xuICAgICAgICBpZih0aGlzLmNvbmZpZy54LmRpc3BsYXlGb3JtYXQgJiYgIXRoaXMucGxvdC54LnRpbWVGb3JtYXQpe1xuICAgICAgICAgICAgdGhpcy5ndWVzc1RpbWVGb3JtYXQoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc3VwZXIuc2V0dXBWYWx1ZXNCZWZvcmVHcm91cHNTb3J0KCk7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcueC5maWxsTWlzc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuaW5pdFRpbWVGb3JtYXRBbmRJbnRlcnZhbCgpO1xuXG4gICAgICAgIHRoaXMucGxvdC54LmludGVydmFsU3RlcCA9IHRoaXMuY29uZmlnLnguaW50ZXJ2YWxTdGVwIHx8IDE7XG5cbiAgICAgICAgdGhpcy5wbG90LngudGltZVBhcnNlciA9IHRoaXMuZ2V0VGltZVBhcnNlcigpO1xuXG5cblxuICAgICAgICB0aGlzLnBsb3QueC51bmlxdWVWYWx1ZXMuc29ydCh0aGlzLmNvbmZpZy54LnNvcnRDb21wYXJhdG9yKTtcblxuICAgICAgICB2YXIgcHJldiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wbG90LngudW5pcXVlVmFsdWVzLmZvckVhY2goKHgsIGkpPT4ge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnBhcnNlVGltZSh4KTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHNlbGYubmV4dFRpbWVUaWNrVmFsdWUocHJldik7XG4gICAgICAgICAgICB2YXIgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZi5jb21wYXJlVGltZVZhbHVlcyhuZXh0LCBjdXJyZW50KTw9MCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb24gPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVTdHJpbmcgPSBzZWxmLmZvcm1hdFRpbWUobmV4dCk7XG4gICAgICAgICAgICAgICAgZFt0aGlzLmNvbmZpZy54LmtleV0gPSB0aW1lU3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVHcm91cHMoZCwgdGltZVN0cmluZywgc2VsZi5wbG90LnguZ3JvdXBzLCBzZWxmLmNvbmZpZy54Lmdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIG5leHQgPSBzZWxmLm5leHRUaW1lVGlja1ZhbHVlKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgcGFyc2VUaW1lKHgpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXMuZ2V0VGltZVBhcnNlcigpO1xuICAgICAgICByZXR1cm4gcGFyc2VyKHgpO1xuICAgIH1cblxuICAgIGZvcm1hdFRpbWUoZGF0ZSl7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmdldFRpbWVGb3JtYXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcihkYXRlKTtcbiAgICB9XG5cbiAgICBmb3JtYXRWYWx1ZVgodmFsdWUpIHsgLy91c2VkIG9ubHkgZm9yIGRpc3BsYXlcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnguZm9ybWF0dGVyKSByZXR1cm4gdGhpcy5jb25maWcueC5mb3JtYXR0ZXIuY2FsbCh0aGlzLmNvbmZpZywgdmFsdWUpO1xuXG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnguZGlzcGxheUZvcm1hdCl7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMucGFyc2VUaW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBkMy50aW1lRm9ybWF0KHRoaXMuY29uZmlnLnguZGlzcGxheUZvcm1hdCkoZGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5wbG90LngudGltZUZvcm1hdCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIGlmKFV0aWxzLmlzRGF0ZSh2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VGltZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29tcGFyZVRpbWVWYWx1ZXMoYSwgYil7XG4gICAgICAgIHJldHVybiBhLWI7XG4gICAgfVxuXG4gICAgdGltZVZhbHVlc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXMucGxvdC54LnRpbWVQYXJzZXI7XG4gICAgICAgIHJldHVybiBwYXJzZXIoYSkgPT09IHBhcnNlcihiKTtcbiAgICB9XG5cbiAgICBuZXh0VGltZVRpY2tWYWx1ZSh0KSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9ICd0aW1lJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIodGhpcy5wbG90LnguaW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiBkM1tpbnRlcnZhbF0ub2Zmc2V0KHQsIHRoaXMucGxvdC54LmludGVydmFsU3RlcCk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnouZmlsbE1pc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5tYXRyaXguZm9yRWFjaCgocm93LCByb3dJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Um93VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcm93LmZvckVhY2goKGNlbGwsIGNvbEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnZhbHVlID09PSB1bmRlZmluZWQgJiYgcHJldlJvd1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudmFsdWUgPSBwcmV2Um93VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLm1pc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZSb3dWYWx1ZSA9IGNlbGwudmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICB9XG5cbiAgICB1cGRhdGUobmV3RGF0YSkge1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG5cbiAgICB9O1xuXG5cbiAgICBpbml0VGltZUZvcm1hdEFuZEludGVydmFsKCkge1xuXG4gICAgICAgIHRoaXMucGxvdC54LmludGVydmFsID0gdGhpcy5jb25maWcueC5pbnRlcnZhbDtcblxuICAgICAgICBpZighdGhpcy5wbG90LngudGltZUZvcm1hdCl7XG4gICAgICAgICAgICB0aGlzLmd1ZXNzVGltZUZvcm1hdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMucGxvdC54LmludGVydmFsICYmIHRoaXMucGxvdC54LnRpbWVGb3JtYXQpe1xuICAgICAgICAgICAgdGhpcy5ndWVzc0ludGVydmFsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBndWVzc1RpbWVGb3JtYXQoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBzZWxmLmNvbmZpZy54LmludGVydmFsVG9Gb3JtYXRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBpbnRlcnZhbEZvcm1hdCA9IHNlbGYuY29uZmlnLnguaW50ZXJ2YWxUb0Zvcm1hdHNbaV07XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBmb3JtYXRNYXRjaCA9IGludGVydmFsRm9ybWF0LmZvcm1hdHMuc29tZShmPT57XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZjtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gZDMudGltZVBhcnNlKGYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBsb3QueC51bmlxdWVWYWx1ZXMuZXZlcnkoeD0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyKHgpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKGZvcm1hdE1hdGNoKXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QueC50aW1lRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHdWVzc2VkIHRpbWVGb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGlmKCFzZWxmLnBsb3QueC5pbnRlcnZhbCl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxvdC54LmludGVydmFsID0gaW50ZXJ2YWxGb3JtYXQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0d1ZXNzZWQgaW50ZXJ2YWwnLCBzZWxmLnBsb3QueC5pbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGd1ZXNzSW50ZXJ2YWwoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBzZWxmLmNvbmZpZy54LmludGVydmFsVG9Gb3JtYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW50ZXJ2YWxGb3JtYXQgPSBzZWxmLmNvbmZpZy54LmludGVydmFsVG9Gb3JtYXRzW2ldO1xuXG4gICAgICAgICAgICBpZihpbnRlcnZhbEZvcm1hdC5mb3JtYXRzLmluZGV4T2Yoc2VsZi5wbG90LngudGltZUZvcm1hdCkgPj0gMCl7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90LnguaW50ZXJ2YWwgPSBpbnRlcnZhbEZvcm1hdC5uYW1lO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHdWVzc2VkIGludGVydmFsJywgc2VsZi5wbG90LnguaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZXRUaW1lRm9ybWF0dGVyKCkge1xuICAgICAgICBpZighdGhpcy5wbG90LngudGltZUZvcm1hdHRlcil7XG4gICAgICAgICAgICB0aGlzLnBsb3QueC50aW1lRm9ybWF0dGVyID0gZDMudGltZUZvcm1hdCh0aGlzLnBsb3QueC50aW1lRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wbG90LngudGltZUZvcm1hdHRlcjtcbiAgICB9XG4gICAgZ2V0VGltZVBhcnNlcigpIHtcbiAgICAgICAgaWYoIXRoaXMucGxvdC54LnRpbWVQYXJzZXIpe1xuICAgICAgICAgICAgdGhpcy5wbG90LngudGltZVBhcnNlciA9IGQzLnRpbWVQYXJzZSh0aGlzLnBsb3QueC50aW1lRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wbG90LngudGltZVBhcnNlcjtcbiAgICB9XG59XG5cbiIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7TGVnZW5kfSBmcm9tICcuL2xlZ2VuZCdcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBIZWF0bWFwQ29uZmlnIGV4dGVuZHMgQ2hhcnRDb25maWcge1xuXG4gICAgc3ZnQ2xhc3MgPSAnb2RjLWhlYXRtYXAnO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTsgLy9zaG93IHRvb2x0aXAgb24gZG90IGhvdmVyXG4gICAgdG9vbHRpcCA9IHtcbiAgICAgICAgbm9EYXRhVGV4dDogXCJOL0FcIlxuICAgIH07XG4gICAgc2hvd0xlZ2VuZCA9IHRydWU7XG4gICAgbGVnZW5kID0ge1xuICAgICAgICB3aWR0aDogMzAsXG4gICAgICAgIHJvdGF0ZUxhYmVsczogZmFsc2UsXG4gICAgICAgIGRlY2ltYWxQbGFjZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybWF0dGVyOiB2ID0+IHRoaXMubGVnZW5kLmRlY2ltYWxQbGFjZXMgPT09IHVuZGVmaW5lZCA/IHYgOiBOdW1iZXIodikudG9GaXhlZCh0aGlzLmxlZ2VuZC5kZWNpbWFsUGxhY2VzKVxuICAgIH1cbiAgICBoaWdobGlnaHRMYWJlbHMgPSB0cnVlO1xuICAgIHggPSB7Ly8gWCBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgdGl0bGVcbiAgICAgICAga2V5OiAwLFxuICAgICAgICB2YWx1ZTogKGQpID0+IGRbdGhpcy54LmtleV0sIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgcm90YXRlTGFiZWxzOiB0cnVlLFxuICAgICAgICBzb3J0TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgc29ydENvbXBhcmF0b3I6IChhLCBiKT0+IFV0aWxzLmlzTnVtYmVyKGEpID8gYSAtIGIgOiBhLmxvY2FsZUNvbXBhcmUoYiksXG4gICAgICAgIGdyb3Vwczoge1xuICAgICAgICAgICAga2V5czogW10sXG4gICAgICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IGRba2V5XSxcbiAgICAgICAgICAgIG92ZXJsYXA6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDIwLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogMjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQgLy8gdmFsdWUgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cbiAgICB9O1xuICAgIHkgPSB7Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgdGl0bGUsXG4gICAgICAgIHJvdGF0ZUxhYmVsczogdHJ1ZSxcbiAgICAgICAga2V5OiAxLFxuICAgICAgICB2YWx1ZTogKGQpID0+IGRbdGhpcy55LmtleV0sIC8vIHkgdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgc29ydExhYmVsczogZmFsc2UsXG4gICAgICAgIHNvcnRDb21wYXJhdG9yOiAoYSwgYik9PiBVdGlscy5pc051bWJlcihiKSA/IGIgLSBhIDogYi5sb2NhbGVDb21wYXJlKGEpLFxuICAgICAgICBncm91cHM6IHtcbiAgICAgICAgICAgIGtleXM6IFtdLFxuICAgICAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBkW2tleV0sXG4gICAgICAgICAgICBvdmVybGFwOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogMjAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDIwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLy8gdmFsdWUgZm9ybWF0dGVyIGZ1bmN0aW9uXG4gICAgfTtcbiAgICB6ID0ge1xuICAgICAgICBrZXk6IDIsXG4gICAgICAgIHZhbHVlOiAoZCkgPT4gZFt0aGlzLnoua2V5XSxcbiAgICAgICAgbm90QXZhaWxhYmxlVmFsdWU6ICh2KSA9PiB2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCxcblxuICAgICAgICBkZWNpbWFsUGxhY2VzOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1hdHRlcjogdiA9PiB0aGlzLnouZGVjaW1hbFBsYWNlcyA9PT0gdW5kZWZpbmVkID8gdiA6IE51bWJlcih2KS50b0ZpeGVkKHRoaXMuei5kZWNpbWFsUGxhY2VzKS8vIHZhbHVlIGZvcm1hdHRlciBmdW5jdGlvblxuXG4gICAgfTtcbiAgICBjb2xvciA9IHtcbiAgICAgICAgbm9EYXRhQ29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIHJldmVyc2VTY2FsZTogZmFsc2UsXG4gICAgICAgIHJhbmdlOiBbXCJkYXJrYmx1ZVwiLCBcImxpZ2h0c2t5Ymx1ZVwiLCBcIm9yYW5nZVwiLCBcImNyaW1zb25cIiwgXCJkYXJrcmVkXCJdXG4gICAgfTtcbiAgICBjZWxsID0ge1xuICAgICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZU1pbjogMTUsXG4gICAgICAgIHNpemVNYXg6IDI1MCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG4gICAgbWFyZ2luID0ge1xuICAgICAgICBsZWZ0OiA2MCxcbiAgICAgICAgcmlnaHQ6IDUwLFxuICAgICAgICB0b3A6IDMwLFxuICAgICAgICBib3R0b206IDgwXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoY3VzdG9tKSB7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vVE9ETyByZWZhY3RvclxuZXhwb3J0IGNsYXNzIEhlYXRtYXAgZXh0ZW5kcyBDaGFydCB7XG5cbiAgICBzdGF0aWMgbWF4R3JvdXBHYXBTaXplID0gMjQ7XG4gICAgc3RhdGljIGdyb3VwVGl0bGVSZWN0SGVpZ2h0ID0gNjtcblxuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgSGVhdG1hcENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IEhlYXRtYXBDb25maWcoY29uZmlnKSk7XG5cbiAgICB9XG5cbiAgICBpbml0UGxvdCgpIHtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbWFyZ2luID0gdGhpcy5jb25maWcubWFyZ2luO1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54ID0ge307XG4gICAgICAgIHRoaXMucGxvdC55ID0ge307XG4gICAgICAgIHRoaXMucGxvdC56ID0ge1xuICAgICAgICAgICAgbWF0cml4ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlbGxzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2xvcjoge30sXG4gICAgICAgICAgICBzaGFwZToge31cbiAgICAgICAgfTtcblxuXG4gICAgICAgIHRoaXMuc2V0dXBWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy5idWlsZENlbGxzKCk7XG5cbiAgICAgICAgdmFyIHRpdGxlUmVjdFdpZHRoID0gNjtcbiAgICAgICAgdGhpcy5wbG90Lngub3ZlcmxhcCA9IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSBzZWxmLmNvbmZpZy54Lmdyb3Vwcy5rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBhbGxUaXRsZXNXaWR0aCA9IGRlcHRoICogKHRpdGxlUmVjdFdpZHRoKTtcblxuICAgICAgICAgICAgdGhpcy5wbG90Lngub3ZlcmxhcC5ib3R0b20gPSBzZWxmLmNvbmZpZy54Lmdyb3Vwcy5vdmVybGFwLmJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMucGxvdC54Lm92ZXJsYXAudG9wID0gc2VsZi5jb25maWcueC5ncm91cHMub3ZlcmxhcC50b3AgKyBhbGxUaXRsZXNXaWR0aDtcbiAgICAgICAgICAgIHRoaXMucGxvdC5tYXJnaW4udG9wID0gdGhpcy5wbG90Lm1hcmdpbi50b3AgKyBjb25mLnguZ3JvdXBzLm92ZXJsYXAudG9wO1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5ib3R0b20gPSB0aGlzLnBsb3QubWFyZ2luLmJvdHRvbSArIGNvbmYueC5ncm91cHMub3ZlcmxhcC5ib3R0b207XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMucGxvdC55Lm92ZXJsYXAgPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgfTtcblxuXG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLmtleXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFsbFRpdGxlc1dpZHRoID0gZGVwdGggKiAodGl0bGVSZWN0V2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5wbG90Lnkub3ZlcmxhcC5yaWdodCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLm92ZXJsYXAubGVmdCArIGFsbFRpdGxlc1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5wbG90Lnkub3ZlcmxhcC5sZWZ0ID0gc2VsZi5jb25maWcueS5ncm91cHMub3ZlcmxhcC5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5sZWZ0ID0gdGhpcy5wbG90Lm1hcmdpbi5sZWZ0ICsgdGhpcy5wbG90Lnkub3ZlcmxhcC5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5yaWdodCA9IHRoaXMucGxvdC5tYXJnaW4ucmlnaHQgKyB0aGlzLnBsb3QueS5vdmVybGFwLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxvdC5zaG93TGVnZW5kID0gY29uZi5zaG93TGVnZW5kO1xuICAgICAgICBpZiAodGhpcy5wbG90LnNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5tYXJnaW4ucmlnaHQgKz0gY29uZi5sZWdlbmQud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgdGhpcy5zZXR1cFpTY2FsZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwVmFsdWVzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb25maWcgPSBzZWxmLmNvbmZpZztcbiAgICAgICAgdmFyIHggPSBzZWxmLnBsb3QueDtcbiAgICAgICAgdmFyIHkgPSBzZWxmLnBsb3QueTtcbiAgICAgICAgdmFyIHogPSBzZWxmLnBsb3QuejtcblxuXG4gICAgICAgIHgudmFsdWUgPSBkID0+IGNvbmZpZy54LnZhbHVlLmNhbGwoY29uZmlnLCBkKTtcbiAgICAgICAgeS52YWx1ZSA9IGQgPT4gY29uZmlnLnkudmFsdWUuY2FsbChjb25maWcsIGQpO1xuICAgICAgICB6LnZhbHVlID0gZCA9PiBjb25maWcuei52YWx1ZS5jYWxsKGNvbmZpZywgZCk7XG5cbiAgICAgICAgeC51bmlxdWVWYWx1ZXMgPSBbXTtcbiAgICAgICAgeS51bmlxdWVWYWx1ZXMgPSBbXTtcblxuXG4gICAgICAgIHNlbGYucGxvdC5ncm91cEJ5WSA9ICEhY29uZmlnLnkuZ3JvdXBzLmtleXMubGVuZ3RoO1xuICAgICAgICBzZWxmLnBsb3QuZ3JvdXBCeVggPSAhIWNvbmZpZy54Lmdyb3Vwcy5rZXlzLmxlbmd0aDtcblxuICAgICAgICB5Lmdyb3VwcyA9IHtcbiAgICAgICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIGxhc3RJbmRleDogMFxuICAgICAgICB9O1xuICAgICAgICB4Lmdyb3VwcyA9IHtcbiAgICAgICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIGxhc3RJbmRleDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB2YWx1ZU1hcCA9IHt9O1xuICAgICAgICB2YXIgbWluWiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG1heFogPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGQ9PiB7XG5cbiAgICAgICAgICAgIHZhciB4VmFsID0geC52YWx1ZShkKTtcbiAgICAgICAgICAgIHZhciB5VmFsID0geS52YWx1ZShkKTtcbiAgICAgICAgICAgIHZhciB6VmFsUmF3ID0gei52YWx1ZShkKTtcbiAgICAgICAgICAgIHZhciB6VmFsID0gY29uZmlnLnoubm90QXZhaWxhYmxlVmFsdWUoelZhbFJhdykgPyB1bmRlZmluZWQgOiBwYXJzZUZsb2F0KHpWYWxSYXcpO1xuXG5cbiAgICAgICAgICAgIGlmICh4LnVuaXF1ZVZhbHVlcy5pbmRleE9mKHhWYWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHgudW5pcXVlVmFsdWVzLnB1c2goeFZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5LnVuaXF1ZVZhbHVlcy5pbmRleE9mKHlWYWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHkudW5pcXVlVmFsdWVzLnB1c2goeVZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncm91cFkgPSB5Lmdyb3VwcztcbiAgICAgICAgICAgIGlmIChzZWxmLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgICAgICBncm91cFkgPSB0aGlzLnVwZGF0ZUdyb3VwcyhkLCB5VmFsLCB5Lmdyb3VwcywgY29uZmlnLnkuZ3JvdXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncm91cFggPSB4Lmdyb3VwcztcbiAgICAgICAgICAgIGlmIChzZWxmLnBsb3QuZ3JvdXBCeVgpIHtcblxuICAgICAgICAgICAgICAgIGdyb3VwWCA9IHRoaXMudXBkYXRlR3JvdXBzKGQsIHhWYWwsIHguZ3JvdXBzLCBjb25maWcueC5ncm91cHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlTWFwW2dyb3VwWS5pbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZU1hcFtncm91cFkuaW5kZXhdID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlTWFwW2dyb3VwWS5pbmRleF1bZ3JvdXBYLmluZGV4XVt5VmFsXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTWFwW2dyb3VwWS5pbmRleF1bZ3JvdXBYLmluZGV4XVt5VmFsXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdW3lWYWxdW3hWYWxdID0gelZhbDtcblxuXG4gICAgICAgICAgICBpZiAobWluWiA9PT0gdW5kZWZpbmVkIHx8IHpWYWwgPCBtaW5aKSB7XG4gICAgICAgICAgICAgICAgbWluWiA9IHpWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4WiA9PT0gdW5kZWZpbmVkIHx8IHpWYWwgPiBtYXhaKSB7XG4gICAgICAgICAgICAgICAgbWF4WiA9IHpWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnBsb3QudmFsdWVNYXAgPSB2YWx1ZU1hcDtcblxuXG4gICAgICAgIGlmICghc2VsZi5wbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICB4Lmdyb3Vwcy52YWx1ZXMgPSB4LnVuaXF1ZVZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZi5wbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICB5Lmdyb3Vwcy52YWx1ZXMgPSB5LnVuaXF1ZVZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dXBWYWx1ZXNCZWZvcmVHcm91cHNTb3J0KCk7XG5cbiAgICAgICAgeC5nYXBzID0gW107XG4gICAgICAgIHgudG90YWxWYWx1ZXNDb3VudCA9IDA7XG4gICAgICAgIHguYWxsVmFsdWVzTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnNvcnRHcm91cHMoeCwgeC5ncm91cHMsIGNvbmZpZy54KTtcblxuICAgICAgICB5LmdhcHMgPSBbXTtcbiAgICAgICAgeS50b3RhbFZhbHVlc0NvdW50ID0gMDtcbiAgICAgICAgeS5hbGxWYWx1ZXNMaXN0ID0gW107XG4gICAgICAgIHRoaXMuc29ydEdyb3Vwcyh5LCB5Lmdyb3VwcywgY29uZmlnLnkpO1xuXG4gICAgICAgIHoubWluID0gbWluWjtcbiAgICAgICAgei5tYXggPSBtYXhaO1xuXG4gICAgfVxuXG4gICAgc2V0dXBWYWx1ZXNCZWZvcmVHcm91cHNTb3J0KCkge1xuICAgIH1cblxuICAgIGJ1aWxkQ2VsbHMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBzZWxmLnBsb3QueDtcbiAgICAgICAgdmFyIHkgPSBzZWxmLnBsb3QueTtcbiAgICAgICAgdmFyIHogPSBzZWxmLnBsb3QuejtcbiAgICAgICAgdmFyIHZhbHVlTWFwID0gc2VsZi5wbG90LnZhbHVlTWFwO1xuXG4gICAgICAgIHZhciBtYXRyaXhDZWxscyA9IHNlbGYucGxvdC5jZWxscyA9IFtdO1xuICAgICAgICB2YXIgbWF0cml4ID0gc2VsZi5wbG90Lm1hdHJpeCA9IFtdO1xuXG4gICAgICAgIHkuYWxsVmFsdWVzTGlzdC5mb3JFYWNoKCh2MSwgaSk9PiB7XG4gICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICBtYXRyaXgucHVzaChyb3cpO1xuXG4gICAgICAgICAgICB4LmFsbFZhbHVlc0xpc3QuZm9yRWFjaCgodjIsIGopID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgelZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB6VmFsID0gdmFsdWVNYXBbdjEuZ3JvdXAuaW5kZXhdW3YyLmdyb3VwLmluZGV4XVt2MS52YWxdW3YyLnZhbF1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1ZhcjogdjEsXG4gICAgICAgICAgICAgICAgICAgIGNvbFZhcjogdjIsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogaSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiBqLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogelZhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcm93LnB1c2goY2VsbCk7XG5cbiAgICAgICAgICAgICAgICBtYXRyaXhDZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgdXBkYXRlR3JvdXBzKGQsIGF4aXNWYWwsIHJvb3RHcm91cCwgYXhpc0dyb3Vwc0NvbmZpZykge1xuXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IHJvb3RHcm91cDtcbiAgICAgICAgYXhpc0dyb3Vwc0NvbmZpZy5rZXlzLmZvckVhY2goKGdyb3VwS2V5LCBncm91cEtleUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAua2V5ID0gZ3JvdXBLZXk7XG5cbiAgICAgICAgICAgIGlmICghY3VycmVudEdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLmNoaWxkcmVuID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncm91cGluZ1ZhbHVlID0gYXhpc0dyb3Vwc0NvbmZpZy52YWx1ZS5jYWxsKGNvbmZpZywgZCwgZ3JvdXBLZXkpO1xuXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRHcm91cC5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShncm91cGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJvb3RHcm91cC5sYXN0SW5kZXgrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuY2hpbGRyZW5bZ3JvdXBpbmdWYWx1ZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBncm91cGluZ1ZhbHVlOiBncm91cGluZ1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudEdyb3VwLmxldmVsICsgMSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJvb3RHcm91cC5sYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZ3JvdXBLZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IGN1cnJlbnRHcm91cC5jaGlsZHJlbltncm91cGluZ1ZhbHVlXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRHcm91cC52YWx1ZXMuaW5kZXhPZihheGlzVmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC52YWx1ZXMucHVzaChheGlzVmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50R3JvdXA7XG4gICAgfVxuXG4gICAgc29ydEdyb3VwcyhheGlzLCBncm91cCwgYXhpc0NvbmZpZywgZ2Fwcykge1xuICAgICAgICBpZiAoYXhpc0NvbmZpZy5ncm91cHMubGFiZWxzICYmIGF4aXNDb25maWcuZ3JvdXBzLmxhYmVscy5sZW5ndGggPiBncm91cC5sZXZlbCkge1xuICAgICAgICAgICAgZ3JvdXAubGFiZWwgPSBheGlzQ29uZmlnLmdyb3Vwcy5sYWJlbHNbZ3JvdXAubGV2ZWxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXAubGFiZWwgPSBncm91cC5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdhcHMpIHtcbiAgICAgICAgICAgIGdhcHMgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdhcHMubGVuZ3RoIDw9IGdyb3VwLmxldmVsKSB7XG4gICAgICAgICAgICBnYXBzLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cC5hbGxWYWx1ZXNDb3VudCA9IGdyb3VwLmFsbFZhbHVlc0NvdW50IHx8IDA7XG4gICAgICAgIGdyb3VwLmFsbFZhbHVlc0JlZm9yZUNvdW50ID0gZ3JvdXAuYWxsVmFsdWVzQmVmb3JlQ291bnQgfHwgMDtcblxuICAgICAgICBncm91cC5nYXBzID0gZ2Fwcy5zbGljZSgpO1xuICAgICAgICBncm91cC5nYXBzQmVmb3JlID0gZ2Fwcy5zbGljZSgpO1xuXG5cbiAgICAgICAgZ3JvdXAuZ2Fwc1NpemUgPSBIZWF0bWFwLmNvbXB1dGVHYXBzU2l6ZShncm91cC5nYXBzKTtcbiAgICAgICAgZ3JvdXAuZ2Fwc0JlZm9yZVNpemUgPSBncm91cC5nYXBzU2l6ZTtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGF4aXNDb25maWcuc29ydExhYmVscykge1xuICAgICAgICAgICAgICAgIGdyb3VwLnZhbHVlcy5zb3J0KGF4aXNDb25maWcuc29ydENvbXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JvdXAudmFsdWVzLmZvckVhY2godj0+YXhpcy5hbGxWYWx1ZXNMaXN0LnB1c2goe3ZhbDogdiwgZ3JvdXA6IGdyb3VwfSkpO1xuICAgICAgICAgICAgZ3JvdXAuYWxsVmFsdWVzQmVmb3JlQ291bnQgPSBheGlzLnRvdGFsVmFsdWVzQ291bnQ7XG4gICAgICAgICAgICBheGlzLnRvdGFsVmFsdWVzQ291bnQgKz0gZ3JvdXAudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGdyb3VwLmFsbFZhbHVlc0NvdW50ICs9IGdyb3VwLnZhbHVlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cC5jaGlsZHJlbkxpc3QgPSBbXTtcbiAgICAgICAgaWYgKGdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5Db3VudCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNoaWxkUHJvcCBpbiBncm91cC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChncm91cC5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShjaGlsZFByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuW2NoaWxkUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmNoaWxkcmVuTGlzdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5Db3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydEdyb3VwcyhheGlzLCBjaGlsZCwgYXhpc0NvbmZpZywgZ2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFsbFZhbHVlc0NvdW50ICs9IGNoaWxkLmFsbFZhbHVlc0NvdW50O1xuICAgICAgICAgICAgICAgICAgICBnYXBzW2dyb3VwLmxldmVsXSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdhcHMgJiYgY2hpbGRyZW5Db3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICBnYXBzW2dyb3VwLmxldmVsXSAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5nYXBzSW5zaWRlID0gW107XG4gICAgICAgICAgICBnYXBzLmZvckVhY2goKGQsIGkpPT4ge1xuICAgICAgICAgICAgICAgIGdyb3VwLmdhcHNJbnNpZGUucHVzaChkIC0gKGdyb3VwLmdhcHNCZWZvcmVbaV0gfHwgMCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cC5nYXBzSW5zaWRlU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcHNTaXplKGdyb3VwLmdhcHNJbnNpZGUpO1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5nYXBzLmxlbmd0aCA8IGdhcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXhpcy5nYXBzID0gZ2FwcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29tcHV0ZVlBeGlzTGFiZWxzV2lkdGgob2Zmc2V0KSB7XG4gICAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMucGxvdC5tYXJnaW4ubGVmdDtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnkudGl0bGUpIHtcbiAgICAgICAgICAgIG1heFdpZHRoIC09IDE1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgJiYgb2Zmc2V0LngpIHtcbiAgICAgICAgICAgIG1heFdpZHRoICs9IG9mZnNldC54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnkucm90YXRlTGFiZWxzKSB7XG4gICAgICAgICAgICBtYXhXaWR0aCAqPSBVdGlscy5TUVJUXzI7XG4gICAgICAgICAgICB2YXIgZm9udFNpemUgPSAxMTsgLy90b2RvIGNoZWNrIGFjdHVhbCBmb250IHNpemVcbiAgICAgICAgICAgIG1heFdpZHRoIC09Zm9udFNpemUvMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9XG5cbiAgICBjb21wdXRlWEF4aXNMYWJlbHNXaWR0aChvZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy54LnJvdGF0ZUxhYmVscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdC5jZWxsV2lkdGggLSAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5wbG90Lm1hcmdpbi5ib3R0b207XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy54LnRpdGxlKSB7XG4gICAgICAgICAgICBzaXplIC09IDE1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgJiYgb2Zmc2V0LnkpIHtcbiAgICAgICAgICAgIHNpemUgLT0gb2Zmc2V0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBzaXplICo9IFV0aWxzLlNRUlRfMjtcblxuICAgICAgICB2YXIgZm9udFNpemUgPSAxMTsgLy90b2RvIGNoZWNrIGFjdHVhbCBmb250IHNpemVcbiAgICAgICAgc2l6ZSAtPWZvbnRTaXplLzI7XG5cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbXB1dGVHYXBTaXplKGdhcExldmVsKSB7XG4gICAgICAgIHJldHVybiBIZWF0bWFwLm1heEdyb3VwR2FwU2l6ZSAvIChnYXBMZXZlbCArIDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb21wdXRlR2Fwc1NpemUoZ2Fwcykge1xuICAgICAgICB2YXIgZ2Fwc1NpemUgPSAwO1xuICAgICAgICBnYXBzLmZvckVhY2goKGdhcHNOdW1iZXIsIGdhcHNMZXZlbCk9PiBnYXBzU2l6ZSArPSBnYXBzTnVtYmVyICogSGVhdG1hcC5jb21wdXRlR2FwU2l6ZShnYXBzTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGdhcHNTaXplO1xuICAgIH1cblxuICAgIGNvbXB1dGVQbG90U2l6ZSgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIG1hcmdpbiA9IHBsb3QubWFyZ2luO1xuICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBVdGlscy5hdmFpbGFibGVXaWR0aCh0aGlzLmNvbmZpZy53aWR0aCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIHRoaXMucGxvdC5tYXJnaW4pO1xuICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gVXRpbHMuYXZhaWxhYmxlSGVpZ2h0KHRoaXMuY29uZmlnLmhlaWdodCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIHRoaXMucGxvdC5tYXJnaW4pO1xuICAgICAgICB2YXIgd2lkdGggPSBhdmFpbGFibGVXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGF2YWlsYWJsZUhlaWdodDtcblxuICAgICAgICB2YXIgeEdhcHNTaXplID0gSGVhdG1hcC5jb21wdXRlR2Fwc1NpemUocGxvdC54LmdhcHMpO1xuXG5cbiAgICAgICAgdmFyIGNvbXB1dGVkQ2VsbFdpZHRoID0gTWF0aC5tYXgoY29uZi5jZWxsLnNpemVNaW4sIE1hdGgubWluKGNvbmYuY2VsbC5zaXplTWF4LCAoYXZhaWxhYmxlV2lkdGggLSB4R2Fwc1NpemUpIC8gdGhpcy5wbG90LngudG90YWxWYWx1ZXNDb3VudCkpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcud2lkdGgpIHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5jZWxsLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxXaWR0aCA9IGNvbXB1dGVkQ2VsbFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFdpZHRoID0gdGhpcy5jb25maWcuY2VsbC53aWR0aDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnBsb3QuY2VsbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxXaWR0aCA9IGNvbXB1dGVkQ2VsbFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggPSB0aGlzLnBsb3QuY2VsbFdpZHRoICogdGhpcy5wbG90LngudG90YWxWYWx1ZXNDb3VudCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0ICsgeEdhcHNTaXplO1xuXG4gICAgICAgIHZhciB5R2Fwc1NpemUgPSBIZWF0bWFwLmNvbXB1dGVHYXBzU2l6ZShwbG90LnkuZ2Fwcyk7XG4gICAgICAgIHZhciBjb21wdXRlZENlbGxIZWlnaHQgPSBNYXRoLm1heChjb25mLmNlbGwuc2l6ZU1pbiwgTWF0aC5taW4oY29uZi5jZWxsLnNpemVNYXgsIChhdmFpbGFibGVIZWlnaHQgLSB5R2Fwc1NpemUpIC8gdGhpcy5wbG90LnkudG90YWxWYWx1ZXNDb3VudCkpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNlbGwuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxIZWlnaHQgPSBjb21wdXRlZENlbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY2VsbEhlaWdodCA9IHRoaXMuY29uZmlnLmNlbGwuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucGxvdC5jZWxsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxIZWlnaHQgPSBjb21wdXRlZENlbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGhlaWdodCA9IHRoaXMucGxvdC5jZWxsSGVpZ2h0ICogdGhpcy5wbG90LnkudG90YWxWYWx1ZXNDb3VudCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgeUdhcHNTaXplO1xuXG5cbiAgICAgICAgdGhpcy5wbG90LndpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgdGhpcy5wbG90LmhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgIH1cblxuXG4gICAgc2V0dXBaU2NhbGUoKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnID0gc2VsZi5jb25maWc7XG4gICAgICAgIHZhciB6ID0gc2VsZi5wbG90Lno7XG4gICAgICAgIHZhciByYW5nZSA9IGNvbmZpZy5jb2xvci5yYW5nZTtcbiAgICAgICAgdmFyIGV4dGVudCA9IHoubWF4IC0gei5taW47XG4gICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgei5kb21haW4gPSBbXTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb2xvci5zY2FsZSA9PSBcInBvd1wiKSB7XG4gICAgICAgICAgICB2YXIgZXhwb25lbnQgPSAxMDtcbiAgICAgICAgICAgIHJhbmdlLmZvckVhY2goKGMsIGkpPT4ge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gei5tYXggLSAoZXh0ZW50IC8gTWF0aC5wb3coMTAsIGkpKTtcbiAgICAgICAgICAgICAgICB6LmRvbWFpbi5wdXNoKHYpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjYWxlID0gZDMuc2NhbGVQb3coKS5leHBvbmVudChleHBvbmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmNvbG9yLnNjYWxlID09IFwibG9nXCIpIHtcblxuICAgICAgICAgICAgcmFuZ2UuZm9yRWFjaCgoYywgaSk9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB6Lm1pbiArIChleHRlbnQgLyBNYXRoLnBvdygxMCwgaSkpO1xuICAgICAgICAgICAgICAgIHouZG9tYWluLnVuc2hpZnQodilcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNjYWxlID0gZDMuc2NhbGVMb2coKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UuZm9yRWFjaCgoYywgaSk9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB6Lm1pbiArIChleHRlbnQgKiAoaSAvIChyYW5nZS5sZW5ndGggLSAxKSkpO1xuICAgICAgICAgICAgICAgIHouZG9tYWluLnB1c2godilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25maWcuY29sb3Iuc2NhbGUpO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIHouZG9tYWluWzBdID0gei5taW47IC8vcmVtb3ZpbmcgdW5uZWNlc3NhcnkgZmxvYXRpbmcgcG9pbnRzXG4gICAgICAgIHouZG9tYWluW3ouZG9tYWluLmxlbmd0aCAtIDFdID0gei5tYXg7IC8vcmVtb3ZpbmcgdW5uZWNlc3NhcnkgZmxvYXRpbmcgcG9pbnRzXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHouZG9tYWluKTtcblxuICAgICAgICBpZiAoY29uZmlnLmNvbG9yLnJldmVyc2VTY2FsZSkge1xuICAgICAgICAgICAgei5kb21haW4ucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2cocmFuZ2UpO1xuXG4gICAgICAgIHBsb3Quei5jb2xvci5zY2FsZSA9IHNjYWxlLmRvbWFpbih6LmRvbWFpbikucmFuZ2UocmFuZ2UpO1xuICAgICAgICB2YXIgc2hhcGUgPSBwbG90Lnouc2hhcGUgPSB7fTtcblxuICAgICAgICB2YXIgY2VsbENvbmYgPSB0aGlzLmNvbmZpZy5jZWxsO1xuICAgICAgICBzaGFwZS50eXBlID0gXCJyZWN0XCI7XG5cbiAgICAgICAgcGxvdC56LnNoYXBlLndpZHRoID0gcGxvdC5jZWxsV2lkdGggLSBjZWxsQ29uZi5wYWRkaW5nICogMjtcbiAgICAgICAgcGxvdC56LnNoYXBlLmhlaWdodCA9IHBsb3QuY2VsbEhlaWdodCAtIGNlbGxDb25mLnBhZGRpbmcgKiAyO1xuICAgIH1cblxuXG4gICAgdXBkYXRlKG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICBpZiAodGhpcy5wbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHcm91cHNZKHRoaXMucGxvdC55Lmdyb3VwcywgdGhpcy5zdmdHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHcm91cHNYKHRoaXMucGxvdC54Lmdyb3VwcywgdGhpcy5zdmdHKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlQ2VsbHMoKTtcblxuICAgICAgICAvLyB0aGlzLnVwZGF0ZVZhcmlhYmxlTGFiZWxzKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVBeGlzWCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNZKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGVnZW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNUaXRsZXMoKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlQXhpc1RpdGxlcygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcblxuXG4gICAgfVxuXG5cbiAgICB1cGRhdGVBeGlzWCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGxhYmVsQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwibGFiZWxcIik7XG4gICAgICAgIHZhciBsYWJlbFhDbGFzcyA9IGxhYmVsQ2xhc3MgKyBcIi14XCI7XG4gICAgICAgIHZhciBsYWJlbFlDbGFzcyA9IGxhYmVsQ2xhc3MgKyBcIi15XCI7XG4gICAgICAgIHBsb3QubGFiZWxDbGFzcyA9IGxhYmVsQ2xhc3M7XG5cbiAgICAgICAgdmFyIG9mZnNldFggPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgIGlmIChwbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxhcCA9IHNlbGYuY29uZmlnLnguZ3JvdXBzLm92ZXJsYXA7XG5cbiAgICAgICAgICAgIG9mZnNldFgueCA9IGdhcFNpemUgLyAyO1xuICAgICAgICAgICAgb2Zmc2V0WC55ID0gb3ZlcmxhcC5ib3R0b20gKyBnYXBTaXplIC8gMiArIDY7XG4gICAgICAgIH0gZWxzZSBpZiAocGxvdC5ncm91cEJ5WSkge1xuICAgICAgICAgICAgb2Zmc2V0WC55ID0gZ2FwU2l6ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgbGFiZWxYQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnguYWxsVmFsdWVzTGlzdCwgKGQsIGkpPT5pKTtcblxuICAgICAgICB2YXIgbGFiZWxzTWVyZ2UgPSBsYWJlbHMuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gbGFiZWxDbGFzcyArIFwiIFwiICsgbGFiZWxYQ2xhc3MgKyBcIiBcIiArIGxhYmVsWENsYXNzICsgXCItXCIgKyBpKS5tZXJnZShsYWJlbHMpO1xuXG4gICAgICAgIGxhYmVsc01lcmdlXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IChpICogcGxvdC5jZWxsV2lkdGggKyBwbG90LmNlbGxXaWR0aCAvIDIpICsgKGQuZ3JvdXAuZ2Fwc1NpemUpICsgb2Zmc2V0WC54KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHBsb3QuaGVpZ2h0ICsgb2Zmc2V0WC55KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMClcblxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoZD0+c2VsZi5mb3JtYXRWYWx1ZVgoZC52YWwpKTtcblxuXG5cbiAgICAgICAgdmFyIG1heFdpZHRoID0gc2VsZi5jb21wdXRlWEF4aXNMYWJlbHNXaWR0aChvZmZzZXRYKTtcblxuICAgICAgICBsYWJlbHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGV4dCA9IHNlbGYuZm9ybWF0VmFsdWVYKGxhYmVsLnZhbCk7XG4gICAgICAgICAgICBVdGlscy5wbGFjZVRleHRXaXRoRWxsaXBzaXNBbmRUb29sdGlwKGVsZW0sIHRleHQsIG1heFdpZHRoLCBzZWxmLmNvbmZpZy5zaG93VG9vbHRpcCA/IHNlbGYucGxvdC50b29sdGlwIDogZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5jb25maWcueC5yb3RhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGxhYmVsc01lcmdlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IFwicm90YXRlKC00NSwgXCIgKyAoKGkgKiBwbG90LmNlbGxXaWR0aCArIHBsb3QuY2VsbFdpZHRoIC8gMikgKyBkLmdyb3VwLmdhcHNTaXplICsgb2Zmc2V0WC54ICkgKyBcIiwgXCIgKyAoIHBsb3QuaGVpZ2h0ICsgb2Zmc2V0WC55KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgLTIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCA4KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxhYmVscy5leGl0KCkucmVtb3ZlKCk7XG5cblxuICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy14JykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChwbG90LndpZHRoIC8gMikgKyBcIixcIiArIChwbG90LmhlaWdodCArIHBsb3QubWFyZ2luLmJvdHRvbSkgKyBcIilcIilcbiAgICAgICAgICAgIC5zZWxlY3RPckFwcGVuZChcInRleHQuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTAuNWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoc2VsZi5jb25maWcueC50aXRsZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBsYWJlbENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImxhYmVsXCIpO1xuICAgICAgICB2YXIgbGFiZWxZQ2xhc3MgPSBsYWJlbENsYXNzICsgXCIteVwiO1xuICAgICAgICBwbG90LmxhYmVsQ2xhc3MgPSBsYWJlbENsYXNzO1xuXG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgbGFiZWxZQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnkuYWxsVmFsdWVzTGlzdCk7XG5cbiAgICAgICAgdmFyIGxhYmVsc0VudGVyID0gbGFiZWxzLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKTtcbiAgICAgICAgdmFyIGxhYmVsc01lcmdlID0gbGFiZWxzRW50ZXIubWVyZ2UobGFiZWxzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0WSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxhcCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLm92ZXJsYXA7XG4gICAgICAgICAgICBsZXQgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgICAgICBvZmZzZXRZLnggPSAtb3ZlcmxhcC5sZWZ0O1xuXG4gICAgICAgICAgICBvZmZzZXRZLnkgPSBnYXBTaXplIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIG9mZnNldFkueClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAoZCwgaSkgPT4gKGkgKiBwbG90LmNlbGxIZWlnaHQgKyBwbG90LmNlbGxIZWlnaHQgLyAyKSArIGQuZ3JvdXAuZ2Fwc1NpemUgKyBvZmZzZXRZLnkpXG4gICAgICAgICAgICAuYXR0cihcImR4XCIsIC0yKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gbGFiZWxDbGFzcyArIFwiIFwiICsgbGFiZWxZQ2xhc3MgKyBcIiBcIiArIGxhYmVsWUNsYXNzICsgXCItXCIgKyBpKVxuXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSBzZWxmLmZvcm1hdFZhbHVlWShkLnZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1heFdpZHRoID0gc2VsZi5jb21wdXRlWUF4aXNMYWJlbHNXaWR0aChvZmZzZXRZKTtcblxuICAgICAgICBsYWJlbHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGV4dCA9IHNlbGYuZm9ybWF0VmFsdWVZKGxhYmVsLnZhbCk7XG4gICAgICAgICAgICBVdGlscy5wbGFjZVRleHRXaXRoRWxsaXBzaXNBbmRUb29sdGlwKGVsZW0sIHRleHQsIG1heFdpZHRoLCBzZWxmLmNvbmZpZy5zaG93VG9vbHRpcCA/IHNlbGYucGxvdC50b29sdGlwIDogZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5jb25maWcueS5yb3RhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGxhYmVsc01lcmdlXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IFwicm90YXRlKC00NSwgXCIgKyAob2Zmc2V0WS54ICApICsgXCIsIFwiICsgKGQuZ3JvdXAuZ2Fwc1NpemUgKyAoaSAqIHBsb3QuY2VsbEhlaWdodCArIHBsb3QuY2VsbEhlaWdodCAvIDIpICsgb2Zmc2V0WS55KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG4gICAgICAgICAgICAvLyAuYXR0cihcImR4XCIsIC03KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsc01lcmdlLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKVxuICAgICAgICB9XG5cblxuICAgICAgICBsYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xuXG5cbiAgICAgICAgc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpKVxuICAgICAgICAgICAgLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1wbG90Lm1hcmdpbi5sZWZ0ICsgXCIsXCIgKyAocGxvdC5oZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoc2VsZi5jb25maWcueS50aXRsZSk7XG5cbiAgICB9XG5cblxuICAgIGRyYXdHcm91cHNZKHBhcmVudEdyb3VwLCBjb250YWluZXIsIGF2YWlsYWJsZVdpZHRoKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcblxuICAgICAgICB2YXIgZ3JvdXBDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJncm91cFwiKTtcbiAgICAgICAgdmFyIGdyb3VwWUNsYXNzID0gZ3JvdXBDbGFzcyArIFwiLXlcIjtcbiAgICAgICAgdmFyIGdyb3VwcyA9IGNvbnRhaW5lci5zZWxlY3RBbGwoXCJnLlwiICsgZ3JvdXBDbGFzcyArIFwiLlwiICsgZ3JvdXBZQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwYXJlbnRHcm91cC5jaGlsZHJlbkxpc3QpO1xuXG4gICAgICAgIHZhciB2YWx1ZXNCZWZvcmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBnYXBzQmVmb3JlU2l6ZSA9IDA7XG5cbiAgICAgICAgdmFyIGdyb3Vwc0VudGVyID0gZ3JvdXBzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgZ3JvdXBzRW50ZXJcbiAgICAgICAgICAgIC5jbGFzc2VkKGdyb3VwQ2xhc3MsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZChncm91cFlDbGFzcywgdHJ1ZSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpLmNsYXNzZWQoXCJncm91cC1yZWN0XCIsIHRydWUpO1xuXG4gICAgICAgIHZhciB0aXRsZUdyb3VwRW50ZXIgPSBncm91cHNFbnRlci5hcHBlbmRTZWxlY3RvcihcImcudGl0bGVcIik7XG4gICAgICAgIHRpdGxlR3JvdXBFbnRlci5hcHBlbmQoXCJyZWN0XCIpO1xuICAgICAgICB0aXRsZUdyb3VwRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuICAgICAgICB2YXIgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUocGFyZW50R3JvdXAubGV2ZWwpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IGdhcFNpemUgLyA0O1xuXG4gICAgICAgIHZhciB0aXRsZVJlY3RXaWR0aCA9IEhlYXRtYXAuZ3JvdXBUaXRsZVJlY3RIZWlnaHQ7XG4gICAgICAgIHZhciBkZXB0aCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLmtleXMubGVuZ3RoIC0gcGFyZW50R3JvdXAubGV2ZWw7XG4gICAgICAgIHZhciBvdmVybGFwID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFhdmFpbGFibGVXaWR0aCkge1xuICAgICAgICAgICAgb3ZlcmxhcC5yaWdodCA9IHBsb3QueS5vdmVybGFwLmxlZnQ7XG4gICAgICAgICAgICBvdmVybGFwLmxlZnQgPSBwbG90Lnkub3ZlcmxhcC5sZWZ0O1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBwbG90LndpZHRoICsgZ2FwU2l6ZSArIG92ZXJsYXAubGVmdCArIG92ZXJsYXAucmlnaHQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBncm91cHNNZXJnZSA9IGdyb3Vwc0VudGVyLm1lcmdlKGdyb3Vwcyk7XG5cbiAgICAgICAgZ3JvdXBzTWVyZ2VcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiICsgKHBhZGRpbmcgLSBvdmVybGFwLmxlZnQpICsgXCIsXCIgKyAoKHBsb3QuY2VsbEhlaWdodCAqIHZhbHVlc0JlZm9yZUNvdW50KSArIGkgKiBnYXBTaXplICsgZ2Fwc0JlZm9yZVNpemUgKyBwYWRkaW5nKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIGdhcHNCZWZvcmVTaXplICs9IChkLmdhcHNJbnNpZGVTaXplIHx8IDApO1xuICAgICAgICAgICAgICAgIHZhbHVlc0JlZm9yZUNvdW50ICs9IGQuYWxsVmFsdWVzQ291bnQgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIHZhciBncm91cFdpZHRoID0gYXZhaWxhYmxlV2lkdGggLSBwYWRkaW5nICogMjtcblxuICAgICAgICB2YXIgdGl0bGVHcm91cHMgPSBncm91cHNNZXJnZS5zZWxlY3RBbGwoXCJnLnRpdGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJ0cmFuc2xhdGUoXCIgKyAoZ3JvdXBXaWR0aCAtIHRpdGxlUmVjdFdpZHRoKSArIFwiLCAwKVwiKTtcblxuICAgICAgICB2YXIgdGlsZVJlY3RzID0gdGl0bGVHcm91cHMuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB0aXRsZVJlY3RXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQ9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkLmdhcHNJbnNpZGVTaXplIHx8IDApICsgcGxvdC5jZWxsSGVpZ2h0ICogZC5hbGxWYWx1ZXNDb3VudCArIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgICAgICAgIC8vIC5hdHRyKFwiZmlsbFwiLCBcImxpZ2h0Z3JleVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMCk7XG5cbiAgICAgICAgdGhpcy5zZXRHcm91cE1vdXNlQ2FsbGJhY2tzKHBhcmVudEdyb3VwLCB0aWxlUmVjdHMpO1xuXG5cbiAgICAgICAgZ3JvdXBzTWVyZ2Uuc2VsZWN0QWxsKFwicmVjdC5ncm91cC1yZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQ9PiBcImdyb3VwLXJlY3QgZ3JvdXAtcmVjdC1cIiArIGQuaW5kZXgpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGdyb3VwV2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZC5nYXBzSW5zaWRlU2l6ZSB8fCAwKSArIHBsb3QuY2VsbEhlaWdodCAqIGQuYWxsVmFsdWVzQ291bnQgKyBwYWRkaW5nICogMlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJ3aGl0ZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDAuNSlcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcblxuXG4gICAgICAgIGdyb3Vwc01lcmdlLmVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG5cbiAgICAgICAgICAgIHNlbGYuZHJhd0dyb3Vwc1kuY2FsbChzZWxmLCBncm91cCwgZDMuc2VsZWN0KHRoaXMpLCBncm91cFdpZHRoIC0gdGl0bGVSZWN0V2lkdGgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGRyYXdHcm91cHNYKHBhcmVudEdyb3VwLCBjb250YWluZXIsIGF2YWlsYWJsZUhlaWdodCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG5cbiAgICAgICAgdmFyIGdyb3VwQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiZ3JvdXBcIik7XG4gICAgICAgIHZhciBncm91cFhDbGFzcyA9IGdyb3VwQ2xhc3MgKyBcIi14XCI7XG4gICAgICAgIHZhciBncm91cHMgPSBjb250YWluZXIuc2VsZWN0QWxsKFwiZy5cIiArIGdyb3VwQ2xhc3MgKyBcIi5cIiArIGdyb3VwWENsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGFyZW50R3JvdXAuY2hpbGRyZW5MaXN0KTtcblxuICAgICAgICB2YXIgdmFsdWVzQmVmb3JlQ291bnQgPSAwO1xuICAgICAgICB2YXIgZ2Fwc0JlZm9yZVNpemUgPSAwO1xuXG4gICAgICAgIHZhciBncm91cHNFbnRlciA9IGdyb3Vwcy5lbnRlcigpLmFwcGVuZChcImdcIik7XG4gICAgICAgIGdyb3Vwc0VudGVyXG4gICAgICAgICAgICAuY2xhc3NlZChncm91cENsYXNzLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoZ3JvdXBYQ2xhc3MsIHRydWUpXG4gICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKS5jbGFzc2VkKFwiZ3JvdXAtcmVjdFwiLCB0cnVlKTtcblxuICAgICAgICB2YXIgdGl0bGVHcm91cEVudGVyID0gZ3JvdXBzRW50ZXIuYXBwZW5kU2VsZWN0b3IoXCJnLnRpdGxlXCIpO1xuICAgICAgICB0aXRsZUdyb3VwRW50ZXIuYXBwZW5kKFwicmVjdFwiKTtcbiAgICAgICAgdGl0bGVHcm91cEVudGVyLmFwcGVuZChcInRleHRcIik7XG5cbiAgICAgICAgdmFyIGdhcFNpemUgPSBIZWF0bWFwLmNvbXB1dGVHYXBTaXplKHBhcmVudEdyb3VwLmxldmVsKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBnYXBTaXplIC8gNDtcbiAgICAgICAgdmFyIHRpdGxlUmVjdEhlaWdodCA9IEhlYXRtYXAuZ3JvdXBUaXRsZVJlY3RIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGRlcHRoID0gc2VsZi5jb25maWcueC5ncm91cHMua2V5cy5sZW5ndGggLSBwYXJlbnRHcm91cC5sZXZlbDtcblxuICAgICAgICB2YXIgb3ZlcmxhcCA9IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICBvdmVybGFwLmJvdHRvbSA9IHBsb3QueC5vdmVybGFwLmJvdHRvbTtcbiAgICAgICAgICAgIG92ZXJsYXAudG9wID0gcGxvdC54Lm92ZXJsYXAudG9wO1xuICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gcGxvdC5oZWlnaHQgKyBnYXBTaXplICsgb3ZlcmxhcC50b3AgKyBvdmVybGFwLmJvdHRvbTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcmxhcC50b3AgPSAtdGl0bGVSZWN0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJlbnRHcm91cCcscGFyZW50R3JvdXAsICdnYXBTaXplJywgZ2FwU2l6ZSwgcGxvdC54Lm92ZXJsYXApO1xuXG4gICAgICAgIHZhciBncm91cHNNZXJnZSA9IGdyb3Vwc0VudGVyLm1lcmdlKGdyb3Vwcyk7XG5cbiAgICAgICAgZ3JvdXBzTWVyZ2VcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiICsgKChwbG90LmNlbGxXaWR0aCAqIHZhbHVlc0JlZm9yZUNvdW50KSArIGkgKiBnYXBTaXplICsgZ2Fwc0JlZm9yZVNpemUgKyBwYWRkaW5nKSArIFwiLCBcIiArIChwYWRkaW5nIC0gb3ZlcmxhcC50b3ApICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgZ2Fwc0JlZm9yZVNpemUgKz0gKGQuZ2Fwc0luc2lkZVNpemUgfHwgMCk7XG4gICAgICAgICAgICAgICAgdmFsdWVzQmVmb3JlQ291bnQgKz0gZC5hbGxWYWx1ZXNDb3VudCB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBncm91cEhlaWdodCA9IGF2YWlsYWJsZUhlaWdodCAtIHBhZGRpbmcgKiAyO1xuXG4gICAgICAgIHZhciB0aXRsZUdyb3VwcyA9IGdyb3Vwc01lcmdlLnNlbGVjdEFsbChcImcudGl0bGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInRyYW5zbGF0ZSgwLCBcIiArICgwKSArIFwiKVwiKTtcblxuXG4gICAgICAgIHZhciB0aWxlUmVjdHMgPSB0aXRsZUdyb3Vwcy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB0aXRsZVJlY3RIZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGQ9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkLmdhcHNJbnNpZGVTaXplIHx8IDApICsgcGxvdC5jZWxsV2lkdGggKiBkLmFsbFZhbHVlc0NvdW50ICsgcGFkZGluZyAqIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJmaWxsXCIsIFwibGlnaHRncmV5XCIpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAwKTtcblxuICAgICAgICB0aGlzLnNldEdyb3VwTW91c2VDYWxsYmFja3MocGFyZW50R3JvdXAsIHRpbGVSZWN0cyk7XG5cblxuICAgICAgICBncm91cHNNZXJnZS5zZWxlY3RBbGwoXCJyZWN0Lmdyb3VwLXJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZD0+IFwiZ3JvdXAtcmVjdCBncm91cC1yZWN0LVwiICsgZC5pbmRleClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGdyb3VwSGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBkPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZC5nYXBzSW5zaWRlU2l6ZSB8fCAwKSArIHBsb3QuY2VsbFdpZHRoICogZC5hbGxWYWx1ZXNDb3VudCArIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIndoaXRlXCIpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMC41KVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcblxuICAgICAgICBncm91cHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgc2VsZi5kcmF3R3JvdXBzWC5jYWxsKHNlbGYsIGdyb3VwLCBkMy5zZWxlY3QodGhpcyksIGdyb3VwSGVpZ2h0IC0gdGl0bGVSZWN0SGVpZ2h0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIH1cblxuICAgIHNldEdyb3VwTW91c2VDYWxsYmFja3MocGFyZW50R3JvdXAsIHRpbGVSZWN0cykge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbW91c2VvdmVyQ2FsbGJhY2tzID0gW107XG4gICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwicmVjdC5ncm91cC1yZWN0LVwiICsgZC5pbmRleCkuY2xhc3NlZCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1vdXNlb3V0Q2FsbGJhY2tzID0gW107XG4gICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwicmVjdC5ncm91cC1yZWN0LVwiICsgZC5pbmRleCkuY2xhc3NlZCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG5cbiAgICAgICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5wdXNoKGQ9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBwYXJlbnRHcm91cC5sYWJlbCArIFwiOiBcIiArIGQuZ3JvdXBpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goZD0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH1cbiAgICAgICAgdGlsZVJlY3RzLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYsIGQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRpbGVSZWN0cy5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBtb3VzZW91dENhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZiwgZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVDZWxscygpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgY2VsbENvbnRhaW5lckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImNlbGxzXCIpO1xuICAgICAgICB2YXIgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgIHZhciBwYWRkaW5nWCA9IHBsb3QueC5ncm91cHMuY2hpbGRyZW5MaXN0Lmxlbmd0aCA/IGdhcFNpemUgLyAyIDogMDtcbiAgICAgICAgdmFyIHBhZGRpbmdZID0gcGxvdC55Lmdyb3Vwcy5jaGlsZHJlbkxpc3QubGVuZ3RoID8gZ2FwU2l6ZSAvIDIgOiAwO1xuICAgICAgICB2YXIgY2VsbENvbnRhaW5lciA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBjZWxsQ29udGFpbmVyQ2xhc3MpO1xuICAgICAgICBjZWxsQ29udGFpbmVyLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBwYWRkaW5nWCArIFwiLCBcIiArIHBhZGRpbmdZICsgXCIpXCIpO1xuXG4gICAgICAgIHZhciBjZWxsQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiY2VsbFwiKTtcbiAgICAgICAgdmFyIGNlbGxTaGFwZSA9IHBsb3Quei5zaGFwZS50eXBlO1xuXG4gICAgICAgIHZhciBjZWxscyA9IGNlbGxDb250YWluZXIuc2VsZWN0QWxsKFwiZy5cIiArIGNlbGxDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHNlbGYucGxvdC5jZWxscyk7XG5cbiAgICAgICAgdmFyIGNlbGxFbnRlciA9IGNlbGxzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmNsYXNzZWQoY2VsbENsYXNzLCB0cnVlKTtcblxuICAgICAgICB2YXIgY2VsbHNNZXJnZSA9IGNlbGxFbnRlci5tZXJnZShjZWxscyk7XG4gICAgICAgIGNlbGxzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCBjPT4gXCJ0cmFuc2xhdGUoXCIgKyAoKHBsb3QuY2VsbFdpZHRoICogYy5jb2wgKyBwbG90LmNlbGxXaWR0aCAvIDIpICsgYy5jb2xWYXIuZ3JvdXAuZ2Fwc1NpemUpICsgXCIsXCIgKyAoKHBsb3QuY2VsbEhlaWdodCAqIGMucm93ICsgcGxvdC5jZWxsSGVpZ2h0IC8gMikgKyBjLnJvd1Zhci5ncm91cC5nYXBzU2l6ZSkgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IGNlbGxzTWVyZ2Uuc2VsZWN0T3JBcHBlbmQoY2VsbFNoYXBlICsgXCIuY2VsbC1zaGFwZS1cIiArIGNlbGxTaGFwZSk7XG5cbiAgICAgICAgc2hhcGVzXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHBsb3Quei5zaGFwZS53aWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBsb3Quei5zaGFwZS5oZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgLXBsb3QuY2VsbFdpZHRoIC8gMilcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtcGxvdC5jZWxsSGVpZ2h0IC8gMik7XG5cbiAgICAgICAgc2hhcGVzLnN0eWxlKFwiZmlsbFwiLCBjPT4gYy52YWx1ZSA9PT0gdW5kZWZpbmVkID8gc2VsZi5jb25maWcuY29sb3Iubm9EYXRhQ29sb3IgOiBwbG90LnouY29sb3Iuc2NhbGUoYy52YWx1ZSkpO1xuICAgICAgICBzaGFwZXMuYXR0cihcImZpbGwtb3BhY2l0eVwiLCBkPT4gZC52YWx1ZSA9PT0gdW5kZWZpbmVkID8gMCA6IDEpO1xuXG4gICAgICAgIHZhciBtb3VzZW92ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIG1vdXNlb3V0Q2FsbGJhY2tzID0gW107XG5cbiAgICAgICAgaWYgKHBsb3QudG9vbHRpcCkge1xuXG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MucHVzaChjPT4ge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gYy52YWx1ZSA9PT0gdW5kZWZpbmVkID8gc2VsZi5jb25maWcudG9vbHRpcC5ub0RhdGFUZXh0IDogc2VsZi5mb3JtYXRWYWx1ZVooYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChodG1sKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goYz0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5oaWdobGlnaHRMYWJlbHMpIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHRDbGFzcyA9IHNlbGYuY29uZmlnLmNzc0NsYXNzUHJlZml4ICsgXCJoaWdobGlnaHRcIjtcbiAgICAgICAgICAgIHZhciB4TGFiZWxDbGFzcyA9IGM9PnBsb3QubGFiZWxDbGFzcyArIFwiLXgtXCIgKyBjLmNvbDtcbiAgICAgICAgICAgIHZhciB5TGFiZWxDbGFzcyA9IGM9PnBsb3QubGFiZWxDbGFzcyArIFwiLXktXCIgKyBjLnJvdztcblxuXG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MucHVzaChjPT4ge1xuXG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB4TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB5TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goYz0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIHhMYWJlbENsYXNzKGMpKS5jbGFzc2VkKGhpZ2hsaWdodENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB5TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNlbGxzTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgYyA9PiB7XG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjaz0+Y2FsbGJhY2soYykpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgYyA9PiB7XG4gICAgICAgICAgICAgICAgbW91c2VvdXRDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjaz0+Y2FsbGJhY2soYykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY2VsbHNNZXJnZS5vbihcImNsaWNrXCIsIGM9PiB7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJjZWxsLXNlbGVjdGVkXCIsIGMpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmb3JtYXRWYWx1ZVgodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy54LmZvcm1hdHRlcikgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy54LmZvcm1hdHRlci5jYWxsKHRoaXMuY29uZmlnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0VmFsdWVZKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcueS5mb3JtYXR0ZXIpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcueS5mb3JtYXR0ZXIuY2FsbCh0aGlzLmNvbmZpZywgdmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdFZhbHVlWih2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnouZm9ybWF0dGVyKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnouZm9ybWF0dGVyLmNhbGwodGhpcy5jb25maWcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXRMZWdlbmRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmxlZ2VuZC5mb3JtYXR0ZXIpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubGVnZW5kLmZvcm1hdHRlci5jYWxsKHRoaXMuY29uZmlnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlTGVnZW5kKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgbGVnZW5kWCA9IHRoaXMucGxvdC53aWR0aCArIDEwO1xuICAgICAgICB2YXIgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIGxlZ2VuZFggKz0gZ2FwU2l6ZSAvIDIgKyBwbG90Lnkub3ZlcmxhcC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVgpIHtcbiAgICAgICAgICAgIGxlZ2VuZFggKz0gZ2FwU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVnZW5kWSA9IDA7XG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVggfHwgdGhpcy5wbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICBsZWdlbmRZICs9IGdhcFNpemUgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhcldpZHRoID0gMTA7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSB0aGlzLnBsb3QuaGVpZ2h0IC0gMjtcbiAgICAgICAgdmFyIHNjYWxlID0gcGxvdC56LmNvbG9yLnNjYWxlO1xuXG4gICAgICAgIHBsb3QubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLnN2ZywgdGhpcy5zdmdHLCBzY2FsZSwgbGVnZW5kWCwgbGVnZW5kWSwgdiA9PiBzZWxmLmZvcm1hdExlZ2VuZFZhbHVlKHYpKS5zZXRSb3RhdGVMYWJlbHMoc2VsZi5jb25maWcubGVnZW5kLnJvdGF0ZUxhYmVscykubGluZWFyR3JhZGllbnRCYXIoYmFyV2lkdGgsIGJhckhlaWdodCk7XG4gICAgfVxuXG5cbn1cbiIsImltcG9ydCB7Q2hhcnRXaXRoQ29sb3JHcm91cHMsIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBIaXN0b2dyYW1Db25maWcgZXh0ZW5kcyBDaGFydFdpdGhDb2xvckdyb3Vwc0NvbmZpZ3tcblxuICAgIHN2Z0NsYXNzPSB0aGlzLmNzc0NsYXNzUHJlZml4KydoaXN0b2dyYW0nO1xuICAgIHNob3dMZWdlbmQ9dHJ1ZTtcbiAgICBzaG93VG9vbHRpcCA9dHJ1ZTtcbiAgICB4PXsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbFxuICAgICAgICBrZXk6IDAsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBVdGlscy5pc051bWJlcihkKSA/IGQgOiBwYXJzZUZsb2F0KGRba2V5XSksIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIG9yaWVudDogXCJib3R0b21cIixcbiAgICAgICAgdGlja3M6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHk9ey8vIFkgYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsLFxuICAgICAgICBvcmllbnQ6IFwibGVmdFwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgZnJlcXVlbmN5PXRydWU7XG4gICAgZ3JvdXBzPXtcbiAgICAgICAga2V5OiAxXG4gICAgfTtcbiAgICB0cmFuc2l0aW9uPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBpZihjdXN0b20pe1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIaXN0b2dyYW0gZXh0ZW5kcyBDaGFydFdpdGhDb2xvckdyb3Vwc3tcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEhpc3RvZ3JhbUNvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKXtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgSGlzdG9ncmFtQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGluaXRQbG90KCl7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG5cbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB0aGlzLnBsb3QueD17fTtcbiAgICAgICAgdGhpcy5wbG90Lnk9e307XG4gICAgICAgIHRoaXMucGxvdC5iYXI9e1xuICAgICAgICAgICAgY29sb3I6IG51bGwvL2NvbG9yIHNjYWxlIG1hcHBpbmcgZnVuY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY29tcHV0ZVBsb3RTaXplKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldHVwWCgpO1xuICAgICAgICB0aGlzLnNldHVwSGlzdG9ncmFtKCk7XG4gICAgICAgIHRoaXMuc2V0dXBHcm91cFN0YWNrcygpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFgoKXtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueDtcblxuICAgICAgICAvKiAqXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICoqL1xuICAgICAgICB4LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlKGQsIGNvbmYua2V5KTtcbiAgICAgICAgeC5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFswLCBwbG90LndpZHRoXSk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuXG4gICAgICAgIHguYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHguc2NhbGUpO1xuXG4gICAgICAgIGlmKGNvbmYudGlja3Mpe1xuICAgICAgICAgICAgeC5heGlzLnRpY2tzKGNvbmYudGlja3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKFtkMy5taW4oZGF0YSwgcz0+ZDMubWluKHMudmFsdWVzLCBwbG90LngudmFsdWUpKSwgZDMubWF4KGRhdGEsIHM9PmQzLm1heChzLnZhbHVlcywgcGxvdC54LnZhbHVlKSldKTtcbiAgICAgICAgXG4gICAgfTtcblxuICAgIHNldHVwWSAoKXtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHkgPSBwbG90Lnk7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFtwbG90LmhlaWdodCwgMF0pO1xuXG4gICAgICAgIHkuYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHkuc2NhbGUpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgeVN0YWNrTWF4ID0gZDMubWF4KHBsb3Quc3RhY2tlZEhpc3RvZ3JhbXMsIGxheWVyID0+IGQzLm1heChsYXllci5oaXN0b2dyYW1CaW5zLCBkID0+IGQueTAgKyBkLnkpKTtcbiAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihbMCwgeVN0YWNrTWF4XSk7XG5cbiAgICB9O1xuXG5cbiAgICBzZXR1cEhpc3RvZ3JhbSgpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5jb25maWcueC50aWNrcyA/IHguc2NhbGUudGlja3ModGhpcy5jb25maWcueC50aWNrcykgOiB4LnNjYWxlLnRpY2tzKCk7XG5cbiAgICAgICAgcGxvdC5oaXN0b2dyYW0gPSBkMy5oaXN0b2dyYW0oKVxuICAgICAgICAgICAgLmRvbWFpbih4LnNjYWxlLmRvbWFpbigpKVxuICAgICAgICAgICAgLnZhbHVlKHgudmFsdWUpXG4gICAgICAgICAgICAudGhyZXNob2xkcyh0aWNrcyk7XG4gICAgfVxuXG4gICAgc2V0dXBHcm91cFN0YWNrcygpIHtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcbiAgICAgICAgdmFyIHkwcyA9IFtdO1xuICAgICAgICB0aGlzLnBsb3QuZ3JvdXBlZERhdGEuZm9yRWFjaChkPT57XG4gICAgICAgICAgICBkLmhpc3RvZ3JhbUJpbnMgPSB0aGlzLnBsb3QuaGlzdG9ncmFtKGQudmFsdWVzKTtcblxuICAgICAgICAgICAgICAgIGQuaGlzdG9ncmFtQmlucy5mb3JFYWNoKChiLGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYi54ID1iLngwO1xuICAgICAgICAgICAgICAgICAgICBiLmR4ID0gYi54MS1iLngwO1xuICAgICAgICAgICAgICAgICAgICBiLnkgPSBiLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZZMCA9IHkwc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIXByZXZZMCkgcHJldlkwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYi55MCA9IHByZXZZMDtcblxuICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5jb25maWcuZnJlcXVlbmN5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIueS89dGhpcy5wbG90LmRhdGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5MHNbaV0gPSBiLnkrcHJldlkwO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhLm1hcChkPT5kLmtleSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGxvdC5ncm91cGVkRGF0YSk7XG5cbiAgICAgICAgdGhpcy5wbG90LnN0YWNrID0gZDMuc3RhY2soKS5rZXlzKGtleXMpLnZhbHVlKGQ9PmQuaGlzdG9ncmFtQmlucyk7XG4gICAgICAgIHRoaXMucGxvdC5zdGFja2VkSGlzdG9ncmFtcyA9IHRoaXMucGxvdC5ncm91cGVkRGF0YTtcbiAgICB9XG5cbiAgICBkcmF3QXhpc1goKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueDtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMteCcpK1wiLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSsoc2VsZi5jb25maWcuZ3VpZGVzID8gJycgOiAnLicrc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIHBsb3QuaGVpZ2h0ICsgXCIpXCIpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC54LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiK3NlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgKHBsb3Qud2lkdGgvMikgK1wiLFwiKyAocGxvdC5tYXJnaW4uYm90dG9tKSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNZKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzLXknKStcIi5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzJykrKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nK3NlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSk7XG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnkuYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAtcGxvdC5tYXJnaW4ubGVmdCArXCIsXCIrKHBsb3QuaGVpZ2h0LzIpK1wiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cblxuICAgIGRyYXdIaXN0b2dyYW0oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGF5ZXJDbGFzcyA9IHRoaXMucHJlZml4Q2xhc3MoXCJsYXllclwiKTtcblxuICAgICAgICB2YXIgYmFyQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKFwiYmFyXCIpO1xuICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiK2xheWVyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnN0YWNrZWRIaXN0b2dyYW1zKTtcblxuICAgICAgICB2YXIgbGF5ZXJNZXJnZSA9IGxheWVyLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBsYXllckNsYXNzKS5tZXJnZShsYXllcik7XG5cblxuICAgICAgICB2YXIgYmFyID0gbGF5ZXJNZXJnZS5zZWxlY3RBbGwoXCIuXCIrYmFyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShkID0+IGQuaGlzdG9ncmFtQmlucyk7XG5cbiAgICAgICAgdmFyIGJhckVudGVyID0gYmFyLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgYmFyRW50ZXJcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgYmFyQ2xhc3MpXG4gICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDEpO1xuXG4gICAgICAgIHZhciBiYXJNZXJnZSA9IGJhckVudGVyLm1lcmdlKGJhcik7XG4gICAgICAgIHZhciBiYXJSZWN0ID0gYmFyTWVyZ2Uuc2VsZWN0KFwicmVjdFwiKTtcblxuICAgICAgICB2YXIgYmFyUmVjdFQgPSBiYXJSZWN0O1xuICAgICAgICB2YXIgYmFyVCA9IGJhck1lcmdlO1xuICAgICAgICB2YXIgbGF5ZXJUID0gbGF5ZXJNZXJnZTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgYmFyUmVjdFQgPSBiYXJSZWN0LnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGJhclQgPSBiYXJNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICBsYXllclQ9IGxheWVyTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyVC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgcGxvdC54LnNjYWxlKGQueCkgKyBcIixcIiArIChwbG90Lnkuc2NhbGUoZC55MCArZC55KSkgKyBcIilcIjsgfSk7XG4gICAgICAgIHZhciByZWN0V2lkdGggPSBwbG90LnN0YWNrZWRIaXN0b2dyYW1zLmxlbmd0aCA/IChwbG90LnN0YWNrZWRIaXN0b2dyYW1zWzBdLmhpc3RvZ3JhbUJpbnMubGVuZ3RoID8gIHBsb3QueC5zY2FsZShwbG90LnN0YWNrZWRIaXN0b2dyYW1zWzBdLmhpc3RvZ3JhbUJpbnNbMF0ueDEpLXBsb3QueC5zY2FsZShwbG90LnN0YWNrZWRIaXN0b2dyYW1zWzBdLmhpc3RvZ3JhbUJpbnNbMF0ueDApLTEgOiAwKSA6IDA7XG5cblxuICAgICAgICBiYXJSZWN0VFxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAgZD0+ICBNYXRoLm1heCgwLCBwbG90Lnguc2NhbGUoZC54MSktcGxvdC54LnNjYWxlKGQueDApLTEpIClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQgPT4gICBwbG90LmhlaWdodCAtIHBsb3QueS5zY2FsZShkLnkpKTtcblxuICAgICAgICBpZih0aGlzLnBsb3QuY29sb3Ipe1xuICAgICAgICAgICAgbGF5ZXJUXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIHRoaXMucGxvdC5zZXJpZXNDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICBiYXJNZXJnZS5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGQueSk7XG4gICAgICAgICAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgYmFyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1goKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1koKTtcblxuICAgICAgICB0aGlzLmRyYXdIaXN0b2dyYW0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7RDNFeHRlbnNpb25zfSBmcm9tICcuL2QzLWV4dGVuc2lvbnMnXG5EM0V4dGVuc2lvbnMuZXh0ZW5kKCk7XG5cbmV4cG9ydCB7U2NhdHRlclBsb3QsIFNjYXR0ZXJQbG90Q29uZmlnfSBmcm9tIFwiLi9zY2F0dGVycGxvdFwiO1xuZXhwb3J0IHtTY2F0dGVyUGxvdE1hdHJpeCwgU2NhdHRlclBsb3RNYXRyaXhDb25maWd9IGZyb20gXCIuL3NjYXR0ZXJwbG90LW1hdHJpeFwiO1xuZXhwb3J0IHtSZWdyZXNzaW9uLCBSZWdyZXNzaW9uQ29uZmlnfSBmcm9tICcuL3JlZ3Jlc3Npb24nXG5leHBvcnQge0NvcnJlbGF0aW9uTWF0cml4LCBDb3JyZWxhdGlvbk1hdHJpeENvbmZpZ30gZnJvbSAnLi9jb3JyZWxhdGlvbi1tYXRyaXgnXG5leHBvcnQge0hlYXRtYXAsIEhlYXRtYXBDb25maWd9IGZyb20gJy4vaGVhdG1hcCdcbmV4cG9ydCB7SGVhdG1hcFRpbWVTZXJpZXMsIEhlYXRtYXBUaW1lU2VyaWVzQ29uZmlnfSBmcm9tICcuL2hlYXRtYXAtdGltZXNlcmllcydcbmV4cG9ydCB7SGlzdG9ncmFtLCBIaXN0b2dyYW1Db25maWd9IGZyb20gJy4vaGlzdG9ncmFtJ1xuZXhwb3J0IHtCYXJDaGFydCwgQmFyQ2hhcnRDb25maWd9IGZyb20gJy4vYmFyLWNoYXJ0J1xuZXhwb3J0IHtCb3hQbG90QmFzZSwgQm94UGxvdEJhc2VDb25maWd9IGZyb20gJy4vYm94LXBsb3QtYmFzZSdcbmV4cG9ydCB7Qm94UGxvdCwgQm94UGxvdENvbmZpZ30gZnJvbSAnLi9ib3gtcGxvdCdcbmV4cG9ydCB7RGl2ZXJnaW5nU3RhY2tlZEJhckNoYXJ0LCBEaXZlcmdpbmdTdGFja2VkQmFyQ2hhcnRDb25maWd9IGZyb20gJy4vZGl2ZXJnaW5nLXN0YWNrZWQtYmFyLWNoYXJ0J1xuZXhwb3J0IHtTdGF0aXN0aWNzVXRpbHN9IGZyb20gJy4vc3RhdGlzdGljcy11dGlscydcbmV4cG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5leHBvcnQge0xlZ2VuZH0gZnJvbSAnLi9sZWdlbmQnXG5cblxuXG5cblxuIiwiaW1wb3J0IHtVdGlsc30gZnJvbSBcIi4vdXRpbHNcIjtcblxuaW1wb3J0IHtsZWdlbmRDb2xvciwgbGVnZW5kU2l6ZSwgbGVnZW5kU3ltYm9sfSBmcm9tICdkMy1zdmctbGVnZW5kJ1xuXG5cbi8qdmFyIGQzID0gcmVxdWlyZSgnLi4vYm93ZXJfY29tcG9uZW50cy9kMycpO1xuKi9cbi8vIHZhciBsZWdlbmQgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2QzLWxlZ2VuZC9uby1leHRlbmQnKTtcbi8vXG4vLyBtb2R1bGUuZXhwb3J0cy5sZWdlbmQgPSBsZWdlbmQ7XG5cbmV4cG9ydCBjbGFzcyBMZWdlbmQge1xuXG4gICAgY3NzQ2xhc3NQcmVmaXg9XCJvZGMtXCI7XG4gICAgbGVnZW5kQ2xhc3M9dGhpcy5jc3NDbGFzc1ByZWZpeCtcImxlZ2VuZFwiO1xuICAgIGNvbnRhaW5lcjtcbiAgICBzY2FsZTtcbiAgICBjb2xvcj0gbGVnZW5kQ29sb3I7XG4gICAgc2l6ZSA9IGxlZ2VuZFNpemU7XG4gICAgc3ltYm9sPSBsZWdlbmRTeW1ib2w7XG4gICAgZ3VpZDtcblxuICAgIGxhYmVsRm9ybWF0ID0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3RydWN0b3Ioc3ZnLCBsZWdlbmRQYXJlbnQsIHNjYWxlLCBsZWdlbmRYLCBsZWdlbmRZLCBsYWJlbEZvcm1hdCl7XG4gICAgICAgIHRoaXMuc2NhbGU9c2NhbGU7XG4gICAgICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgICAgICB0aGlzLmd1aWQgPSBVdGlscy5ndWlkKCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gIFV0aWxzLnNlbGVjdE9yQXBwZW5kKGxlZ2VuZFBhcmVudCwgXCJnLlwiK3RoaXMubGVnZW5kQ2xhc3MsIFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrbGVnZW5kWCtcIixcIitsZWdlbmRZK1wiKVwiKVxuICAgICAgICAgICAgLmNsYXNzZWQodGhpcy5sZWdlbmRDbGFzcywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdCA9IGxhYmVsRm9ybWF0O1xuICAgIH1cblxuXG5cbiAgICBsaW5lYXJHcmFkaWVudEJhcihiYXJXaWR0aCwgYmFySGVpZ2h0LCB0aXRsZSl7XG4gICAgICAgIHZhciBncmFkaWVudElkID0gdGhpcy5jc3NDbGFzc1ByZWZpeCtcImxpbmVhci1ncmFkaWVudFwiK1wiLVwiK3RoaXMuZ3VpZDtcbiAgICAgICAgdmFyIHNjYWxlPSB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5saW5lYXJHcmFkaWVudCA9IFV0aWxzLmxpbmVhckdyYWRpZW50KHRoaXMuc3ZnLCBncmFkaWVudElkLCB0aGlzLnNjYWxlLnJhbmdlKCksIDAsIDEwMCwgMCwgMCk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuc2VsZWN0T3JBcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGJhcldpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgYmFySGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCJ1cmwoI1wiK2dyYWRpZW50SWQrXCIpXCIpO1xuXG5cbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5jb250YWluZXIuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgLmRhdGEoIHNjYWxlLmRvbWFpbigpICk7XG4gICAgICAgIHZhciB0aWNrc051bWJlciA9c2NhbGUuZG9tYWluKCkubGVuZ3RoLTE7XG4gICAgICAgIHZhciB0aWNrc01lcmdlID0gdGlja3MuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLm1lcmdlKHRpY2tzKTtcblxuICAgICAgICB0aWNrc01lcmdlLmF0dHIoXCJ4XCIsIGJhcldpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsICAoZCwgaSkgPT4gIGJhckhlaWdodCAtKGkqYmFySGVpZ2h0L3RpY2tzTnVtYmVyKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMylcbiAgICAgICAgICAgIC8vIC5hdHRyKFwiZHlcIiwgMSlcbiAgICAgICAgICAgIC5hdHRyKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChkPT4gc2VsZi5sYWJlbEZvcm1hdCA/IHNlbGYubGFiZWxGb3JtYXQoZCkgOiBkKTtcbiAgICAgICAgdGlja3NNZXJnZS5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgaWYodGhpcy5yb3RhdGVMYWJlbHMpe1xuICAgICAgICAgICAgdGlja3NNZXJnZVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInJvdGF0ZSgtNDUsIFwiICsgYmFyV2lkdGggKyBcIiwgXCIgKyAoYmFySGVpZ2h0IC0oaSpiYXJIZWlnaHQvdGlja3NOdW1iZXIpKSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIDUpO1xuXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aWNrcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0Um90YXRlTGFiZWxzKHJvdGF0ZUxhYmVscykge1xuICAgICAgICB0aGlzLnJvdGF0ZUxhYmVscyA9IHJvdGF0ZUxhYmVscztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgXG59IiwiaW1wb3J0IHtDaGFydCwgQ2hhcnRDb25maWd9IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQge1NjYXR0ZXJQbG90LCBTY2F0dGVyUGxvdENvbmZpZ30gZnJvbSBcIi4vc2NhdHRlcnBsb3RcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge1N0YXRpc3RpY3NVdGlsc30gZnJvbSAnLi9zdGF0aXN0aWNzLXV0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIFJlZ3Jlc3Npb25Db25maWcgZXh0ZW5kcyBTY2F0dGVyUGxvdENvbmZpZ3tcblxuICAgIG1haW5SZWdyZXNzaW9uID0gdHJ1ZTtcbiAgICBncm91cFJlZ3Jlc3Npb24gPSB0cnVlO1xuICAgIGNvbmZpZGVuY2U9e1xuICAgICAgICBsZXZlbDogMC45NSxcbiAgICAgICAgY3JpdGljYWxWYWx1ZTogKGRlZ3JlZXNPZkZyZWVkb20sIGNyaXRpY2FsUHJvYmFiaWxpdHkpID0+IFN0YXRpc3RpY3NVdGlscy50VmFsdWUoZGVncmVlc09mRnJlZWRvbSwgY3JpdGljYWxQcm9iYWJpbGl0eSksXG4gICAgICAgIG1hcmdpbk9mRXJyb3I6IHVuZGVmaW5lZCwgLy9jdXN0b20gIG1hcmdpbiBPZiBFcnJvciBmdW5jdGlvbiAoeCwgcG9pbnRzKVxuICAgICAgICBhcmVhQ3VydmU6IGQzLmN1cnZlTmF0dXJhbFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlZ3Jlc3Npb24gZXh0ZW5kcyBTY2F0dGVyUGxvdHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IFJlZ3Jlc3Npb25Db25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZyl7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IFJlZ3Jlc3Npb25Db25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKXtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdGhpcy5pbml0UmVncmVzc2lvbkxpbmVzKCk7XG4gICAgfVxuXG4gICAgaW5pdFJlZ3Jlc3Npb25MaW5lcygpe1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdyb3Vwc0F2YWlsYWJsZSA9IHNlbGYucGxvdC5ncm91cGluZ0VuYWJsZWQ7XG5cbiAgICAgICAgc2VsZi5wbG90LnJlZ3Jlc3Npb25zPSBbXTtcblxuXG4gICAgICAgIGlmKGdyb3Vwc0F2YWlsYWJsZSAmJiBzZWxmLmNvbmZpZy5tYWluUmVncmVzc2lvbil7XG4gICAgICAgICAgICB2YXIgcmVncmVzc2lvbiA9IHRoaXMuaW5pdFJlZ3Jlc3Npb24odGhpcy5wbG90LmRhdGEsIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYucGxvdC5yZWdyZXNzaW9ucy5wdXNoKHJlZ3Jlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2VsZi5jb25maWcuZ3JvdXBSZWdyZXNzaW9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEdyb3VwUmVncmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpbml0R3JvdXBSZWdyZXNzaW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhLmZvckVhY2goZ3JvdXA9PntcbiAgICAgICAgICAgIGlmKGdyb3VwLnZhbHVlcy5sZW5ndGg8Mil7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVncmVzc2lvbiA9IHRoaXMuaW5pdFJlZ3Jlc3Npb24oZ3JvdXAudmFsdWVzLCBncm91cC5rZXkpO1xuICAgICAgICAgICAgc2VsZi5wbG90LnJlZ3Jlc3Npb25zLnB1c2gocmVncmVzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaXRSZWdyZXNzaW9uKHZhbHVlcywgZ3JvdXBWYWwpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHZhbHVlcy5tYXAoZD0+e1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJzZUZsb2F0KHNlbGYucGxvdC54LnZhbHVlKGQpKSwgcGFyc2VGbG9hdChzZWxmLnBsb3QueS52YWx1ZShkKSldO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBwb2ludHMuc29ydCgoYSxiKSA9PiBhWzBdLWJbMF0pO1xuXG4gICAgICAgIHZhciBsaW5lYXJSZWdyZXNzaW9uID0gIFN0YXRpc3RpY3NVdGlscy5saW5lYXJSZWdyZXNzaW9uKHBvaW50cyk7XG4gICAgICAgIHZhciBsaW5lYXJSZWdyZXNzaW9uTGluZSA9IFN0YXRpc3RpY3NVdGlscy5saW5lYXJSZWdyZXNzaW9uTGluZShsaW5lYXJSZWdyZXNzaW9uKTtcblxuXG4gICAgICAgIHZhciBleHRlbnRYID0gZDMuZXh0ZW50KHBvaW50cywgZD0+ZFswXSk7XG5cblxuICAgICAgICB2YXIgbGluZVBvaW50cyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiBleHRlbnRYWzBdLFxuICAgICAgICAgICAgICAgIHk6IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGV4dGVudFhbMF0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6IGV4dGVudFhbMV0sXG4gICAgICAgICAgICAgICAgeTogbGluZWFyUmVncmVzc2lvbkxpbmUoZXh0ZW50WFsxXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgbGluZSA9IGQzLmxpbmUoKVxuICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpXG4gICAgICAgICAgICAueChkID0+IHNlbGYucGxvdC54LnNjYWxlKGQueCkpXG4gICAgICAgICAgICAueShkID0+IHNlbGYucGxvdC55LnNjYWxlKGQueSkpO1xuXG4gICAgICAgIHZhciBjb2xvciA9IHNlbGYucGxvdC5jb2xvcjtcblxuICAgICAgICB2YXIgZGVmYXVsdENvbG9yID0gXCJibGFja1wiO1xuICAgICAgICBpZihVdGlscy5pc0Z1bmN0aW9uKGNvbG9yKSl7XG4gICAgICAgICAgICBpZih2YWx1ZXMubGVuZ3RoICYmIGdyb3VwVmFsIT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIGlmKHNlbGYuY29uZmlnLnNlcmllcyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID1zZWxmLnBsb3QuY29sb3JDYXRlZ29yeShncm91cFZhbCk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3IodmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZSBpZighY29sb3IgJiYgZ3JvdXBWYWw9PT1mYWxzZSl7XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGNvbmZpZGVuY2UgPSB0aGlzLmNvbXB1dGVDb25maWRlbmNlKHBvaW50cywgZXh0ZW50WCwgIGxpbmVhclJlZ3Jlc3Npb24sbGluZWFyUmVncmVzc2lvbkxpbmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXA6IGdyb3VwVmFsIHx8IGZhbHNlLFxuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGxpbmVQb2ludHM6IGxpbmVQb2ludHMsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBjb25maWRlbmNlOiBjb25maWRlbmNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcHV0ZUNvbmZpZGVuY2UocG9pbnRzLCBleHRlbnRYLCBsaW5lYXJSZWdyZXNzaW9uLGxpbmVhclJlZ3Jlc3Npb25MaW5lKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2xvcGUgPSBsaW5lYXJSZWdyZXNzaW9uLm07XG4gICAgICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlZ3JlZXNPZkZyZWVkb20gPSBNYXRoLm1heCgwLCBuLTIpO1xuXG4gICAgICAgIHZhciBhbHBoYSA9IDEgLSBzZWxmLmNvbmZpZy5jb25maWRlbmNlLmxldmVsO1xuICAgICAgICB2YXIgY3JpdGljYWxQcm9iYWJpbGl0eSAgPSAxIC0gYWxwaGEvMjtcbiAgICAgICAgdmFyIGNyaXRpY2FsVmFsdWUgPSBzZWxmLmNvbmZpZy5jb25maWRlbmNlLmNyaXRpY2FsVmFsdWUoZGVncmVlc09mRnJlZWRvbSxjcml0aWNhbFByb2JhYmlsaXR5KTtcblxuICAgICAgICB2YXIgeFZhbHVlcyA9IHBvaW50cy5tYXAoZD0+ZFswXSk7XG4gICAgICAgIHZhciBtZWFuWCA9IFN0YXRpc3RpY3NVdGlscy5tZWFuKHhWYWx1ZXMpO1xuICAgICAgICB2YXIgeE15U3VtPTA7XG4gICAgICAgIHZhciB4U3VtPTA7XG4gICAgICAgIHZhciB4UG93U3VtPTA7XG4gICAgICAgIHZhciB5U3VtPTA7XG4gICAgICAgIHZhciB5UG93U3VtPTA7XG4gICAgICAgIHBvaW50cy5mb3JFYWNoKHA9PntcbiAgICAgICAgICAgIHZhciB4ID0gcFswXTtcbiAgICAgICAgICAgIHZhciB5ID0gcFsxXTtcblxuICAgICAgICAgICAgeE15U3VtICs9IHgqeTtcbiAgICAgICAgICAgIHhTdW0rPXg7XG4gICAgICAgICAgICB5U3VtKz15O1xuICAgICAgICAgICAgeFBvd1N1bSs9IHgqeDtcbiAgICAgICAgICAgIHlQb3dTdW0rPSB5Knk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYSA9IGxpbmVhclJlZ3Jlc3Npb24ubTtcbiAgICAgICAgdmFyIGIgPSBsaW5lYXJSZWdyZXNzaW9uLmI7XG5cbiAgICAgICAgdmFyIFNhMiA9IG4vKG4rMikgKiAoKHlQb3dTdW0tYSp4TXlTdW0tYip5U3VtKS8obip4UG93U3VtLSh4U3VtKnhTdW0pKSk7IC8vV2FyaWFuY2phIHdzcMOzxYJjenlubmlrYSBraWVydW5rb3dlZ28gcmVncmVzamkgbGluaW93ZWogYVxuICAgICAgICB2YXIgU3kyID0gKHlQb3dTdW0gLSBhKnhNeVN1bS1iKnlTdW0pLyhuKihuLTIpKTsgLy9TYTIgLy9NZWFuIHkgdmFsdWUgdmFyaWFuY2VcblxuICAgICAgICB2YXIgZXJyb3JGbiA9IHg9PiBNYXRoLnNxcnQoU3kyICsgTWF0aC5wb3coeC1tZWFuWCwyKSpTYTIpOyAvL3BpZXJ3aWFzdGVrIGt3YWRyYXRvd3kgeiB3YXJpYW5jamkgZG93b2xuZWdvIHB1bmt0dSBwcm9zdGVqXG4gICAgICAgIHZhciBtYXJnaW5PZkVycm9yID0gIHg9PiBjcml0aWNhbFZhbHVlKiBlcnJvckZuKHgpO1xuXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ24nLCBuLCAnZGVncmVlc09mRnJlZWRvbScsIGRlZ3JlZXNPZkZyZWVkb20sICdjcml0aWNhbFByb2JhYmlsaXR5Jyxjcml0aWNhbFByb2JhYmlsaXR5KTtcbiAgICAgICAgLy8gdmFyIGNvbmZpZGVuY2VEb3duID0geCA9PiBsaW5lYXJSZWdyZXNzaW9uTGluZSh4KSAtICBtYXJnaW5PZkVycm9yKHgpO1xuICAgICAgICAvLyB2YXIgY29uZmlkZW5jZVVwID0geCA9PiBsaW5lYXJSZWdyZXNzaW9uTGluZSh4KSArICBtYXJnaW5PZkVycm9yKHgpO1xuXG5cbiAgICAgICAgdmFyIGNvbXB1dGVDb25maWRlbmNlQXJlYVBvaW50ID0geD0+e1xuICAgICAgICAgICAgdmFyIGxpbmVhclJlZ3Jlc3Npb24gPSBsaW5lYXJSZWdyZXNzaW9uTGluZSh4KTtcbiAgICAgICAgICAgIHZhciBtb2UgPSBtYXJnaW5PZkVycm9yKHgpO1xuICAgICAgICAgICAgdmFyIGNvbmZEb3duID0gbGluZWFyUmVncmVzc2lvbiAtIG1vZTtcbiAgICAgICAgICAgIHZhciBjb25mVXAgPSBsaW5lYXJSZWdyZXNzaW9uICsgbW9lO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHkwOiBjb25mRG93bixcbiAgICAgICAgICAgICAgICB5MTogY29uZlVwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2VudGVyWCA9IChleHRlbnRYWzFdK2V4dGVudFhbMF0pLzI7XG5cbiAgICAgICAgLy8gdmFyIGNvbmZpZGVuY2VBcmVhUG9pbnRzID0gW2V4dGVudFhbMF0sIGNlbnRlclgsICBleHRlbnRYWzFdXS5tYXAoY29tcHV0ZUNvbmZpZGVuY2VBcmVhUG9pbnQpO1xuICAgICAgICB2YXIgY29uZmlkZW5jZUFyZWFQb2ludHMgPSBbZXh0ZW50WFswXSwgY2VudGVyWCwgIGV4dGVudFhbMV1dLm1hcChjb21wdXRlQ29uZmlkZW5jZUFyZWFQb2ludCk7XG5cbiAgICAgICAgdmFyIGZpdEluUGxvdCA9IHkgPT4geTtcblxuICAgICAgICB2YXIgY29uZmlkZW5jZUFyZWEgPSAgZDMuYXJlYSgpXG4gICAgICAgIC5jdXJ2ZShzZWxmLmNvbmZpZy5jb25maWRlbmNlLmFyZWFDdXJ2ZSlcbiAgICAgICAgICAgIC54KGQgPT4gc2VsZi5wbG90Lnguc2NhbGUoZC54KSlcbiAgICAgICAgICAgIC55MChkID0+IGZpdEluUGxvdChzZWxmLnBsb3QueS5zY2FsZShkLnkwKSkpXG4gICAgICAgICAgICAueTEoZCA9PiBmaXRJblBsb3Qoc2VsZi5wbG90Lnkuc2NhbGUoZC55MSkpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJlYTpjb25maWRlbmNlQXJlYSxcbiAgICAgICAgICAgIHBvaW50czpjb25maWRlbmNlQXJlYVBvaW50c1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlZ3Jlc3Npb25MaW5lcygpO1xuXG4gICAgfTtcblxuICAgIHVwZGF0ZVJlZ3Jlc3Npb25MaW5lcygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmVncmVzc2lvbkNvbnRhaW5lckNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcInJlZ3Jlc3Npb24tY29udGFpbmVyXCIpO1xuICAgICAgICB2YXIgcmVncmVzc2lvbkNvbnRhaW5lclNlbGVjdG9yID0gXCJnLlwiK3JlZ3Jlc3Npb25Db250YWluZXJDbGFzcztcblxuICAgICAgICB2YXIgY2xpcFBhdGhJZCA9IHNlbGYucHJlZml4Q2xhc3MoXCJjbGlwXCIpO1xuXG4gICAgICAgIHZhciByZWdyZXNzaW9uQ29udGFpbmVyID0gc2VsZi5zdmdHLnNlbGVjdE9ySW5zZXJ0KHJlZ3Jlc3Npb25Db250YWluZXJTZWxlY3RvciwgXCIuXCIrc2VsZi5kb3RzQ29udGFpbmVyQ2xhc3MpO1xuICAgICAgICB2YXIgcmVncmVzc2lvbkNvbnRhaW5lckNsaXAgPSByZWdyZXNzaW9uQ29udGFpbmVyLnNlbGVjdE9yQXBwZW5kKFwiY2xpcFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgY2xpcFBhdGhJZCk7XG5cblxuICAgICAgICByZWdyZXNzaW9uQ29udGFpbmVyQ2xpcC5zZWxlY3RPckFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzZWxmLnBsb3Qud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc2VsZi5wbG90LmhlaWdodClcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMCk7XG5cbiAgICAgICAgcmVncmVzc2lvbkNvbnRhaW5lci5hdHRyKFwiY2xpcC1wYXRoXCIsIChkLGkpID0+IFwidXJsKCNcIitjbGlwUGF0aElkK1wiKVwiKTtcblxuICAgICAgICB2YXIgcmVncmVzc2lvbkNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcInJlZ3Jlc3Npb25cIik7XG4gICAgICAgIHZhciBjb25maWRlbmNlQXJlYUNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImNvbmZpZGVuY2VcIik7XG4gICAgICAgIHZhciByZWdyZXNzaW9uU2VsZWN0b3IgPSBcImcuXCIrcmVncmVzc2lvbkNsYXNzO1xuICAgICAgICB2YXIgcmVncmVzc2lvbiA9IHJlZ3Jlc3Npb25Db250YWluZXIuc2VsZWN0QWxsKHJlZ3Jlc3Npb25TZWxlY3RvcilcbiAgICAgICAgICAgIC5kYXRhKHNlbGYucGxvdC5yZWdyZXNzaW9ucywgKGQsaSk9PiBkLmdyb3VwKTtcblxuXG4gICAgICAgIHZhciByZWdyZXNzaW9uRW50ZXIgPSByZWdyZXNzaW9uLmVudGVyKCkuYXBwZW5kU2VsZWN0b3IocmVncmVzc2lvblNlbGVjdG9yKTtcbiAgICAgICAgdmFyIHJlZ3Jlc3Npb25NZXJnZSA9IHJlZ3Jlc3Npb25FbnRlci5tZXJnZShyZWdyZXNzaW9uKTtcbiAgICAgICAgdmFyIGxpbmVDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJsaW5lXCIpO1xuICAgICAgICByZWdyZXNzaW9uRW50ZXJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGxpbmVDbGFzcylcbiAgICAgICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwib3B0aW1pemVRdWFsaXR5XCIpO1xuXG4gICAgICAgIHZhciBsaW5lID0gcmVncmVzc2lvbk1lcmdlLnNlbGVjdChcInBhdGguXCIrbGluZUNsYXNzKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIHIgPT4gci5jb2xvcik7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGluZVQgPSBsaW5lO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBsaW5lVCA9IGxpbmUudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZVQuYXR0cihcImRcIiwgciA9PiByLmxpbmUoci5saW5lUG9pbnRzKSlcblxuXG4gICAgICAgIHJlZ3Jlc3Npb25FbnRlclxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgY29uZmlkZW5jZUFyZWFDbGFzcylcbiAgICAgICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwib3B0aW1pemVRdWFsaXR5XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMC40XCIpO1xuXG5cblxuICAgICAgICB2YXIgYXJlYSA9IHJlZ3Jlc3Npb25NZXJnZS5zZWxlY3QoXCJwYXRoLlwiK2NvbmZpZGVuY2VBcmVhQ2xhc3MpO1xuXG4gICAgICAgIHZhciBhcmVhVCA9IGFyZWE7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGFyZWFUID0gYXJlYS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXJlYVQuYXR0cihcImRcIiwgciA9PiByLmNvbmZpZGVuY2UuYXJlYShyLmNvbmZpZGVuY2UucG9pbnRzKSk7XG4gICAgICAgIGFyZWFULnN0eWxlKFwiZmlsbFwiLCByID0+IHIuY29sb3IpXG4gICAgICAgIHJlZ3Jlc3Npb24uZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgfVxuXG5cblxufVxuXG4iLCJpbXBvcnQge0NoYXJ0V2l0aENvbG9yR3JvdXBzfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtTY2F0dGVyUGxvdENvbmZpZ30gZnJvbSBcIi4vc2NhdHRlcnBsb3RcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSBcIi4vbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgU2NhdHRlclBsb3RNYXRyaXhDb25maWcgZXh0ZW5kcyBTY2F0dGVyUGxvdENvbmZpZ3tcblxuICAgIHN2Z0NsYXNzPSB0aGlzLmNzc0NsYXNzUHJlZml4KydzY2F0dGVycGxvdC1tYXRyaXgnO1xuICAgIHNpemU9IHVuZGVmaW5lZDsgLy9zY2F0dGVyIHBsb3QgY2VsbCBzaXplXG4gICAgbWluQ2VsbFNpemUgPSA1MDtcbiAgICBtYXhDZWxsU2l6ZSA9IDEwMDA7XG4gICAgcGFkZGluZz0gMjA7IC8vc2NhdHRlciBwbG90IGNlbGwgcGFkZGluZ1xuICAgIGJydXNoPSB0cnVlO1xuICAgIGd1aWRlcz0gdHJ1ZTsgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgc2hvd1Rvb2x0aXA9IHRydWU7IC8vc2hvdyB0b29sdGlwIG9uIGRvdCBob3ZlclxuICAgIHRpY2tzPSB1bmRlZmluZWQ7IC8vdGlja3MgbnVtYmVyLCAoZGVmYXVsdDogY29tcHV0ZWQgdXNpbmcgY2VsbCBzaXplKVxuICAgIHg9ey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgb3JpZW50OiBcImJvdHRvbVwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgeT17Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICBvcmllbnQ6IFwibGVmdFwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgZ3JvdXBzPXtcbiAgICAgICAga2V5OiB1bmRlZmluZWQsIC8vb2JqZWN0IHByb3BlcnR5IG5hbWUgb3IgYXJyYXkgaW5kZXggd2l0aCBncm91cGluZyB2YXJpYWJsZVxuICAgICAgICBpbmNsdWRlSW5QbG90OiBmYWxzZSwgLy9pbmNsdWRlIGdyb3VwIGFzIHZhcmlhYmxlIGluIHBsb3QsIGJvb2xlYW4gKGRlZmF1bHQ6IGZhbHNlKVxuICAgIH07XG4gICAgdmFyaWFibGVzPSB7XG4gICAgICAgIGxhYmVsczogW10sIC8vb3B0aW9uYWwgYXJyYXkgb2YgdmFyaWFibGUgbGFiZWxzIChmb3IgdGhlIGRpYWdvbmFsIG9mIHRoZSBwbG90KS5cbiAgICAgICAga2V5czogW10sIC8vb3B0aW9uYWwgYXJyYXkgb2YgdmFyaWFibGUga2V5c1xuICAgICAgICB2YWx1ZTogKGQsIHZhcmlhYmxlS2V5KSA9PiBkW3ZhcmlhYmxlS2V5XSAvLyB2YXJpYWJsZSB2YWx1ZSBhY2Nlc3NvclxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGNsYXNzIFNjYXR0ZXJQbG90TWF0cml4IGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHMge1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgU2NhdHRlclBsb3RNYXRyaXhDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBTY2F0dGVyUGxvdE1hdHJpeENvbmZpZyhjb25maWcpKTtcblxuICAgIH1cblxuICAgIGluaXRQbG90KCkge1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMucGxvdC5tYXJnaW47XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG4gICAgICAgIHRoaXMucGxvdC54PXt9O1xuICAgICAgICB0aGlzLnBsb3QueT17fTtcbiAgICAgICAgdGhpcy5wbG90LmRvdD17XG4gICAgICAgICAgICBjb2xvcjogbnVsbC8vY29sb3Igc2NhbGUgbWFwcGluZyBmdW5jdGlvblxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXR1cFZhcmlhYmxlcygpO1xuXG4gICAgICAgIHRoaXMucGxvdC5zaXplID0gY29uZi5zaXplO1xuXG5cbiAgICAgICAgdmFyIHdpZHRoID0gY29uZi53aWR0aDtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gVXRpbHMuYXZhaWxhYmxlV2lkdGgodGhpcy5jb25maWcud2lkdGgsIHRoaXMuZ2V0QmFzZUNvbnRhaW5lcigpLCBtYXJnaW4pO1xuICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gVXRpbHMuYXZhaWxhYmxlSGVpZ2h0KHRoaXMuY29uZmlnLmhlaWdodCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIG1hcmdpbik7XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnBsb3Quc2l6ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LnNpemUgPSAgTWF0aC5taW4oY29uZi5tYXhDZWxsU2l6ZSwgTWF0aC5tYXgoY29uZi5taW5DZWxsU2l6ZSwgYXZhaWxhYmxlV2lkdGgvdGhpcy5wbG90LnZhcmlhYmxlcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRoID0gbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQgKyB0aGlzLnBsb3QudmFyaWFibGVzLmxlbmd0aCp0aGlzLnBsb3Quc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZighdGhpcy5wbG90LnNpemUpe1xuICAgICAgICAgICAgdGhpcy5wbG90LnNpemUgPSAod2lkdGggLSAobWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpKSAvIHRoaXMucGxvdC52YXJpYWJsZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoO1xuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbG90LndpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgdGhpcy5wbG90LmhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5cbiAgICAgICAgdGhpcy5wbG90LnRpY2tzID0gY29uZi50aWNrcztcblxuICAgICAgICBpZih0aGlzLnBsb3QudGlja3M9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy5wbG90LnRpY2tzID0gdGhpcy5wbG90LnNpemUgLyA0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dXBYKCk7XG4gICAgICAgIHRoaXMuc2V0dXBZKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBWYXJpYWJsZXMoKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZXNDb25mID0gdGhpcy5jb25maWcudmFyaWFibGVzO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgcGxvdC5kb21haW5CeVZhcmlhYmxlID0ge307XG4gICAgICAgIHBsb3QudmFyaWFibGVzID0gdmFyaWFibGVzQ29uZi5rZXlzO1xuICAgICAgICBpZighcGxvdC52YXJpYWJsZXMgfHwgIXBsb3QudmFyaWFibGVzLmxlbmd0aCl7XG5cbiAgICAgICAgICAgIHBsb3QudmFyaWFibGVzID0gZGF0YS5sZW5ndGggPyBVdGlscy5pbmZlclZhcmlhYmxlcyhkYXRhWzBdLnZhbHVlcywgdGhpcy5jb25maWcuZ3JvdXBzLmtleSwgdGhpcy5jb25maWcuaW5jbHVkZUluUGxvdCkgOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QubGFiZWxzID0gW107XG4gICAgICAgIHBsb3QubGFiZWxCeVZhcmlhYmxlID0ge307XG4gICAgICAgIHBsb3QudmFyaWFibGVzLmZvckVhY2goKHZhcmlhYmxlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIG1pbiA9IGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIGQ9PnZhcmlhYmxlc0NvbmYudmFsdWUoZCwgdmFyaWFibGVLZXkpKSk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gZDMubWF4KGRhdGEsIHM9PmQzLm1heChzLnZhbHVlcywgZD0+dmFyaWFibGVzQ29uZi52YWx1ZShkLCB2YXJpYWJsZUtleSkpKTtcbiAgICAgICAgICAgIHBsb3QuZG9tYWluQnlWYXJpYWJsZVt2YXJpYWJsZUtleV0gPSBbbWluLG1heF07XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB2YXJpYWJsZUtleTtcbiAgICAgICAgICAgIGlmKHZhcmlhYmxlc0NvbmYubGFiZWxzICYmIHZhcmlhYmxlc0NvbmYubGFiZWxzLmxlbmd0aD5pbmRleCl7XG5cbiAgICAgICAgICAgICAgICBsYWJlbCA9IHZhcmlhYmxlc0NvbmYubGFiZWxzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsb3QubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgcGxvdC5sYWJlbEJ5VmFyaWFibGVbdmFyaWFibGVLZXldID0gbGFiZWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3Quc3VicGxvdHMgPSBbXTtcbiAgICB9O1xuXG4gICAgc2V0dXBYKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBcbiAgICAgICAgeC52YWx1ZSA9IGNvbmYudmFyaWFibGVzLnZhbHVlO1xuICAgICAgICB4LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi54LnNjYWxlKS5yYW5nZShbY29uZi5wYWRkaW5nIC8gMiwgcGxvdC5zaXplIC0gY29uZi5wYWRkaW5nIC8gMl0pO1xuICAgICAgICB4Lm1hcCA9IChkLCB2YXJpYWJsZSkgPT4geC5zY2FsZSh4LnZhbHVlKGQsIHZhcmlhYmxlKSk7XG5cbiAgICAgICAgeC5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLngub3JpZW50LCB4LnNjYWxlKS50aWNrcyhwbG90LnRpY2tzKTtcbiAgICAgICAgeC5heGlzLnRpY2tTaXplKHBsb3Quc2l6ZSAqIHBsb3QudmFyaWFibGVzLmxlbmd0aCk7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB5LnZhbHVlID0gY29uZi52YXJpYWJsZXMudmFsdWU7XG4gICAgICAgIHkuc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnkuc2NhbGUpLnJhbmdlKFsgcGxvdC5zaXplIC0gY29uZi5wYWRkaW5nIC8gMiwgY29uZi5wYWRkaW5nIC8gMl0pO1xuXG4gICAgICAgIHkubWFwID0gKGQsIHZhcmlhYmxlKSA9PiB5LnNjYWxlKHkudmFsdWUoZCwgdmFyaWFibGUpKTtcbiAgICAgICAgeS5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLnkub3JpZW50LCB5LnNjYWxlKS50aWNrcyhwbG90LnRpY2tzKTtcbiAgICAgICAgeS5heGlzLnRpY2tTaXplKC1wbG90LnNpemUgKiBwbG90LnZhcmlhYmxlcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB1cGRhdGUoIG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuXG4gICAgICAgIHZhciBzZWxmID10aGlzO1xuICAgICAgICB2YXIgbiA9IHNlbGYucGxvdC52YXJpYWJsZXMubGVuZ3RoO1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHZhciBheGlzQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiYXhpc1wiKTtcbiAgICAgICAgdmFyIGF4aXNYQ2xhc3MgPSBheGlzQ2xhc3MrXCIteFwiO1xuICAgICAgICB2YXIgYXhpc1lDbGFzcyA9IGF4aXNDbGFzcytcIi15XCI7XG5cbiAgICAgICAgdmFyIHhBeGlzU2VsZWN0b3IgPSBcImcuXCIrYXhpc1hDbGFzcytcIi5cIitheGlzQ2xhc3M7XG4gICAgICAgIHZhciB5QXhpc1NlbGVjdG9yID0gXCJnLlwiK2F4aXNZQ2xhc3MrXCIuXCIrYXhpc0NsYXNzO1xuXG4gICAgICAgIHZhciBub0d1aWRlc0NsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcIm5vLWd1aWRlc1wiKTtcbiAgICAgICAgdmFyIHhBeGlzID0gc2VsZi5zdmdHLnNlbGVjdEFsbCh4QXhpc1NlbGVjdG9yKVxuICAgICAgICAgICAgLmRhdGEoc2VsZi5wbG90LnZhcmlhYmxlcyk7XG5cbiAgICAgICAgdmFyIHhBeGlzTWVyZ2UgPSB4QXhpcy5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKHhBeGlzU2VsZWN0b3IpXG4gICAgICAgICAgICAuY2xhc3NlZChub0d1aWRlc0NsYXNzLCAhY29uZi5ndWlkZXMpLm1lcmdlKHhBeGlzKTtcblxuXG4gICAgICAgIHhBeGlzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJ0cmFuc2xhdGUoXCIgKyAobiAtIGkgLSAxKSAqIHNlbGYucGxvdC5zaXplICsgXCIsMClcIilcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QueC5zY2FsZS5kb21haW4oc2VsZi5wbG90LmRvbWFpbkJ5VmFyaWFibGVbZF0pO1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcyA9IGF4aXMudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBheGlzLmNhbGwoc2VsZi5wbG90LnguYXhpcyk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHhBeGlzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgeUF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKHlBeGlzU2VsZWN0b3IpXG4gICAgICAgICAgICAuZGF0YShzZWxmLnBsb3QudmFyaWFibGVzKTtcbiAgICAgICAgdmFyIHlBeGlzTWVyZ2UgPSB5QXhpcy5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKHlBeGlzU2VsZWN0b3IpLm1lcmdlKHlBeGlzKTtcbiAgICAgICAgeUF4aXNNZXJnZS5jbGFzc2VkKG5vR3VpZGVzQ2xhc3MsICFjb25mLmd1aWRlcylcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInRyYW5zbGF0ZSgwLFwiICsgaSAqIHNlbGYucGxvdC5zaXplICsgXCIpXCIpO1xuICAgICAgICB5QXhpc01lcmdlLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgc2VsZi5wbG90Lnkuc2NhbGUuZG9tYWluKHNlbGYucGxvdC5kb21haW5CeVZhcmlhYmxlW2RdKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIGF4aXMgPSBheGlzLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF4aXMuY2FsbChzZWxmLnBsb3QueS5heGlzKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICB5QXhpcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIGNlbGxDbGFzcyA9ICBzZWxmLnByZWZpeENsYXNzKFwiY2VsbFwiKTtcbiAgICAgICAgdmFyIGNlbGwgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiK2NlbGxDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHNlbGYudXRpbHMuY3Jvc3Moc2VsZi5wbG90LnZhcmlhYmxlcywgc2VsZi5wbG90LnZhcmlhYmxlcykpO1xuXG4gICAgICAgIHZhciBjZWxsRW50ZXIgPSAgY2VsbC5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKFwiZy5cIitjZWxsQ2xhc3MpO1xuICAgICAgICBjZWxsRW50ZXIuZmlsdGVyKGQgPT4gZC5pID09PSBkLmopLmFwcGVuZChcInRleHRcIik7XG5cbiAgICAgICAgdmFyIGNlbGxNZXJnZSA9IGNlbGxFbnRlci5tZXJnZShjZWxsKTtcbiAgICAgICAgY2VsbE1lcmdlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIChuIC0gZC5pIC0gMSkgKiBzZWxmLnBsb3Quc2l6ZSArIFwiLFwiICsgZC5qICogc2VsZi5wbG90LnNpemUgKyBcIilcIik7XG5cbiAgICAgICAgaWYoY29uZi5icnVzaCl7XG4gICAgICAgICAgICB0aGlzLmRyYXdCcnVzaChjZWxsTWVyZ2UpO1xuICAgICAgICB9XG5cblxuICAgICAgICBjZWxsTWVyZ2UuZWFjaChwbG90U3VicGxvdCk7XG5cbiAgICAgICAgLy9MYWJlbHNcbiAgICAgICAgY2VsbE1lcmdlLnNlbGVjdChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBjb25mLnBhZGRpbmcpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgY29uZi5wYWRkaW5nKVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi43MWVtXCIpXG4gICAgICAgICAgICAudGV4dCggZCA9PiBzZWxmLnBsb3QubGFiZWxCeVZhcmlhYmxlW2QueF0pO1xuXG4gICAgICAgIGNlbGwuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBsb3RTdWJwbG90KHApIHtcbiAgICAgICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICAgICAgcGxvdC5zdWJwbG90cy5wdXNoKHApO1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgIHBsb3QueC5zY2FsZS5kb21haW4ocGxvdC5kb21haW5CeVZhcmlhYmxlW3AueF0pO1xuICAgICAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihwbG90LmRvbWFpbkJ5VmFyaWFibGVbcC55XSk7XG5cbiAgICAgICAgICAgIHZhciBmcmFtZUNsYXNzID0gIHNlbGYucHJlZml4Q2xhc3MoXCJmcmFtZVwiKTtcbiAgICAgICAgICAgIGNlbGwuc2VsZWN0T3JBcHBlbmQoXCJyZWN0LlwiK2ZyYW1lQ2xhc3MpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmcmFtZUNsYXNzKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBjb25mLnBhZGRpbmcgLyAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBjb25mLnBhZGRpbmcgLyAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGxvdC5zaXplIC0gY29uZi5wYWRkaW5nKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBsb3Quc2l6ZSAtIGNvbmYucGFkZGluZyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHAudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VicGxvdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKCdsYXllcicpO1xuXG5cbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBjZWxsLnNlbGVjdEFsbChcImcuXCIrbGF5ZXJDbGFzcykuZGF0YShzZWxmLnBsb3QuZ3JvdXBlZERhdGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyTWVyZ2UgPSBsYXllci5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKFwiZy5cIitsYXllckNsYXNzKS5tZXJnZShsYXllcik7XG5cbiAgICAgICAgICAgICAgICB2YXIgZG90cyA9IGxheWVyTWVyZ2Uuc2VsZWN0QWxsKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGQ9PmQudmFsdWVzKTtcblxuICAgICAgICAgICAgICAgIHZhciBkb3RzTWVyZ2UgPSBkb3RzLmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpLm1lcmdlKGRvdHMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRvdHNUID0gZG90c01lcmdlO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG90c1QgPSBkb3RzTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvdHNULmF0dHIoXCJjeFwiLCAoZCkgPT4gcGxvdC54Lm1hcChkLCBzdWJwbG90LngpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIChkKSA9PiBwbG90LnkubWFwKGQsIHN1YnBsb3QueSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCBzZWxmLmNvbmZpZy5kb3RSYWRpdXMpO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAocGxvdC5zZXJpZXNDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllck1lcmdlLnN0eWxlKFwiZmlsbFwiLCBwbG90LnNlcmllc0NvbG9yKVxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHBsb3QuY29sb3Ipe1xuICAgICAgICAgICAgICAgICAgICBkb3RzTWVyZ2Uuc3R5bGUoXCJmaWxsXCIsIHBsb3QuY29sb3IpXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvdHNNZXJnZS5vbihcIm1vdXNlb3ZlclwiLCAoZCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IFwiKFwiICsgcGxvdC54LnZhbHVlKGQsIHN1YnBsb3QueCkgKyBcIiwgXCIgKyBwbG90LnkudmFsdWUoZCwgc3VicGxvdC55KSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gc2VsZi5jb25maWcuZ3JvdXBzID8gc2VsZi5jb25maWcuZ3JvdXBzLnZhbHVlLmNhbGwoc2VsZi5jb25maWcsIGQpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cCB8fCBncm91cCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcGxvdC5ncm91cFRvTGFiZWxbZ3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gXCI8YnIvPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHNlbGYuY29uZmlnLmdyb3Vwcy5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBsYWJlbCArIFwiOiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChodG1sKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkKT0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb3RzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBsYXllci5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcC51cGRhdGUoKTtcblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRyYXdCcnVzaChjZWxsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGhpZGRlbkNsYXNzID0gc2VsZi5wbG90LmhpZGRlbkNsYXNzID0gIHNlbGYucHJlZml4Q2xhc3MoXCJoaWRkZW5cIik7XG4gICAgICAgIHZhciBicnVzaCA9IGQzLmJydXNoKClcbiAgICAgICAgICAgIC8vIC54KHNlbGYucGxvdC54LnNjYWxlKVxuICAgICAgICAgICAgLy8gLnkoc2VsZi5wbG90Lnkuc2NhbGUpXG4gICAgICAgICAgICAub24oXCJzdGFydFwiLCBicnVzaHN0YXJ0KVxuICAgICAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2htb3ZlKVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGJydXNoZW5kKTtcblxuICAgICAgICBicnVzaC5leHRlbnQoW1swLCAwXSwgW3NlbGYucGxvdC5zaXplLCBzZWxmLnBsb3Quc2l6ZV1dKTtcbiAgICAgICAgY2VsbC5zZWxlY3RPckFwcGVuZChcImcuYnJ1c2gtY29udGFpbmVyXCIpLmNhbGwoYnJ1c2gpO1xuXG4gICAgICAgIHNlbGYuY2xlYXJCcnVzaCgpO1xuXG4gICAgICAgIC8vIENsZWFyIHRoZSBwcmV2aW91c2x5LWFjdGl2ZSBicnVzaCwgaWYgYW55LlxuICAgICAgICBmdW5jdGlvbiBicnVzaHN0YXJ0KHApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnBsb3QuYnJ1c2hDZWxsICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhckJydXNoKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lnguc2NhbGUuZG9tYWluKHNlbGYucGxvdC5kb21haW5CeVZhcmlhYmxlW3AueF0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC55LnNjYWxlLmRvbWFpbihzZWxmLnBsb3QuZG9tYWluQnlWYXJpYWJsZVtwLnldKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuYnJ1c2hDZWxsID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuYnJ1c2ggPSBicnVzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZ2hsaWdodCB0aGUgc2VsZWN0ZWQgY2lyY2xlcy5cbiAgICAgICAgZnVuY3Rpb24gYnJ1c2htb3ZlKHApIHtcbiAgICAgICAgICAgIHZhciBzID0gZDMuZXZlbnQuc2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYoIXMpcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGUgPSBzLm1hcChfPT4gW3NlbGYucGxvdC54LnNjYWxlLmludmVydChfWzBdKSwgc2VsZi5wbG90Lnkuc2NhbGUuaW52ZXJ0KF9bMV0pXSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlKTtcblxuICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcImNpcmNsZVwiKS5jbGFzc2VkKGhpZGRlbkNsYXNzLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChkW3AueF0pLFxuICAgICAgICAgICAgICAgICAgICB5ID0gcGFyc2VGbG9hdChkW3AueV0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVbMF1bMF0gPiB4IHx8IHggPiBlWzFdWzBdXG4gICAgICAgICAgICAgICAgICAgIHx8IGVbMV1bMV0gPiB5IHx8IHkgPiBlWzBdWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGJydXNoIGlzIGVtcHR5LCBzZWxlY3QgYWxsIGNpcmNsZXMuXG4gICAgICAgIGZ1bmN0aW9uIGJydXNoZW5kKCkge1xuICAgICAgICAgICAgaWYgKCFkMy5ldmVudC5zZWxlY3Rpb24pIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCIuXCIraGlkZGVuQ2xhc3MpLmNsYXNzZWQoaGlkZGVuQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjbGVhckJydXNoKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYoIXNlbGYucGxvdC5icnVzaENlbGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZWxmLnBsb3QuYnJ1c2gubW92ZShkMy5zZWxlY3Qoc2VsZi5wbG90LmJydXNoQ2VsbCksIG51bGwpO1xuICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiK3NlbGYucGxvdC5oaWRkZW5DbGFzcykuY2xhc3NlZChzZWxmLnBsb3QuaGlkZGVuQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgc2VsZi5wbG90LmJydXNoQ2VsbD1udWxsO1xuXG4gICAgfVxufSIsImltcG9ydCB7Q2hhcnRXaXRoQ29sb3JHcm91cHMsIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBTY2F0dGVyUGxvdENvbmZpZyBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlne1xuXG4gICAgc3ZnQ2xhc3M9IHRoaXMuY3NzQ2xhc3NQcmVmaXgrJ3NjYXR0ZXJwbG90JztcbiAgICBndWlkZXM9IGZhbHNlOyAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICBzaG93VG9vbHRpcD0gdHJ1ZTsgLy9zaG93IHRvb2x0aXAgb24gZG90IGhvdmVyXG5cbiAgICB4PXsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbFxuICAgICAgICBrZXk6IDAsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBkW2tleV0sIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgb3JpZW50OiBcImJvdHRvbVwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgZG9tYWluTWFyZ2luOiAwLjA1XG4gICAgfTtcbiAgICB5PXsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbCxcbiAgICAgICAga2V5OiAxLFxuICAgICAgICB2YWx1ZTogKGQsIGtleSkgPT4gZFtrZXldLCAvLyB5IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIG9yaWVudDogXCJsZWZ0XCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBkb21haW5NYXJnaW46IDAuMDVcbiAgICB9O1xuICAgIGdyb3Vwcz17XG4gICAgICAgIGtleTogMlxuICAgIH07XG4gICAgZG90UmFkaXVzID0gMjtcbiAgICBkb3RJZCA9IChkLCBpKT0+IHVuZGVmaW5lZDtcbiAgICB0cmFuc2l0aW9uPSB0cnVlO1xuICAgIG9uRG90SG92ZXIgPSAoZCwgaSkgPT4ge307XG4gICAgb25Eb3RIb3Zlck91dCA9IChkLCBpKSA9PiB7fTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG5cblxuXG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNjYXR0ZXJQbG90IGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHN7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBTY2F0dGVyUGxvdENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKXtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgU2NhdHRlclBsb3RDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKXtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcblxuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54PXt9O1xuICAgICAgICB0aGlzLnBsb3QueT17fTtcblxuICAgICAgICB0aGlzLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnNldHVwWCgpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWCgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy54O1xuXG4gICAgICAgIC8qICpcbiAgICAgICAgICogdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAgICAgICAqIHNjYWxlIC0gbWFwcyB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzIGEgcGl4ZWwgcG9zaXRpb24uXG4gICAgICAgICAqIG1hcCBmdW5jdGlvbiAtIG1hcHMgZnJvbSBkYXRhIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICogYXhpcyAtIHNldHMgdXAgYXhpc1xuICAgICAgICAgKiovXG4gICAgICAgIHgudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuICAgICAgICBcbiAgICAgICAgeC5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFswLCBwbG90LndpZHRoXSk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuICAgICAgICBcbiAgICAgICAgeC5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeC5zY2FsZSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG5cbiAgICAgICAgdmFyIGRvbWFpbiA9IFtwYXJzZUZsb2F0KGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueC52YWx1ZSkpKSwgcGFyc2VGbG9hdChkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBwbG90LngudmFsdWUpKSldO1xuICAgICAgICB2YXIgZXh0ZW50ID0gKGRvbWFpblsxXS1kb21haW5bMF0pIHx8IDE7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoZXh0ZW50KSogY29uZi5kb21haW5NYXJnaW47XG4gICAgICAgIGRvbWFpblswXS09bWFyZ2luO1xuICAgICAgICBkb21haW5bMV0rPW1hcmdpbjtcbiAgICAgICAgcGxvdC54LnNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgICAgICBpZih0aGlzLmNvbmZpZy5ndWlkZXMpIHtcbiAgICAgICAgICAgIHguYXhpcy50aWNrU2l6ZSgtcGxvdC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZICgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy55O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIHkudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuXG4gICAgICAgIHkuc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnNjYWxlKS5yYW5nZShbcGxvdC5oZWlnaHQsIDBdKTtcblxuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcblxuICAgICAgICBpZih0aGlzLmNvbmZpZy5ndWlkZXMpe1xuICAgICAgICAgICAgeS5heGlzLnRpY2tTaXplKC1wbG90LndpZHRoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG5cbiAgICAgICAgdmFyIGRvbWFpbiA9IFtwYXJzZUZsb2F0KGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueS52YWx1ZSkpKSwgcGFyc2VGbG9hdChkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBwbG90LnkudmFsdWUpKSldO1xuICAgICAgICB2YXIgZXh0ZW50ID0gKGRvbWFpblsxXS1kb21haW5bMF0pIHx8IDE7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoZXh0ZW50KSogY29uZi5kb21haW5NYXJnaW47XG5cbiAgICAgICAgZG9tYWluWzBdLT1tYXJnaW47XG4gICAgICAgIGRvbWFpblsxXSs9bWFyZ2luO1xuICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIHBsb3QueS5zY2FsZS5kb21haW4oW2QzLm1pbihkYXRhLCBwbG90LnkudmFsdWUpLTEsIGQzLm1heChkYXRhLCBwbG90LnkudmFsdWUpKzFdKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNYKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLng7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzLXgnKStcIi5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzJykrKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nK3NlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnguYXhpcyk7XG4gICAgICAgIFxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIitzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIChwbG90LndpZHRoLzIpICtcIixcIisgKHBsb3QubWFyZ2luLmJvdHRvbSkgK1wiKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi0xZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIGRyYXdBeGlzWSgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcy15JykrXCIuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpKyhzZWxmLmNvbmZpZy5ndWlkZXMgPyAnJyA6ICcuJytzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnkuYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAtcGxvdC5tYXJnaW4ubGVmdCArXCIsXCIrKHBsb3QuaGVpZ2h0LzIpK1wiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1goKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1koKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZURvdHMoKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlRG90cygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGRhdGEgPSBwbG90LmRhdGE7XG4gICAgICAgIHZhciBsYXllckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnbGF5ZXInKTtcbiAgICAgICAgdmFyIGRvdENsYXNzID0gdGhpcy5kb3RDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2RvdCcpO1xuICAgICAgICBzZWxmLmRvdHNDb250YWluZXJDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2RvdHMtY29udGFpbmVyJyk7XG5cbiAgICAgICAgdmFyIGRvdHNDb250YWluZXIgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5kb3RzQ29udGFpbmVyQ2xhc3MpO1xuXG4gICAgICAgIHZhciBsYXllciA9IGRvdHNDb250YWluZXIuc2VsZWN0QWxsKFwiZy5cIitsYXllckNsYXNzKS5kYXRhKHBsb3QuZ3JvdXBlZERhdGEpO1xuXG4gICAgICAgIHZhciBsYXllckVudGVyID0gbGF5ZXIuZW50ZXIoKS5hcHBlbmRTZWxlY3RvcihcImcuXCIrbGF5ZXJDbGFzcyk7XG5cbiAgICAgICAgdmFyIGxheWVyTWVyZ2UgPSBsYXllckVudGVyLm1lcmdlKGxheWVyKTtcblxuICAgICAgICB2YXIgZG90cyA9IGxheWVyTWVyZ2Uuc2VsZWN0QWxsKCcuJyArIGRvdENsYXNzKVxuICAgICAgICAgICAgLmRhdGEoZD0+ZC52YWx1ZXMpXG5cbiAgICAgICAgdmFyIGRvdHNFbnRlciA9IGRvdHMuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZG90Q2xhc3MpO1xuXG4gICAgICAgIHZhciBkb3RzTWVyZ2UgPSBkb3RzRW50ZXIubWVyZ2UoZG90cyk7XG5cbiAgICAgICAgdmFyIGRvdHNUID0gZG90c01lcmdlO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBkb3RzVCA9IGRvdHNNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3RzVC5hdHRyKFwiclwiLCBzZWxmLmNvbmZpZy5kb3RSYWRpdXMpXG4gICAgICAgICAgICAuYXR0cihcImN4XCIsIHBsb3QueC5tYXApXG4gICAgICAgICAgICAuYXR0cihcImN5XCIsIHBsb3QueS5tYXApXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIHRoaXMuY29uZmlnLmRvdElkKTtcblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICBkb3RzTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBcIihcIiArIHBsb3QueC52YWx1ZShkKSArIFwiLCBcIiArIHBsb3QueS52YWx1ZShkKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHNlbGYuY29uZmlnLmdyb3VwcyA/ICBzZWxmLmNvbmZpZy5ncm91cHMudmFsdWUuY2FsbChzZWxmLmNvbmZpZyxkKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwIHx8IGdyb3VwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcGxvdC5ncm91cFRvTGFiZWxbZ3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IFwiPGJyLz5cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gc2VsZi5jb25maWcuZ3JvdXBzLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gbGFiZWwgKyBcIjogXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBncm91cFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZG90c01lcmdlLm9uKFwibW91c2VvdmVyLm9uRG90SG92ZXJcIiwgdGhpcy5jb25maWcub25Eb3RIb3Zlcik7XG4gICAgICAgIGRvdHNNZXJnZS5vbihcIm1vdXNlb3V0Lm9uRG90SG92ZXJPdXRcIiwgdGhpcy5jb25maWcub25Eb3RIb3Zlck91dCk7XG5cbiAgICAgICAgaWYgKHBsb3Quc2VyaWVzQ29sb3IpIHtcbiAgICAgICAgICAgIGxheWVyTWVyZ2Uuc3R5bGUoXCJmaWxsXCIsIHBsb3Quc2VyaWVzQ29sb3IpXG4gICAgICAgIH1lbHNlIGlmKHBsb3QuY29sb3Ipe1xuICAgICAgICAgICAgZG90c01lcmdlLnN0eWxlKFwiZmlsbFwiLCBwbG90LmNvbG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgZG90cy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGxheWVyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG59XG4iLCIvKlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmVucmFzbXVzZW4vMTI2MTk3N1xuICogTkFNRVxuICogXG4gKiBzdGF0aXN0aWNzLWRpc3RyaWJ1dGlvbnMuanMgLSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGNhbGN1bGF0aW5nXG4gKiAgIGNyaXRpY2FsIHZhbHVlcyBhbmQgdXBwZXIgcHJvYmFiaWxpdGllcyBvZiBjb21tb24gc3RhdGlzdGljYWxcbiAqICAgZGlzdHJpYnV0aW9uc1xuICogXG4gKiBTWU5PUFNJU1xuICogXG4gKiBcbiAqICAgLy8gQ2hpLXNxdWFyZWQtY3JpdCAoMiBkZWdyZWVzIG9mIGZyZWVkb20sIDk1dGggcGVyY2VudGlsZSA9IDAuMDUgbGV2ZWxcbiAqICAgY2hpc3FyZGlzdHIoMiwgLjA1KVxuICogICBcbiAqICAgLy8gdS1jcml0ICg5NXRoIHBlcmNlbnRpbGUgPSAwLjA1IGxldmVsKVxuICogICB1ZGlzdHIoLjA1KTtcbiAqICAgXG4gKiAgIC8vIHQtY3JpdCAoMSBkZWdyZWUgb2YgZnJlZWRvbSwgOTkuNXRoIHBlcmNlbnRpbGUgPSAwLjAwNSBsZXZlbCkgXG4gKiAgIHRkaXN0cigxLC4wMDUpO1xuICogICBcbiAqICAgLy8gRi1jcml0ICgxIGRlZ3JlZSBvZiBmcmVlZG9tIGluIG51bWVyYXRvciwgMyBkZWdyZWVzIG9mIGZyZWVkb20gXG4gKiAgIC8vICAgICAgICAgaW4gZGVub21pbmF0b3IsIDk5dGggcGVyY2VudGlsZSA9IDAuMDEgbGV2ZWwpXG4gKiAgIGZkaXN0cigxLDMsLjAxKTtcbiAqICAgXG4gKiAgIC8vIHVwcGVyIHByb2JhYmlsaXR5IG9mIHRoZSB1IGRpc3RyaWJ1dGlvbiAodSA9IC0wLjg1KTogUSh1KSA9IDEtRyh1KVxuICogICB1cHJvYigtMC44NSk7XG4gKiAgIFxuICogICAvLyB1cHBlciBwcm9iYWJpbGl0eSBvZiB0aGUgY2hpLXNxdWFyZSBkaXN0cmlidXRpb25cbiAqICAgLy8gKDMgZGVncmVlcyBvZiBmcmVlZG9tLCBjaGktc3F1YXJlZCA9IDYuMjUpOiBRID0gMS1HXG4gKiAgIGNoaXNxcnByb2IoMyw2LjI1KTtcbiAqICAgXG4gKiAgIC8vIHVwcGVyIHByb2JhYmlsaXR5IG9mIHRoZSB0IGRpc3RyaWJ1dGlvblxuICogICAvLyAoMyBkZWdyZWVzIG9mIGZyZWVkb20sIHQgPSA2LjI1MSk6IFEgPSAxLUdcbiAqICAgdHByb2IoMyw2LjI1MSk7XG4gKiAgIFxuICogICAvLyB1cHBlciBwcm9iYWJpbGl0eSBvZiB0aGUgRiBkaXN0cmlidXRpb25cbiAqICAgLy8gKDMgZGVncmVlcyBvZiBmcmVlZG9tIGluIG51bWVyYXRvciwgNSBkZWdyZWVzIG9mIGZyZWVkb20gaW5cbiAqICAgLy8gIGRlbm9taW5hdG9yLCBGID0gNi4yNSk6IFEgPSAxLUdcbiAqICAgZnByb2IoMyw1LC42MjUpO1xuICogXG4gKiBcbiAqICBERVNDUklQVElPTlxuICogXG4gKiBUaGlzIGxpYnJhcnkgY2FsY3VsYXRlcyBwZXJjZW50YWdlIHBvaW50cyAoNSBzaWduaWZpY2FudCBkaWdpdHMpIG9mIHRoZSB1XG4gKiAoc3RhbmRhcmQgbm9ybWFsKSBkaXN0cmlidXRpb24sIHRoZSBzdHVkZW50J3MgdCBkaXN0cmlidXRpb24sIHRoZVxuICogY2hpLXNxdWFyZSBkaXN0cmlidXRpb24gYW5kIHRoZSBGIGRpc3RyaWJ1dGlvbi4gSXQgY2FuIGFsc28gY2FsY3VsYXRlIHRoZVxuICogdXBwZXIgcHJvYmFiaWxpdHkgKDUgc2lnbmlmaWNhbnQgZGlnaXRzKSBvZiB0aGUgdSAoc3RhbmRhcmQgbm9ybWFsKSwgdGhlXG4gKiBjaGktc3F1YXJlLCB0aGUgdCBhbmQgdGhlIEYgZGlzdHJpYnV0aW9uLlxuICogXG4gKiBUaGVzZSBjcml0aWNhbCB2YWx1ZXMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIHN0YXRpc3RpY2FsIHRlc3RzLCBsaWtlIHRoZSB1XG4gKiB0ZXN0LCB0aGUgdCB0ZXN0LCB0aGUgRiB0ZXN0IGFuZCB0aGUgY2hpLXNxdWFyZWQgdGVzdCwgYW5kIHRvIGNhbGN1bGF0ZVxuICogY29uZmlkZW5jZSBpbnRlcnZhbHMuXG4gKiBcbiAqIElmIHlvdSBhcmUgaW50ZXJlc3RlZCBpbiBtb3JlIHByZWNpc2UgYWxnb3JpdGhtcyB5b3UgY291bGQgbG9vayBhdDpcbiAqICAgU3RhdExpYjogaHR0cDovL2xpYi5zdGF0LmNtdS5lZHUvYXBzdGF0LyA7IFxuICogICBBcHBsaWVkIFN0YXRpc3RpY3MgQWxnb3JpdGhtcyBieSBHcmlmZml0aHMsIFAuIGFuZCBIaWxsLCBJLkQuXG4gKiAgICwgRWxsaXMgSG9yd29vZDogQ2hpY2hlc3RlciAoMTk4NSlcbiAqIFxuICogQlVHUyBcbiAqIFxuICogVGhpcyBwb3J0IHdhcyBwcm9kdWNlZCBmcm9tIHRoZSBQZXJsIG1vZHVsZSBTdGF0aXN0aWNzOjpEaXN0cmlidXRpb25zXG4gKiB0aGF0IGhhcyBoYWQgbm8gYnVnIHJlcG9ydHMgaW4gc2V2ZXJhbCB5ZWFycy4gIElmIHlvdSBmaW5kIGEgYnVnIHRoZW5cbiAqIHBsZWFzZSBkb3VibGUtY2hlY2sgdGhhdCBKYXZhU2NyaXB0IGRvZXMgbm90IHRoaW5nIHRoZSBudW1iZXJzIHlvdSBhcmVcbiAqIHBhc3NpbmcgaW4gYXJlIHN0cmluZ3MuICAoWW91IGNhbiBzdWJ0cmFjdCAwIGZyb20gdGhlbSBhcyB5b3UgcGFzcyB0aGVtXG4gKiBpbiBzbyB0aGF0IFwiNVwiIGlzIHByb3Blcmx5IHVuZGVyc3Rvb2QgdG8gYmUgNS4pICBJZiB5b3UgaGF2ZSBwYXNzZWQgaW4gYVxuICogbnVtYmVyIHRoZW4gcGxlYXNlIGNvbnRhY3QgdGhlIGF1dGhvclxuICogXG4gKiBBVVRIT1JcbiAqIFxuICogQmVuIFRpbGx5IDxidGlsbHlAZ21haWwuY29tPlxuICogXG4gKiBPcmlnaW5sIFBlcmwgdmVyc2lvbiBieSBNaWNoYWVsIEtvc3BhY2ggPG1pa2UucGVybEBnbXguYXQ+XG4gKiBcbiAqIE5pY2UgZm9ybWF0aW5nLCBzaW1wbGlmaWNhdGlvbiBhbmQgYnVnIHJlcGFpciBieSBNYXR0aGlhcyBUcmF1dG5lciBLcm9tYW5uXG4gKiA8bXRrQGlkLmNicy5kaz5cbiAqIFxuICogQ09QWVJJR0hUIFxuICogXG4gKiBDb3B5cmlnaHQgMjAwOCBCZW4gVGlsbHkuXG4gKiBcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgc2FtZSB0ZXJtcyBhcyBQZXJsIGl0c2VsZi4gIFRoaXMgbWVhbnMgdW5kZXIgZWl0aGVyIHRoZSBQZXJsXG4gKiBBcnRpc3RpYyBMaWNlbnNlIG9yIHRoZSBHUEwgdjEgb3IgbGF0ZXIuXG4gKi9cblxudmFyIFNJR05JRklDQU5UID0gNTsgLy8gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyB0byBiZSByZXR1cm5lZFxuXG5mdW5jdGlvbiBjaGlzcXJkaXN0ciAoJG4sICRwKSB7XG5cdGlmICgkbiA8PSAwIHx8IE1hdGguYWJzKCRuKSAtIE1hdGguYWJzKGludGVnZXIoJG4pKSAhPSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpOyAvKiBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdGlmICgkcCA8PSAwIHx8ICRwID4gMSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBwOiAkcFxcblwiKTsgXG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YmNoaXNxcigkbi0wLCAkcC0wKSk7XG59XG5cbmZ1bmN0aW9uIHVkaXN0ciAoJHApIHtcblx0aWYgKCRwID4gMSB8fCAkcCA8PSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIHA6ICRwXFxuXCIpO1xuXHR9XG5cdHJldHVybiBwcmVjaXNpb25fc3RyaW5nKF9zdWJ1KCRwLTApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRkaXN0ciAoJG4sICRwKSB7XG5cdGlmICgkbiA8PSAwIHx8IE1hdGguYWJzKCRuKSAtIE1hdGguYWJzKGludGVnZXIoJG4pKSAhPSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpO1xuXHR9XG5cdGlmICgkcCA8PSAwIHx8ICRwID49IDEpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YnQoJG4tMCwgJHAtMCkpO1xufVxuXG5mdW5jdGlvbiBmZGlzdHIgKCRuLCAkbSwgJHApIHtcblx0aWYgKCgkbjw9MCkgfHwgKChNYXRoLmFicygkbiktKE1hdGguYWJzKGludGVnZXIoJG4pKSkpIT0wKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBuOiAkblxcblwiKTsgLyogZmlyc3QgZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRpZiAoKCRtPD0wKSB8fCAoKE1hdGguYWJzKCRtKS0oTWF0aC5hYnMoaW50ZWdlcigkbSkpKSkhPTApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG06ICRtXFxuXCIpOyAvKiBzZWNvbmQgZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRpZiAoKCRwPD0wKSB8fCAoJHA+MSkpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YmYoJG4tMCwgJG0tMCwgJHAtMCkpO1xufVxuXG5mdW5jdGlvbiB1cHJvYiAoJHgpIHtcblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YnVwcm9iKCR4LTApKTtcbn1cblxuZnVuY3Rpb24gY2hpc3FycHJvYiAoJG4sJHgpIHtcblx0aWYgKCgkbiA8PSAwKSB8fCAoKE1hdGguYWJzKCRuKSAtIChNYXRoLmFicyhpbnRlZ2VyKCRuKSkpKSAhPSAwKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBuOiAkblxcblwiKTsgLyogZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3ViY2hpc3FycHJvYigkbi0wLCAkeC0wKSk7XG59XG5cbmZ1bmN0aW9uIHRwcm9iICgkbiwgJHgpIHtcblx0aWYgKCgkbiA8PSAwKSB8fCAoKE1hdGguYWJzKCRuKSAtIE1hdGguYWJzKGludGVnZXIoJG4pKSkgIT0wKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBuOiAkblxcblwiKTsgLyogZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3VidHByb2IoJG4tMCwgJHgtMCkpO1xufVxuXG5mdW5jdGlvbiBmcHJvYiAoJG4sICRtLCAkeCkge1xuXHRpZiAoKCRuPD0wKSB8fCAoKE1hdGguYWJzKCRuKS0oTWF0aC5hYnMoaW50ZWdlcigkbikpKSkhPTApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpOyAvKiBmaXJzdCBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdGlmICgoJG08PTApIHx8ICgoTWF0aC5hYnMoJG0pLShNYXRoLmFicyhpbnRlZ2VyKCRtKSkpKSE9MCkpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgbTogJG1cXG5cIik7IC8qIHNlY29uZCBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9IFxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3ViZnByb2IoJG4tMCwgJG0tMCwgJHgtMCkpO1xufVxuXG5cbmZ1bmN0aW9uIF9zdWJmcHJvYiAoJG4sICRtLCAkeCkge1xuXHR2YXIgJHA7XG5cblx0aWYgKCR4PD0wKSB7XG5cdFx0JHA9MTtcblx0fSBlbHNlIGlmICgkbSAlIDIgPT0gMCkge1xuXHRcdHZhciAkeiA9ICRtIC8gKCRtICsgJG4gKiAkeCk7XG5cdFx0dmFyICRhID0gMTtcblx0XHRmb3IgKHZhciAkaSA9ICRtIC0gMjsgJGkgPj0gMjsgJGkgLT0gMikge1xuXHRcdFx0JGEgPSAxICsgKCRuICsgJGkgLSAyKSAvICRpICogJHogKiAkYTtcblx0XHR9XG5cdFx0JHAgPSAxIC0gTWF0aC5wb3coKDEgLSAkeiksICgkbiAvIDIpICogJGEpO1xuXHR9IGVsc2UgaWYgKCRuICUgMiA9PSAwKSB7XG5cdFx0dmFyICR6ID0gJG4gKiAkeCAvICgkbSArICRuICogJHgpO1xuXHRcdHZhciAkYSA9IDE7XG5cdFx0Zm9yICh2YXIgJGkgPSAkbiAtIDI7ICRpID49IDI7ICRpIC09IDIpIHtcblx0XHRcdCRhID0gMSArICgkbSArICRpIC0gMikgLyAkaSAqICR6ICogJGE7XG5cdFx0fVxuXHRcdCRwID0gTWF0aC5wb3coKDEgLSAkeiksICgkbSAvIDIpKSAqICRhO1xuXHR9IGVsc2Uge1xuXHRcdHZhciAkeSA9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KCRuICogJHggLyAkbSksIDEpO1xuXHRcdHZhciAkeiA9IE1hdGgucG93KE1hdGguc2luKCR5KSwgMik7XG5cdFx0dmFyICRhID0gKCRuID09IDEpID8gMCA6IDE7XG5cdFx0Zm9yICh2YXIgJGkgPSAkbiAtIDI7ICRpID49IDM7ICRpIC09IDIpIHtcblx0XHRcdCRhID0gMSArICgkbSArICRpIC0gMikgLyAkaSAqICR6ICogJGE7XG5cdFx0fSBcblx0XHR2YXIgJGIgPSBNYXRoLlBJO1xuXHRcdGZvciAodmFyICRpID0gMjsgJGkgPD0gJG0gLSAxOyAkaSArPSAyKSB7XG5cdFx0XHQkYiAqPSAoJGkgLSAxKSAvICRpO1xuXHRcdH1cblx0XHR2YXIgJHAxID0gMiAvICRiICogTWF0aC5zaW4oJHkpICogTWF0aC5wb3coTWF0aC5jb3MoJHkpLCAkbSkgKiAkYTtcblxuXHRcdCR6ID0gTWF0aC5wb3coTWF0aC5jb3MoJHkpLCAyKTtcblx0XHQkYSA9ICgkbSA9PSAxKSA/IDAgOiAxO1xuXHRcdGZvciAodmFyICRpID0gJG0tMjsgJGkgPj0gMzsgJGkgLT0gMikge1xuXHRcdFx0JGEgPSAxICsgKCRpIC0gMSkgLyAkaSAqICR6ICogJGE7XG5cdFx0fVxuXHRcdCRwID0gbWF4KDAsICRwMSArIDEgLSAyICogJHkgLyBNYXRoLlBJXG5cdFx0XHQtIDIgLyBNYXRoLlBJICogTWF0aC5zaW4oJHkpICogTWF0aC5jb3MoJHkpICogJGEpO1xuXHR9XG5cdHJldHVybiAkcDtcbn1cblxuXG5mdW5jdGlvbiBfc3ViY2hpc3FycHJvYiAoJG4sJHgpIHtcblx0dmFyICRwO1xuXG5cdGlmICgkeCA8PSAwKSB7XG5cdFx0JHAgPSAxO1xuXHR9IGVsc2UgaWYgKCRuID4gMTAwKSB7XG5cdFx0JHAgPSBfc3VidXByb2IoKE1hdGgucG93KCgkeCAvICRuKSwgMS8zKVxuXHRcdFx0XHQtICgxIC0gMi85LyRuKSkgLyBNYXRoLnNxcnQoMi85LyRuKSk7XG5cdH0gZWxzZSBpZiAoJHggPiA0MDApIHtcblx0XHQkcCA9IDA7XG5cdH0gZWxzZSB7ICAgXG5cdFx0dmFyICRhO1xuICAgICAgICAgICAgICAgIHZhciAkaTtcbiAgICAgICAgICAgICAgICB2YXIgJGkxO1xuXHRcdGlmICgoJG4gJSAyKSAhPSAwKSB7XG5cdFx0XHQkcCA9IDIgKiBfc3VidXByb2IoTWF0aC5zcXJ0KCR4KSk7XG5cdFx0XHQkYSA9IE1hdGguc3FydCgyL01hdGguUEkpICogTWF0aC5leHAoLSR4LzIpIC8gTWF0aC5zcXJ0KCR4KTtcblx0XHRcdCRpMSA9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRwID0gJGEgPSBNYXRoLmV4cCgtJHgvMik7XG5cdFx0XHQkaTEgPSAyO1xuXHRcdH1cblxuXHRcdGZvciAoJGkgPSAkaTE7ICRpIDw9ICgkbi0yKTsgJGkgKz0gMikge1xuXHRcdFx0JGEgKj0gJHggLyAkaTtcblx0XHRcdCRwICs9ICRhO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJHA7XG59XG5cbmZ1bmN0aW9uIF9zdWJ1ICgkcCkge1xuXHR2YXIgJHkgPSAtTWF0aC5sb2coNCAqICRwICogKDEgLSAkcCkpO1xuXHR2YXIgJHggPSBNYXRoLnNxcnQoXG5cdFx0JHkgKiAoMS41NzA3OTYyODhcblx0XHQgICsgJHkgKiAoLjAzNzA2OTg3OTA2XG5cdFx0ICBcdCsgJHkgKiAoLS44MzY0MzUzNTg5RS0zXG5cdFx0XHQgICsgJHkgKigtLjIyNTA5NDcxNzZFLTNcblx0XHRcdCAgXHQrICR5ICogKC42ODQxMjE4Mjk5RS01XG5cdFx0XHRcdCAgKyAkeSAqICgwLjU4MjQyMzg1MTVFLTVcblx0XHRcdFx0XHQrICR5ICogKC0uMTA0NTI3NDk3RS01XG5cdFx0XHRcdFx0ICArICR5ICogKC44MzYwOTM3MDE3RS03XG5cdFx0XHRcdFx0XHQrICR5ICogKC0uMzIzMTA4MTI3N0UtOFxuXHRcdFx0XHRcdFx0ICArICR5ICogKC4zNjU3NzYzMDM2RS0xMFxuXHRcdFx0XHRcdFx0XHQrICR5ICouNjkzNjIzMzk4MkUtMTIpKSkpKSkpKSkpKTtcblx0aWYgKCRwPi41KVxuICAgICAgICAgICAgICAgICR4ID0gLSR4O1xuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJ1cHJvYiAoJHgpIHtcblx0dmFyICRwID0gMDsgLyogaWYgKCRhYnN4ID4gMTAwKSAqL1xuXHR2YXIgJGFic3ggPSBNYXRoLmFicygkeCk7XG5cblx0aWYgKCRhYnN4IDwgMS45KSB7XG5cdFx0JHAgPSBNYXRoLnBvdygoMSArXG5cdFx0XHQkYWJzeCAqICguMDQ5ODY3MzQ3XG5cdFx0XHQgICsgJGFic3ggKiAoLjAyMTE0MTAwNjFcblx0XHRcdCAgXHQrICRhYnN4ICogKC4wMDMyNzc2MjYzXG5cdFx0XHRcdCAgKyAkYWJzeCAqICguMDAwMDM4MDAzNlxuXHRcdFx0XHRcdCsgJGFic3ggKiAoLjAwMDA0ODg5MDZcblx0XHRcdFx0XHQgICsgJGFic3ggKiAuMDAwMDA1MzgzKSkpKSkpLCAtMTYpLzI7XG5cdH0gZWxzZSBpZiAoJGFic3ggPD0gMTAwKSB7XG5cdFx0Zm9yICh2YXIgJGkgPSAxODsgJGkgPj0gMTsgJGktLSkge1xuXHRcdFx0JHAgPSAkaSAvICgkYWJzeCArICRwKTtcblx0XHR9XG5cdFx0JHAgPSBNYXRoLmV4cCgtLjUgKiAkYWJzeCAqICRhYnN4KSBcblx0XHRcdC8gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKSAvICgkYWJzeCArICRwKTtcblx0fVxuXG5cdGlmICgkeDwwKVxuICAgICAgICBcdCRwID0gMSAtICRwO1xuXHRyZXR1cm4gJHA7XG59XG5cbiAgIFxuZnVuY3Rpb24gX3N1YnQgKCRuLCAkcCkge1xuXG5cdGlmICgkcCA+PSAxIHx8ICRwIDw9IDApIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblxuXHRpZiAoJHAgPT0gMC41KSB7XG5cdFx0cmV0dXJuIDA7XG5cdH0gZWxzZSBpZiAoJHAgPCAwLjUpIHtcblx0XHRyZXR1cm4gLSBfc3VidCgkbiwgMSAtICRwKTtcblx0fVxuXG5cdHZhciAkdSA9IF9zdWJ1KCRwKTtcblx0dmFyICR1MiA9IE1hdGgucG93KCR1LCAyKTtcblxuXHR2YXIgJGEgPSAoJHUyICsgMSkgLyA0O1xuXHR2YXIgJGIgPSAoKDUgKiAkdTIgKyAxNikgKiAkdTIgKyAzKSAvIDk2O1xuXHR2YXIgJGMgPSAoKCgzICogJHUyICsgMTkpICogJHUyICsgMTcpICogJHUyIC0gMTUpIC8gMzg0O1xuXHR2YXIgJGQgPSAoKCgoNzkgKiAkdTIgKyA3NzYpICogJHUyICsgMTQ4MikgKiAkdTIgLSAxOTIwKSAqICR1MiAtIDk0NSkgXG5cdFx0XHRcdC8gOTIxNjA7XG5cdHZhciAkZSA9ICgoKCgoMjcgKiAkdTIgKyAzMzkpICogJHUyICsgOTMwKSAqICR1MiAtIDE3ODIpICogJHUyIC0gNzY1KSAqICR1MlxuXHRcdFx0KyAxNzk1NSkgLyAzNjg2NDA7XG5cblx0dmFyICR4ID0gJHUgKiAoMSArICgkYSArICgkYiArICgkYyArICgkZCArICRlIC8gJG4pIC8gJG4pIC8gJG4pIC8gJG4pIC8gJG4pO1xuXG5cdGlmICgkbiA8PSBNYXRoLnBvdyhsb2cxMCgkcCksIDIpICsgMykge1xuXHRcdHZhciAkcm91bmQ7XG5cdFx0ZG8geyBcblx0XHRcdHZhciAkcDEgPSBfc3VidHByb2IoJG4sICR4KTtcblx0XHRcdHZhciAkbjEgPSAkbiArIDE7XG5cdFx0XHR2YXIgJGRlbHRhID0gKCRwMSAtICRwKSBcblx0XHRcdFx0LyBNYXRoLmV4cCgoJG4xICogTWF0aC5sb2coJG4xIC8gKCRuICsgJHggKiAkeCkpIFxuXHRcdFx0XHRcdCsgTWF0aC5sb2coJG4vJG4xLzIvTWF0aC5QSSkgLSAxIFxuXHRcdFx0XHRcdCsgKDEvJG4xIC0gMS8kbikgLyA2KSAvIDIpO1xuXHRcdFx0JHggKz0gJGRlbHRhO1xuXHRcdFx0JHJvdW5kID0gcm91bmRfdG9fcHJlY2lzaW9uKCRkZWx0YSwgTWF0aC5hYnMoaW50ZWdlcihsb2cxMChNYXRoLmFicygkeCkpLTQpKSk7XG5cdFx0fSB3aGlsZSAoKCR4KSAmJiAoJHJvdW5kICE9IDApKTtcblx0fVxuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJ0cHJvYiAoJG4sICR4KSB7XG5cblx0dmFyICRhO1xuICAgICAgICB2YXIgJGI7XG5cdHZhciAkdyA9IE1hdGguYXRhbjIoJHggLyBNYXRoLnNxcnQoJG4pLCAxKTtcblx0dmFyICR6ID0gTWF0aC5wb3coTWF0aC5jb3MoJHcpLCAyKTtcblx0dmFyICR5ID0gMTtcblxuXHRmb3IgKHZhciAkaSA9ICRuLTI7ICRpID49IDI7ICRpIC09IDIpIHtcblx0XHQkeSA9IDEgKyAoJGktMSkgLyAkaSAqICR6ICogJHk7XG5cdH0gXG5cblx0aWYgKCRuICUgMiA9PSAwKSB7XG5cdFx0JGEgPSBNYXRoLnNpbigkdykvMjtcblx0XHQkYiA9IC41O1xuXHR9IGVsc2Uge1xuXHRcdCRhID0gKCRuID09IDEpID8gMCA6IE1hdGguc2luKCR3KSpNYXRoLmNvcygkdykvTWF0aC5QSTtcblx0XHQkYj0gLjUgKyAkdy9NYXRoLlBJO1xuXHR9XG5cdHJldHVybiBtYXgoMCwgMSAtICRiIC0gJGEgKiAkeSk7XG59XG5cbmZ1bmN0aW9uIF9zdWJmICgkbiwgJG0sICRwKSB7XG5cdHZhciAkeDtcblxuXHRpZiAoJHAgPj0gMSB8fCAkcCA8PSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIHA6ICRwXFxuXCIpO1xuXHR9XG5cblx0aWYgKCRwID09IDEpIHtcblx0XHQkeCA9IDA7XG5cdH0gZWxzZSBpZiAoJG0gPT0gMSkge1xuXHRcdCR4ID0gMSAvIE1hdGgucG93KF9zdWJ0KCRuLCAwLjUgLSAkcCAvIDIpLCAyKTtcblx0fSBlbHNlIGlmICgkbiA9PSAxKSB7XG5cdFx0JHggPSBNYXRoLnBvdyhfc3VidCgkbSwgJHAvMiksIDIpO1xuXHR9IGVsc2UgaWYgKCRtID09IDIpIHtcblx0XHR2YXIgJHUgPSBfc3ViY2hpc3FyKCRtLCAxIC0gJHApO1xuXHRcdHZhciAkYSA9ICRtIC0gMjtcblx0XHQkeCA9IDEgLyAoJHUgLyAkbSAqICgxICtcblx0XHRcdCgoJHUgLSAkYSkgLyAyICtcblx0XHRcdFx0KCgoNCAqICR1IC0gMTEgKiAkYSkgKiAkdSArICRhICogKDcgKiAkbSAtIDEwKSkgLyAyNCArXG5cdFx0XHRcdFx0KCgoMiAqICR1IC0gMTAgKiAkYSkgKiAkdSArICRhICogKDE3ICogJG0gLSAyNikpICogJHVcblx0XHRcdFx0XHRcdC0gJGEgKiAkYSAqICg5ICogJG0gLSA2KVxuXHRcdFx0XHRcdCkvNDgvJG5cblx0XHRcdFx0KS8kblxuXHRcdFx0KS8kbikpO1xuXHR9IGVsc2UgaWYgKCRuID4gJG0pIHtcblx0XHQkeCA9IDEgLyBfc3ViZjIoJG0sICRuLCAxIC0gJHApXG5cdH0gZWxzZSB7XG5cdFx0JHggPSBfc3ViZjIoJG4sICRtLCAkcClcblx0fVxuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJmMiAoJG4sICRtLCAkcCkge1xuXHR2YXIgJHUgPSBfc3ViY2hpc3FyKCRuLCAkcCk7XG5cdHZhciAkbjIgPSAkbiAtIDI7XG5cdHZhciAkeCA9ICR1IC8gJG4gKiBcblx0XHQoMSArIFxuXHRcdFx0KCgkdSAtICRuMikgLyAyICsgXG5cdFx0XHRcdCgoKDQgKiAkdSAtIDExICogJG4yKSAqICR1ICsgJG4yICogKDcgKiAkbiAtIDEwKSkgLyAyNCArIFxuXHRcdFx0XHRcdCgoKDIgKiAkdSAtIDEwICogJG4yKSAqICR1ICsgJG4yICogKDE3ICogJG4gLSAyNikpICogJHUgXG5cdFx0XHRcdFx0XHQtICRuMiAqICRuMiAqICg5ICogJG4gLSA2KSkgLyA0OCAvICRtKSAvICRtKSAvICRtKTtcblx0dmFyICRkZWx0YTtcblx0ZG8ge1xuXHRcdHZhciAkeiA9IE1hdGguZXhwKFxuXHRcdFx0KCgkbiskbSkgKiBNYXRoLmxvZygoJG4rJG0pIC8gKCRuICogJHggKyAkbSkpIFxuXHRcdFx0XHQrICgkbiAtIDIpICogTWF0aC5sb2coJHgpXG5cdFx0XHRcdCsgTWF0aC5sb2coJG4gKiAkbSAvICgkbiskbSkpXG5cdFx0XHRcdC0gTWF0aC5sb2coNCAqIE1hdGguUEkpXG5cdFx0XHRcdC0gKDEvJG4gICsgMS8kbSAtIDEvKCRuKyRtKSkvNlxuXHRcdFx0KS8yKTtcblx0XHQkZGVsdGEgPSAoX3N1YmZwcm9iKCRuLCAkbSwgJHgpIC0gJHApIC8gJHo7XG5cdFx0JHggKz0gJGRlbHRhO1xuXHR9IHdoaWxlIChNYXRoLmFicygkZGVsdGEpPjNlLTQpO1xuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJjaGlzcXIgKCRuLCAkcCkge1xuXHR2YXIgJHg7XG5cblx0aWYgKCgkcCA+IDEpIHx8ICgkcCA8PSAwKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBwOiAkcFxcblwiKTtcblx0fSBlbHNlIGlmICgkcCA9PSAxKXtcblx0XHQkeCA9IDA7XG5cdH0gZWxzZSBpZiAoJG4gPT0gMSkge1xuXHRcdCR4ID0gTWF0aC5wb3coX3N1YnUoJHAgLyAyKSwgMik7XG5cdH0gZWxzZSBpZiAoJG4gPT0gMikge1xuXHRcdCR4ID0gLTIgKiBNYXRoLmxvZygkcCk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyICR1ID0gX3N1YnUoJHApO1xuXHRcdHZhciAkdTIgPSAkdSAqICR1O1xuXG5cdFx0JHggPSBtYXgoMCwgJG4gKyBNYXRoLnNxcnQoMiAqICRuKSAqICR1IFxuXHRcdFx0KyAyLzMgKiAoJHUyIC0gMSlcblx0XHRcdCsgJHUgKiAoJHUyIC0gNykgLyA5IC8gTWF0aC5zcXJ0KDIgKiAkbilcblx0XHRcdC0gMi80MDUgLyAkbiAqICgkdTIgKiAoMyAqJHUyICsgNykgLSAxNikpO1xuXG5cdFx0aWYgKCRuIDw9IDEwMCkge1xuXHRcdFx0dmFyICR4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkcDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHo7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdCR4MCA9ICR4O1xuXHRcdFx0XHRpZiAoJHggPCAwKSB7XG5cdFx0XHRcdFx0JHAxID0gMTtcblx0XHRcdFx0fSBlbHNlIGlmICgkbj4xMDApIHtcblx0XHRcdFx0XHQkcDEgPSBfc3VidXByb2IoKE1hdGgucG93KCgkeCAvICRuKSwgKDEvMykpIC0gKDEgLSAyLzkvJG4pKVxuXHRcdFx0XHRcdFx0LyBNYXRoLnNxcnQoMi85LyRuKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJHg+NDAwKSB7XG5cdFx0XHRcdFx0JHAxID0gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgJGkwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRhO1xuXHRcdFx0XHRcdGlmICgoJG4gJSAyKSAhPSAwKSB7XG5cdFx0XHRcdFx0XHQkcDEgPSAyICogX3N1YnVwcm9iKE1hdGguc3FydCgkeCkpO1xuXHRcdFx0XHRcdFx0JGEgPSBNYXRoLnNxcnQoMi9NYXRoLlBJKSAqIE1hdGguZXhwKC0keC8yKSAvIE1hdGguc3FydCgkeCk7XG5cdFx0XHRcdFx0XHQkaTAgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQkcDEgPSAkYSA9IE1hdGguZXhwKC0keC8yKTtcblx0XHRcdFx0XHRcdCRpMCA9IDI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICh2YXIgJGkgPSAkaTA7ICRpIDw9ICRuLTI7ICRpICs9IDIpIHtcblx0XHRcdFx0XHRcdCRhICo9ICR4IC8gJGk7XG5cdFx0XHRcdFx0XHQkcDEgKz0gJGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCR6ID0gTWF0aC5leHAoKCgkbi0xKSAqIE1hdGgubG9nKCR4LyRuKSAtIE1hdGgubG9nKDQqTWF0aC5QSSokeCkgXG5cdFx0XHRcdFx0KyAkbiAtICR4IC0gMS8kbi82KSAvIDIpO1xuXHRcdFx0XHQkeCArPSAoJHAxIC0gJHApIC8gJHo7XG5cdFx0XHRcdCR4ID0gcm91bmRfdG9fcHJlY2lzaW9uKCR4LCA1KTtcblx0XHRcdH0gd2hpbGUgKCgkbiA8IDMxKSAmJiAoTWF0aC5hYnMoJHgwIC0gJHgpID4gMWUtNCkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIGxvZzEwICgkbikge1xuXHRyZXR1cm4gTWF0aC5sb2coJG4pIC8gTWF0aC5sb2coMTApO1xufVxuIFxuZnVuY3Rpb24gbWF4ICgpIHtcblx0dmFyICRtYXggPSBhcmd1bWVudHNbMF07XG5cdGZvciAodmFyICRpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgkbWF4IDwgYXJndW1lbnRzWyRpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICRtYXggPSBhcmd1bWVudHNbJGldO1xuXHR9XHRcblx0cmV0dXJuICRtYXg7XG59XG5cbmZ1bmN0aW9uIG1pbiAoKSB7XG5cdHZhciAkbWluID0gYXJndW1lbnRzWzBdO1xuXHRmb3IgKHZhciAkaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoJG1pbiA+IGFyZ3VtZW50c1skaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAkbWluID0gYXJndW1lbnRzWyRpXTtcblx0fVxuXHRyZXR1cm4gJG1pbjtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uICgkeCkge1xuXHRyZXR1cm4gTWF0aC5hYnMoaW50ZWdlcihsb2cxMChNYXRoLmFicygkeCkpIC0gU0lHTklGSUNBTlQpKTtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uX3N0cmluZyAoJHgpIHtcblx0aWYgKCR4KSB7XG5cdFx0cmV0dXJuIHJvdW5kX3RvX3ByZWNpc2lvbigkeCwgcHJlY2lzaW9uKCR4KSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFwiMFwiO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJvdW5kX3RvX3ByZWNpc2lvbiAoJHgsICRwKSB7XG4gICAgICAgICR4ID0gJHggKiBNYXRoLnBvdygxMCwgJHApO1xuICAgICAgICAkeCA9IE1hdGgucm91bmQoJHgpO1xuICAgICAgICByZXR1cm4gJHggLyBNYXRoLnBvdygxMCwgJHApO1xufVxuXG5mdW5jdGlvbiBpbnRlZ2VyICgkaSkge1xuICAgICAgICBpZiAoJGkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCRpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoJGkpO1xufSIsImltcG9ydCB7dGRpc3RyfSBmcm9tIFwiLi9zdGF0aXN0aWNzLWRpc3RyaWJ1dGlvbnNcIlxuXG52YXIgc3UgPSBtb2R1bGUuZXhwb3J0cy5TdGF0aXN0aWNzVXRpbHMgPXt9O1xuc3Uuc2FtcGxlQ29ycmVsYXRpb24gPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvc2FtcGxlX2NvcnJlbGF0aW9uJyk7XG5zdS5saW5lYXJSZWdyZXNzaW9uID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2xpbmVhcl9yZWdyZXNzaW9uJyk7XG5zdS5saW5lYXJSZWdyZXNzaW9uTGluZSA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9saW5lYXJfcmVncmVzc2lvbl9saW5lJyk7XG5zdS5lcnJvckZ1bmN0aW9uID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2Vycm9yX2Z1bmN0aW9uJyk7XG5zdS5zdGFuZGFyZERldmlhdGlvbiA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zdGFuZGFyZF9kZXZpYXRpb24nKTtcbnN1LnNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3NhbXBsZV9zdGFuZGFyZF9kZXZpYXRpb24nKTtcbnN1LnZhcmlhbmNlID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3ZhcmlhbmNlJyk7XG5zdS5tZWFuID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL21lYW4nKTtcbnN1LnpTY29yZSA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy96X3Njb3JlJyk7XG5zdS5zdGFuZGFyZEVycm9yPSBhcnIgPT4gTWF0aC5zcXJ0KHN1LnZhcmlhbmNlKGFycikvKGFyci5sZW5ndGgtMSkpO1xuc3UucXVhbnRpbGUgPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvcXVhbnRpbGUnKTtcblxuc3UudFZhbHVlPSAoZGVncmVlc09mRnJlZWRvbSwgY3JpdGljYWxQcm9iYWJpbGl0eSkgPT4geyAvL2FzIGluIGh0dHA6Ly9zdGF0dHJlay5jb20vb25saW5lLWNhbGN1bGF0b3IvdC1kaXN0cmlidXRpb24uYXNweFxuICAgIHJldHVybiB0ZGlzdHIoZGVncmVlc09mRnJlZWRvbSwgY3JpdGljYWxQcm9iYWJpbGl0eSk7XG59OyIsImltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBVdGlscyB7XG4gICAgc3RhdGljIFNRUlRfMiA9IDEuNDE0MjEzNTYyMzc7XG4gICAgLy8gdXNhZ2UgZXhhbXBsZSBkZWVwRXh0ZW5kKHt9LCBvYmpBLCBvYmpCKTsgPT4gc2hvdWxkIHdvcmsgc2ltaWxhciB0byAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqQSwgb2JqQik7XG4gICAgc3RhdGljIGRlZXBFeHRlbmQob3V0KSB7XG5cbiAgICAgICAgdmFyIHV0aWxzID0gdGhpcztcbiAgICAgICAgdmFyIGVtcHR5T3V0ID0ge307XG5cblxuICAgICAgICBpZiAoIW91dCAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG91dFtrZXldKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNPYmplY3QgPSB1dGlscy5pc09iamVjdChvdXRba2V5XSk7XG4gICAgICAgICAgICAgICAgdmFyIHNyY09iaiA9IHV0aWxzLmlzT2JqZWN0KHNvdXJjZVtrZXldKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAhaXNBcnJheSAmJiBzcmNPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMuZGVlcEV4dGVuZChvdXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgc3RhdGljIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0Tm90QXJyYXkodGFyZ2V0KSAmJiBVdGlscy5pc09iamVjdE5vdEFycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdE5vdEFycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7W2tleV06IHNvdXJjZVtrZXldfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gVXRpbHMubWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHtba2V5XTogc291cmNlW2tleV19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcm9zcyhhLCBiKSB7XG4gICAgICAgIHZhciBjID0gW10sIG4gPSBhLmxlbmd0aCwgbSA9IGIubGVuZ3RoLCBpLCBqO1xuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjspIGZvciAoaiA9IC0xOyArK2ogPCBtOykgYy5wdXNoKHt4OiBhW2ldLCBpOiBpLCB5OiBiW2pdLCBqOiBqfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaW5mZXJWYXJpYWJsZXMoZGF0YSwgZ3JvdXBLZXksIGluY2x1ZGVHcm91cCkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGlmKCFkYXRhKXtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBkID0gZGF0YVswXTtcbiAgICAgICAgICAgIGlmIChkIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBkLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGQgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwS2V5ICE9PSBudWxsICYmIGdyb3VwS2V5ICE9PSB1bmRlZmluZWQgJiYgIWluY2x1ZGVHcm91cCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVzLmluZGV4T2YoZ3JvdXBLZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIHN0YXRpYyBpc09iamVjdE5vdEFycmF5KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSAmJiBpdGVtICE9PSBudWxsKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzQXJyYXkoaXRlbSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzT2JqZWN0KGEpIHtcbiAgICAgICAgcmV0dXJuIGEgIT09IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaXNOdW1iZXIoYSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGEpICYmIHR5cGVvZiBhID09PSAnbnVtYmVyJztcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzRnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG4gICAgfTtcblxuICAgIHN0YXRpYyBpc0RhdGUoYSl7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09ICdbb2JqZWN0IERhdGVdJ1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1N0cmluZyhhKXtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCBhIGluc3RhbmNlb2YgU3RyaW5nXG4gICAgfVxuXG4gICAgc3RhdGljIGluc2VydE9yQXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3Rvciwgb3BlcmF0aW9uLCBiZWZvcmUpIHtcblxuICAgICAgICB2YXIgc2VsZWN0b3JQYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KC8oW1xcLlxcI10pLyk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcGFyZW50W29wZXJhdGlvbl0oc2VsZWN0b3JQYXJ0cy5zaGlmdCgpLCBiZWZvcmUpOy8vXCI6Zmlyc3QtY2hpbGRcIlxuICAgICAgICBcbiAgICAgICAgd2hpbGUgKHNlbGVjdG9yUGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yTW9kaWZpZXIgPSBzZWxlY3RvclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JJdGVtID0gc2VsZWN0b3JQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yTW9kaWZpZXIgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuY2xhc3NlZChzZWxlY3Rvckl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvck1vZGlmaWVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmF0dHIoJ2lkJywgc2VsZWN0b3JJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5zZXJ0U2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5pbnNlcnRPckFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IsIFwiaW5zZXJ0XCIsIGJlZm9yZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmluc2VydE9yQXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgXCJhcHBlbmRcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdE9yQXBwZW5kKHBhcmVudCwgc2VsZWN0b3IsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHBhcmVudC5zZWxlY3Qoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuYXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG5cbiAgICBzdGF0aWMgc2VsZWN0T3JJbnNlcnQocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBwYXJlbnQuc2VsZWN0KHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaW5zZXJ0U2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG5cbiAgICBzdGF0aWMgbGluZWFyR3JhZGllbnQoc3ZnLCBncmFkaWVudElkLCByYW5nZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBVdGlscy5zZWxlY3RPckFwcGVuZChzdmcsIFwiZGVmc1wiKTtcbiAgICAgICAgdmFyIGxpbmVhckdyYWRpZW50ID0gZGVmcy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBncmFkaWVudElkKTtcblxuICAgICAgICBsaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4MSArIFwiJVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5MSArIFwiJVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4MiArIFwiJVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5MiArIFwiJVwiKTtcblxuICAgICAgICAvL0FwcGVuZCBtdWx0aXBsZSBjb2xvciBzdG9wcyBieSB1c2luZyBEMydzIGRhdGEvZW50ZXIgc3RlcFxuICAgICAgICB2YXIgc3RvcHMgPSBsaW5lYXJHcmFkaWVudC5zZWxlY3RBbGwoXCJzdG9wXCIpXG4gICAgICAgICAgICAuZGF0YShyYW5nZSk7XG5cbiAgICAgICAgdmFyIHN0b3BzTWVyZ2UgPSBzdG9wcy5lbnRlcigpLmFwcGVuZChcInN0b3BcIikubWVyZ2Uoc3RvcHMpO1xuXG4gICAgICAgIHN0b3BzTWVyZ2UuYXR0cihcIm9mZnNldFwiLCAoZCwgaSkgPT4gaSAvIChyYW5nZS5sZW5ndGggLSAxKSlcbiAgICAgICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBkID0+IGQpO1xuXG4gICAgICAgIHN0b3BzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2FuaXRpemVIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSwgMTApIHx8IDQwMCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBzYW5pdGl6ZVdpZHRoID0gZnVuY3Rpb24gKHdpZHRoLCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuICh3aWR0aCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJyksIDEwKSB8fCA5NjApO1xuICAgIH07XG5cbiAgICBzdGF0aWMgYXZhaWxhYmxlSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIFV0aWxzLnNhbml0aXplSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyKSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGF2YWlsYWJsZVdpZHRoID0gZnVuY3Rpb24gKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgVXRpbHMuc2FuaXRpemVXaWR0aCh3aWR0aCwgY29udGFpbmVyKSAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGd1aWQoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArXG4gICAgICAgICAgICBzNCgpICsgJy0nICsgczQoKSArIHM0KCkgKyBzNCgpO1xuICAgIH1cblxuICAgIC8vcGxhY2VzIHRleHRTdHJpbmcgaW4gdGV4dE9iaiwgYWRkcyBhbiBlbGxpcHNpcyBpZiB0ZXh0IGNhbid0IGZpdCBpbiB3aWR0aFxuICAgIHN0YXRpYyBwbGFjZVRleHRXaXRoRWxsaXBzaXModGV4dEQzT2JqLCB0ZXh0U3RyaW5nLCB3aWR0aCl7XG4gICAgICAgIHZhciB0ZXh0T2JqID0gdGV4dEQzT2JqLm5vZGUoKTtcbiAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudD10ZXh0U3RyaW5nO1xuXG4gICAgICAgIHZhciBtYXJnaW4gPSAwO1xuICAgICAgICB2YXIgZWxsaXBzaXNMZW5ndGggPSA5O1xuICAgICAgICAvL2VsbGlwc2lzIGlzIG5lZWRlZFxuICAgICAgICBpZiAodGV4dE9iai5nZXRDb21wdXRlZFRleHRMZW5ndGgoKT53aWR0aCttYXJnaW4pe1xuICAgICAgICAgICAgZm9yICh2YXIgeD10ZXh0U3RyaW5nLmxlbmd0aC0zO3g+MDt4LT0xKXtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE9iai5nZXRTdWJTdHJpbmdMZW5ndGgoMCx4KStlbGxpcHNpc0xlbmd0aDw9d2lkdGgrbWFyZ2luKXtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudD10ZXh0U3RyaW5nLnN1YnN0cmluZygwLHgpK1wiLi4uXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRPYmoudGV4dENvbnRlbnQ9XCIuLi5cIjsgLy9jYW4ndCBwbGFjZSBhdCBhbGxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGxhY2VUZXh0V2l0aEVsbGlwc2lzQW5kVG9vbHRpcCh0ZXh0RDNPYmosIHRleHRTdHJpbmcsIHdpZHRoLCB0b29sdGlwKXtcbiAgICAgICAgdmFyIGVsbGlwc2lzUGxhY2VkID0gVXRpbHMucGxhY2VUZXh0V2l0aEVsbGlwc2lzKHRleHREM09iaiwgdGV4dFN0cmluZywgd2lkdGgpO1xuICAgICAgICBpZihlbGxpcHNpc1BsYWNlZCAmJiB0b29sdGlwKXtcbiAgICAgICAgICAgIHRleHREM09iai5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuaHRtbCh0ZXh0U3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIChkMy5ldmVudC5wYWdlWCArIDUpICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgKGQzLmV2ZW50LnBhZ2VZIC0gMjgpICsgXCJweFwiKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0ZXh0RDNPYmoub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGljIGdldEZvbnRTaXplKGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnQtc2l6ZVwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTY2FsZShzY2FsZU5hbWUpIHtcbiAgICAgICAgdmFyIHNjYWxlRnVuY3Rpb25OYW1lID0gJ3NjYWxlJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoc2NhbGVOYW1lKTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgcmV0dXJuIGQzW3NjYWxlRnVuY3Rpb25OYW1lXSgpO1xuICAgICAgICB9Y2F0Y2ggKGUpe1xuICAgICAgICAgICAgdGhyb3cgJ09EQy1EMyAtIHNjYWxlIG5vdCBzdXBwb3J0ZWQ6ICcrc2NhbGVOYW1lKyAnICgnK3NjYWxlRnVuY3Rpb25OYW1lKycpJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVBeGlzKG9yaWVudCwgc2NhbGUpe1xuICAgICAgICB2YXIgYXhpc0ZuTmFtZSA9ICdheGlzJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIob3JpZW50KTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgcmV0dXJuIGQzW2F4aXNGbk5hbWVdKHNjYWxlKVxuICAgICAgICB9Y2F0Y2ggKGUpe1xuICAgICAgICAgICAgdGhyb3cgJ09EQy1EMyAtIGF4aXMgb3JpZW50IG5vdCBzdXBwb3J0ZWQ6ICcrb3JpZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuIl19
