(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ODCD3 = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],2:[function(require,module,exports){
// https://d3js.org/d3-color/ v1.2.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://beta.observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.lch = lch;
exports.gray = gray;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = d3Color.rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function array(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function number(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
      : b instanceof d3Color.color ? rgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function round(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$1 = hsl(hue);
var hslLong = hsl(nogamma);

function lab(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$1 = hcl(hue);
var hclLong = hcl(nogamma);

function cubehelix(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

var cubehelix$1 = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHue = hue$1;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$1;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab;
exports.interpolateHcl = hcl$1;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$1;
exports.interpolateCubehelixLong = cubehelixLong;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":2}],4:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-format'), require('d3-dispatch'), require('d3-scale'), require('d3-array')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-format', 'd3-dispatch', 'd3-scale', 'd3-array'], factory) :
	(factory((global.indexRollup = global.indexRollup || {}),global.d3Selection,global.d3Format,global.d3Dispatch,global.d3Scale,global.d3Array));
}(this, (function (exports,d3Selection,d3Format,d3Dispatch,d3Scale,d3Array) { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var d3_identity = function d3_identity(d) {
  return d;
};

var d3_reverse = function d3_reverse(arr) {
  var mirror = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    mirror[i] = arr[l - i - 1];
  }
  return mirror;
};

//Text wrapping code adapted from Mike Bostock
var d3_textWrapping = function d3_textWrapping(text, width) {
  text.each(function () {
    var text = d3Selection.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.2,
        //ems
    y = text.attr("y"),
        dy = parseFloat(text.attr("dy")) || 0,
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", dy + "em");

    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width && line.length > 1) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + dy + "em").text(word);
      }
    }
  });
};

var d3_mergeLabels = function d3_mergeLabels() {
  var gen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var labels = arguments[1];
  var domain = arguments[2];
  var range = arguments[3];
  var labelDelimiter = arguments[4];

  if ((typeof labels === "undefined" ? "undefined" : _typeof(labels)) === "object") {
    if (labels.length === 0) return gen;

    var i = labels.length;
    for (; i < gen.length; i++) {
      labels.push(gen[i]);
    }
    return labels;
  } else if (typeof labels === "function") {
    var customLabels = [];
    var genLength = gen.length;
    for (var _i = 0; _i < genLength; _i++) {
      customLabels.push(labels({
        i: _i,
        genLength: genLength,
        generatedLabels: gen,
        domain: domain,
        range: range,
        labelDelimiter: labelDelimiter
      }));
    }
    return customLabels;
  }

  return gen;
};

var d3_linearLegend = function d3_linearLegend(scale, cells, labelFormat) {
  var data = [];

  if (cells.length > 1) {
    data = cells;
  } else {
    var domain = scale.domain(),
        increment = (domain[domain.length - 1] - domain[0]) / (cells - 1);
    var i = 0;

    for (; i < cells; i++) {
      data.push(domain[0] + i * increment);
    }
  }

  var labels = data.map(labelFormat);
  return {
    data: data,
    labels: labels,
    feature: function feature(d) {
      return scale(d);
    }
  };
};

var d3_quantLegend = function d3_quantLegend(scale, labelFormat, labelDelimiter) {
  var labels = scale.range().map(function (d) {
    var invert = scale.invertExtent(d);
    return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
  });

  return {
    data: scale.range(),
    labels: labels,
    feature: d3_identity
  };
};

var d3_ordinalLegend = function d3_ordinalLegend(scale) {
  return {
    data: scale.domain(),
    labels: scale.domain(),
    feature: function feature(d) {
      return scale(d);
    }
  };
};

var d3_cellOver = function d3_cellOver(cellDispatcher, d, obj) {
  cellDispatcher.call("cellover", obj, d);
};

var d3_cellOut = function d3_cellOut(cellDispatcher, d, obj) {
  cellDispatcher.call("cellout", obj, d);
};

var d3_cellClick = function d3_cellClick(cellDispatcher, d, obj) {
  cellDispatcher.call("cellclick", obj, d);
};

var helper = {
  d3_drawShapes: function d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
    if (shape === "rect") {
      shapes.attr("height", shapeHeight).attr("width", shapeWidth);
    } else if (shape === "circle") {
      shapes.attr("r", shapeRadius);
    } else if (shape === "line") {
      shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);
    } else if (shape === "path") {
      shapes.attr("d", path);
    }
  },

  d3_addText: function d3_addText(svg, enter, labels, classPrefix, labelWidth) {
    enter.append("text").attr("class", classPrefix + "label");
    var text = svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").data(labels).text(d3_identity);

    if (labelWidth) {
      svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").call(d3_textWrapping, labelWidth);
    }

    return text;
  },

  d3_calcType: function d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter) {
    var type = scale.invertExtent ? d3_quantLegend(scale, labelFormat, labelDelimiter) : scale.ticks ? d3_linearLegend(scale, cells, labelFormat) : d3_ordinalLegend(scale);

    //for d3.scaleSequential that doesn't have a range function
    var range = scale.range && scale.range() || scale.domain();
    type.labels = d3_mergeLabels(type.labels, labels, scale.domain(), range, labelDelimiter);

    if (ascending) {
      type.labels = d3_reverse(type.labels);
      type.data = d3_reverse(type.data);
    }

    return type;
  },

  d3_filterCells: function d3_filterCells(type, cellFilter) {
    var filterCells = type.data.map(function (d, i) {
      return { data: d, label: type.labels[i] };
    }).filter(cellFilter);
    var dataValues = filterCells.map(function (d) {
      return d.data;
    });
    var labelValues = filterCells.map(function (d) {
      return d.label;
    });
    type.data = type.data.filter(function (d) {
      return dataValues.indexOf(d) !== -1;
    });
    type.labels = type.labels.filter(function (d) {
      return labelValues.indexOf(d) !== -1;
    });
    return type;
  },

  d3_placement: function d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign) {
    cell.attr("transform", cellTrans);
    text.attr("transform", textTrans);
    if (orient === "horizontal") {
      text.style("text-anchor", labelAlign);
    }
  },

  d3_addEvents: function d3_addEvents(cells, dispatcher) {
    cells.on("mouseover.legend", function (d) {
      d3_cellOver(dispatcher, d, this);
    }).on("mouseout.legend", function (d) {
      d3_cellOut(dispatcher, d, this);
    }).on("click.legend", function (d) {
      d3_cellClick(dispatcher, d, this);
    });
  },

  d3_title: function d3_title(svg, title, classPrefix, titleWidth) {
    if (title !== "") {
      var titleText = svg.selectAll("text." + classPrefix + "legendTitle");

      titleText.data([title]).enter().append("text").attr("class", classPrefix + "legendTitle");

      svg.selectAll("text." + classPrefix + "legendTitle").text(title);

      if (titleWidth) {
        svg.selectAll("text." + classPrefix + "legendTitle").call(d3_textWrapping, titleWidth);
      }

      var cellsSvg = svg.select("." + classPrefix + "legendCells");
      var yOffset = svg.select("." + classPrefix + "legendTitle").nodes().map(function (d) {
        return d.getBBox().height;
      })[0],
          xOffset = -cellsSvg.nodes().map(function (d) {
        return d.getBBox().x;
      })[0];
      cellsSvg.attr("transform", "translate(" + xOffset + "," + yOffset + ")");
    }
  },

  d3_defaultLocale: {
    format: d3Format.format,
    formatPrefix: d3Format.formatPrefix
  },

  d3_defaultFormatSpecifier: ".01f",

  d3_defaultDelimiter: "to"
};

function color() {
  var scale = d3Scale.scaleLinear(),
      shape = "rect",
      shapeWidth = 15,
      shapeHeight = 15,
      shapeRadius = 10,
      shapePadding = 2,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      useClass = false,
      title = "",
      locale = helper.d3_defaultLocale,
      specifier = helper.d3_defaultFormatSpecifier,
      labelOffset = 10,
      labelAlign = "middle",
      labelDelimiter = helper.d3_defaultDelimiter,
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      path = void 0,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {
    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
        legendG = svg.selectAll("g").data([scale]);

    legendG.enter().append("g").attr("class", classPrefix + "legendCells");

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);

    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch").data(type.data);

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    cell.exit().transition().style("opacity", 0).remove();
    shapes.exit().transition().style("opacity", 0).remove();

    shapes = shapes.merge(shapes);

    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);
    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    // sets placement
    var textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d) {
      return d.getBBox();
    });
    //sets scale
    //everything is fill except for line which is stroke,
    if (!useClass) {
      if (shape == "line") {
        shapes.style("stroke", type.feature);
      } else {
        shapes.style("fill", type.feature);
      }
    } else {
      shapes.attr("class", function (d) {
        return classPrefix + "swatch " + type.feature(d);
      });
    }

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(d.height, shapeSize[i].height);
        });

        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));
          return "translate(0, " + (height + i * shapePadding) + ")";
        };

        textTrans = function textTrans(d, i) {
          return "translate( " + (shapeSize[i].width + shapeSize[i].x + labelOffset) + ", " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans(d, i) {
        return "translate(" + i * (shapeSize[i].width + shapePadding) + ",0)";
      };
      textTrans = function textTrans(d, i) {
        return "translate(" + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n          " + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ")";
      };
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);

    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shape = function (_, d) {
    if (!arguments.length) return shape;
    if (_ == "rect" || _ == "circle" || _ == "line" || _ == "path" && typeof d === "string") {
      shape = _;
      path = d;
    }
    return legend;
  };

  legend.shapeWidth = function (_) {
    if (!arguments.length) return shapeWidth;
    shapeWidth = +_;
    return legend;
  };

  legend.shapeHeight = function (_) {
    if (!arguments.length) return shapeHeight;
    shapeHeight = +_;
    return legend;
  };

  legend.shapeRadius = function (_) {
    if (!arguments.length) return shapeRadius;
    shapeRadius = +_;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.locale = function (_) {
    if (!arguments.length) return locale;
    locale = d3Format.formatLocale(_);
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return legend.locale().format(specifier);
    specifier = d3Format.formatSpecifier(_);
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.useClass = function (_) {
    if (!arguments.length) return useClass;
    if (_ === true || _ === false) {
      useClass = _;
    }
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

function size() {
  var scale = d3Scale.scaleLinear(),
      shape = "rect",
      shapeWidth = 15,
      shapePadding = 2,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      title = "",
      locale = helper.d3_defaultLocale,
      specifier = helper.d3_defaultFormatSpecifier,
      labelOffset = 10,
      labelAlign = "middle",
      labelDelimiter = helper.d3_defaultDelimiter,
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      path = void 0,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {
    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
        legendG = svg.selectAll("g").data([scale]);

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    legendG.enter().append("g").attr("class", classPrefix + "legendCells");

    var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);
    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch");

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    cell.exit().transition().style("opacity", 0).remove();

    shapes.exit().transition().style("opacity", 0).remove();
    shapes = shapes.merge(shapes);

    //creates shape
    if (shape === "line") {
      helper.d3_drawShapes(shape, shapes, 0, shapeWidth);
      shapes.attr("stroke-width", type.feature);
    } else {
      helper.d3_drawShapes(shape, shapes, type.feature, type.feature, type.feature, path);
    }

    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    //sets placement

    var textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d, i) {
      var bbox = d.getBBox();
      var stroke = scale(type.data[i]);

      if (shape === "line" && orient === "horizontal") {
        bbox.height = bbox.height + stroke;
      } else if (shape === "line" && orient === "vertical") {
        bbox.width = bbox.width;
      }
      return bbox;
    });

    var maxH = d3Array.max(shapeSize, function (d) {
      return d.height + d.y;
    }),
        maxW = d3Array.max(shapeSize, function (d) {
      return d.width + d.x;
    });

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(d.height, shapeSize[i].height);
        });
        var y = shape == "circle" || shape == "line" ? shapeSize[0].height / 2 : 0;
        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));

          return "translate(0, " + (y + height + i * shapePadding) + ")";
        };

        textTrans = function textTrans(d, i) {
          return "translate( " + (maxW + labelOffset) + ",\n          " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
        };
      })();
    } else if (orient === "horizontal") {
      (function () {
        cellTrans = function cellTrans(d, i) {
          var width = d3Array.sum(shapeSize.slice(0, i), function (d) {
            return d.width;
          });
          var y = shape == "circle" || shape == "line" ? maxH / 2 : 0;
          return "translate(" + (width + i * shapePadding) + ", " + y + ")";
        };

        var offset = shape == "line" ? maxH / 2 : maxH;
        textTrans = function textTrans(d, i) {
          return "translate( " + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n              " + (offset + labelOffset) + ")";
        };
      })();
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);

    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shape = function (_, d) {
    if (!arguments.length) return shape;
    if (_ == "rect" || _ == "circle" || _ == "line") {
      shape = _;
      path = d;
    }
    return legend;
  };

  legend.shapeWidth = function (_) {
    if (!arguments.length) return shapeWidth;
    shapeWidth = +_;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.locale = function (_) {
    if (!arguments.length) return locale;
    locale = d3Format.formatLocale(_);
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return legend.locale().format(specifier);
    specifier = d3Format.formatSpecifier(_);
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

function symbol() {
  var scale = d3Scale.scaleLinear(),
      shape = "path",
      shapeWidth = 15,
      shapeHeight = 15,
      shapeRadius = 10,
      shapePadding = 5,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      title = "",
      locale = helper.d3_defaultLocale,
      specifier = helper.d3_defaultFormatSpecifier,
      labelAlign = "middle",
      labelOffset = 10,
      labelDelimiter = helper.d3_defaultDelimiter,
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {
    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
        legendG = svg.selectAll("g").data([scale]);

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    legendG.enter().append("g").attr("class", classPrefix + "legendCells");

    var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);
    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch");

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    //remove old shapes
    cell.exit().transition().style("opacity", 0).remove();
    shapes.exit().transition().style("opacity", 0).remove();
    shapes = shapes.merge(shapes);

    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, type.feature);
    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    // sets placement
    var textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d) {
      return d.getBBox();
    });

    var maxH = d3Array.max(shapeSize, function (d) {
      return d.height;
    }),
        maxW = d3Array.max(shapeSize, function (d) {
      return d.width;
    });

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(maxH, d.height);
        });

        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));
          return "translate(0, " + (height + i * shapePadding) + " )";
        };
        textTrans = function textTrans(d, i) {
          return "translate( " + (maxW + labelOffset) + ",\n              " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans(d, i) {
        return "translate( " + i * (maxW + shapePadding) + ",0)";
      };
      textTrans = function textTrans(d, i) {
        return "translate( " + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n              " + (maxH + labelOffset) + ")";
      };
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);
    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.locale = function (_) {
    if (!arguments.length) return locale;
    locale = d3Format.formatLocale(_);
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return legend.locale().format(specifier);
    specifier = d3Format.formatSpecifier(_);
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

var thresholdLabels = function thresholdLabels(_ref) {
  var i = _ref.i,
      genLength = _ref.genLength,
      generatedLabels = _ref.generatedLabels,
      labelDelimiter = _ref.labelDelimiter;

  if (i === 0) {
    var values = generatedLabels[i].split(" " + labelDelimiter + " ");
    return "Less than " + values[1];
  } else if (i === genLength - 1) {
    var _values = generatedLabels[i].split(" " + labelDelimiter + " ");
    return _values[0] + " or more";
  }
  return generatedLabels[i];
};

var legendHelpers = {
  thresholdLabels: thresholdLabels
};

var index = {
  legendColor: color,
  legendSize: size,
  legendSymbol: symbol,
  legendHelpers: legendHelpers
};

exports.legendColor = color;
exports.legendSize = size;
exports.legendSymbol = symbol;
exports.legendHelpers = legendHelpers;
exports['default'] = index;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{"d3-array":5,"d3-dispatch":6,"d3-format":7,"d3-scale":8,"d3-selection":9}],5:[function(require,module,exports){
// https://d3js.org/d3-array/ Version 1.0.1. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  function descending(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  function number(x) {
    return x === null ? NaN : +x;
  }

  function variance(array, f) {
    var n = array.length,
        m = 0,
        a,
        d,
        s = 0,
        i = -1,
        j = 0;

    if (f == null) {
      while (++i < n) {
        if (!isNaN(a = number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    else {
      while (++i < n) {
        if (!isNaN(a = number(f(array[i], i, array)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    if (j > 1) return s / (j - 1);
  }

  function deviation(array, f) {
    var v = variance(array, f);
    return v ? Math.sqrt(v) : v;
  }

  function extent(array, f) {
    var i = -1,
        n = array.length,
        a,
        b,
        c;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    return [a, c];
  }

  var array = Array.prototype;

  var slice = array.slice;
  var map = array.map;

  function constant(x) {
    return function() {
      return x;
    };
  }

  function identity(x) {
    return x;
  }

  function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function ticks(start, stop, count) {
    var step = tickStep(start, stop, count);
    return range(
      Math.ceil(start / step) * step,
      Math.floor(stop / step) * step + step / 2, // inclusive
      step
    );
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function sturges(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
  }

  function histogram() {
    var value = identity,
        domain = extent,
        threshold = sturges;

    function histogram(data) {
      var i,
          n = data.length,
          x,
          values = new Array(n);

      for (i = 0; i < n; ++i) {
        values[i] = value(data[i], i, data);
      }

      var xz = domain(values),
          x0 = xz[0],
          x1 = xz[1],
          tz = threshold(values, x0, x1);

      // Convert number of thresholds into uniform thresholds.
      if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);

      // Remove any thresholds outside the domain.
      var m = tz.length;
      while (tz[0] <= x0) tz.shift(), --m;
      while (tz[m - 1] >= x1) tz.pop(), --m;

      var bins = new Array(m + 1),
          bin;

      // Initialize bins.
      for (i = 0; i <= m; ++i) {
        bin = bins[i] = [];
        bin.x0 = i > 0 ? tz[i - 1] : x0;
        bin.x1 = i < m ? tz[i] : x1;
      }

      // Assign data to bins by value, ignoring any outside the domain.
      for (i = 0; i < n; ++i) {
        x = values[i];
        if (x0 <= x && x <= x1) {
          bins[bisectRight(tz, x, 0, m)].push(data[i]);
        }
      }

      return bins;
    }

    histogram.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
    };

    histogram.domain = function(_) {
      return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
    };

    histogram.thresholds = function(_) {
      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
    };

    return histogram;
  }

  function quantile(array, p, f) {
    if (f == null) f = number;
    if (!(n = array.length)) return;
    if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
    if (p >= 1) return +f(array[n - 1], n - 1, array);
    var n,
        h = (n - 1) * p,
        i = Math.floor(h),
        a = +f(array[i], i, array),
        b = +f(array[i + 1], i + 1, array);
    return a + (b - a) * (h - i);
  }

  function freedmanDiaconis(values, min, max) {
    values = map.call(values, number).sort(ascending);
    return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
  }

  function scott(values, min, max) {
    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
  }

  function max(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
    }

    return a;
  }

  function mean(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1,
        j = n;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number(array[i]))) s += a; else --j;
    }

    else {
      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a; else --j;
    }

    if (j) return s / j;
  }

  function median(array, f) {
    var numbers = [],
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);
    }

    else {
      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);
    }

    return quantile(numbers.sort(ascending), 0.5);
  }

  function merge(arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) j += arrays[i].length;
    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  }

  function min(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
    }

    return a;
  }

  function pairs(array) {
    var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [p, p = array[++i]];
    return pairs;
  }

  function permute(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  }

  function scan(array, compare) {
    if (!(n = array.length)) return;
    var i = 0,
        n,
        j = 0,
        xi,
        xj = array[j];

    if (!compare) compare = ascending;

    while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;

    if (compare(xj, xj) === 0) return j;
  }

  function shuffle(array, i0, i1) {
    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }

    return array;
  }

  function sum(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
    }

    else {
      while (++i < n) if (a = +f(array[i], i, array)) s += a;
    }

    return s;
  }

  function transpose(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  }

  function length(d) {
    return d.length;
  }

  function zip() {
    return transpose(arguments);
  }

  exports.bisect = bisectRight;
  exports.bisectRight = bisectRight;
  exports.bisectLeft = bisectLeft;
  exports.ascending = ascending;
  exports.bisector = bisector;
  exports.descending = descending;
  exports.deviation = deviation;
  exports.extent = extent;
  exports.histogram = histogram;
  exports.thresholdFreedmanDiaconis = freedmanDiaconis;
  exports.thresholdScott = scott;
  exports.thresholdSturges = sturges;
  exports.max = max;
  exports.mean = mean;
  exports.median = median;
  exports.merge = merge;
  exports.min = min;
  exports.pairs = pairs;
  exports.permute = permute;
  exports.quantile = quantile;
  exports.range = range;
  exports.scan = scan;
  exports.shuffle = shuffle;
  exports.sum = sum;
  exports.ticks = ticks;
  exports.tickStep = tickStep;
  exports.transpose = transpose;
  exports.variance = variance;
  exports.zip = zip;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],6:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ Version 1.0.1. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  var noop = {value: function() {}};

  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch(_);
  }

  function Dispatch(_) {
    this._ = _;
  }

  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return {type: t, name: name};
    });
  }

  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._,
          T = parseTypenames(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
      }

      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _) copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };

  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({name: name, value: callback});
    return type;
  }

  exports.dispatch = dispatch;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],7:[function(require,module,exports){
// https://d3js.org/d3-format/ Version 1.0.2. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatDefault(x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        case "e": break out;
        default: if (i0 > 0) i0 = 0; break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "": formatDefault,
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + this.type;
  };

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function identity(x) {
    return x;
  }

  function formatLocale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
        currency = locale.currency,
        decimal = locale.decimal;

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? (type ? 6 : 12)
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Convert negative to positive, and compute the prefix.
          // Note that -0 is not less than 0, but 1 / -0 is!
          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

          // Perform the initial formatting.
          value = formatType(value, precision);

          // If the original value was negative, it may be rounded to zero during
          // formatting; treat this as (positive) zero.
          if (valueNegative) {
            i = -1, n = value.length;
            valueNegative = false;
            while (++i < n) {
              if (c = value.charCodeAt(i), (48 < c && c < 58)
                  || (type === "x" && 96 < c && c < 103)
                  || (type === "X" && 64 < c && c < 71)) {
                valueNegative = true;
                break;
              }
            }
          }

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": return valuePrefix + value + valueSuffix + padding;
          case "=": return valuePrefix + padding + value + valueSuffix;
          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
        }
        return padding + valuePrefix + value + valueSuffix;
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    exports.format = locale.format;
    exports.formatPrefix = locale.formatPrefix;
    return locale;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  }

  exports.formatDefaultLocale = defaultLocale;
  exports.formatLocale = formatLocale;
  exports.formatSpecifier = formatSpecifier;
  exports.precisionFixed = precisionFixed;
  exports.precisionPrefix = precisionPrefix;
  exports.precisionRound = precisionRound;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],8:[function(require,module,exports){
// https://d3js.org/d3-scale/ Version 1.0.3. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-collection'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format'), require('d3-color')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format', 'd3-color'], factory) :
  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat,d3Color) { 'use strict';

  var array = Array.prototype;

  var map$1 = array.map;
  var slice = array.slice;

  var implicit = {name: "implicit"};

  function ordinal(range) {
    var index = d3Collection.map(),
        domain = [],
        unknown = implicit;

    range = range == null ? [] : slice.call(range);

    function scale(d) {
      var key = d + "", i = index.get(key);
      if (!i) {
        if (unknown !== implicit) return unknown;
        index.set(key, i = domain.push(d));
      }
      return range[(i - 1) % range.length];
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = d3Collection.map();
      var i = -1, n = _.length, d, key;
      while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
      return scale;
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), scale) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return ordinal()
          .domain(domain)
          .range(range)
          .unknown(unknown);
    };

    return scale;
  }

  function band() {
    var scale = ordinal().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range,
        range = [0, 1],
        step,
        bandwidth,
        round = false,
        paddingInner = 0,
        paddingOuter = 0,
        align = 0.5;

    delete scale.unknown;

    function rescale() {
      var n = domain().length,
          reverse = range[1] < range[0],
          start = range[reverse - 0],
          stop = range[1 - reverse];
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = d3Array.range(n).map(function(i) { return start + step * i; });
      return ordinalRange(reverse ? values.reverse() : values);
    }

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.range = function(_) {
      return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = [+_[0], +_[1]], round = true, rescale();
    };

    scale.bandwidth = function() {
      return bandwidth;
    };

    scale.step = function() {
      return step;
    };

    scale.round = function(_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };

    scale.padding = function(_) {
      return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
    };

    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };

    scale.copy = function() {
      return band()
          .domain(domain())
          .range(range)
          .round(round)
          .paddingInner(paddingInner)
          .paddingOuter(paddingOuter)
          .align(align);
    };

    return rescale();
  }

  function pointish(scale) {
    var copy = scale.copy;

    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;

    scale.copy = function() {
      return pointish(copy());
    };

    return scale;
  }

  function point() {
    return pointish(band().paddingInner(1));
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  function number(x) {
    return +x;
  }

  var unit = [0, 1];

  function deinterpolate(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant(b);
  }

  function deinterpolateClamp(deinterpolate) {
    return function(a, b) {
      var d = deinterpolate(a = +a, b = +b);
      return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
    };
  }

  function reinterpolateClamp(reinterpolate) {
    return function(a, b) {
      var r = reinterpolate(a = +a, b = +b);
      return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
    };
  }

  function bimap(domain, range, deinterpolate, reinterpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
    else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, deinterpolate, reinterpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = deinterpolate(domain[i], domain[i + 1]);
      r[i] = reinterpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = d3Array.bisect(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp());
  }

  // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
  function continuous(deinterpolate$$, reinterpolate) {
    var domain = unit,
        range = unit,
        interpolate = d3Interpolate.interpolate,
        clamp = false,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate$$) : deinterpolate$$, interpolate)))(+x);
    }

    scale.invert = function(y) {
      return (input || (input = piecewise(range, domain, deinterpolate, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, rescale()) : clamp;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    return rescale();
  }

  function tickFormat(domain, count, specifier) {
    var start = domain[0],
        stop = domain[domain.length - 1],
        step = d3Array.tickStep(start, stop, count == null ? 10 : count),
        precision;
    specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
        return d3Format.formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return d3Format.format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      return tickFormat(domain(), count, specifier);
    };

    scale.nice = function(count) {
      var d = domain(),
          i = d.length - 1,
          n = count == null ? 10 : count,
          start = d[0],
          stop = d[i],
          step = d3Array.tickStep(start, stop, n);

      if (step) {
        step = d3Array.tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
        d[0] = Math.floor(start / step) * step;
        d[i] = Math.ceil(stop / step) * step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear() {
    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber);

    scale.copy = function() {
      return copy(scale, linear());
    };

    return linearish(scale);
  }

  function identity() {
    var domain = [0, 1];

    function scale(x) {
      return +x;
    }

    scale.invert = scale;

    scale.domain = scale.range = function(_) {
      return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
    };

    scale.copy = function() {
      return identity().domain(domain);
    };

    return linearish(scale);
  }

  function nice(domain, interval) {
    domain = domain.slice();

    var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;

    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }

    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  function deinterpolate$1(a, b) {
    return (b = Math.log(b / a))
        ? function(x) { return Math.log(x / a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    return a < 0
        ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
        : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
  }

  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }

  function powp(base) {
    return base === 10 ? pow10
        : base === Math.E ? Math.exp
        : function(x) { return Math.pow(base, x); };
  }

  function logp(base) {
    return base === Math.E ? Math.log
        : base === 10 && Math.log10
        || base === 2 && Math.log2
        || (base = Math.log(base), function(x) { return Math.log(x) / base; });
  }

  function reflect(f) {
    return function(x) {
      return -f(-x);
    };
  }

  function log() {
    var scale = continuous(deinterpolate$1, reinterpolate).domain([1, 10]),
        domain = scale.domain,
        base = 10,
        logs = logp(10),
        pows = powp(10);

    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
      return scale;
    }

    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.ticks = function(count) {
      var d = domain(),
          u = d[0],
          v = d[d.length - 1],
          r;

      if (r = v < u) i = u, u = v, v = i;

      var i = logs(u),
          j = logs(v),
          p,
          k,
          t,
          n = count == null ? 10 : +count,
          z = [];

      if (!(base % 1) && j - i < n) {
        i = Math.round(i) - 1, j = Math.round(j) + 1;
        if (u > 0) for (; i < j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        } else for (; i < j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
      } else {
        z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
      }

      return r ? z.reverse() : z;
    };

    scale.tickFormat = function(count, specifier) {
      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
      if (typeof specifier !== "function") specifier = d3Format.format(specifier);
      if (count === Infinity) return specifier;
      if (count == null) count = 10;
      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
      return function(d) {
        var i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };

    scale.nice = function() {
      return domain(nice(domain(), {
        floor: function(x) { return pows(Math.floor(logs(x))); },
        ceil: function(x) { return pows(Math.ceil(logs(x))); }
      }));
    };

    scale.copy = function() {
      return copy(scale, log().base(base));
    };

    return scale;
  }

  function raise(x, exponent) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  }

  function pow() {
    var exponent = 1,
        scale = continuous(deinterpolate, reinterpolate),
        domain = scale.domain;

    function deinterpolate(a, b) {
      return (b = raise(b, exponent) - (a = raise(a, exponent)))
          ? function(x) { return (raise(x, exponent) - a) / b; }
          : constant(b);
    }

    function reinterpolate(a, b) {
      b = raise(b, exponent) - (a = raise(a, exponent));
      return function(t) { return raise(a + b * t, 1 / exponent); };
    }

    scale.exponent = function(_) {
      return arguments.length ? (exponent = +_, domain(domain())) : exponent;
    };

    scale.copy = function() {
      return copy(scale, pow().exponent(exponent));
    };

    return linearish(scale);
  }

  function sqrt() {
    return pow().exponent(0.5);
  }

  function quantile$1() {
    var domain = [],
        range = [],
        thresholds = [];

    function rescale() {
      var i = 0, n = Math.max(1, range.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
      return scale;
    }

    function scale(x) {
      if (!isNaN(x = +x)) return range[d3Array.bisect(thresholds, x)];
    }

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(d3Array.ascending);
      return rescale();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
    };

    scale.quantiles = function() {
      return thresholds.slice();
    };

    scale.copy = function() {
      return quantile$1()
          .domain(domain)
          .range(range);
    };

    return scale;
  }

  function quantize() {
    var x0 = 0,
        x1 = 1,
        n = 1,
        domain = [0.5],
        range = [0, 1];

    function scale(x) {
      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
    }

    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }

    scale.domain = function(_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
    };

    scale.range = function(_) {
      return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN]
          : i < 1 ? [x0, domain[0]]
          : i >= n ? [domain[n - 1], x1]
          : [domain[i - 1], domain[i]];
    };

    scale.copy = function() {
      return quantize()
          .domain([x0, x1])
          .range(range);
    };

    return linearish(scale);
  }

  function threshold() {
    var domain = [0.5],
        range = [0, 1],
        n = 1;

    function scale(x) {
      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
    }

    scale.domain = function(_) {
      return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return [domain[i - 1], domain[i]];
    };

    scale.copy = function() {
      return threshold()
          .domain(domain)
          .range(range);
    };

    return scale;
  }

  var durationSecond = 1000;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;
  function date(t) {
    return new Date(t);
  }

  function number$1(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }

  function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber),
        invert = scale.invert,
        domain = scale.domain;

    var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");

    var tickIntervals = [
      [second,  1,      durationSecond],
      [second,  5,  5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute,  1,      durationMinute],
      [minute,  5,  5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [  hour,  1,      durationHour  ],
      [  hour,  3,  3 * durationHour  ],
      [  hour,  6,  6 * durationHour  ],
      [  hour, 12, 12 * durationHour  ],
      [   day,  1,      durationDay   ],
      [   day,  2,  2 * durationDay   ],
      [  week,  1,      durationWeek  ],
      [ month,  1,      durationMonth ],
      [ month,  3,  3 * durationMonth ],
      [  year,  1,      durationYear  ]
    ];

    function tickFormat(date) {
      return (second(date) < date ? formatMillisecond
          : minute(date) < date ? formatSecond
          : hour(date) < date ? formatMinute
          : day(date) < date ? formatHour
          : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
          : year(date) < date ? formatMonth
          : formatYear)(date);
    }

    function tickInterval(interval, start, stop, step) {
      if (interval == null) interval = 10;

      // If a desired tick count is specified, pick a reasonable tick interval
      // based on the extent of the domain and a rough estimate of tick size.
      // Otherwise, assume interval is already a time interval and use it.
      if (typeof interval === "number") {
        var target = Math.abs(stop - start) / interval,
            i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
        if (i === tickIntervals.length) {
          step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
          interval = year;
        } else if (i) {
          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
          step = i[1];
          interval = i[0];
        } else {
          step = d3Array.tickStep(start, stop, interval);
          interval = millisecond;
        }
      }

      return step == null ? interval : interval.every(step);
    }

    scale.invert = function(y) {
      return new Date(invert(y));
    };

    scale.domain = function(_) {
      return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
    };

    scale.ticks = function(interval, step) {
      var d = domain(),
          t0 = d[0],
          t1 = d[d.length - 1],
          r = t1 < t0,
          t;
      if (r) t = t0, t0 = t1, t1 = t;
      t = tickInterval(interval, t0, t1, step);
      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
      return r ? t.reverse() : t;
    };

    scale.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat : format(specifier);
    };

    scale.nice = function(interval, step) {
      var d = domain();
      return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
          ? domain(nice(d, interval))
          : scale;
    };

    scale.copy = function() {
      return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
    };

    return scale;
  }

  function time() {
    return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
  }

  function utcTime() {
    return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
  }

  function colors(s) {
    return s.match(/.{6}/g).map(function(x) {
      return "#" + x;
    });
  }

  var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

  var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

  var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

  var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

  var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

  var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

  var rainbow = d3Color.cubehelix();

  function rainbow$1(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    rainbow.h = 360 * t - 100;
    rainbow.s = 1.5 - 1.5 * ts;
    rainbow.l = 0.8 - 0.9 * ts;
    return rainbow + "";
  }

  function ramp(range) {
    var n = range.length;
    return function(t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

  var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

  var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

  var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  function sequential(interpolator) {
    var x0 = 0,
        x1 = 1,
        clamp = false;

    function scale(x) {
      var t = (x - x0) / (x1 - x0);
      return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
    }

    scale.domain = function(_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.copy = function() {
      return sequential(interpolator).domain([x0, x1]).clamp(clamp);
    };

    return linearish(scale);
  }

  exports.scaleBand = band;
  exports.scalePoint = point;
  exports.scaleIdentity = identity;
  exports.scaleLinear = linear;
  exports.scaleLog = log;
  exports.scaleOrdinal = ordinal;
  exports.scaleImplicit = implicit;
  exports.scalePow = pow;
  exports.scaleSqrt = sqrt;
  exports.scaleQuantile = quantile$1;
  exports.scaleQuantize = quantize;
  exports.scaleThreshold = threshold;
  exports.scaleTime = time;
  exports.scaleUtc = utcTime;
  exports.schemeCategory10 = category10;
  exports.schemeCategory20b = category20b;
  exports.schemeCategory20c = category20c;
  exports.schemeCategory20 = category20;
  exports.interpolateCubehelixDefault = cubehelix$1;
  exports.interpolateRainbow = rainbow$1;
  exports.interpolateWarm = warm;
  exports.interpolateCool = cool;
  exports.interpolateViridis = viridis;
  exports.interpolateMagma = magma;
  exports.interpolateInferno = inferno;
  exports.interpolatePlasma = plasma;
  exports.scaleSequential = sequential;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{"d3-array":5,"d3-collection":1,"d3-color":2,"d3-format":7,"d3-interpolate":3,"d3-time":11,"d3-time-format":10}],9:[function(require,module,exports){
// https://d3js.org/d3-selection/ Version 1.0.2. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  var nextId = 0;

  function local() {
    return new Local;
  }

  function Local() {
    this._ = "@" + (++nextId).toString(36);
  }

  Local.prototype = local.prototype = {
    constructor: Local,
    get: function(node) {
      var id = this._;
      while (!(id in node)) if (!(node = node.parentNode)) return;
      return node[id];
    },
    set: function(node, value) {
      return node[this._] = value;
    },
    remove: function(node) {
      return this._ in node && delete node[this._];
    },
    toString: function() {
      return this._;
    }
  };

  var matcher = function(selector) {
    return function() {
      return this.matches(selector);
    };
  };

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!element.matches) {
      var vendorMatches = element.webkitMatchesSelector
          || element.msMatchesSelector
          || element.mozMatchesSelector
          || element.oMatchesSelector;
      matcher = function(selector) {
        return function() {
          return vendorMatches.call(this, selector);
        };
      };
    }
  }

  var matcher$1 = matcher;

  var filterEvents = {};

  exports.event = null;

  if (typeof document !== "undefined") {
    var element$1 = document.documentElement;
    if (!("onmouseenter" in element$1)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      var event0 = exports.event; // Events can be reentrant (e.g., focus).
      exports.event = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        exports.event = event0;
      }
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function customEvent(event1, listener, that, args) {
    var event0 = exports.event;
    event1.sourceEvent = exports.event;
    exports.event = event1;
    try {
      return listener.apply(that, args);
    } finally {
      exports.event = event0;
    }
  }

  function sourceEvent() {
    var current = exports.event, source;
    while (source = current.sourceEvent) current = source;
    return current;
  }

  function point(node, event) {
    var svg = node.ownerSVGElement || node;

    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }

    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
  }

  function mouse(node) {
    var event = sourceEvent();
    if (event.changedTouches) event = event.changedTouches[0];
    return point(node, event);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher$1(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    var node;
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : defaultView(node = this.node())
            .getComputedStyle(node, null)
            .getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (event) {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function selectAll(selector) {
    return typeof selector === "string"
        ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
        : new Selection([selector == null ? [] : selector], root);
  }

  function touch(node, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

    for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return point(node, touch);
      }
    }

    return null;
  }

  function touches(node, touches) {
    if (touches == null) touches = sourceEvent().touches;

    for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
      points[i] = point(node, touches[i]);
    }

    return points;
  }

  exports.creator = creator;
  exports.local = local;
  exports.matcher = matcher$1;
  exports.mouse = mouse;
  exports.namespace = namespace;
  exports.namespaces = namespaces;
  exports.select = select;
  exports.selectAll = selectAll;
  exports.selection = selection;
  exports.selector = selector;
  exports.selectorAll = selectorAll;
  exports.touch = touch;
  exports.touches = touches;
  exports.window = defaultView;
  exports.customEvent = customEvent;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],10:[function(require,module,exports){
// https://d3js.org/d3-time-format/ v2.1.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":11}],11:[function(require,module,exports){
// https://d3js.org/d3-time/ v1.0.10 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],12:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x/*: number */)/*: number */ {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau = t * Math.exp(-Math.pow(x, 2) -
        1.26551223 +
        1.00002368 * t +
        0.37409196 * Math.pow(t, 2) +
        0.09678418 * Math.pow(t, 3) -
        0.18628806 * Math.pow(t, 4) +
        0.27886807 * Math.pow(t, 5) -
        1.13520398 * Math.pow(t, 6) +
        1.48851587 * Math.pow(t, 7) -
        0.82215223 * Math.pow(t, 8) +
        0.17087277 * Math.pow(t, 9));
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

module.exports = errorFunction;

},{}],13:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data/*: Array<Array<number>> */)/*: { m: number, b: number } */ {

    var m, b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0, sumY = 0,
            sumXX = 0, sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point, x, y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m = ((dataLength * sumXY) - (sumX * sumY)) /
            ((dataLength * sumXX) - (sumX * sumX));

        // `b` is the y-intercept of the line.
        b = (sumY / dataLength) - ((m * sumX) / dataLength);
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}


module.exports = linearRegression;

},{}],14:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb/*: { b: number, m: number }*/)/*: Function */ {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function(x) {
        return mb.b + (mb.m * x);
    };
}

module.exports = linearRegressionLine;

},{}],15:[function(require,module,exports){
'use strict';
/* @flow */

var sum = require('./sum');

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x /*: Array<number> */)/*:number*/ {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error('mean requires at least one data point');
    }

    return sum(x) / x.length;
}

module.exports = mean;

},{"./sum":24}],16:[function(require,module,exports){
'use strict';
/* @flow */

var quantileSorted = require('./quantile_sorted');
var quickselect = require('./quickselect');

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x /*: Array<number> */, p /*: Array<number> | number */) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) continue;

        var m = Math.floor((l + r) / 2);
        quantileSelect(arr, indices[m], indices[l], indices[r]);

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len /*: number */, p /*: number */)/*:number*/ {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

module.exports = quantile;

},{"./quantile_sorted":17,"./quickselect":18}],17:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x /*: Array<number> */, p /*: number */)/*:number*/ {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error('quantile requires at least one data point.');
    } else if (p < 0 || p > 1) {
        throw new Error('quantiles must be between 0 and 1');
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

module.exports = quantileSorted;

},{}],18:[function(require,module,exports){
'use strict';
/* @flow */

module.exports = quickselect;

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @private
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} left left index
 * @param {number} right right index
 * @returns {undefined}
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr /*: Array<number> */, k /*: number */, left /*: number */, right /*: number */) {
    left = left || 0;
    right = right || (arr.length - 1);

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);
            if (m - n / 2 < 0) sd *= -1;
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) i++;
            while (arr[j] > t) j--;
        }

        if (arr[left] === t) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

},{}],19:[function(require,module,exports){
'use strict';
/* @flow */

var sampleCovariance = require('./sample_covariance');
var sampleStandardDeviation = require('./sample_standard_deviation');

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x/*: Array<number> */, y/*: Array<number> */)/*:number*/ {
    var cov = sampleCovariance(x, y),
        xstd = sampleStandardDeviation(x),
        ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

module.exports = sampleCorrelation;

},{"./sample_covariance":20,"./sample_standard_deviation":21}],20:[function(require,module,exports){
'use strict';
/* @flow */

var mean = require('./mean');

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x /*:Array<number>*/, y /*:Array<number>*/)/*:number*/ {

    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error('sampleCovariance requires samples with equal lengths');
    }

    if (x.length < 2) {
        throw new Error('sampleCovariance requires at least two data points in each sample');
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x),
        ymean = mean(y),
        sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

module.exports = sampleCovariance;

},{"./mean":15}],21:[function(require,module,exports){
'use strict';
/* @flow */

var sampleVariance = require('./sample_variance');

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x/*:Array<number>*/)/*:number*/ {
    // The standard deviation of no numbers is null
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

module.exports = sampleStandardDeviation;

},{"./sample_variance":22}],22:[function(require,module,exports){
'use strict';
/* @flow */

var sumNthPowerDeviations = require('./sum_nth_power_deviations');

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x /*: Array<number> */)/*:number*/ {
    // The variance of no numbers is null
    if (x.length < 2) {
        throw new Error('sampleVariance requires at least two data points');
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

module.exports = sampleVariance;

},{"./sum_nth_power_deviations":25}],23:[function(require,module,exports){
'use strict';
/* @flow */

var variance = require('./variance');

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x /*: Array<number> */)/*:number*/ {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

module.exports = standardDeviation;

},{"./variance":26}],24:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x/*: Array<number> */)/*: number */ {

    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    for (var i = 1; i < x.length; i++) {
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += ((sum - transition) + x[i]);
        }
        else {
            correction += ((x[i] - transition) + sum);
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

module.exports = sum;

},{}],25:[function(require,module,exports){
'use strict';
/* @flow */

var mean = require('./mean');

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * var variance = sumNthPowerDeviations(input) / input.length;
 */
function sumNthPowerDeviations(x/*: Array<number> */, n/*: number */)/*:number*/ {
    var meanValue = mean(x),
        sum = 0,
        tempValue,
        i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

module.exports = sumNthPowerDeviations;

},{"./mean":15}],26:[function(require,module,exports){
'use strict';
/* @flow */

var sumNthPowerDeviations = require('./sum_nth_power_deviations');

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x/*: Array<number> */)/*:number*/ {
    // The variance of no numbers is null
    if (x.length === 0) {
        throw new Error('variance requires at least one data point');
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

module.exports = variance;

},{"./sum_nth_power_deviations":25}],27:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x/*:number*/, mean/*:number*/, standardDeviation/*:number*/)/*:number*/ {
    return (x - mean) / standardDeviation;
}

module.exports = zScore;

},{}],28:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BarChart = exports.BarChartConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var BarChartConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(BarChartConfig, _ChartWithColorGroups);

  function BarChartConfig(custom) {
    var _this;

    _classCallCheck(this, BarChartConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BarChartConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'bar-chart';
    _this.showLegend = true;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return _utils.Utils.isNumber(d) ? d : d[key];
      },
      // x value accessor
      scale: "ordinal",
      orient: "bottom",
      ticks: undefined
    };
    _this.y = {
      // Y axis config
      key: 1,
      value: function value(d, key) {
        return _utils.Utils.isNumber(d) ? d : d[key];
      },
      // x value accessor
      title: '',
      // axis label,
      orient: "left",
      scale: "linear"
    };
    _this.transition = true;

    var config = _assertThisInitialized(_this);

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return BarChartConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.BarChartConfig = BarChartConfig;

var BarChart =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(BarChart, _ChartWithColorGroups2);

  function BarChart(placeholderSelector, data, config) {
    _classCallCheck(this, BarChart);

    return _possibleConstructorReturn(this, _getPrototypeOf(BarChart).call(this, placeholderSelector, data, new BarChartConfig(config)));
  }

  _createClass(BarChart, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(BarChart.prototype), "setConfig", this).call(this, new BarChartConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(BarChart.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.computePlotSize();
      this.setupY();
      this.setupX();
      this.setupGroupStacks();
      this.setupYDomain();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = d3.scaleBand().range([0, plot.width]).paddingInner(.08);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.ticks) {
        x.axis.ticks(conf.ticks);
      }

      var data = this.plot.data;
      var domain;

      if (!data || !data.length) {
        domain = [];
      } else if (!this.config.series) {
        domain = d3.map(data, x.value).keys();
      } else {
        domain = d3.map(data[0].values, x.value).keys();
      }

      plot.x.scale.domain(domain);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;

      y.value = function (d) {
        return conf.value(d, conf.key);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
    }
  }, {
    key: "setupYDomain",
    value: function setupYDomain() {
      var plot = this.plot;
      var data = this.plot.data;
      var domain;
      var yStackMax = d3.max(plot.layers, function (layer) {
        return d3.max(layer.points, function (d) {
          return d.y0 + d.y;
        });
      }); // var min = d3.min(data, s=>d3.min(s.values, plot.y.value));

      var max = yStackMax;
      domain = [0, max];
      plot.y.scale.domain(domain); // console.log(' plot.y.scale.domain', plot.y.scale.domain());
    }
  }, {
    key: "setupGroupStacks",
    value: function setupGroupStacks() {
      var self = this;
      this.groupData();
      var y0s = [];
      this.plot.groupedData.forEach(function (s) {
        s.points = s.values.map(function (v) {
          return self.mapToPoint(v);
        });
        s.points.forEach(function (p, i) {
          var prevY0 = y0s[i];
          if (!prevY0) prevY0 = 0;
          p.y0 = prevY0;
          y0s[i] = p.y + prevY0;
        });
      });
      this.plot.layers = this.plot.groupedData;
    }
  }, {
    key: "mapToPoint",
    value: function mapToPoint(value) {
      var plot = this.plot;
      return {
        x: plot.x.value(value),
        y: parseFloat(plot.y.value(value))
      };
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawBars",
    value: function drawBars() {
      var self = this;
      var plot = self.plot; // console.log('layers', plot.layers);

      var layerClass = this.prefixClass("layer");
      var barClass = this.prefixClass("bar");
      var layer = self.svgG.selectAll("." + layerClass).data(plot.layers);
      var layerMerge = layer.enter().append("g").attr("class", layerClass).merge(layer);
      var bar = layerMerge.selectAll("." + barClass).data(function (d) {
        return d.points;
      });
      var barEnter = bar.enter().append("g").attr("class", barClass);
      var barRectEnter = barEnter.append("rect").attr("x", 1);
      var barMerge = barEnter.merge(bar);
      var barRect = barMerge.select("rect");
      var barRectT = barRect;
      var barT = barMerge;
      var layerT = layerMerge;

      if (this.transitionEnabled()) {
        barRectT = barRect.transition();
        barT = barMerge.transition();
        layerT = layerMerge.transition();
      }

      barEnter.attr("transform", function (d) {
        return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0) + ")";
      });
      var yDomain = plot.y.scale.domain();
      barT.attr("transform", function (d) {
        return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0 + d.y) + ")";
      });
      barRectEnter.attr("width", plot.x.scale.bandwidth()).attr("height", 0);
      barRectT.attr("width", plot.x.scale.bandwidth()).attr("height", function (d) {
        return plot.y.scale(d.y0) - plot.y.scale(d.y0 + d.y - yDomain[0]);
      });

      if (this.plot.seriesColor) {
        layerT.attr("fill", this.plot.seriesColor);
      }

      if (plot.tooltip) {
        barMerge.on("mouseover", function (d) {
          self.showTooltip(d.y);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      layer.exit().remove();
      bar.exit().remove();
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(BarChart.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawBars();
      return this;
    }
  }]);

  return BarChart;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.BarChart = BarChart;

},{"./chart-with-color-groups":31,"./d3":35,"./legend":41,"./utils":48}],29:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoxPlotBase = exports.BoxPlotBaseConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var BoxPlotBaseConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(BoxPlotBaseConfig, _ChartConfig); // string or function returning color's value for color scale


  function BoxPlotBaseConfig(custom) {
    var _this;

    _classCallCheck(this, BoxPlotBaseConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BoxPlotBaseConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'box-plot';
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      value: function value(s) {
        return s.key;
      },
      // x value accessor
      guides: false,
      //show axis guides
      orient: 'bottom'
    };
    _this.y = {
      // Y axis config
      title: '',
      value: function value(d) {
        return d;
      },
      // y value accessor
      scale: "linear",
      orient: 'left',
      domainMargin: 0.1,
      guides: true //show axis guides

    };

    _this.Q1 = function (d) {
      return d.values.Q1;
    };

    _this.Q2 = function (d) {
      return d.values.Q2;
    };

    _this.Q3 = function (d) {
      return d.values.Q3;
    };

    _this.Wl = function (d) {
      return d.values.whiskerLow;
    };

    _this.Wh = function (d) {
      return d.values.whiskerHigh;
    };

    _this.outliers = function (d) {
      return d.values.outliers;
    };

    _this.outlierValue = function (d, i) {
      return d;
    };

    _this.outlierLabel = function (d, i) {
      return d;
    };

    _this.minBoxWidth = 35;
    _this.maxBoxWidth = 100;
    _this.transition = true;
    _this.color = undefined;
    _this.d3ColorCategory = 'category10';

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return BoxPlotBaseConfig;
}(_chart.ChartConfig);

exports.BoxPlotBaseConfig = BoxPlotBaseConfig;

var BoxPlotBase =
/*#__PURE__*/
function (_Chart) {
  _inherits(BoxPlotBase, _Chart);

  function BoxPlotBase(placeholderSelector, data, config) {
    _classCallCheck(this, BoxPlotBase);

    return _possibleConstructorReturn(this, _getPrototypeOf(BoxPlotBase).call(this, placeholderSelector, data, new BoxPlotBaseConfig(config)));
  }

  _createClass(BoxPlotBase, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(BoxPlotBase.prototype), "setConfig", this).call(this, new BoxPlotBaseConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(BoxPlotBase.prototype), "initPlot", this).call(this);

      _get(_getPrototypeOf(BoxPlotBase.prototype), "computePlotSize", this).call(this);

      this.plot.x = {};
      this.plot.y = {};
      this.plot.data = this.getDataToPlot();
      this.setupY();
      this.setupX();
      this.setupColor();
    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      return this.data;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      x.value = conf.value;
      x.scale = d3.scaleBand().range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.guides) {
        x.axis.tickSize(-plot.height);
      }

      var data = this.plot.data;
      var domain;

      if (!data || !data.length) {
        domain = [];
      } else {
        domain = data.map(x.value);
      }

      plot.x.scale.domain(domain);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var _this2 = this;

      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;

      y.value = function (d) {
        return conf.value.call(_this2.config, d);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (conf.ticks) {
        y.axis.ticks(conf.ticks);
      }

      if (conf.guides) {
        y.axis.tickSize(-plot.width);
      }

      this.setupYDomain();
    }
  }, {
    key: "setupYDomain",
    value: function setupYDomain() {
      var plot = this.plot;
      var data = this.plot.data;
      var c = this.config;
      var values = [],
          yMin,
          yMax;
      data.forEach(function (d, i) {
        var q1 = c.Q1(d),
            q3 = c.Q3(d),
            wl = c.Wl(d),
            wh = c.Wh(d),
            outliers = c.outliers(d);

        if (outliers) {
          outliers.forEach(function (o, i) {
            values.push(c.outlierValue(o, i));
          });
        }

        if (wl) {
          values.push(wl);
        }

        if (q1) {
          values.push(q1);
        }

        if (q3) {
          values.push(q3);
        }

        if (wh) {
          values.push(wh);
        }
      });
      yMin = d3.min(values);
      yMax = d3.max(values);
      var margin = (yMax - yMin) * this.config.y.domainMargin;
      yMin -= margin;
      yMax += margin;
      var domain = [yMin, yMax];
      plot.y.scale.domain(domain);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.label);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawBoxPlots",
    value: function drawBoxPlots() {
      var self = this,
          plot = self.plot,
          config = self.config,
          boxplotClass = self.prefixClass("boxplot-item");
      var boxplots = self.svgG.selectAll('.' + boxplotClass).data(plot.data);
      var boxplotEnter = boxplots.enter().append('g').attr('class', boxplotClass).style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);
      var boxplotsMerge = boxplotEnter.merge(boxplots);
      var duration = 1000;
      var boxplotsT = boxplotsMerge;

      if (self.transitionEnabled()) {
        boxplotsT = boxplotsMerge.transition();
        boxplotsT.delay(function (d, i) {
          return i * duration / plot.data.length;
        });
      }

      boxplotsT.style('fill', plot.color).style('stroke-opacity', 1).style('fill-opacity', 0.75).attr('transform', function (d, i) {
        return 'translate(' + (plot.x.map(d, i) + plot.x.scale.bandwidth() * 0.05) + ', 0)';
      });
      boxplots.exit().remove();
      var boxWidth = !config.maxBoxWidth ? plot.x.scale.bandwidth() * 0.9 : Math.min(config.maxBoxWidth, Math.max(config.minBoxWidth, plot.x.scale.bandwidth() * 0.9));
      var boxLeft = plot.x.scale.bandwidth() * 0.45 - boxWidth / 2;
      var boxRight = plot.x.scale.bandwidth() * 0.45 + boxWidth / 2;
      var boxClass = self.prefixClass("box");
      boxplotEnter.append('rect').attr('class', boxClass) // tooltip events
      .on('mouseover', function (d, i) {
        d3.select(this).classed('hover', true);
        var html = 'Q3: ' + config.Q3(d, i) + '<br/>Q2: ' + config.Q2(d, i) + '<br/>Q1: ' + config.Q1(d, i);
        self.showTooltip(html);
      }).on('mouseout', function (d, i) {
        d3.select(this).classed('hover', false);
        self.hideTooltip();
      });
      var boxRects = boxplotsMerge.select('rect.' + boxClass);
      var boxRectsT = boxRects;

      if (self.config.transition) {
        boxRectsT = boxRects.transition();
      }

      boxRectsT.attr('y', function (d, i) {
        return plot.y.scale(config.Q3(d));
      }).attr('width', boxWidth).attr('x', boxLeft).attr('height', function (d, i) {
        return Math.abs(plot.y.scale(config.Q3(d)) - plot.y.scale(config.Q1(d))) || 1;
      }).style('stroke', plot.color); // median line

      var medianClass = self.prefixClass('median');
      boxplotEnter.append('line').attr('class', medianClass);
      var medianLine = boxplotsMerge.select('line.' + medianClass);

      if (self.config.transition) {
        medianLine = medianLine.transition();
      }

      medianLine.attr('x1', boxLeft).attr('y1', function (d, i) {
        return plot.y.scale(config.Q2(d));
      }).attr('x2', boxRight).attr('y2', function (d, i) {
        return plot.y.scale(config.Q2(d));
      }); //whiskers

      var whiskerClass = self.prefixClass("whisker"),
          tickClass = self.prefixClass("boxplot-tick");
      var whiskers = [{
        key: 'low',
        value: config.Wl
      }, {
        key: 'high',
        value: config.Wh
      }];
      boxplotEnter.each(function (d, i) {
        var box = d3.select(this);
        whiskers.forEach(function (f) {
          if (f.value(d)) {
            box.append('line').style('stroke', plot.color(d, i)).attr('class', whiskerClass + ' ' + boxplotClass + '-' + f.key);
            box.append('line').style('stroke', plot.color(d, i)).attr('class', tickClass + ' ' + boxplotClass + '-' + f.key);
          }
        });
      });
      whiskers.forEach(function (f) {
        var endpoint = f.key === 'low' ? config.Q1 : config.Q3;
        var whisker = boxplotsMerge.select('.' + whiskerClass + '.' + boxplotClass + '-' + f.key);
        var tick = boxplotsMerge.select('.' + tickClass + '.' + boxplotClass + '-' + f.key);

        if (self.config.transition) {
          whisker = whisker.transition();
          tick = tick.transition();
        }

        whisker.attr('x1', plot.x.scale.bandwidth() * 0.45).attr('y1', function (d, i) {
          return plot.y.scale(f.value(d));
        }).attr('x2', plot.x.scale.bandwidth() * 0.45).attr('y2', function (d, i) {
          return plot.y.scale(endpoint(d));
        });
        tick.attr('x1', boxLeft).attr('y1', function (d, i) {
          return plot.y.scale(f.value(d));
        }).attr('x2', boxRight).attr('y2', function (d, i) {
          return plot.y.scale(f.value(d));
        });
        boxplotEnter.selectAll('.' + boxplotClass + '-' + f.key).on('mouseover', function (d, i, j) {
          d3.select(this).classed('hover', true);
          self.showTooltip(f.value(d));
        }).on('mouseout', function (d, i, j) {
          d3.select(this).classed('hover', false);
          self.hideTooltip();
        });
      }); // outliers

      var outlierClass = self.prefixClass("outlier");
      var outliers = boxplotsMerge.selectAll('.' + outlierClass).data(function (d, i) {
        return config.outliers(d, i) || [];
      });
      var outlierEnterCircle = outliers.enter().append('circle').attr('class', outlierClass).style('z-index', 9000);
      outlierEnterCircle.on('mouseover', function (d, i, j) {
        d3.select(this).classed('hover', true);
        self.showTooltip(config.outlierLabel(d, i));
      }).on('mouseout', function (d, i, j) {
        d3.select(this).classed('hover', false);
        self.hideTooltip();
      });
      var outliersMerge = outlierEnterCircle.merge(outliers);
      var outliersT = outliersMerge;

      if (self.config.transition) {
        outliersT = outliersMerge.transition();
      }

      outliersT.attr('cx', plot.x.scale.bandwidth() * 0.45).attr('cy', function (d, i) {
        return plot.y.scale(config.outlierValue(d, i));
      }).attr('r', '3');
      outliers.exit().remove();
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(BoxPlotBase.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawBoxPlots();
      return this;
    }
  }, {
    key: "setupColor",
    value: function setupColor() {
      var _this3 = this;

      var self = this;
      var conf = this.config;

      if (conf.d3ColorCategory) {
        var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);

        this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
      }

      var colorValue = conf.color;

      if (colorValue && typeof colorValue === 'string' || colorValue instanceof String) {
        this.plot.color = colorValue;
      } else if (this.plot.colorCategory) {
        self.plot.colorValue = colorValue;

        this.plot.color = function (d) {
          return self.plot.colorCategory(_this3.plot.x.value(d));
        };
      }
    }
  }]);

  return BoxPlotBase;
}(_chart.Chart);

exports.BoxPlotBase = BoxPlotBase;

},{"./chart":32,"./d3":35,"./utils":48}],30:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoxPlot = exports.BoxPlotConfig = void 0;

var _boxPlotBase = require("./box-plot-base");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var BoxPlotConfig =
/*#__PURE__*/
function (_BoxPlotBaseConfig) {
  _inherits(BoxPlotConfig, _BoxPlotBaseConfig);

  function BoxPlotConfig(custom) {
    var _this;

    _classCallCheck(this, BoxPlotConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BoxPlotConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'box-plot';
    _this.showLegend = true;
    _this.showTooltip = true;
    _this.y = {
      // Y axis config
      key: undefined,
      value: function value(d) {
        return this.y.key === undefined ? d : d[this.y.key];
      },
      // y value accessor
      scale: "linear",
      orient: 'left',
      domainMargin: 0.1,
      guides: true //show axis guides

    };
    _this.series = false;
    _this.groups = {
      key: undefined,
      value: function value(d) {
        return this.groups.key === undefined ? '' : d[this.groups.key];
      },
      // grouping value accessor,
      label: "",
      displayValue: undefined // optional function returning display value (series label) for given group value, or object/array mapping value to display value

    };
    _this.tukey = false;

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return BoxPlotConfig;
}(_boxPlotBase.BoxPlotBaseConfig);

exports.BoxPlotConfig = BoxPlotConfig;

var BoxPlot =
/*#__PURE__*/
function (_BoxPlotBase) {
  _inherits(BoxPlot, _BoxPlotBase);

  function BoxPlot(placeholderSelector, data, config) {
    _classCallCheck(this, BoxPlot);

    return _possibleConstructorReturn(this, _getPrototypeOf(BoxPlot).call(this, placeholderSelector, data, new BoxPlotConfig(config)));
  }

  _createClass(BoxPlot, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(BoxPlot.prototype), "setConfig", this).call(this, new BoxPlotConfig(config));
    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      var self = this;
      var conf = self.config;
      self.plot.groupingEnabled = this.isGroupingEnabled();
      var data = this.data;

      if (!self.plot.groupingEnabled) {
        self.plot.groupedData = [{
          key: '',
          values: data
        }];
        self.plot.dataLength = data.length;
      } else {
        if (self.config.series) {
          self.plot.groupedData = data.map(function (s) {
            return {
              key: s.label || s.key || '',
              values: s.values
            };
          });
        } else {
          self.plot.groupValue = function (d) {
            return conf.groups.value.call(conf, d);
          };

          self.plot.groupedData = d3.nest().key(this.plot.groupValue).entries(data);

          var getDisplayValue = function getDisplayValue(k) {
            return k;
          };

          if (self.config.groups.displayValue) {
            if (_utils.Utils.isFunction(self.config.groups.displayValue)) {
              getDisplayValue = function getDisplayValue(k) {
                return self.config.groups.displayValue(k) || k;
              };
            } else if (_utils.Utils.isObject(self.config.groups.displayValue)) {
              getDisplayValue = function getDisplayValue(k) {
                return self.config.groups.displayValue[k] || k;
              };
            }
          }

          self.plot.groupedData.forEach(function (g) {
            g.key = getDisplayValue(g.key);
          });
        }

        self.plot.dataLength = d3.sum(this.plot.groupedData, function (s) {
          return s.values.length;
        });
      }

      self.plot.groupedData.forEach(function (s) {
        if (!Array.isArray(s.values)) {
          return;
        }

        var values = s.values.map(function (d) {
          return parseFloat(self.config.y.value.call(self.config, d));
        });
        s.values.Q1 = _statisticsUtils.StatisticsUtils.quantile(values, 0.25);
        s.values.Q2 = _statisticsUtils.StatisticsUtils.quantile(values, 0.5);
        s.values.Q3 = _statisticsUtils.StatisticsUtils.quantile(values, 0.75);
        var IQR = s.values.Q3 - s.values.Q1;

        if (!self.config.tukey) {
          s.values.whiskerLow = d3.min(values);
          s.values.whiskerHigh = d3.max(values);
        } else {
          s.values.whiskerLow = s.values.Q1 - 1.5 * IQR;
          s.values.whiskerHigh = s.values.Q3 + 1.5 * IQR;
          s.values.outliers = values.filter(function (d) {
            return d < s.values.whiskerLow || d > s.values.whiskerHigh;
          });
        }
      });
      return self.plot.groupedData;
    }
  }, {
    key: "isGroupingEnabled",
    value: function isGroupingEnabled() {
      return this.config.series || !!(this.config.groups && this.config.groups.value);
    }
  }]);

  return BoxPlot;
}(_boxPlotBase.BoxPlotBase);

exports.BoxPlot = BoxPlot;

},{"./box-plot-base":29,"./d3":35,"./statistics-utils":47,"./utils":48}],31:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChartWithColorGroups = exports.ChartWithColorGroupsConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var ChartWithColorGroupsConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(ChartWithColorGroupsConfig, _ChartConfig); // string or function returning color's value for color scale


  function ChartWithColorGroupsConfig(custom) {
    var _this;

    _classCallCheck(this, ChartWithColorGroupsConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ChartWithColorGroupsConfig).call(this));
    _this.showLegend = true;
    _this.forceLegend = false;
    _this.legend = {
      width: 80,
      margin: 10,
      shapeWidth: 20
    };
    _this.groups = {
      key: 2,
      value: function value(d) {
        return d[this.groups.key];
      },
      // grouping value accessor,
      label: "",
      displayValue: undefined // optional function returning display value (series label) for given group value, or object/array mapping value to display value

    };
    _this.series = false;
    _this.color = undefined;
    _this.d3ColorCategory = 'category10';

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return ChartWithColorGroupsConfig;
}(_chart.ChartConfig);

exports.ChartWithColorGroupsConfig = ChartWithColorGroupsConfig;

var ChartWithColorGroups =
/*#__PURE__*/
function (_Chart) {
  _inherits(ChartWithColorGroups, _Chart);

  function ChartWithColorGroups(placeholderSelector, data, config) {
    _classCallCheck(this, ChartWithColorGroups);

    return _possibleConstructorReturn(this, _getPrototypeOf(ChartWithColorGroups).call(this, placeholderSelector, data, new ChartWithColorGroupsConfig(config)));
  }

  _createClass(ChartWithColorGroups, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(ChartWithColorGroups.prototype), "setConfig", this).call(this, new ChartWithColorGroupsConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(ChartWithColorGroups.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.showLegend = conf.showLegend;
      this.setupGroups();
      this.plot.data = this.getDataToPlot();
      this.groupData();

      if (this.plot.showLegend) {
        var scale = this.plot.colorCategory;

        if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
          this.plot.showLegend = false;
        } else {
          this.plot.margin.right = conf.margin.right + conf.legend.width + conf.legend.margin * 2;
        }
      }

      return this;
    }
  }, {
    key: "isGroupingEnabled",
    value: function isGroupingEnabled() {
      return this.config.series || !!(this.config.groups && this.config.groups.value);
    }
  }, {
    key: "computeGroupColorDomain",
    value: function computeGroupColorDomain() {
      var _this2 = this;

      var map = d3.set(this.data, function (d) {
        return _this2.plot.groupValue(d);
      });
      return Object.getOwnPropertyNames(map).map(function (d) {
        return map[d];
      });
    }
  }, {
    key: "setupGroups",
    value: function setupGroups() {
      var _this3 = this;

      var self = this;
      var conf = this.config;
      this.plot.groupingEnabled = this.isGroupingEnabled();
      var domain = [];

      if (this.plot.groupingEnabled) {
        self.plot.groupToLabel = {};

        if (this.config.series) {
          this.plot.groupValue = function (s) {
            return s.key;
          };

          domain = this.computeGroupColorDomain();
          this.data.forEach(function (s) {
            self.plot.groupToLabel[s.key] = s.label || s.key;
          });
        } else {
          this.plot.groupValue = function (d) {
            return conf.groups.value.call(conf, d);
          };

          domain = this.computeGroupColorDomain();

          var getLabel = function getLabel(k) {
            return k;
          };

          if (self.config.groups.displayValue) {
            if (_utils.Utils.isFunction(self.config.groups.displayValue)) {
              getLabel = function getLabel(k) {
                return self.config.groups.displayValue(k) || k;
              };
            } else if (_utils.Utils.isObject(self.config.groups.displayValue)) {
              getLabel = function getLabel(k) {
                return self.config.groups.displayValue[k] || k;
              };
            }
          }

          domain.forEach(function (k) {
            self.plot.groupToLabel[k] = getLabel(k);
          });
        }
      } else {
        this.plot.groupValue = function (d) {
          return null;
        };
      }

      this.plot.groupColorDomain = domain;

      if (conf.d3ColorCategory) {
        var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);

        this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
      }

      var colorValue = conf.color;

      if (colorValue) {
        if (typeof colorValue === 'string' || colorValue instanceof String) {
          this.plot.color = colorValue;
          this.plot.seriesColor = this.plot.color;
        } else {
          this.plot.color = colorValue;
          this.plot.seriesColor = this.plot.color;
          var range = domain.map(function (v) {
            return _this3.plot.seriesColor({
              key: v
            });
          });
          this.plot.colorCategory = d3.scaleOrdinal(range);
          this.plot.colorCategory.domain(domain);
        }
      } else if (this.plot.colorCategory) {
        self.plot.colorValue = colorValue;
        self.plot.colorCategory.domain(domain);

        this.plot.seriesColor = function (s) {
          return self.plot.colorCategory(s.key);
        };

        this.plot.color = function (d) {
          return self.plot.colorCategory(_this3.plot.groupValue(d));
        };
      } else {
        this.plot.color = this.plot.seriesColor = function (s) {
          return 'black';
        };
      }
    }
  }, {
    key: "groupData",
    value: function groupData() {
      var self = this;
      var data = this.plot.data;

      if (!self.plot.groupingEnabled) {
        self.plot.groupedData = [{
          key: null,
          label: '',
          values: data
        }];
        self.plot.dataLength = data.length;
      } else {
        if (self.config.series) {
          self.plot.groupedData = data.map(function (s) {
            return {
              key: s.key,
              label: s.label,
              values: s.values
            };
          });
        } else {
          self.plot.groupedData = d3.nest().key(this.plot.groupValue).entries(data);
          self.plot.groupedData.forEach(function (g) {
            g.label = self.plot.groupToLabel[g.key];
          });
        }

        self.plot.dataLength = d3.sum(this.plot.groupedData, function (s) {
          return s.values.length;
        });
      } // this.plot.seriesColor

    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      var _this4 = this;

      if (!this.plot.groupingEnabled || !this.enabledGroups) {
        return this.data;
      }

      return this.data.filter(function (d) {
        return _this4.enabledGroups.indexOf(_this4.plot.groupValue(d)) > -1;
      });
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(ChartWithColorGroups.prototype), "update", this).call(this, newData);

      this.updateLegend();
      return this;
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var self = this;
      var plot = this.plot;
      var scale = plot.colorCategory;

      if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
        plot.showLegend = false;
      }

      if (!plot.showLegend) {
        if (plot.legend && plot.legend.container) {
          plot.legend.container.remove();
        }

        return;
      }

      var legendX = this.plot.width + this.config.legend.margin;
      var legendY = this.config.legend.margin;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY);
      plot.legendColor = plot.legend.color().shapeWidth(this.config.legend.shapeWidth).orient('vertical').scale(scale).labelWrap(this.config.legend.width).labels(scale.domain().map(function (v) {
        return plot.groupToLabel[v];
      }));
      plot.legendColor.on('cellclick', function (c) {
        return self.onLegendCellClick(c);
      });
      plot.legend.container.call(plot.legendColor);
      this.updateLegendCellStatuses();
    }
  }, {
    key: "onLegendCellClick",
    value: function onLegendCellClick(cellValue) {
      this.updateEnabledGroups(cellValue);
      this.init();
    }
  }, {
    key: "updateLegendCellStatuses",
    value: function updateLegendCellStatuses() {
      var self = this;
      this.plot.legend.container.selectAll("g.cell").each(function (cell) {
        var isDisabled = self.enabledGroups && self.enabledGroups.indexOf(cell) < 0;
        d3.select(this).classed("odc-disabled", isDisabled);
      });
    }
  }, {
    key: "updateEnabledGroups",
    value: function updateEnabledGroups(cellValue) {
      if (!this.enabledGroups) {
        this.enabledGroups = this.plot.colorCategory.domain().slice();
      }

      var index = this.enabledGroups.indexOf(cellValue);

      if (index < 0) {
        this.enabledGroups.push(cellValue);
      } else {
        this.enabledGroups.splice(index, 1);
      }

      if (!this.enabledGroups.length) {
        this.enabledGroups = this.plot.colorCategory.domain().slice();
      }
    }
  }, {
    key: "setData",
    value: function setData(data) {
      _get(_getPrototypeOf(ChartWithColorGroups.prototype), "setData", this).call(this, data);

      this.enabledGroups = null;
      return this;
    }
  }]);

  return ChartWithColorGroups;
}(_chart.Chart);

exports.ChartWithColorGroups = ChartWithColorGroups;

},{"./chart":32,"./d3":35,"./legend":41,"./utils":48}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chart = exports.ChartConfig = void 0;

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ChartConfig = function ChartConfig(custom) {
  _classCallCheck(this, ChartConfig);

  this.cssClassPrefix = "odc-";
  this.svgClass = this.cssClassPrefix + 'mw-d3-chart';
  this.width = undefined;
  this.height = undefined;
  this.margin = {
    left: 50,
    right: 30,
    top: 30,
    bottom: 50
  };
  this.showTooltip = false;
  this.transition = true;
  this.title = undefined;
  this.titleSize = 20;
  this.titleMargin = {
    left: 0,
    right: 0,
    top: 15,
    bottom: 20
  };
  this.subtitle = undefined;
  this.subtitleSize = 14;
  this.subtitleMargin = {
    left: 0,
    right: 0,
    top: 10,
    bottom: 20
  };

  if (custom) {
    _utils.Utils.deepExtend(this, custom);
  }
};

exports.ChartConfig = ChartConfig;

var Chart =
/*#__PURE__*/
function () {
  function Chart(base, data, config) {
    _classCallCheck(this, Chart);

    this.utils = _utils.Utils;
    this.plot = {
      margin: {}
    };
    this._attached = {};
    this._layers = {};
    this._events = {};
    this._isInitialized = false;
    this._id = _utils.Utils.guid();
    this._isAttached = base instanceof Chart;
    this.baseContainer = base;
    this.setConfig(config);

    if (data) {
      this.setData(data);
    }

    this.init();
    this.postInit();
  }

  _createClass(Chart, [{
    key: "setConfig",
    value: function setConfig(config) {
      if (!config) {
        this.config = new ChartConfig();
      } else {
        this.config = config;
      }

      this.initConfigAccessors();
      return this;
    }
  }, {
    key: "setData",
    value: function setData(data) {
      this.data = data;
      return this;
    }
  }, {
    key: "init",
    value: function init() {
      var self = this;
      self.initPlot();
      self.initSvg();

      if (!this._isInitialized) {
        self.initTooltip();
      }

      self.draw();
      this._isInitialized = true;
      return this;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      this.initConfigAccessors(true);
      return this.init();
    }
  }, {
    key: "postInit",
    value: function postInit() {}
  }, {
    key: "initSvg",
    value: function initSvg() {
      var self = this;
      var config = this.config;
      var margin = self.plot.margin;
      var width = self.svgWidth = self.plot.width + margin.left + margin.right;
      var height = self.svgHeight = self.plot.height + margin.top + margin.bottom;
      var aspect = width / height;

      if (!self._isAttached) {
        if (!this._isInitialized) {
          d3.select(self.baseContainer).select("svg").remove();
        }

        self.svg = d3.select(self.baseContainer).selectOrAppend("svg").classed(config.svgClass, true);
        self.svg.attr("width", width).attr("height", height).attr("viewBox", "0 0 " + " " + width + " " + height).attr("preserveAspectRatio", "xMidYMid meet");
        self.svgG = self.svg.selectOrAppend("g.main-group");
      } else {
        // console.log(self.baseContainer);
        self.svg = self.baseContainer.svg;
        self.svgG = self.svg.selectOrAppend("g.main-group." + config.svgClass);
      }

      self.svgG.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      if (!config.width || config.height) {
        d3.select(window).on("resize." + self._id, function () {
          var transition = self.config.transition;
          self.config.transition = false;
          self.init();
          self.config.transition = transition;
        });
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      d3.select(this.baseContainer).selectAll("*").remove();
      d3.select(window).on("resize." + this._id, null);
    }
  }, {
    key: "initTooltip",
    value: function initTooltip() {
      var self = this;

      if (self.config.showTooltip) {
        if (!self._isAttached) {
          self.plot.tooltip = d3.select("body").selectOrAppend('div.' + self.config.cssClassPrefix + 'tooltip').style("opacity", 0);
        } else {
          self.plot.tooltip = self.baseContainer.plot.tooltip;
        }
      } else {
        self.plot.tooltip = null;
      }
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      var margin = this.config.margin;
      this.plot = this.plot || {};
      this.plot.margin = {
        top: margin.top,
        bottom: margin.bottom,
        left: margin.left,
        right: margin.right
      };
      var titleMarginSize = 0;

      if (this.config.title) {
        titleMarginSize = this.config.titleSize + this.config.titleMargin.top;

        if (!this.config.subtitle) {
          titleMarginSize += this.config.titleMargin.bottom;
        }

        this.plot.margin.top = Math.max(this.plot.margin.top, titleMarginSize);
      }

      if (this.config.subtitle) {
        this.plot.margin.top = Math.max(this.plot.margin.top, titleMarginSize + this.config.subtitleMargin.top + this.config.subtitleSize + this.config.subtitleMargin.bottom);
      }
    }
  }, {
    key: "update",
    value: function update(data) {
      if (data) {
        this.setData(data);
      }

      this.updateTitle();
      this.updateSubtitle();
      var layerName, attachmentData;

      for (var attachmentName in this._attached) {
        attachmentData = data;

        this._attached[attachmentName].update(attachmentData);
      }

      return this;
    }
  }, {
    key: "updateTitle",
    value: function updateTitle() {
      var titleClass = this.prefixClass('plot-title');

      if (!this.config.title) {
        this.svg.select("text." + titleClass).remove();
        return;
      }

      this.svg.selectOrAppend("text." + titleClass).attr("transform", "translate(" + this.svgWidth / 2 + "," + this.config.titleMargin.top + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "0.5em").style("text-anchor", "middle").style("dominant-baseline", "central").style("font-size", this.config.titleSize + "px").text(this.config.title);
    }
  }, {
    key: "updateSubtitle",
    value: function updateSubtitle() {
      var subtitleClass = this.prefixClass('plot-subtitle');

      if (!this.config.subtitle) {
        this.svg.select("text." + subtitleClass).remove();
        return;
      }

      var y = this.config.subtitleMargin.top;

      if (this.config.title) {
        y += this.config.titleMargin.top + this.config.titleSize;
      }

      this.svg.selectOrAppend("text." + subtitleClass).attr("transform", "translate(" + this.svgWidth / 2 + "," + y + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "0.5em").style("text-anchor", "middle").style("dominant-baseline", "central").style("font-size", this.config.subtitleSize + "px").text(this.config.subtitle);
    }
  }, {
    key: "draw",
    value: function draw(data) {
      this.update(data);
      return this;
    } //Borrowed from d3.chart

    /**
     * Register or retrieve an "attachment" Chart. The "attachment" chart's `draw`
     * method will be invoked whenever the containing chart's `draw` method is
     * invoked.
     *
     * @externalExample chart-attach
     *
     * @param {String} attachmentName Name of the attachment
     * @param {Chart} [chart] Chart to register as a mix in of this chart. When
     *        unspecified, this method will return the attachment previously
     *        registered with the specified `attachmentName` (if any).
     *
     * @returns {Chart} Reference to this chart (chainable).
     */

  }, {
    key: "attach",
    value: function attach(attachmentName, chart) {
      if (arguments.length === 1) {
        return this._attached[attachmentName];
      }

      this._attached[attachmentName] = chart;
      return chart;
    }
  }, {
    key: "on",
    //Borrowed from d3.chart

    /**
     * Subscribe a callback function to an event triggered on the chart. See {@link
        * Chart#once} to subscribe a callback function to an event for one occurence.
     *
     * @externalExample {runnable} chart-on
     *
     * @param {String} name Name of the event
     * @param {ChartEventHandler} callback Function to be invoked when the event
     *        occurs
     * @param {Object} [context] Value to set as `this` when invoking the
     *        `callback`. Defaults to the chart instance.
     *
     * @returns {Chart} A reference to this chart (chainable).
     */
    value: function on(name, callback, context) {
      var events = this._events[name] || (this._events[name] = []);
      events.push({
        callback: callback,
        context: context || this,
        _chart: this
      });
      return this;
    } //Borrowed from d3.chart

    /**
     *
     * Subscribe a callback function to an event triggered on the chart. This
     * function will be invoked at the next occurance of the event and immediately
     * unsubscribed. See {@link Chart#on} to subscribe a callback function to an
     * event indefinitely.
     *
     * @externalExample {runnable} chart-once
     *
     * @param {String} name Name of the event
     * @param {ChartEventHandler} callback Function to be invoked when the event
     *        occurs
     * @param {Object} [context] Value to set as `this` when invoking the
     *        `callback`. Defaults to the chart instance
     *
     * @returns {Chart} A reference to this chart (chainable)
     */

  }, {
    key: "once",
    value: function once(name, callback, context) {
      var self = this;

      var once = function once() {
        self.off(name, once);
        callback.apply(this, arguments);
      };

      return this.on(name, once, context);
    } //Borrowed from d3.chart

    /**
     * Unsubscribe one or more callback functions from an event triggered on the
     * chart. When no arguments are specified, *all* handlers will be unsubscribed.
     * When only a `name` is specified, all handlers subscribed to that event will
     * be unsubscribed. When a `name` and `callback` are specified, only that
     * function will be unsubscribed from that event. When a `name` and `context`
     * are specified (but `callback` is omitted), all events bound to the given
     * event with the given context will be unsubscribed.
     *
     * @externalExample {runnable} chart-off
     *
     * @param {String} [name] Name of the event to be unsubscribed
     * @param {ChartEventHandler} [callback] Function to be unsubscribed
     * @param {Object} [context] Contexts to be unsubscribe
     *
     * @returns {Chart} A reference to this chart (chainable).
     */

  }, {
    key: "off",
    value: function off(name, callback, context) {
      var names, n, events, event, i, j; // remove all events

      if (arguments.length === 0) {
        for (name in this._events) {
          this._events[name].length = 0;
        }

        return this;
      } // remove all events for a specific name


      if (arguments.length === 1) {
        events = this._events[name];

        if (events) {
          events.length = 0;
        }

        return this;
      } // remove all events that match whatever combination of name, context
      // and callback.


      names = name ? [name] : Object.keys(this._events);

      for (i = 0; i < names.length; i++) {
        n = names[i];
        events = this._events[n];
        j = events.length;

        while (j--) {
          event = events[j];

          if (callback && callback === event.callback || context && context === event.context) {
            events.splice(j, 1);
          }
        }
      }

      return this;
    }
  }, {
    key: "trigger",
    //Borrowed from d3.chart

    /**
     * Publish an event on this chart with the given `name`.
     *
     * @externalExample {runnable} chart-trigger
     *
     * @param {String} name Name of the event to publish
     * @param {...*} arguments Values with which to invoke the registered
     *        callbacks.
     *
     * @returns {Chart} A reference to this chart (chainable).
     */
    value: function trigger(name) {
      var args = Array.prototype.slice.call(arguments, 1);
      var events = this._events[name];
      var i, ev;

      if (events !== undefined) {
        for (i = 0; i < events.length; i++) {
          ev = events[i];
          ev.callback.apply(ev.context, args);
        }
      }

      return this;
    }
  }, {
    key: "getBaseContainer",
    value: function getBaseContainer() {
      if (this._isAttached) {
        return this.baseContainer.svg;
      }

      return d3.select(this.baseContainer);
    }
  }, {
    key: "getBaseContainerNode",
    value: function getBaseContainerNode() {
      return this.getBaseContainer().node();
    }
  }, {
    key: "prefixClass",
    value: function prefixClass(clazz, addDot) {
      return addDot ? '.' : '' + this.config.cssClassPrefix + clazz;
    }
  }, {
    key: "computePlotSize",
    value: function computePlotSize() {
      this.plot.width = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), this.plot.margin);
      this.plot.height = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), this.plot.margin);
    }
  }, {
    key: "transitionEnabled",
    value: function transitionEnabled() {
      return this._isInitialized && this.config.transition;
    }
  }, {
    key: "showTooltip",
    value: function showTooltip(html) {
      if (!this.plot.tooltip) {
        return;
      }

      this.plot.tooltip.transition().duration(200).style("opacity", .9);
      this.plot.tooltip.html(html).style("left", d3.event.pageX + 5 + "px").style("top", d3.event.pageY - 28 + "px");
    }
  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      if (!this.plot.tooltip) {
        return;
      }

      this.plot.tooltip.transition().duration(500).style("opacity", 0);
    }
  }, {
    key: "initConfigAccessors",
    value: function initConfigAccessors(clean) {
      if (clean) {
        this.removePropertyAccessors(this, this, this.config, "$");
      }

      this.initPropertyAccessors(this, this, this.config, "$", true);
    }
  }, {
    key: "removePropertyAccessors",
    value: function removePropertyAccessors(bindTo, returnObj, source, prefix) {
      var self = this;

      for (var i in source) {
        if (!source.hasOwnProperty(i)) {
          continue;
        }

        delete bindTo[prefix + i];
      }
    }
  }, {
    key: "initPropertyAccessors",
    value: function initPropertyAccessors(bindTo, returnObj, source, prefix, recursive) {
      var self = this;

      for (var i in source) {
        if (!source.hasOwnProperty(i)) {
          continue;
        }

        var accessor = self.initPropertyAccessor(bindTo, returnObj, source, i, prefix);

        if (recursive && _utils.Utils.isObjectNotArray(source[i])) {
          self.initPropertyAccessors(accessor, bindTo, source[i], prefix, recursive);
        }
      }
    }
  }, {
    key: "initPropertyAccessor",
    value: function initPropertyAccessor(bindTo, returnObj, source, propertyKey, prefix) {
      return bindTo[prefix + propertyKey] = function (_) {
        if (!arguments.length) {
          return source[propertyKey];
        }

        source[propertyKey] = _;
        return returnObj;
      };
    }
  }]);

  return Chart;
}();

exports.Chart = Chart;

},{"./d3":35,"./utils":48}],33:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CorrelationMatrix = exports.CorrelationMatrixConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var _legend = require("./legend");

var _scatterplot = require("./scatterplot");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var CorrelationMatrixConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(CorrelationMatrixConfig, _ChartConfig); //show axis guides
  //show tooltip on dot hover


  function CorrelationMatrixConfig(custom) {
    var _this;

    _classCallCheck(this, CorrelationMatrixConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CorrelationMatrixConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'correlation-matrix';
    _this.guides = false;
    _this.showTooltip = true;
    _this.showLegend = true;
    _this.highlightLabels = true;
    _this.rotateLabelsX = true;
    _this.rotateLabelsY = true;
    _this.variables = {
      labels: undefined,
      keys: [],
      //optional array of variable keys
      value: function value(d, variableKey) {
        return parseFloat(d[variableKey]);
      },
      // variable value accessor
      scale: "ordinal"
    };
    _this.correlation = {
      scale: "linear",
      domain: [-1, -0.75, -0.5, 0, 0.5, 0.75, 1],
      range: ["darkblue", "blue", "lightskyblue", "white", "orangered", "crimson", "darkred"],
      value: function value(xValues, yValues) {
        return _statisticsUtils.StatisticsUtils.sampleCorrelation(xValues, yValues);
      }
    };
    _this.cell = {
      shape: "ellipse",
      //possible values: rect, circle, ellipse
      size: undefined,
      sizeMin: 15,
      sizeMax: 250,
      padding: 1
    };
    _this.margin = {
      left: 60,
      right: 50,
      top: 30,
      bottom: 60
    };
    _this.groups = {
      key: null
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return CorrelationMatrixConfig;
}(_chart.ChartConfig);

exports.CorrelationMatrixConfig = CorrelationMatrixConfig;

var CorrelationMatrix =
/*#__PURE__*/
function (_Chart) {
  _inherits(CorrelationMatrix, _Chart);

  function CorrelationMatrix(placeholderSelector, data, config) {
    _classCallCheck(this, CorrelationMatrix);

    return _possibleConstructorReturn(this, _getPrototypeOf(CorrelationMatrix).call(this, placeholderSelector, data, new CorrelationMatrixConfig(config)));
  }

  _createClass(CorrelationMatrix, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(CorrelationMatrix.prototype), "setConfig", this).call(this, new CorrelationMatrixConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(CorrelationMatrix.prototype), "initPlot", this).call(this);

      var self = this;
      var margin = this.config.margin;
      var conf = this.config;
      this.plot.x = {};
      this.plot.correlation = {
        matrix: undefined,
        cells: undefined,
        color: {},
        shape: {}
      };
      this.setupVariables();
      var width = conf.width;
      var placeholderNode = this.getBaseContainerNode();
      this.plot.placeholderNode = placeholderNode;
      var parentWidth = placeholderNode.getBoundingClientRect().width;

      if (width) {
        if (!this.plot.cellSize) {
          this.plot.cellSize = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (width - margin.left - margin.right) / this.plot.variables.length));
        }
      } else {
        this.plot.cellSize = this.config.cell.size;

        if (!this.plot.cellSize) {
          this.plot.cellSize = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (parentWidth - margin.left - margin.right) / this.plot.variables.length));
        }

        width = this.plot.cellSize * this.plot.variables.length + margin.left + margin.right;
      }

      var height = width;

      if (!height) {
        height = placeholderNode.getBoundingClientRect().height;
      }

      this.plot.width = width - margin.left - margin.right;
      this.plot.height = this.plot.width;
      this.setupVariablesScales();
      this.setupCorrelationScales();
      this.setupCorrelationMatrix();
      return this;
    }
  }, {
    key: "setupVariablesScales",
    value: function setupVariablesScales() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.variables;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = conf.value;
      x.scale = d3.scaleBand().range([plot.width, 0]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };
    }
  }, {
    key: "setupCorrelationScales",
    value: function setupCorrelationScales() {
      var plot = this.plot;
      var corrConf = this.config.correlation;
      plot.correlation.color.scale = _utils.Utils.createScale(corrConf.scale).domain(corrConf.domain).range(corrConf.range);
      var shape = plot.correlation.shape = {};
      var cellConf = this.config.cell;
      shape.type = cellConf.shape;
      var shapeSize = plot.cellSize - cellConf.padding * 2;

      if (shape.type == 'circle') {
        var radiusMax = shapeSize / 2;
        shape.radiusScale = d3.scaleLinear().domain([0, 1]).range([2, radiusMax]);

        shape.radius = function (c) {
          return shape.radiusScale(Math.abs(c.value));
        };
      } else if (shape.type == 'ellipse') {
        var radiusMax = shapeSize / 2;
        shape.radiusScale = d3.scaleLinear().domain([0, 1]).range([radiusMax, 2]);

        shape.radiusX = function (c) {
          return shape.radiusScale(Math.abs(c.value));
        };

        shape.radiusY = radiusMax;

        shape.rotateVal = function (v) {
          if (v == 0) return "0";
          if (v < 0) return "-45";
          return "45";
        };
      } else if (shape.type == 'rect') {
        shape.size = shapeSize;
      }
    }
  }, {
    key: "setupVariables",
    value: function setupVariables() {
      var variablesConf = this.config.variables;
      var data = this.data;
      var plot = this.plot;
      plot.domainByVariable = {};
      plot.variables = variablesConf.keys;

      if (!plot.variables || !plot.variables.length) {
        plot.variables = _utils.Utils.inferVariables(data, this.config.groups.key, this.config.includeInPlot);
      }

      plot.labels = [];
      plot.labelByVariable = {};
      plot.variables.forEach(function (variableKey, index) {
        plot.domainByVariable[variableKey] = d3.extent(data, function (d) {
          return variablesConf.value(d, variableKey);
        });
        var label = variableKey;

        if (variablesConf.labels && variablesConf.labels.length > index) {
          label = variablesConf.labels[index];
        }

        plot.labels.push(label);
        plot.labelByVariable[variableKey] = label;
      }); // console.log(plot.labelByVariable);
    }
  }, {
    key: "setupCorrelationMatrix",
    value: function setupCorrelationMatrix() {
      var self = this;
      var data = this.data;
      var matrix = this.plot.correlation.matrix = [];
      var matrixCells = this.plot.correlation.matrix.cells = [];
      var plot = this.plot;
      var variableToValues = {};
      plot.variables.forEach(function (v, i) {
        variableToValues[v] = data.map(function (d) {
          return plot.x.value(d, v);
        });
      });
      plot.variables.forEach(function (v1, i) {
        var row = [];
        matrix.push(row);
        plot.variables.forEach(function (v2, j) {
          var corr = 1;

          if (v1 != v2) {
            corr = self.config.correlation.value(variableToValues[v1], variableToValues[v2]);
          }

          var cell = {
            rowVar: v1,
            colVar: v2,
            row: i,
            col: j,
            value: corr
          };
          row.push(cell);
          matrixCells.push(cell);
        });
      });
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(CorrelationMatrix.prototype), "update", this).call(this, newData); // this.update


      this.updateCells();
      this.updateVariableLabels();

      if (this.config.showLegend) {
        this.updateLegend();
      }
    }
  }, {
    key: "updateVariableLabels",
    value: function updateVariableLabels() {
      this.plot.labelClass = this.prefixClass("label");
      this.updateAxisX();
      this.updateAxisY();
    }
  }, {
    key: "updateAxisX",
    value: function updateAxisX() {
      var self = this;
      var plot = self.plot;
      var labelClass = plot.labelClass;
      var labelXClass = labelClass + "-x";
      var labels = self.svgG.selectAll("text." + labelXClass).data(plot.variables, function (d, i) {
        return i;
      });
      var labelsMerge = labels.enter().append("text").attr("class", function (d, i) {
        return labelClass + " " + labelXClass + " " + labelXClass + "-" + i;
      }).merge(labels);
      labelsMerge.attr("x", function (d, i) {
        return i * plot.cellSize + plot.cellSize / 2;
      }).attr("y", plot.height).attr("dx", -2).attr("dy", 5).attr("text-anchor", "end") // .attr("dominant-baseline", "hanging")
      .text(function (v) {
        return plot.labelByVariable[v];
      });

      if (this.config.rotateLabelsX) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + (i * plot.cellSize + plot.cellSize / 2) + ", " + plot.height + ")";
        });
      }

      var maxWidth = self.computeXAxisLabelsWidth();
      labelsMerge.each(function (label) {
        _utils.Utils.placeTextWithEllipsisAndTooltip(d3.select(this), label, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });
      labels.exit().remove();
    }
  }, {
    key: "updateAxisY",
    value: function updateAxisY() {
      var self = this;
      var plot = self.plot;
      var labelClass = plot.labelClass;
      var labelYClass = plot.labelClass + "-y";
      var labels = self.svgG.selectAll("text." + labelYClass).data(plot.variables);
      var labelsMerge = labels.enter().append("text").merge(labels);
      labelsMerge.attr("x", 0).attr("y", function (d, i) {
        return i * plot.cellSize + plot.cellSize / 2;
      }).attr("dx", -2).attr("text-anchor", "end").attr("class", function (d, i) {
        return labelClass + " " + labelYClass + " " + labelYClass + "-" + i;
      }) // .attr("dominant-baseline", "hanging")
      .text(function (v) {
        return plot.labelByVariable[v];
      });

      if (this.config.rotateLabelsY) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + 0 + ", " + (i * plot.cellSize + plot.cellSize / 2) + ")";
        }).attr("text-anchor", "end");
      }

      var maxWidth = self.computeYAxisLabelsWidth();
      labelsMerge.each(function (label) {
        _utils.Utils.placeTextWithEllipsisAndTooltip(d3.select(this), label, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });
      labels.exit().remove();
    }
  }, {
    key: "computeYAxisLabelsWidth",
    value: function computeYAxisLabelsWidth() {
      var maxWidth = this.plot.margin.left;

      if (!this.config.rotateLabelsY) {
        return maxWidth;
      }

      maxWidth *= _utils.Utils.SQRT_2;
      var fontSize = 11; //todo check actual font size

      maxWidth -= fontSize / 2;
      return maxWidth;
    }
  }, {
    key: "computeXAxisLabelsWidth",
    value: function computeXAxisLabelsWidth(offset) {
      if (!this.config.rotateLabelsX) {
        return this.plot.cellSize - 2;
      }

      var size = this.plot.margin.bottom;
      size *= _utils.Utils.SQRT_2;
      var fontSize = 11; //todo check actual font size

      size -= fontSize / 2;
      return size;
    }
  }, {
    key: "updateCells",
    value: function updateCells() {
      var self = this;
      var plot = self.plot;
      var cellClass = self.prefixClass("cell");
      var cellShape = plot.correlation.shape.type;
      var cells = self.svgG.selectAll("g." + cellClass).data(plot.correlation.matrix.cells);
      var cellsEnter = cells.enter().append("g").classed(cellClass, true);
      var cellsMerge = cellsEnter.merge(cells);
      cellsMerge.attr("transform", function (c) {
        return "translate(" + (plot.cellSize * c.col + plot.cellSize / 2) + "," + (plot.cellSize * c.row + plot.cellSize / 2) + ")";
      });
      cellsMerge.classed(self.config.cssClassPrefix + "selectable", !!self.scatterPlot);
      var selector = "*:not(.cell-shape-" + cellShape + ")";
      var wrongShapes = cells.selectAll(selector);
      wrongShapes.remove();
      var shapes = cellsMerge.selectOrAppend(cellShape + ".cell-shape-" + cellShape);

      if (plot.correlation.shape.type == 'circle') {
        shapes.attr("r", plot.correlation.shape.radius).attr("cx", 0).attr("cy", 0);
      }

      if (plot.correlation.shape.type == 'ellipse') {
        // cells.attr("transform", c=> "translate(300,150) rotate("+plot.correlation.shape.rotateVal(c.value)+")");
        shapes.attr("rx", plot.correlation.shape.radiusX).attr("ry", plot.correlation.shape.radiusY).attr("cx", 0).attr("cy", 0).attr("transform", function (c) {
          return "rotate(" + plot.correlation.shape.rotateVal(c.value) + ")";
        });
      }

      if (plot.correlation.shape.type == 'rect') {
        shapes.attr("width", plot.correlation.shape.size).attr("height", plot.correlation.shape.size).attr("x", -plot.cellSize / 2).attr("y", -plot.cellSize / 2);
      }

      shapes.style("fill", function (c) {
        return plot.correlation.color.scale(c.value);
      });
      var mouseoverCallbacks = [];
      var mouseoutCallbacks = [];

      if (plot.tooltip) {
        mouseoverCallbacks.push(function (c) {
          var html = c.value;
          self.showTooltip(html);
        });
        mouseoutCallbacks.push(function (c) {
          self.hideTooltip();
        });
      }

      if (self.config.highlightLabels) {
        var highlightClass = self.config.cssClassPrefix + "highlight";

        var xLabelClass = function xLabelClass(c) {
          return plot.labelClass + "-x-" + c.col;
        };

        var yLabelClass = function yLabelClass(c) {
          return plot.labelClass + "-y-" + c.row;
        };

        mouseoverCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, true);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, true);
        });
        mouseoutCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, false);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, false);
        });
      }

      cellsMerge.on("mouseover", function (c) {
        mouseoverCallbacks.forEach(function (callback) {
          return callback(c);
        });
      }).on("mouseout", function (c) {
        mouseoutCallbacks.forEach(function (callback) {
          return callback(c);
        });
      });
      cellsMerge.on("click", function (c) {
        self.trigger("cell-selected", c);
      });
      cells.exit().remove();
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var plot = this.plot;
      var legendX = this.plot.width + 10;
      var legendY = 0;
      var barWidth = 10;
      var barHeight = this.plot.height - 2;
      var scale = plot.correlation.color.scale;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY).linearGradientBar(barWidth, barHeight);
    }
  }, {
    key: "attachScatterPlot",
    value: function attachScatterPlot(containerSelector, config) {
      var _this2 = this;

      var self = this;
      config = config || {};
      var scatterPlotConfig = {
        height: self.plot.height + self.config.margin.top + self.config.margin.bottom,
        width: self.plot.height + self.config.margin.top + self.config.margin.bottom,
        groups: {
          key: self.config.groups.key,
          label: self.config.groups.label
        },
        guides: true,
        showLegend: false
      };
      self.scatterPlot = true;
      scatterPlotConfig = _utils.Utils.deepExtend(scatterPlotConfig, config);
      this.update();
      this.on("cell-selected", function (c) {
        scatterPlotConfig.x = {
          key: c.rowVar,
          label: self.plot.labelByVariable[c.rowVar]
        };
        scatterPlotConfig.y = {
          key: c.colVar,
          label: self.plot.labelByVariable[c.colVar]
        };

        if (self.scatterPlot && self.scatterPlot !== true) {
          self.scatterPlot.setConfig(scatterPlotConfig).init();
        } else {
          self.scatterPlot = new _scatterplot.ScatterPlot(containerSelector, self.data, scatterPlotConfig);

          _this2.attach("ScatterPlot", self.scatterPlot);
        }
      });
    }
  }]);

  return CorrelationMatrix;
}(_chart.Chart);

exports.CorrelationMatrix = CorrelationMatrix;

},{"./chart":32,"./d3":35,"./legend":41,"./scatterplot":45,"./statistics-utils":47,"./utils":48}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.D3Extensions = void 0;

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var D3Extensions =
/*#__PURE__*/
function () {
  function D3Extensions() {
    _classCallCheck(this, D3Extensions);
  }

  _createClass(D3Extensions, null, [{
    key: "extend",
    value: function extend() {
      d3.selection.prototype.enter.prototype.insertSelector = d3.selection.prototype.insertSelector = function (selector, before) {
        return D3Extensions.insertSelector(this, selector, before);
      };

      d3.selection.prototype.enter.prototype.appendSelector = d3.selection.prototype.appendSelector = function (selector) {
        return D3Extensions.appendSelector(this, selector);
      };

      d3.selection.prototype.enter.prototype.selectOrAppend = d3.selection.prototype.selectOrAppend = function (selector) {
        return D3Extensions.selectOrAppend(this, selector);
      };

      d3.selection.prototype.enter.prototype.selectOrInsert = d3.selection.prototype.selectOrInsert = function (selector, before) {
        return D3Extensions.selectOrInsert(this, selector, before);
      };
    }
  }, {
    key: "insertOrAppendSelector",
    value: function insertOrAppendSelector(parent, selector, operation, before) {
      var selectorParts = selector.split(/([\.\#])/);
      var element = parent[operation](selectorParts.shift(), before); //":first-child"

      while (selectorParts.length > 1) {
        var selectorModifier = selectorParts.shift();
        var selectorItem = selectorParts.shift();

        if (selectorModifier === ".") {
          element = element.classed(selectorItem, true);
        } else if (selectorModifier === "#") {
          element = element.attr('id', selectorItem);
        }
      }

      return element;
    }
  }, {
    key: "insertSelector",
    value: function insertSelector(parent, selector, before) {
      return D3Extensions.insertOrAppendSelector(parent, selector, "insert", before);
    }
  }, {
    key: "appendSelector",
    value: function appendSelector(parent, selector) {
      return D3Extensions.insertOrAppendSelector(parent, selector, "append");
    }
  }, {
    key: "selectOrAppend",
    value: function selectOrAppend(parent, selector, element) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        if (element) {
          return parent.append(element);
        }

        return D3Extensions.appendSelector(parent, selector);
      }

      return selection;
    }
  }, {
    key: "selectOrInsert",
    value: function selectOrInsert(parent, selector, before) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        return D3Extensions.insertSelector(parent, selector, before);
      }

      return selection;
    }
  }]);

  return D3Extensions;
}();

exports.D3Extensions = D3Extensions;

},{"./d3":35}],35:[function(require,module,exports){
"use strict";

module.exports = d3;

},{}],36:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DivergingStackedBarChart = exports.DivergingStackedBarChartConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var DivergingStackedBarChartConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(DivergingStackedBarChartConfig, _ChartConfig); // string or function returning color's value for color scale


  function DivergingStackedBarChartConfig(custom) {
    var _this;

    _classCallCheck(this, DivergingStackedBarChartConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DivergingStackedBarChartConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'diverging-stacked-bar-chart';
    _this.showTooltip = true;
    _this.showLegend = true;
    _this.forceLegend = false;
    _this.legend = {
      width: 80,
      margin: 10,
      shapeWidth: 20
    };
    _this.x = {
      // X axis config
      title: '',
      // axis label
      value: function value(d) {
        return d.values;
      },
      // x value accessor
      guides: true,
      //show axis guides
      orient: 'top',
      scale: "linear",
      domainMargin: 0.02
    };
    _this.y = {
      // Y axis config
      title: '',
      value: function value(d) {
        return d.key;
      },
      // y value accessor
      scale: "ordinal",
      orient: 'left',
      guides: true //show axis guides

    };
    _this.transition = true;
    _this.color = undefined;
    _this.d3ColorCategory = 'category10';
    _this.showBarValues = true;
    _this.colorRange = undefined;
    _this.categoryNames = undefined;
    _this.middleValue = 0;

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return DivergingStackedBarChartConfig;
}(_chart.ChartConfig);

exports.DivergingStackedBarChartConfig = DivergingStackedBarChartConfig;

var DivergingStackedBarChart =
/*#__PURE__*/
function (_Chart) {
  _inherits(DivergingStackedBarChart, _Chart);

  function DivergingStackedBarChart(placeholderSelector, data, config) {
    _classCallCheck(this, DivergingStackedBarChart);

    return _possibleConstructorReturn(this, _getPrototypeOf(DivergingStackedBarChart).call(this, placeholderSelector, data, new DivergingStackedBarChartConfig(config)));
  }

  _createClass(DivergingStackedBarChart, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "setConfig", this).call(this, new DivergingStackedBarChartConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "initPlot", this).call(this);

      this.plot.showLegend = this.config.showLegend;

      if (this.plot.showLegend) {
        this.plot.margin.right = this.config.margin.right + this.config.legend.width + this.config.legend.margin * 2;
      }

      _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "computePlotSize", this).call(this);

      this.plot.x = {};
      this.plot.y = {};
      this.plot.data = this.getDataToPlot();
      this.setupY();
      this.setupX();
      this.setupColor();
    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      return this.data;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var _this2 = this;

      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;

      x.value = function (d) {
        return conf.value.call(_this2.config, d);
      };

      x.scale = _utils.Utils.createScale(conf.scale).rangeRound([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.guides) {
        x.axis.tickSize(-plot.height);
      }

      var data = this.plot.data;
      plot.categoryNames = this.config.categoryNames;
      plot.neutralIndex = Math.floor(plot.categoryNames.length / 2);
      plot.rows = data.map(function (d) {
        var originalValues = x.value(d);
        var x0 = _this2.config.middleValue - d3.sum(originalValues.map(function (v, i) {
          return i < plot.neutralIndex ? v : 0;
        }));
        if (plot.categoryNames.length & 1) x0 += -1 * originalValues[plot.neutralIndex] / 2;
        var values = originalValues.map(function (v, i) {
          return i < plot.neutralIndex ? _this2.config.middleValue - v : _this2.config.middleValue + v;
        });
        var total = d3.sum(originalValues);
        var categories = plot.categoryNames;

        if (d.categories) {
          categories = d.categories.map(function (catIndex, i) {
            return plot.categoryNames[catIndex];
          });
        }

        return {
          datum: d,
          originalValues: originalValues,
          values: values,
          categories: [],
          min: x0,
          max: x0 + total,
          total: total,
          boxes: values.map(function (v, i) {
            return {
              name: categories[i],
              x0: x0,
              x1: x0 += originalValues[i],
              originalValue: originalValues[i]
            };
          })
        };
      });
      var domain;

      if (!data || !data.length) {
        domain = [];
      } else {
        var _ref;

        domain = d3.extent((_ref = []).concat.apply(_ref, _toConsumableArray(plot.rows.map(function (b) {
          return [b.min, b.max];
        }))));
        var margin = (domain[1] - domain[0]) * conf.domainMargin || conf.domainMargin * domain[0];
        domain[0] -= margin;
        domain[1] += margin;
      }

      plot.x.scale.domain(domain);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var _this3 = this;

      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;

      y.value = function (d) {
        return conf.value.call(_this3.config, d);
      };

      y.scale = d3.scaleBand().range([0, plot.height]).padding(.3);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (conf.ticks) {
        y.axis.ticks(conf.ticks);
      }

      if (conf.guides) {
        y.axis.tickSize(-plot.width);
      }

      this.setupYDomain();
    }
  }, {
    key: "setupYDomain",
    value: function setupYDomain() {
      var plot = this.plot;
      var data = this.plot.data;
      var c = this.config;
      var domain = data.map(plot.y.value);
      plot.y.scale.domain(domain);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));

      if (axisConf.orient === 'bottom') {
        axis.attr("transform", "translate(0," + plot.height + ")");
      }

      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      var titleY = axisConf.orient === 'bottom' ? plot.margin.bottom : 0;
      var titleDY = axisConf.orient === 'bottom' ? "-1em" : "-1.5em";
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + titleY + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", titleDY).style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawBars",
    value: function drawBars() {
      var self = this,
          plot = self.plot,
          config = self.config;
      var rowClass = self.prefixClass("row");
      var rows = self.svgG.selectAll("." + rowClass).data(plot.rows);
      var rowEnter = rows.enter().appendSelector("g." + rowClass);
      var rowMerge = rowEnter.merge(rows).attr("transform", function (d) {
        return "translate(0," + plot.y.map(d.datum) + ")";
      });
      rows.exit().remove();
      var barClass = self.prefixClass("bar");
      var bars = rowMerge.selectAll("g." + barClass).data(function (d) {
        return d.boxes;
      });
      bars.exit().remove();
      var barsEnter = bars.enter().append("g").attr("class", barClass);
      barsEnter.append("rect");

      if (config.showBarValues) {
        barsEnter.append("text");
      }

      var barsM = barsEnter.merge(bars);
      barsM.select("rect").attr("height", plot.y.scale.bandwidth()).attr("x", function (d) {
        return plot.x.scale(d.x0);
      }).attr("width", function (d) {
        return plot.x.scale(d.x1) - plot.x.scale(d.x0);
      }).style("fill", function (d, i) {
        return plot.color(d.name, i);
      });
      var textM = barsM.select("text");

      if (config.showBarValues) {
        textM.attr("x", function (d) {
          return plot.x.scale(d.x0);
        }).attr("y", plot.y.scale.bandwidth() / 2).attr("dy", "0.5em").attr("dx", function (d) {
          return (plot.x.scale(d.x1) - plot.x.scale(d.x0)) / 2;
        }).style("text-anchor", "middle").text(function (d) {
          return d.originalValue !== 0 && d.x1 - d.x0 > 0.04 ? d.originalValue : "";
        });
      } else {
        textM.remove();
      }

      self.svgG.selectOrAppend("line." + self.prefixClass("middle-line")).attr("x1", plot.x.scale(self.config.middleValue)).attr("y1", 0).attr("x2", plot.x.scale(self.config.middleValue)).attr("y2", plot.height);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawBars();
      this.updateLegend();
      return this;
    }
  }, {
    key: "setupColor",
    value: function setupColor() {
      var self = this;
      var conf = this.config;

      if (conf.d3ColorCategory) {
        var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);

        this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
      }

      var colorValue = conf.color;

      if (colorValue && typeof colorValue === 'string' || colorValue instanceof String) {
        this.plot.color = colorValue;
      } else if (conf.colorRange) {
        this.plot.color = _utils.Utils.createScale("ordinal").domain(this.plot.categoryNames).range(conf.colorRange);
      } else if (this.plot.colorCategory) {
        self.plot.colorValue = colorValue;
        this.plot.color = this.plot.colorCategory;
      }
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var self = this;
      var plot = this.plot;
      var scale = plot.color;

      if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
        plot.showLegend = false;
      }

      if (!plot.showLegend) {
        if (plot.legend && plot.legend.container) {
          plot.legend.container.remove();
        }

        return;
      }

      var legendX = this.plot.width + this.config.legend.margin;
      var legendY = this.config.legend.margin;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY);
      plot.legendColor = plot.legend.color().shapeWidth(this.config.legend.shapeWidth).orient('vertical').scale(scale).labelWrap(this.config.legend.width); // .labels(scale.domain().map(v=>plot.groupToLabel[v]));

      plot.legend.container.call(plot.legendColor);
    }
  }]);

  return DivergingStackedBarChart;
}(_chart.Chart);

exports.DivergingStackedBarChart = DivergingStackedBarChart;

},{"./chart":32,"./d3":35,"./legend":41,"./utils":48}],37:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HeatmapTimeSeries = exports.HeatmapTimeSeriesConfig = void 0;

var _chart = require("./chart");

var _heatmap = require("./heatmap");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var HeatmapTimeSeriesConfig =
/*#__PURE__*/
function (_HeatmapConfig) {
  _inherits(HeatmapTimeSeriesConfig, _HeatmapConfig);

  function HeatmapTimeSeriesConfig(custom) {
    var _this;

    _classCallCheck(this, HeatmapTimeSeriesConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HeatmapTimeSeriesConfig).call(this));
    _this.x = {
      fillMissing: false,
      // fill missing values using interval and intervalStep
      interval: undefined,
      //used in filling missing ticks
      intervalStep: 1,
      format: undefined,
      //input data d3 time format
      displayFormat: undefined,
      //d3 time format for display
      intervalToFormats: [//used to guess interval and format
      {
        name: 'year',
        formats: ["%Y"]
      }, {
        name: 'month',
        formats: ["%Y-%m"]
      }, {
        name: 'day',
        formats: ["%Y-%m-%d"]
      }, {
        name: 'hour',
        formats: ['%H', '%Y-%m-%d %H']
      }, {
        name: 'minute',
        formats: ['%H:%M', '%Y-%m-%d %H:%M']
      }, {
        name: 'second',
        formats: ['%H:%M:%S', '%Y-%m-%d %H:%M:%S']
      }],
      sortComparator: function sortComparator(a, b) {
        return _utils.Utils.isString(a) ? a.localeCompare(b) : a - b;
      },
      formatter: undefined
    };
    _this.z = {
      fillMissing: true // fiill missing values with nearest previous value

    };
    _this.legend = {
      formatter: function formatter(v) {
        var suffix = "";

        if (v / 1000000 >= 1) {
          suffix = " M";
          v = Number(v / 1000000).toFixed(3);
        }

        var nf = Intl.NumberFormat();
        return nf.format(v) + suffix;
      }
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return HeatmapTimeSeriesConfig;
}(_heatmap.HeatmapConfig);

exports.HeatmapTimeSeriesConfig = HeatmapTimeSeriesConfig;

var HeatmapTimeSeries =
/*#__PURE__*/
function (_Heatmap) {
  _inherits(HeatmapTimeSeries, _Heatmap);

  function HeatmapTimeSeries(placeholderSelector, data, config) {
    _classCallCheck(this, HeatmapTimeSeries);

    return _possibleConstructorReturn(this, _getPrototypeOf(HeatmapTimeSeries).call(this, placeholderSelector, data, new HeatmapTimeSeriesConfig(config)));
  }

  _createClass(HeatmapTimeSeries, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "setConfig", this).call(this, new HeatmapTimeSeriesConfig(config));
    }
  }, {
    key: "setupValuesBeforeGroupsSort",
    value: function setupValuesBeforeGroupsSort() {
      var _this2 = this;

      this.plot.x.timeFormat = this.config.x.format;

      if (this.config.x.displayFormat && !this.plot.x.timeFormat) {
        this.guessTimeFormat();
      }

      _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "setupValuesBeforeGroupsSort", this).call(this);

      if (!this.config.x.fillMissing) {
        return;
      }

      var self = this;
      this.initTimeFormatAndInterval();
      this.plot.x.intervalStep = this.config.x.intervalStep || 1;
      this.plot.x.timeParser = this.getTimeParser();
      this.plot.x.uniqueValues.sort(this.config.x.sortComparator);
      var prev = null;
      this.plot.x.uniqueValues.forEach(function (x, i) {
        var current = _this2.parseTime(x);

        if (prev === null) {
          prev = current;
          return;
        }

        var next = self.nextTimeTickValue(prev);
        var missing = [];
        var iteration = 0;

        while (self.compareTimeValues(next, current) <= 0) {
          iteration++;

          if (iteration > 100) {
            break;
          }

          var d = {};
          var timeString = self.formatTime(next);
          d[_this2.config.x.key] = timeString;
          self.updateGroups(d, timeString, self.plot.x.groups, self.config.x.groups);
          missing.push(next);
          next = self.nextTimeTickValue(next);
        }

        prev = current;
      });
    }
  }, {
    key: "parseTime",
    value: function parseTime(x) {
      var parser = this.getTimeParser();
      return parser(x);
    }
  }, {
    key: "formatTime",
    value: function formatTime(date) {
      var formatter = this.getTimeFormatter();
      return formatter(date);
    }
  }, {
    key: "formatValueX",
    value: function formatValueX(value) {
      //used only for display
      if (this.config.x.formatter) return this.config.x.formatter.call(this.config, value);

      if (this.config.x.displayFormat) {
        var date = this.parseTime(value);
        return d3.timeFormat(this.config.x.displayFormat)(date);
      }

      if (!this.plot.x.timeFormat) return value;

      if (_utils.Utils.isDate(value)) {
        return this.formatTime(value);
      }

      return value;
    }
  }, {
    key: "compareTimeValues",
    value: function compareTimeValues(a, b) {
      return a - b;
    }
  }, {
    key: "timeValuesEqual",
    value: function timeValuesEqual(a, b) {
      var parser = this.plot.x.timeParser;
      return parser(a) === parser(b);
    }
  }, {
    key: "nextTimeTickValue",
    value: function nextTimeTickValue(t) {
      var interval = 'time' + _utils.Utils.capitalizeFirstLetter(this.plot.x.interval);

      return d3[interval].offset(t, this.plot.x.intervalStep);
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "initPlot", this).call(this);

      if (this.config.z.fillMissing) {
        this.plot.matrix.forEach(function (row, rowIndex) {
          var prevRowValue = undefined;
          row.forEach(function (cell, colIndex) {
            if (cell.value === undefined && prevRowValue !== undefined) {
              cell.value = prevRowValue;
              cell.missing = true;
            }

            prevRowValue = cell.value;
          });
        });
      }
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "update", this).call(this, newData);
    }
  }, {
    key: "initTimeFormatAndInterval",
    value: function initTimeFormatAndInterval() {
      this.plot.x.interval = this.config.x.interval;

      if (!this.plot.x.timeFormat) {
        this.guessTimeFormat();
      }

      if (!this.plot.x.interval && this.plot.x.timeFormat) {
        this.guessInterval();
      }
    }
  }, {
    key: "guessTimeFormat",
    value: function guessTimeFormat() {
      var self = this;

      for (var i = 0; i < self.config.x.intervalToFormats.length; i++) {
        var intervalFormat = self.config.x.intervalToFormats[i];
        var format = null;
        var formatMatch = intervalFormat.formats.some(function (f) {
          format = f;
          var parser = d3.timeParse(f);
          return self.plot.x.uniqueValues.every(function (x) {
            return parser(x) !== null;
          });
        });

        if (formatMatch) {
          self.plot.x.timeFormat = format; // console.log('Guessed timeFormat', format);

          if (!self.plot.x.interval) {
            self.plot.x.interval = intervalFormat.name; // console.log('Guessed interval', self.plot.x.interval);
          }

          return;
        }
      }
    }
  }, {
    key: "guessInterval",
    value: function guessInterval() {
      var self = this;

      for (var i = 0; i < self.config.x.intervalToFormats.length; i++) {
        var intervalFormat = self.config.x.intervalToFormats[i];

        if (intervalFormat.formats.indexOf(self.plot.x.timeFormat) >= 0) {
          self.plot.x.interval = intervalFormat.name; // console.log('Guessed interval', self.plot.x.interval);

          return;
        }
      }
    }
  }, {
    key: "getTimeFormatter",
    value: function getTimeFormatter() {
      if (!this.plot.x.timeFormatter) {
        this.plot.x.timeFormatter = d3.timeFormat(this.plot.x.timeFormat);
      }

      return this.plot.x.timeFormatter;
    }
  }, {
    key: "getTimeParser",
    value: function getTimeParser() {
      if (!this.plot.x.timeParser) {
        this.plot.x.timeParser = d3.timeParse(this.plot.x.timeFormat);
      }

      return this.plot.x.timeParser;
    }
  }]);

  return HeatmapTimeSeries;
}(_heatmap.Heatmap);

exports.HeatmapTimeSeries = HeatmapTimeSeries;

},{"./chart":32,"./d3":35,"./heatmap":38,"./statistics-utils":47,"./utils":48}],38:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Heatmap = exports.HeatmapConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var HeatmapConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(HeatmapConfig, _ChartConfig); //show tooltip on dot hover


  function HeatmapConfig(custom) {
    var _this;

    _classCallCheck(this, HeatmapConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HeatmapConfig).call(this));
    _this.svgClass = 'odc-heatmap';
    _this.showTooltip = true;
    _this.tooltip = {
      noDataText: "N/A"
    };
    _this.showLegend = true;
    _this.legend = {
      width: 30,
      rotateLabels: false,
      decimalPlaces: undefined,
      formatter: function formatter(v) {
        return _this.legend.decimalPlaces === undefined ? v : Number(v).toFixed(_this.legend.decimalPlaces);
      }
    };
    _this.highlightLabels = true;
    _this.x = {
      // X axis config
      title: '',
      // axis title
      key: 0,
      value: function value(d) {
        return d[_this.x.key];
      },
      // x value accessor
      rotateLabels: true,
      sortLabels: false,
      sortComparator: function sortComparator(a, b) {
        return _utils.Utils.isNumber(a) ? a - b : a.localeCompare(b);
      },
      groups: {
        keys: [],
        labels: [],
        value: function value(d, key) {
          return d[key];
        },
        overlap: {
          top: 20,
          bottom: 20
        }
      },
      formatter: undefined // value formatter function

    };
    _this.y = {
      // Y axis config
      title: '',
      // axis title,
      rotateLabels: true,
      key: 1,
      value: function value(d) {
        return d[_this.y.key];
      },
      // y value accessor
      sortLabels: false,
      sortComparator: function sortComparator(a, b) {
        return _utils.Utils.isNumber(b) ? b - a : b.localeCompare(a);
      },
      groups: {
        keys: [],
        labels: [],
        value: function value(d, key) {
          return d[key];
        },
        overlap: {
          left: 20,
          right: 20
        }
      },
      formatter: undefined // value formatter function

    };
    _this.z = {
      key: 2,
      value: function value(d) {
        return d[_this.z.key];
      },
      notAvailableValue: function notAvailableValue(v) {
        return v === null || v === undefined;
      },
      decimalPlaces: undefined,
      formatter: function formatter(v) {
        return _this.z.decimalPlaces === undefined ? v : Number(v).toFixed(_this.z.decimalPlaces);
      } // value formatter function

    };
    _this.color = {
      noDataColor: "white",
      scale: "linear",
      reverseScale: false,
      range: ["darkblue", "lightskyblue", "orange", "crimson", "darkred"]
    };
    _this.cell = {
      width: undefined,
      height: undefined,
      sizeMin: 15,
      sizeMax: 250,
      padding: 0
    };
    _this.margin = {
      left: 60,
      right: 50,
      top: 30,
      bottom: 80
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return HeatmapConfig;
}(_chart.ChartConfig); //TODO refactor


exports.HeatmapConfig = HeatmapConfig;

var Heatmap =
/*#__PURE__*/
function (_Chart) {
  _inherits(Heatmap, _Chart);

  function Heatmap(placeholderSelector, data, config) {
    _classCallCheck(this, Heatmap);

    return _possibleConstructorReturn(this, _getPrototypeOf(Heatmap).call(this, placeholderSelector, data, new HeatmapConfig(config)));
  }

  _createClass(Heatmap, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(Heatmap.prototype), "setConfig", this).call(this, new HeatmapConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(Heatmap.prototype), "initPlot", this).call(this);

      var self = this;
      var margin = this.config.margin;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.plot.z = {
        matrixes: undefined,
        cells: undefined,
        color: {},
        shape: {}
      };
      this.setupValues();
      this.buildCells();
      var titleRectWidth = 6;
      this.plot.x.overlap = {
        top: 0,
        bottom: 0
      };

      if (this.plot.groupByX) {
        var depth = self.config.x.groups.keys.length;
        var allTitlesWidth = depth * titleRectWidth;
        this.plot.x.overlap.bottom = self.config.x.groups.overlap.bottom;
        this.plot.x.overlap.top = self.config.x.groups.overlap.top + allTitlesWidth;
        this.plot.margin.top = this.plot.margin.top + conf.x.groups.overlap.top;
        this.plot.margin.bottom = this.plot.margin.bottom + conf.x.groups.overlap.bottom;
      }

      this.plot.y.overlap = {
        left: 0,
        right: 0
      };

      if (this.plot.groupByY) {
        var _depth = self.config.y.groups.keys.length;

        var _allTitlesWidth = _depth * titleRectWidth;

        this.plot.y.overlap.right = self.config.y.groups.overlap.left + _allTitlesWidth;
        this.plot.y.overlap.left = self.config.y.groups.overlap.left;
        this.plot.margin.left = this.plot.margin.left + this.plot.y.overlap.left;
        this.plot.margin.right = this.plot.margin.right + this.plot.y.overlap.right;
      }

      this.plot.showLegend = conf.showLegend;

      if (this.plot.showLegend) {
        this.plot.margin.right += conf.legend.width;
      }

      this.computePlotSize();
      this.setupZScale();
      return this;
    }
  }, {
    key: "setupValues",
    value: function setupValues() {
      var _this2 = this;

      var self = this;
      var config = self.config;
      var x = self.plot.x;
      var y = self.plot.y;
      var z = self.plot.z;

      x.value = function (d) {
        return config.x.value.call(config, d);
      };

      y.value = function (d) {
        return config.y.value.call(config, d);
      };

      z.value = function (d) {
        return config.z.value.call(config, d);
      };

      x.uniqueValues = [];
      y.uniqueValues = [];
      self.plot.groupByY = !!config.y.groups.keys.length;
      self.plot.groupByX = !!config.x.groups.keys.length;
      y.groups = {
        key: undefined,
        label: '',
        values: [],
        children: null,
        level: 0,
        index: 0,
        lastIndex: 0
      };
      x.groups = {
        key: undefined,
        label: '',
        values: [],
        children: null,
        level: 0,
        index: 0,
        lastIndex: 0
      };
      var valueMap = {};
      var minZ = undefined;
      var maxZ = undefined;
      this.data.forEach(function (d) {
        var xVal = x.value(d);
        var yVal = y.value(d);
        var zValRaw = z.value(d);
        var zVal = config.z.notAvailableValue(zValRaw) ? undefined : parseFloat(zValRaw);

        if (x.uniqueValues.indexOf(xVal) === -1) {
          x.uniqueValues.push(xVal);
        }

        if (y.uniqueValues.indexOf(yVal) === -1) {
          y.uniqueValues.push(yVal);
        }

        var groupY = y.groups;

        if (self.plot.groupByY) {
          groupY = _this2.updateGroups(d, yVal, y.groups, config.y.groups);
        }

        var groupX = x.groups;

        if (self.plot.groupByX) {
          groupX = _this2.updateGroups(d, xVal, x.groups, config.x.groups);
        }

        if (!valueMap[groupY.index]) {
          valueMap[groupY.index] = {};
        }

        if (!valueMap[groupY.index][groupX.index]) {
          valueMap[groupY.index][groupX.index] = {};
        }

        if (!valueMap[groupY.index][groupX.index][yVal]) {
          valueMap[groupY.index][groupX.index][yVal] = {};
        }

        valueMap[groupY.index][groupX.index][yVal][xVal] = zVal;

        if (minZ === undefined || zVal < minZ) {
          minZ = zVal;
        }

        if (maxZ === undefined || zVal > maxZ) {
          maxZ = zVal;
        }
      });
      self.plot.valueMap = valueMap;

      if (!self.plot.groupByX) {
        x.groups.values = x.uniqueValues;
      }

      if (!self.plot.groupByY) {
        y.groups.values = y.uniqueValues;
      }

      this.setupValuesBeforeGroupsSort();
      x.gaps = [];
      x.totalValuesCount = 0;
      x.allValuesList = [];
      this.sortGroups(x, x.groups, config.x);
      y.gaps = [];
      y.totalValuesCount = 0;
      y.allValuesList = [];
      this.sortGroups(y, y.groups, config.y);
      z.min = minZ;
      z.max = maxZ;
    }
  }, {
    key: "setupValuesBeforeGroupsSort",
    value: function setupValuesBeforeGroupsSort() {}
  }, {
    key: "buildCells",
    value: function buildCells() {
      var self = this;
      var x = self.plot.x;
      var y = self.plot.y;
      var z = self.plot.z;
      var valueMap = self.plot.valueMap;
      var matrixCells = self.plot.cells = [];
      var matrix = self.plot.matrix = [];
      y.allValuesList.forEach(function (v1, i) {
        var row = [];
        matrix.push(row);
        x.allValuesList.forEach(function (v2, j) {
          var zVal = undefined;

          try {
            zVal = valueMap[v1.group.index][v2.group.index][v1.val][v2.val];
          } catch (e) {}

          var cell = {
            rowVar: v1,
            colVar: v2,
            row: i,
            col: j,
            value: zVal
          };
          row.push(cell);
          matrixCells.push(cell);
        });
      });
    }
  }, {
    key: "updateGroups",
    value: function updateGroups(d, axisVal, rootGroup, axisGroupsConfig) {
      var config = this.config;
      var currentGroup = rootGroup;
      axisGroupsConfig.keys.forEach(function (groupKey, groupKeyIndex) {
        currentGroup.key = groupKey;

        if (!currentGroup.children) {
          currentGroup.children = {};
        }

        var groupingValue = axisGroupsConfig.value.call(config, d, groupKey);

        if (!currentGroup.children.hasOwnProperty(groupingValue)) {
          rootGroup.lastIndex++;
          currentGroup.children[groupingValue] = {
            values: [],
            children: null,
            groupingValue: groupingValue,
            level: currentGroup.level + 1,
            index: rootGroup.lastIndex,
            key: groupKey
          };
        }

        currentGroup = currentGroup.children[groupingValue];
      });

      if (currentGroup.values.indexOf(axisVal) === -1) {
        currentGroup.values.push(axisVal);
      }

      return currentGroup;
    }
  }, {
    key: "sortGroups",
    value: function sortGroups(axis, group, axisConfig, gaps) {
      if (axisConfig.groups.labels && axisConfig.groups.labels.length > group.level) {
        group.label = axisConfig.groups.labels[group.level];
      } else {
        group.label = group.key;
      }

      if (!gaps) {
        gaps = [0];
      }

      if (gaps.length <= group.level) {
        gaps.push(0);
      }

      group.allValuesCount = group.allValuesCount || 0;
      group.allValuesBeforeCount = group.allValuesBeforeCount || 0;
      group.gaps = gaps.slice();
      group.gapsBefore = gaps.slice();
      group.gapsSize = Heatmap.computeGapsSize(group.gaps);
      group.gapsBeforeSize = group.gapsSize;

      if (group.values) {
        if (axisConfig.sortLabels) {
          group.values.sort(axisConfig.sortComparator);
        }

        group.values.forEach(function (v) {
          return axis.allValuesList.push({
            val: v,
            group: group
          });
        });
        group.allValuesBeforeCount = axis.totalValuesCount;
        axis.totalValuesCount += group.values.length;
        group.allValuesCount += group.values.length;
      }

      group.childrenList = [];

      if (group.children) {
        var childrenCount = 0;

        for (var childProp in group.children) {
          if (group.children.hasOwnProperty(childProp)) {
            var child = group.children[childProp];
            group.childrenList.push(child);
            childrenCount++;
            this.sortGroups(axis, child, axisConfig, gaps);
            group.allValuesCount += child.allValuesCount;
            gaps[group.level] += 1;
          }
        }

        if (gaps && childrenCount > 1) {
          gaps[group.level] -= 1;
        }

        group.gapsInside = [];
        gaps.forEach(function (d, i) {
          group.gapsInside.push(d - (group.gapsBefore[i] || 0));
        });
        group.gapsInsideSize = Heatmap.computeGapsSize(group.gapsInside);

        if (axis.gaps.length < gaps.length) {
          axis.gaps = gaps;
        }
      }
    }
  }, {
    key: "computeYAxisLabelsWidth",
    value: function computeYAxisLabelsWidth(offset) {
      var maxWidth = this.plot.margin.left;

      if (this.config.y.title) {
        maxWidth -= 15;
      }

      if (offset && offset.x) {
        maxWidth += offset.x;
      }

      if (this.config.y.rotateLabels) {
        maxWidth *= _utils.Utils.SQRT_2;
        var fontSize = 11; //todo check actual font size

        maxWidth -= fontSize / 2;
      }

      return maxWidth;
    }
  }, {
    key: "computeXAxisLabelsWidth",
    value: function computeXAxisLabelsWidth(offset) {
      if (!this.config.x.rotateLabels) {
        return this.plot.cellWidth - 2;
      }

      var size = this.plot.margin.bottom;

      if (this.config.x.title) {
        size -= 15;
      }

      if (offset && offset.y) {
        size -= offset.y;
      }

      size *= _utils.Utils.SQRT_2;
      var fontSize = 11; //todo check actual font size

      size -= fontSize / 2;
      return size;
    }
  }, {
    key: "computePlotSize",
    value: function computePlotSize() {
      var plot = this.plot;
      var conf = this.config;
      var margin = plot.margin;

      var availableWidth = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), this.plot.margin);

      var availableHeight = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), this.plot.margin);

      var width = availableWidth;
      var height = availableHeight;
      var xGapsSize = Heatmap.computeGapsSize(plot.x.gaps);
      var computedCellWidth = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (availableWidth - xGapsSize) / this.plot.x.totalValuesCount));

      if (this.config.width) {
        if (!this.config.cell.width) {
          this.plot.cellWidth = computedCellWidth;
        }
      } else {
        this.plot.cellWidth = this.config.cell.width;

        if (!this.plot.cellWidth) {
          this.plot.cellWidth = computedCellWidth;
        }
      }

      width = this.plot.cellWidth * this.plot.x.totalValuesCount + margin.left + margin.right + xGapsSize;
      var yGapsSize = Heatmap.computeGapsSize(plot.y.gaps);
      var computedCellHeight = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (availableHeight - yGapsSize) / this.plot.y.totalValuesCount));

      if (this.config.height) {
        if (!this.config.cell.height) {
          this.plot.cellHeight = computedCellHeight;
        }
      } else {
        this.plot.cellHeight = this.config.cell.height;

        if (!this.plot.cellHeight) {
          this.plot.cellHeight = computedCellHeight;
        }
      }

      height = this.plot.cellHeight * this.plot.y.totalValuesCount + margin.top + margin.bottom + yGapsSize;
      this.plot.width = width - margin.left - margin.right;
      this.plot.height = height - margin.top - margin.bottom;
    }
  }, {
    key: "setupZScale",
    value: function setupZScale() {
      var self = this;
      var config = self.config;
      var z = self.plot.z;
      var range = config.color.range;
      var extent = z.max - z.min;
      var scale;
      z.domain = [];

      if (config.color.scale == "pow") {
        var exponent = 10;
        range.forEach(function (c, i) {
          var v = z.max - extent / Math.pow(10, i);
          z.domain.push(v);
        });
        scale = d3.scalePow().exponent(exponent);
      } else if (config.color.scale == "log") {
        range.forEach(function (c, i) {
          var v = z.min + extent / Math.pow(10, i);
          z.domain.unshift(v);
        });
        scale = d3.scaleLog();
      } else {
        range.forEach(function (c, i) {
          var v = z.min + extent * (i / (range.length - 1));
          z.domain.push(v);
        });
        scale = _utils.Utils.createScale(config.color.scale);
      }

      z.domain[0] = z.min; //removing unnecessary floating points

      z.domain[z.domain.length - 1] = z.max; //removing unnecessary floating points
      // console.log(z.domain);

      if (config.color.reverseScale) {
        z.domain.reverse();
      }

      var plot = this.plot; // console.log(range);

      plot.z.color.scale = scale.domain(z.domain).range(range);
      var shape = plot.z.shape = {};
      var cellConf = this.config.cell;
      shape.type = "rect";
      plot.z.shape.width = plot.cellWidth - cellConf.padding * 2;
      plot.z.shape.height = plot.cellHeight - cellConf.padding * 2;
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(Heatmap.prototype), "update", this).call(this, newData);

      if (this.plot.groupByY) {
        this.drawGroupsY(this.plot.y.groups, this.svgG);
      }

      if (this.plot.groupByX) {
        this.drawGroupsX(this.plot.x.groups, this.svgG);
      }

      this.updateCells(); // this.updateVariableLabels();

      this.updateAxisX();
      this.updateAxisY();

      if (this.config.showLegend) {
        this.updateLegend();
      }

      this.updateAxisTitles();
    }
  }, {
    key: "updateAxisTitles",
    value: function updateAxisTitles() {
      var self = this;
      var plot = self.plot;
    }
  }, {
    key: "updateAxisX",
    value: function updateAxisX() {
      var self = this;
      var plot = self.plot;
      var labelClass = self.prefixClass("label");
      var labelXClass = labelClass + "-x";
      var labelYClass = labelClass + "-y";
      plot.labelClass = labelClass;
      var offsetX = {
        x: 0,
        y: 0
      };
      var gapSize = Heatmap.computeGapSize(0);

      if (plot.groupByX) {
        var overlap = self.config.x.groups.overlap;
        offsetX.x = gapSize / 2;
        offsetX.y = overlap.bottom + gapSize / 2 + 6;
      } else if (plot.groupByY) {
        offsetX.y = gapSize;
      }

      var labels = self.svgG.selectAll("text." + labelXClass).data(plot.x.allValuesList, function (d, i) {
        return i;
      });
      var labelsMerge = labels.enter().append("text").attr("class", function (d, i) {
        return labelClass + " " + labelXClass + " " + labelXClass + "-" + i;
      }).merge(labels);
      labelsMerge.attr("x", function (d, i) {
        return i * plot.cellWidth + plot.cellWidth / 2 + d.group.gapsSize + offsetX.x;
      }).attr("y", plot.height + offsetX.y).attr("dy", 10).attr("text-anchor", "middle").text(function (d) {
        return self.formatValueX(d.val);
      });
      var maxWidth = self.computeXAxisLabelsWidth(offsetX);
      labelsMerge.each(function (label) {
        var elem = d3.select(this),
            text = self.formatValueX(label.val);

        _utils.Utils.placeTextWithEllipsisAndTooltip(elem, text, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });

      if (self.config.x.rotateLabels) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + (i * plot.cellWidth + plot.cellWidth / 2 + d.group.gapsSize + offsetX.x) + ", " + (plot.height + offsetX.y) + ")";
        }).attr("dx", -2).attr("dy", 8).attr("text-anchor", "end");
      }

      labels.exit().remove();
      self.svgG.selectOrAppend("g." + self.prefixClass('axis-x')).attr("transform", "translate(" + plot.width / 2 + "," + (plot.height + plot.margin.bottom) + ")").selectOrAppend("text." + self.prefixClass('label')).attr("dy", "-0.5em").style("text-anchor", "middle").text(self.config.x.title);
    }
  }, {
    key: "updateAxisY",
    value: function updateAxisY() {
      var self = this;
      var plot = self.plot;
      var labelClass = self.prefixClass("label");
      var labelYClass = labelClass + "-y";
      plot.labelClass = labelClass;
      var labels = self.svgG.selectAll("text." + labelYClass).data(plot.y.allValuesList);
      var labelsEnter = labels.enter().append("text");
      var labelsMerge = labelsEnter.merge(labels);
      var offsetY = {
        x: 0,
        y: 0
      };

      if (plot.groupByY) {
        var overlap = self.config.y.groups.overlap;
        var gapSize = Heatmap.computeGapSize(0);
        offsetY.x = -overlap.left;
        offsetY.y = gapSize / 2;
      }

      labelsMerge.attr("x", offsetY.x).attr("y", function (d, i) {
        return i * plot.cellHeight + plot.cellHeight / 2 + d.group.gapsSize + offsetY.y;
      }).attr("dx", -2).attr("text-anchor", "end").attr("class", function (d, i) {
        return labelClass + " " + labelYClass + " " + labelYClass + "-" + i;
      }).text(function (d) {
        var formatted = self.formatValueY(d.val);
        return formatted;
      });
      var maxWidth = self.computeYAxisLabelsWidth(offsetY);
      labelsMerge.each(function (label) {
        var elem = d3.select(this),
            text = self.formatValueY(label.val);

        _utils.Utils.placeTextWithEllipsisAndTooltip(elem, text, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });

      if (self.config.y.rotateLabels) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + offsetY.x + ", " + (d.group.gapsSize + (i * plot.cellHeight + plot.cellHeight / 2) + offsetY.y) + ")";
        }).attr("text-anchor", "end"); // .attr("dx", -7);
      } else {
        labelsMerge.attr("dominant-baseline", "middle");
      }

      labels.exit().remove();
      self.svgG.selectOrAppend("g." + self.prefixClass('axis-y')).selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)").attr("dy", "1em").style("text-anchor", "middle").text(self.config.y.title);
    }
  }, {
    key: "drawGroupsY",
    value: function drawGroupsY(parentGroup, container, availableWidth) {
      var self = this;
      var plot = self.plot;
      var groupClass = self.prefixClass("group");
      var groupYClass = groupClass + "-y";
      var groups = container.selectAll("g." + groupClass + "." + groupYClass).data(parentGroup.childrenList);
      var valuesBeforeCount = 0;
      var gapsBeforeSize = 0;
      var groupsEnter = groups.enter().append("g");
      groupsEnter.classed(groupClass, true).classed(groupYClass, true).append("rect").classed("group-rect", true);
      var titleGroupEnter = groupsEnter.appendSelector("g.title");
      titleGroupEnter.append("rect");
      titleGroupEnter.append("text");
      var gapSize = Heatmap.computeGapSize(parentGroup.level);
      var padding = gapSize / 4;
      var titleRectWidth = Heatmap.groupTitleRectHeight;
      var depth = self.config.y.groups.keys.length - parentGroup.level;
      var overlap = {
        left: 0,
        right: 0
      };

      if (!availableWidth) {
        overlap.right = plot.y.overlap.left;
        overlap.left = plot.y.overlap.left;
        availableWidth = plot.width + gapSize + overlap.left + overlap.right;
      }

      var groupsMerge = groupsEnter.merge(groups);
      groupsMerge.attr("transform", function (d, i) {
        var translate = "translate(" + (padding - overlap.left) + "," + (plot.cellHeight * valuesBeforeCount + i * gapSize + gapsBeforeSize + padding) + ")";
        gapsBeforeSize += d.gapsInsideSize || 0;
        valuesBeforeCount += d.allValuesCount || 0;
        return translate;
      });
      var groupWidth = availableWidth - padding * 2;
      var titleGroups = groupsMerge.selectAll("g.title").attr("transform", function (d, i) {
        return "translate(" + (groupWidth - titleRectWidth) + ", 0)";
      });
      var tileRects = titleGroups.selectAll("rect").attr("width", titleRectWidth).attr("height", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellHeight * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0) // .attr("fill", "lightgrey")
      .attr("stroke-width", 0);
      this.setGroupMouseCallbacks(parentGroup, tileRects);
      groupsMerge.selectAll("rect.group-rect").attr("class", function (d) {
        return "group-rect group-rect-" + d.index;
      }).attr("width", groupWidth).attr("height", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellHeight * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0).attr("fill", "white").attr("fill-opacity", 0).attr("stroke-width", 0.5).attr("stroke", "black");
      groupsMerge.each(function (group) {
        self.drawGroupsY.call(self, group, d3.select(this), groupWidth - titleRectWidth);
      });
      groups.exit().remove();
    }
  }, {
    key: "drawGroupsX",
    value: function drawGroupsX(parentGroup, container, availableHeight) {
      var self = this;
      var plot = self.plot;
      var groupClass = self.prefixClass("group");
      var groupXClass = groupClass + "-x";
      var groups = container.selectAll("g." + groupClass + "." + groupXClass).data(parentGroup.childrenList);
      var valuesBeforeCount = 0;
      var gapsBeforeSize = 0;
      var groupsEnter = groups.enter().append("g");
      groupsEnter.classed(groupClass, true).classed(groupXClass, true).append("rect").classed("group-rect", true);
      var titleGroupEnter = groupsEnter.appendSelector("g.title");
      titleGroupEnter.append("rect");
      titleGroupEnter.append("text");
      var gapSize = Heatmap.computeGapSize(parentGroup.level);
      var padding = gapSize / 4;
      var titleRectHeight = Heatmap.groupTitleRectHeight;
      var depth = self.config.x.groups.keys.length - parentGroup.level;
      var overlap = {
        top: 0,
        bottom: 0
      };

      if (!availableHeight) {
        overlap.bottom = plot.x.overlap.bottom;
        overlap.top = plot.x.overlap.top;
        availableHeight = plot.height + gapSize + overlap.top + overlap.bottom;
      } else {
        overlap.top = -titleRectHeight;
      } // console.log('parentGroup',parentGroup, 'gapSize', gapSize, plot.x.overlap);


      var groupsMerge = groupsEnter.merge(groups);
      groupsMerge.attr("transform", function (d, i) {
        var translate = "translate(" + (plot.cellWidth * valuesBeforeCount + i * gapSize + gapsBeforeSize + padding) + ", " + (padding - overlap.top) + ")";
        gapsBeforeSize += d.gapsInsideSize || 0;
        valuesBeforeCount += d.allValuesCount || 0;
        return translate;
      });
      var groupHeight = availableHeight - padding * 2;
      var titleGroups = groupsMerge.selectAll("g.title").attr("transform", function (d, i) {
        return "translate(0, " + 0 + ")";
      });
      var tileRects = titleGroups.selectAll("rect").attr("height", titleRectHeight).attr("width", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellWidth * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0) // .attr("fill", "lightgrey")
      .attr("stroke-width", 0);
      this.setGroupMouseCallbacks(parentGroup, tileRects);
      groupsMerge.selectAll("rect.group-rect").attr("class", function (d) {
        return "group-rect group-rect-" + d.index;
      }).attr("height", groupHeight).attr("width", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellWidth * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0).attr("fill", "white").attr("fill-opacity", 0).attr("stroke-width", 0.5).attr("stroke", "black");
      groupsMerge.each(function (group) {
        self.drawGroupsX.call(self, group, d3.select(this), groupHeight - titleRectHeight);
      });
      groups.exit().remove();
    }
  }, {
    key: "setGroupMouseCallbacks",
    value: function setGroupMouseCallbacks(parentGroup, tileRects) {
      var plot = this.plot;
      var self = this;
      var mouseoverCallbacks = [];
      mouseoverCallbacks.push(function (d) {
        d3.select(this).classed('highlighted', true);
        d3.select(this.parentNode.parentNode).selectAll("rect.group-rect-" + d.index).classed('highlighted', true);
      });
      var mouseoutCallbacks = [];
      mouseoutCallbacks.push(function (d) {
        d3.select(this).classed('highlighted', false);
        d3.select(this.parentNode.parentNode).selectAll("rect.group-rect-" + d.index).classed('highlighted', false);
      });

      if (plot.tooltip) {
        mouseoverCallbacks.push(function (d) {
          var html = parentGroup.label + ": " + d.groupingValue;
          self.showTooltip(html);
        });
        mouseoutCallbacks.push(function (d) {
          self.hideTooltip();
        });
      }

      tileRects.on("mouseover", function (d) {
        var self = this;
        mouseoverCallbacks.forEach(function (callback) {
          callback.call(self, d);
        });
      });
      tileRects.on("mouseout", function (d) {
        var self = this;
        mouseoutCallbacks.forEach(function (callback) {
          callback.call(self, d);
        });
      });
    }
  }, {
    key: "updateCells",
    value: function updateCells() {
      var self = this;
      var plot = self.plot;
      var cellContainerClass = self.prefixClass("cells");
      var gapSize = Heatmap.computeGapSize(0);
      var paddingX = plot.x.groups.childrenList.length ? gapSize / 2 : 0;
      var paddingY = plot.y.groups.childrenList.length ? gapSize / 2 : 0;
      var cellContainer = self.svgG.selectOrAppend("g." + cellContainerClass);
      cellContainer.attr("transform", "translate(" + paddingX + ", " + paddingY + ")");
      var cellClass = self.prefixClass("cell");
      var cellShape = plot.z.shape.type;
      var cells = cellContainer.selectAll("g." + cellClass).data(self.plot.cells);
      var cellEnter = cells.enter().append("g").classed(cellClass, true);
      var cellsMerge = cellEnter.merge(cells);
      cellsMerge.attr("transform", function (c) {
        return "translate(" + (plot.cellWidth * c.col + plot.cellWidth / 2 + c.colVar.group.gapsSize) + "," + (plot.cellHeight * c.row + plot.cellHeight / 2 + c.rowVar.group.gapsSize) + ")";
      });
      var shapes = cellsMerge.selectOrAppend(cellShape + ".cell-shape-" + cellShape);
      shapes.attr("width", plot.z.shape.width).attr("height", plot.z.shape.height).attr("x", -plot.cellWidth / 2).attr("y", -plot.cellHeight / 2);
      shapes.style("fill", function (c) {
        return c.value === undefined ? self.config.color.noDataColor : plot.z.color.scale(c.value);
      });
      shapes.attr("fill-opacity", function (d) {
        return d.value === undefined ? 0 : 1;
      });
      var mouseoverCallbacks = [];
      var mouseoutCallbacks = [];

      if (plot.tooltip) {
        mouseoverCallbacks.push(function (c) {
          var html = c.value === undefined ? self.config.tooltip.noDataText : self.formatValueZ(c.value);
          self.showTooltip(html);
        });
        mouseoutCallbacks.push(function (c) {
          self.hideTooltip();
        });
      }

      if (self.config.highlightLabels) {
        var highlightClass = self.config.cssClassPrefix + "highlight";

        var xLabelClass = function xLabelClass(c) {
          return plot.labelClass + "-x-" + c.col;
        };

        var yLabelClass = function yLabelClass(c) {
          return plot.labelClass + "-y-" + c.row;
        };

        mouseoverCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, true);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, true);
        });
        mouseoutCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, false);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, false);
        });
      }

      cellsMerge.on("mouseover", function (c) {
        mouseoverCallbacks.forEach(function (callback) {
          return callback(c);
        });
      }).on("mouseout", function (c) {
        mouseoutCallbacks.forEach(function (callback) {
          return callback(c);
        });
      });
      cellsMerge.on("click", function (c) {
        self.trigger("cell-selected", c);
      });
      cells.exit().remove();
    }
  }, {
    key: "formatValueX",
    value: function formatValueX(value) {
      if (!this.config.x.formatter) return value;
      return this.config.x.formatter.call(this.config, value);
    }
  }, {
    key: "formatValueY",
    value: function formatValueY(value) {
      if (!this.config.y.formatter) return value;
      return this.config.y.formatter.call(this.config, value);
    }
  }, {
    key: "formatValueZ",
    value: function formatValueZ(value) {
      if (!this.config.z.formatter) return value;
      return this.config.z.formatter.call(this.config, value);
    }
  }, {
    key: "formatLegendValue",
    value: function formatLegendValue(value) {
      if (!this.config.legend.formatter) return value;
      return this.config.legend.formatter.call(this.config, value);
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var self = this;
      var plot = this.plot;
      var legendX = this.plot.width + 10;
      var gapSize = Heatmap.computeGapSize(0);

      if (this.plot.groupByY) {
        legendX += gapSize / 2 + plot.y.overlap.right;
      } else if (this.plot.groupByX) {
        legendX += gapSize;
      }

      var legendY = 0;

      if (this.plot.groupByX || this.plot.groupByY) {
        legendY += gapSize / 2;
      }

      var barWidth = 10;
      var barHeight = this.plot.height - 2;
      var scale = plot.z.color.scale;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY, function (v) {
        return self.formatLegendValue(v);
      }).setRotateLabels(self.config.legend.rotateLabels).linearGradientBar(barWidth, barHeight);
    }
  }], [{
    key: "computeGapSize",
    value: function computeGapSize(gapLevel) {
      return Heatmap.maxGroupGapSize / (gapLevel + 1);
    }
  }, {
    key: "computeGapsSize",
    value: function computeGapsSize(gaps) {
      var gapsSize = 0;
      gaps.forEach(function (gapsNumber, gapsLevel) {
        return gapsSize += gapsNumber * Heatmap.computeGapSize(gapsLevel);
      });
      return gapsSize;
    }
  }]);

  return Heatmap;
}(_chart.Chart);

exports.Heatmap = Heatmap;
Heatmap.maxGroupGapSize = 24;
Heatmap.groupTitleRectHeight = 6;

},{"./chart":32,"./d3":35,"./legend":41,"./utils":48}],39:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Histogram = exports.HistogramConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var HistogramConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(HistogramConfig, _ChartWithColorGroups);

  function HistogramConfig(custom) {
    var _this;

    _classCallCheck(this, HistogramConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HistogramConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'histogram';
    _this.showLegend = true;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return _utils.Utils.isNumber(d) ? d : parseFloat(d[key]);
      },
      // x value accessor
      scale: "linear",
      orient: "bottom",
      ticks: undefined
    };
    _this.y = {
      // Y axis config
      title: '',
      // axis label,
      orient: "left",
      scale: "linear"
    };
    _this.frequency = true;
    _this.groups = {
      key: 1
    };
    _this.transition = true;

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return HistogramConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.HistogramConfig = HistogramConfig;

var Histogram =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(Histogram, _ChartWithColorGroups2);

  function Histogram(placeholderSelector, data, config) {
    _classCallCheck(this, Histogram);

    return _possibleConstructorReturn(this, _getPrototypeOf(Histogram).call(this, placeholderSelector, data, new HistogramConfig(config)));
  }

  _createClass(Histogram, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(Histogram.prototype), "setConfig", this).call(this, new HistogramConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(Histogram.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.plot.bar = {
        color: null //color scale mapping function

      };
      this.computePlotSize();
      this.setupX();
      this.setupHistogram();
      this.setupGroupStacks();
      this.setupY();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.ticks) {
        x.axis.ticks(conf.ticks);
      }

      var data = this.plot.groupedData;
      plot.x.scale.domain([d3.min(data, function (s) {
        return d3.min(s.values, plot.x.value);
      }), d3.max(data, function (s) {
        return d3.max(s.values, plot.x.value);
      })]);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;
      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);
      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
      var data = this.plot.data;
      var yStackMax = d3.max(plot.stackedHistograms, function (layer) {
        return d3.max(layer.histogramBins, function (d) {
          return d.y0 + d.y;
        });
      });
      plot.y.scale.domain([0, yStackMax]);
    }
  }, {
    key: "setupHistogram",
    value: function setupHistogram() {
      var plot = this.plot;
      var x = plot.x;
      var y = plot.y;
      var ticks = this.config.x.ticks ? x.scale.ticks(this.config.x.ticks) : x.scale.ticks();
      plot.histogram = d3.histogram().domain(x.scale.domain()).value(x.value).thresholds(ticks);
    }
  }, {
    key: "setupGroupStacks",
    value: function setupGroupStacks() {
      var _this2 = this;

      var self = this;
      var y0s = [];
      this.plot.groupedData.forEach(function (d) {
        d.histogramBins = _this2.plot.histogram(d.values);
        d.histogramBins.forEach(function (b, i) {
          b.x = b.x0;
          b.dx = b.x1 - b.x0;
          b.y = b.length;
          var prevY0 = y0s[i];
          if (!prevY0) prevY0 = 0;
          b.y0 = prevY0;

          if (!_this2.config.frequency) {
            b.y /= _this2.plot.dataLength;
          }

          y0s[i] = b.y + prevY0;
        });
      });
      var keys = this.plot.groupedData.map(function (d) {
        return d.key;
      }); // console.log(this.plot.groupedData);

      this.plot.stack = d3.stack().keys(keys).value(function (d) {
        return d.histogramBins;
      });
      this.plot.stackedHistograms = this.plot.groupedData;
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawHistogram",
    value: function drawHistogram() {
      var self = this;
      var plot = self.plot;
      var layerClass = this.prefixClass("layer");
      var barClass = this.prefixClass("bar");
      var layer = self.svgG.selectAll("." + layerClass).data(plot.stackedHistograms);
      var layerMerge = layer.enter().append("g").attr("class", layerClass).merge(layer);
      var bar = layerMerge.selectAll("." + barClass).data(function (d) {
        return d.histogramBins;
      });
      var barEnter = bar.enter().append("g");
      barEnter.attr("class", barClass).append("rect").attr("x", 1);
      var barMerge = barEnter.merge(bar);
      var barRect = barMerge.select("rect");
      var barRectT = barRect;
      var barT = barMerge;
      var layerT = layerMerge;

      if (this.transitionEnabled()) {
        barRectT = barRect.transition();
        barT = barMerge.transition();
        layerT = layerMerge.transition();
      }

      barT.attr("transform", function (d) {
        return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0 + d.y) + ")";
      });
      var rectWidth = plot.stackedHistograms.length ? plot.stackedHistograms[0].histogramBins.length ? plot.x.scale(plot.stackedHistograms[0].histogramBins[0].x1) - plot.x.scale(plot.stackedHistograms[0].histogramBins[0].x0) - 1 : 0 : 0;
      barRectT.attr("width", function (d) {
        return Math.max(0, plot.x.scale(d.x1) - plot.x.scale(d.x0) - 1);
      }).attr("height", function (d) {
        return plot.height - plot.y.scale(d.y);
      });

      if (this.plot.color) {
        layerT.attr("fill", this.plot.seriesColor);
      }

      if (plot.tooltip) {
        barMerge.on("mouseover", function (d) {
          self.showTooltip(d.y);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      layer.exit().remove();
      bar.exit().remove();
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(Histogram.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawHistogram();
      return this;
    }
  }]);

  return Histogram;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.Histogram = Histogram;

},{"./chart-with-color-groups":31,"./d3":35,"./utils":48}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ScatterPlot", {
  enumerable: true,
  get: function get() {
    return _scatterplot.ScatterPlot;
  }
});
Object.defineProperty(exports, "ScatterPlotConfig", {
  enumerable: true,
  get: function get() {
    return _scatterplot.ScatterPlotConfig;
  }
});
Object.defineProperty(exports, "ScatterPlotMatrix", {
  enumerable: true,
  get: function get() {
    return _scatterplotMatrix.ScatterPlotMatrix;
  }
});
Object.defineProperty(exports, "ScatterPlotMatrixConfig", {
  enumerable: true,
  get: function get() {
    return _scatterplotMatrix.ScatterPlotMatrixConfig;
  }
});
Object.defineProperty(exports, "Regression", {
  enumerable: true,
  get: function get() {
    return _regression.Regression;
  }
});
Object.defineProperty(exports, "RegressionConfig", {
  enumerable: true,
  get: function get() {
    return _regression.RegressionConfig;
  }
});
Object.defineProperty(exports, "CorrelationMatrix", {
  enumerable: true,
  get: function get() {
    return _correlationMatrix.CorrelationMatrix;
  }
});
Object.defineProperty(exports, "CorrelationMatrixConfig", {
  enumerable: true,
  get: function get() {
    return _correlationMatrix.CorrelationMatrixConfig;
  }
});
Object.defineProperty(exports, "Heatmap", {
  enumerable: true,
  get: function get() {
    return _heatmap.Heatmap;
  }
});
Object.defineProperty(exports, "HeatmapConfig", {
  enumerable: true,
  get: function get() {
    return _heatmap.HeatmapConfig;
  }
});
Object.defineProperty(exports, "HeatmapTimeSeries", {
  enumerable: true,
  get: function get() {
    return _heatmapTimeseries.HeatmapTimeSeries;
  }
});
Object.defineProperty(exports, "HeatmapTimeSeriesConfig", {
  enumerable: true,
  get: function get() {
    return _heatmapTimeseries.HeatmapTimeSeriesConfig;
  }
});
Object.defineProperty(exports, "Histogram", {
  enumerable: true,
  get: function get() {
    return _histogram.Histogram;
  }
});
Object.defineProperty(exports, "HistogramConfig", {
  enumerable: true,
  get: function get() {
    return _histogram.HistogramConfig;
  }
});
Object.defineProperty(exports, "BarChart", {
  enumerable: true,
  get: function get() {
    return _barChart.BarChart;
  }
});
Object.defineProperty(exports, "BarChartConfig", {
  enumerable: true,
  get: function get() {
    return _barChart.BarChartConfig;
  }
});
Object.defineProperty(exports, "BoxPlotBase", {
  enumerable: true,
  get: function get() {
    return _boxPlotBase.BoxPlotBase;
  }
});
Object.defineProperty(exports, "BoxPlotBaseConfig", {
  enumerable: true,
  get: function get() {
    return _boxPlotBase.BoxPlotBaseConfig;
  }
});
Object.defineProperty(exports, "BoxPlot", {
  enumerable: true,
  get: function get() {
    return _boxPlot.BoxPlot;
  }
});
Object.defineProperty(exports, "BoxPlotConfig", {
  enumerable: true,
  get: function get() {
    return _boxPlot.BoxPlotConfig;
  }
});
Object.defineProperty(exports, "DivergingStackedBarChart", {
  enumerable: true,
  get: function get() {
    return _divergingStackedBarChart.DivergingStackedBarChart;
  }
});
Object.defineProperty(exports, "DivergingStackedBarChartConfig", {
  enumerable: true,
  get: function get() {
    return _divergingStackedBarChart.DivergingStackedBarChartConfig;
  }
});
Object.defineProperty(exports, "LineChart", {
  enumerable: true,
  get: function get() {
    return _lineChart.LineChart;
  }
});
Object.defineProperty(exports, "LineChartConfig", {
  enumerable: true,
  get: function get() {
    return _lineChart.LineChartConfig;
  }
});
Object.defineProperty(exports, "StatisticsUtils", {
  enumerable: true,
  get: function get() {
    return _statisticsUtils.StatisticsUtils;
  }
});
Object.defineProperty(exports, "Utils", {
  enumerable: true,
  get: function get() {
    return _utils.Utils;
  }
});
Object.defineProperty(exports, "Legend", {
  enumerable: true,
  get: function get() {
    return _legend.Legend;
  }
});

var _d3Extensions = require("./d3-extensions");

var _scatterplot = require("./scatterplot");

var _scatterplotMatrix = require("./scatterplot-matrix");

var _regression = require("./regression");

var _correlationMatrix = require("./correlation-matrix");

var _heatmap = require("./heatmap");

var _heatmapTimeseries = require("./heatmap-timeseries");

var _histogram = require("./histogram");

var _barChart = require("./bar-chart");

var _boxPlotBase = require("./box-plot-base");

var _boxPlot = require("./box-plot");

var _divergingStackedBarChart = require("./diverging-stacked-bar-chart");

var _lineChart = require("./line-chart");

var _statisticsUtils = require("./statistics-utils");

var _utils = require("./utils");

var _legend = require("./legend");

_d3Extensions.D3Extensions.extend();

},{"./bar-chart":28,"./box-plot":30,"./box-plot-base":29,"./correlation-matrix":33,"./d3-extensions":34,"./diverging-stacked-bar-chart":36,"./heatmap":38,"./heatmap-timeseries":37,"./histogram":39,"./legend":41,"./line-chart":42,"./regression":43,"./scatterplot":45,"./scatterplot-matrix":44,"./statistics-utils":47,"./utils":48}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Legend = void 0;

var _utils = require("./utils");

var _d3SvgLegend = require("d3-svg-legend");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Legend =
/*#__PURE__*/
function () {
  function Legend(svg, legendParent, scale, legendX, legendY, labelFormat) {
    _classCallCheck(this, Legend);

    this.cssClassPrefix = "odc-";
    this.legendClass = this.cssClassPrefix + "legend";
    this.color = _d3SvgLegend.legendColor;
    this.size = _d3SvgLegend.legendSize;
    this.symbol = _d3SvgLegend.legendSymbol;
    this.labelFormat = undefined;
    this.scale = scale;
    this.svg = svg;
    this.guid = _utils.Utils.guid();
    this.container = _utils.Utils.selectOrAppend(legendParent, "g." + this.legendClass, "g").attr("transform", "translate(" + legendX + "," + legendY + ")").classed(this.legendClass, true);
    this.labelFormat = labelFormat;
  }

  _createClass(Legend, [{
    key: "linearGradientBar",
    value: function linearGradientBar(barWidth, barHeight, title) {
      var gradientId = this.cssClassPrefix + "linear-gradient" + "-" + this.guid;
      var scale = this.scale;
      var self = this;
      this.linearGradient = _utils.Utils.linearGradient(this.svg, gradientId, this.scale.range(), 0, 100, 0, 0);
      this.container.selectOrAppend("rect").attr("width", barWidth).attr("height", barHeight).attr("x", 0).attr("y", 0).style("fill", "url(#" + gradientId + ")");
      var ticks = this.container.selectAll("text").data(scale.domain());
      var ticksNumber = scale.domain().length - 1;
      var ticksMerge = ticks.enter().append("text").merge(ticks);
      ticksMerge.attr("x", barWidth).attr("y", function (d, i) {
        return barHeight - i * barHeight / ticksNumber;
      }).attr("dx", 3) // .attr("dy", 1)
      .attr("alignment-baseline", "middle").text(function (d) {
        return self.labelFormat ? self.labelFormat(d) : d;
      });
      ticksMerge.attr("dominant-baseline", "middle");

      if (this.rotateLabels) {
        ticksMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + barWidth + ", " + (barHeight - i * barHeight / ticksNumber) + ")";
        }).attr("text-anchor", "start").attr("dx", 5).attr("dy", 5);
      } else {}

      ticks.exit().remove();
      return this;
    }
  }, {
    key: "setRotateLabels",
    value: function setRotateLabels(rotateLabels) {
      this.rotateLabels = rotateLabels;
      return this;
    }
  }]);

  return Legend;
}();

exports.Legend = Legend;

},{"./utils":48,"d3-svg-legend":4}],42:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineChart = exports.LineChartConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var LineChartConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(LineChartConfig, _ChartWithColorGroups); //show axis guides
  //show tooltip on dot hover


  function LineChartConfig(custom) {
    var _this;

    _classCallCheck(this, LineChartConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineChartConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'line-chart';
    _this.guides = false;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return d[key];
      },
      // x value accessor
      orient: "bottom",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.y = {
      // Y axis config
      title: '',
      // axis label,
      key: 1,
      value: function value(d, key) {
        return d[key];
      },
      // y value accessor
      orient: "left",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.groups = {
      key: 2
    };
    _this.dotRadius = 2;

    _this.dotId = function (d, i) {
      return undefined;
    };

    _this.transition = true;

    _this.onDotHover = function (d, i) {};

    _this.onDotHoverOut = function (d, i) {};

    _this.lineId = function (d, i) {
      return undefined;
    };

    _this.transition = true;

    _this.onLineHover = function (d, i) {};

    _this.onLineHoverOut = function (d, i) {};

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return LineChartConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.LineChartConfig = LineChartConfig;

var LineChart =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(LineChart, _ChartWithColorGroups2);

  function LineChart(placeholderSelector, data, config) {
    _classCallCheck(this, LineChart);

    return _possibleConstructorReturn(this, _getPrototypeOf(LineChart).call(this, placeholderSelector, data, new LineChartConfig(config)));
  }

  _createClass(LineChart, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(LineChart.prototype), "setConfig", this).call(this, new LineChartConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(LineChart.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.computePlotSize();
      this.setupX();
      this.setupY();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);
      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.x.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.x.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.x.scale.domain(domain);

      if (this.config.guides) {
        x.axis.tickSize(-plot.height);
      }
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;
      /*
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       */

      y.value = function (d) {
        return conf.value(d, conf.key);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (this.config.guides) {
        y.axis.tickSize(-plot.width);
      }

      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.y.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.y.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.y.scale.domain(domain); // plot.y.scale.domain([d3.min(data, plot.y.value)-1, d3.max(data, plot.y.value)+1]);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(LineChart.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.updateLines();
    }
  }, {
    key: "updateLines",
    value: function updateLines() {
      var self = this;
      var plot = self.plot;
      var data = plot.data;
      var layerClass = self.prefixClass('layer');
      var lineClass = this.lineClass = self.prefixClass('line');
      self.linesContainerClass = self.prefixClass('lines-container');
      var linesContainer = self.svgG.selectOrAppend("g." + self.linesContainerClass);
      var layer = linesContainer.selectAll("g." + layerClass).data(plot.groupedData);
      var layerEnter = layer.enter().appendSelector("g." + layerClass);
      var linePathEnter = layerEnter.append("path").attr("class", lineClass);
      var layerMerge = layerEnter.merge(layer);
      var linePath = layerMerge.select('.' + lineClass).datum(function (d) {
        return d.values;
      });
      var linePathMerge = linePathEnter.merge(linePath);
      var linePathT = linePathMerge;

      if (self.transitionEnabled()) {
        linePathT = linePathMerge.transition();
      }

      var line = d3.line().x(plot.x.map).y(plot.y.map);
      linePathT.attr("fill", "none") // .attr("stroke", "steelblue")
      .attr("stroke-linejoin", "round").attr("stroke-linecap", "round").attr("stroke-width", 1.5).attr("id", this.config.lineId).attr("d", line); //TODO add tooltip

      linePathMerge.on("mouseover.onLineHover", this.config.onLineHover);
      linePathMerge.on("mouseout.onLineHoverOut", this.config.onLineHoverOut);

      if (plot.seriesColor) {
        layerMerge.style("stroke", plot.seriesColor);
      } else if (plot.color) {
        linePathMerge.style("stroke", plot.color);
      }

      linePath.exit().remove();
      var dotClass = this.dotClass = self.prefixClass('dot');
      var dots = layerMerge.selectAll('.' + dotClass).data(function (d) {
        return d.values;
      });
      var dotsEnter = dots.enter().append("circle").attr("class", dotClass);
      var dotsMerge = dotsEnter.merge(dots);
      var dotsT = dotsMerge;

      if (self.transitionEnabled()) {
        dotsT = dotsMerge.transition();
      }

      dotsT.attr("r", self.config.dotRadius).attr("cx", plot.x.map).attr("cy", plot.y.map).attr("id", this.config.dotId);

      if (plot.tooltip) {
        dotsMerge.on("mouseover", function (d) {
          var html = "(" + plot.x.value(d) + ", " + plot.y.value(d) + ")";
          var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;

          if (group || group === 0) {
            group = plot.groupToLabel[group];
            html += "<br/>";
            var label = self.config.groups.label;

            if (label) {
              html += label + ": ";
            }

            html += group;
          }

          self.showTooltip(html);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      dotsMerge.on("mouseover.onDotHover", this.config.onDotHover);
      dotsMerge.on("mouseout.onDotHoverOut", this.config.onDotHoverOut);

      if (plot.seriesColor) {
        layerMerge.style("fill", plot.seriesColor);
      } else if (plot.color) {
        dotsMerge.style("fill", plot.color);
      }

      dots.exit().remove();
      layer.exit().remove();
    }
  }]);

  return LineChart;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.LineChart = LineChart;

},{"./chart-with-color-groups":31,"./d3":35,"./utils":48}],43:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Regression = exports.RegressionConfig = void 0;

var _chart = require("./chart");

var _scatterplot = require("./scatterplot");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var RegressionConfig =
/*#__PURE__*/
function (_ScatterPlotConfig) {
  _inherits(RegressionConfig, _ScatterPlotConfig);

  function RegressionConfig(custom) {
    var _this;

    _classCallCheck(this, RegressionConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RegressionConfig).call(this));
    _this.mainRegression = true;
    _this.groupRegression = true;
    _this.confidence = {
      level: 0.95,
      criticalValue: function criticalValue(degreesOfFreedom, criticalProbability) {
        return _statisticsUtils.StatisticsUtils.tValue(degreesOfFreedom, criticalProbability);
      },
      marginOfError: undefined,
      //custom  margin Of Error function (x, points)
      areaCurve: d3.curveNatural
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return RegressionConfig;
}(_scatterplot.ScatterPlotConfig);

exports.RegressionConfig = RegressionConfig;

var Regression =
/*#__PURE__*/
function (_ScatterPlot) {
  _inherits(Regression, _ScatterPlot);

  function Regression(placeholderSelector, data, config) {
    _classCallCheck(this, Regression);

    return _possibleConstructorReturn(this, _getPrototypeOf(Regression).call(this, placeholderSelector, data, new RegressionConfig(config)));
  }

  _createClass(Regression, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(Regression.prototype), "setConfig", this).call(this, new RegressionConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(Regression.prototype), "initPlot", this).call(this);

      this.initRegressionLines();
    }
  }, {
    key: "initRegressionLines",
    value: function initRegressionLines() {
      var self = this;
      var groupsAvailable = self.plot.groupingEnabled;
      self.plot.regressions = [];

      if (groupsAvailable && self.config.mainRegression) {
        var regression = this.initRegression(this.plot.data, false);
        self.plot.regressions.push(regression);
      }

      if (self.config.groupRegression) {
        this.initGroupRegression();
      }
    }
  }, {
    key: "initGroupRegression",
    value: function initGroupRegression() {
      var _this2 = this;

      var self = this;
      self.plot.groupedData.forEach(function (group) {
        if (group.values.length < 2) {
          return;
        }

        var regression = _this2.initRegression(group.values, group.key);

        self.plot.regressions.push(regression);
      });
    }
  }, {
    key: "initRegression",
    value: function initRegression(values, groupVal) {
      var self = this;
      var points = values.map(function (d) {
        return [parseFloat(self.plot.x.value(d)), parseFloat(self.plot.y.value(d))];
      }); // points.sort((a,b) => a[0]-b[0]);

      var linearRegression = _statisticsUtils.StatisticsUtils.linearRegression(points);

      var linearRegressionLine = _statisticsUtils.StatisticsUtils.linearRegressionLine(linearRegression);

      var extentX = d3.extent(points, function (d) {
        return d[0];
      });
      var linePoints = [{
        x: extentX[0],
        y: linearRegressionLine(extentX[0])
      }, {
        x: extentX[1],
        y: linearRegressionLine(extentX[1])
      }];
      var line = d3.line().curve(d3.curveBasis).x(function (d) {
        return self.plot.x.scale(d.x);
      }).y(function (d) {
        return self.plot.y.scale(d.y);
      });
      var color = self.plot.color;
      var defaultColor = "black";

      if (_utils.Utils.isFunction(color)) {
        if (values.length && groupVal !== false) {
          if (self.config.series) {
            color = self.plot.colorCategory(groupVal);
          } else {
            color = color(values[0]);
          }
        } else {
          color = defaultColor;
        }
      } else if (!color && groupVal === false) {
        color = defaultColor;
      }

      var confidence = this.computeConfidence(points, extentX, linearRegression, linearRegressionLine);
      return {
        group: groupVal || false,
        line: line,
        linePoints: linePoints,
        color: color,
        confidence: confidence
      };
    }
  }, {
    key: "computeConfidence",
    value: function computeConfidence(points, extentX, linearRegression, linearRegressionLine) {
      var self = this;
      var slope = linearRegression.m;
      var n = points.length;
      var degreesOfFreedom = Math.max(0, n - 2);
      var alpha = 1 - self.config.confidence.level;
      var criticalProbability = 1 - alpha / 2;
      var criticalValue = self.config.confidence.criticalValue(degreesOfFreedom, criticalProbability);
      var xValues = points.map(function (d) {
        return d[0];
      });

      var meanX = _statisticsUtils.StatisticsUtils.mean(xValues);

      var xMySum = 0;
      var xSum = 0;
      var xPowSum = 0;
      var ySum = 0;
      var yPowSum = 0;
      points.forEach(function (p) {
        var x = p[0];
        var y = p[1];
        xMySum += x * y;
        xSum += x;
        ySum += y;
        xPowSum += x * x;
        yPowSum += y * y;
      });
      var a = linearRegression.m;
      var b = linearRegression.b;
      var Sa2 = n / (n + 2) * ((yPowSum - a * xMySum - b * ySum) / (n * xPowSum - xSum * xSum)); //Wariancja współczynnika kierunkowego regresji liniowej a

      var Sy2 = (yPowSum - a * xMySum - b * ySum) / (n * (n - 2)); //Sa2 //Mean y value variance

      var errorFn = function errorFn(x) {
        return Math.sqrt(Sy2 + Math.pow(x - meanX, 2) * Sa2);
      }; //pierwiastek kwadratowy z wariancji dowolnego punktu prostej


      var marginOfError = function marginOfError(x) {
        return criticalValue * errorFn(x);
      }; // console.log('n', n, 'degreesOfFreedom', degreesOfFreedom, 'criticalProbability',criticalProbability);
      // var confidenceDown = x => linearRegressionLine(x) -  marginOfError(x);
      // var confidenceUp = x => linearRegressionLine(x) +  marginOfError(x);


      var computeConfidenceAreaPoint = function computeConfidenceAreaPoint(x) {
        var linearRegression = linearRegressionLine(x);
        var moe = marginOfError(x);
        var confDown = linearRegression - moe;
        var confUp = linearRegression + moe;
        return {
          x: x,
          y0: confDown,
          y1: confUp
        };
      };

      var centerX = (extentX[1] + extentX[0]) / 2; // var confidenceAreaPoints = [extentX[0], centerX,  extentX[1]].map(computeConfidenceAreaPoint);

      var confidenceAreaPoints = [extentX[0], centerX, extentX[1]].map(computeConfidenceAreaPoint);

      var fitInPlot = function fitInPlot(y) {
        return y;
      };

      var confidenceArea = d3.area().curve(self.config.confidence.areaCurve).x(function (d) {
        return self.plot.x.scale(d.x);
      }).y0(function (d) {
        return fitInPlot(self.plot.y.scale(d.y0));
      }).y1(function (d) {
        return fitInPlot(self.plot.y.scale(d.y1));
      });
      return {
        area: confidenceArea,
        points: confidenceAreaPoints
      };
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(Regression.prototype), "update", this).call(this, newData);

      this.updateRegressionLines();
    }
  }, {
    key: "updateRegressionLines",
    value: function updateRegressionLines() {
      var self = this;
      var regressionContainerClass = this.prefixClass("regression-container");
      var regressionContainerSelector = "g." + regressionContainerClass;
      var clipPathId = self.prefixClass("clip");
      var regressionContainer = self.svgG.selectOrInsert(regressionContainerSelector, "." + self.dotsContainerClass);
      var regressionContainerClip = regressionContainer.selectOrAppend("clipPath").attr("id", clipPathId);
      regressionContainerClip.selectOrAppend('rect').attr('width', self.plot.width).attr('height', self.plot.height).attr('x', 0).attr('y', 0);
      regressionContainer.attr("clip-path", function (d, i) {
        return "url(#" + clipPathId + ")";
      });
      var regressionClass = this.prefixClass("regression");
      var confidenceAreaClass = self.prefixClass("confidence");
      var regressionSelector = "g." + regressionClass;
      var regression = regressionContainer.selectAll(regressionSelector).data(self.plot.regressions, function (d, i) {
        return d.group;
      });
      var regressionEnter = regression.enter().appendSelector(regressionSelector);
      var regressionMerge = regressionEnter.merge(regression);
      var lineClass = self.prefixClass("line");
      regressionEnter.append("path").attr("class", lineClass).attr("shape-rendering", "optimizeQuality");
      var line = regressionMerge.select("path." + lineClass).style("stroke", function (r) {
        return r.color;
      });
      var lineT = line;

      if (self.transitionEnabled()) {
        lineT = line.transition();
      }

      lineT.attr("d", function (r) {
        return r.line(r.linePoints);
      });
      regressionEnter.append("path").attr("class", confidenceAreaClass).attr("shape-rendering", "optimizeQuality").style("opacity", "0.4");
      var area = regressionMerge.select("path." + confidenceAreaClass);
      var areaT = area;

      if (self.transitionEnabled()) {
        areaT = area.transition();
      }

      areaT.attr("d", function (r) {
        return r.confidence.area(r.confidence.points);
      });
      areaT.style("fill", function (r) {
        return r.color;
      });
      regression.exit().remove();
    }
  }]);

  return Regression;
}(_scatterplot.ScatterPlot);

exports.Regression = Regression;

},{"./chart":32,"./d3":35,"./scatterplot":45,"./statistics-utils":47,"./utils":48}],44:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScatterPlotMatrix = exports.ScatterPlotMatrixConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _scatterplot = require("./scatterplot");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var ScatterPlotMatrixConfig =
/*#__PURE__*/
function (_ScatterPlotConfig) {
  _inherits(ScatterPlotMatrixConfig, _ScatterPlotConfig); //scatter plot cell size
  //scatter plot cell padding
  //show axis guides
  //show tooltip on dot hover
  //ticks number, (default: computed using cell size)


  function ScatterPlotMatrixConfig(custom) {
    var _this;

    _classCallCheck(this, ScatterPlotMatrixConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlotMatrixConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'scatterplot-matrix';
    _this.size = undefined;
    _this.minCellSize = 50;
    _this.maxCellSize = 1000;
    _this.padding = 20;
    _this.brush = true;
    _this.guides = true;
    _this.showTooltip = true;
    _this.ticks = undefined;
    _this.x = {
      // X axis config
      orient: "bottom",
      scale: "linear"
    };
    _this.y = {
      // Y axis config
      orient: "left",
      scale: "linear"
    };
    _this.groups = {
      key: undefined,
      //object property name or array index with grouping variable
      includeInPlot: false //include group as variable in plot, boolean (default: false)

    };
    _this.variables = {
      labels: [],
      //optional array of variable labels (for the diagonal of the plot).
      keys: [],
      //optional array of variable keys
      value: function value(d, variableKey) {
        return d[variableKey];
      } // variable value accessor

    };

    _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);

    return _this;
  }

  return ScatterPlotMatrixConfig;
}(_scatterplot.ScatterPlotConfig);

exports.ScatterPlotMatrixConfig = ScatterPlotMatrixConfig;

var ScatterPlotMatrix =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(ScatterPlotMatrix, _ChartWithColorGroups);

  function ScatterPlotMatrix(placeholderSelector, data, config) {
    _classCallCheck(this, ScatterPlotMatrix);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlotMatrix).call(this, placeholderSelector, data, new ScatterPlotMatrixConfig(config)));
  }

  _createClass(ScatterPlotMatrix, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(ScatterPlotMatrix.prototype), "setConfig", this).call(this, new ScatterPlotMatrixConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(ScatterPlotMatrix.prototype), "initPlot", this).call(this);

      var self = this;
      var margin = this.plot.margin;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.plot.dot = {
        color: null //color scale mapping function

      };
      this.setupVariables();
      this.plot.size = conf.size;
      var width = conf.width;

      var availableWidth = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), margin);

      var availableHeight = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), margin);

      if (!width) {
        if (!this.plot.size) {
          this.plot.size = Math.min(conf.maxCellSize, Math.max(conf.minCellSize, availableWidth / this.plot.variables.length));
        }

        width = margin.left + margin.right + this.plot.variables.length * this.plot.size;
      }

      if (!this.plot.size) {
        this.plot.size = (width - (margin.left + margin.right)) / this.plot.variables.length;
      }

      var height = width;

      if (!height) {
        height = availableHeight;
      }

      this.plot.width = width - margin.left - margin.right;
      this.plot.height = height - margin.top - margin.bottom;
      this.plot.ticks = conf.ticks;

      if (this.plot.ticks === undefined) {
        this.plot.ticks = this.plot.size / 40;
      }

      this.setupX();
      this.setupY();
      return this;
    }
  }, {
    key: "setupVariables",
    value: function setupVariables() {
      var variablesConf = this.config.variables;
      var data = this.plot.groupedData;
      var plot = this.plot;
      plot.domainByVariable = {};
      plot.variables = variablesConf.keys;

      if (!plot.variables || !plot.variables.length) {
        plot.variables = data.length ? _utils.Utils.inferVariables(data[0].values, this.config.groups.key, this.config.includeInPlot) : [];
      }

      plot.labels = [];
      plot.labelByVariable = {};
      plot.variables.forEach(function (variableKey, index) {
        var min = d3.min(data, function (s) {
          return d3.min(s.values, function (d) {
            return variablesConf.value(d, variableKey);
          });
        });
        var max = d3.max(data, function (s) {
          return d3.max(s.values, function (d) {
            return variablesConf.value(d, variableKey);
          });
        });
        plot.domainByVariable[variableKey] = [min, max];
        var label = variableKey;

        if (variablesConf.labels && variablesConf.labels.length > index) {
          label = variablesConf.labels[index];
        }

        plot.labels.push(label);
        plot.labelByVariable[variableKey] = label;
      });
      plot.subplots = [];
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config;
      x.value = conf.variables.value;
      x.scale = _utils.Utils.createScale(conf.x.scale).range([conf.padding / 2, plot.size - conf.padding / 2]);

      x.map = function (d, variable) {
        return x.scale(x.value(d, variable));
      };

      x.axis = _utils.Utils.createAxis(conf.x.orient, x.scale).ticks(plot.ticks);
      x.axis.tickSize(plot.size * plot.variables.length);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config;
      y.value = conf.variables.value;
      y.scale = _utils.Utils.createScale(conf.y.scale).range([plot.size - conf.padding / 2, conf.padding / 2]);

      y.map = function (d, variable) {
        return y.scale(y.value(d, variable));
      };

      y.axis = _utils.Utils.createAxis(conf.y.orient, y.scale).ticks(plot.ticks);
      y.axis.tickSize(-plot.size * plot.variables.length);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(ScatterPlotMatrix.prototype), "update", this).call(this, newData);

      var self = this;
      var n = self.plot.variables.length;
      var conf = this.config;
      var axisClass = self.prefixClass("axis");
      var axisXClass = axisClass + "-x";
      var axisYClass = axisClass + "-y";
      var xAxisSelector = "g." + axisXClass + "." + axisClass;
      var yAxisSelector = "g." + axisYClass + "." + axisClass;
      var noGuidesClass = self.prefixClass("no-guides");
      var xAxis = self.svgG.selectAll(xAxisSelector).data(self.plot.variables);
      var xAxisMerge = xAxis.enter().appendSelector(xAxisSelector).classed(noGuidesClass, !conf.guides).merge(xAxis);
      xAxisMerge.attr("transform", function (d, i) {
        return "translate(" + (n - i - 1) * self.plot.size + ",0)";
      }).each(function (d) {
        self.plot.x.scale.domain(self.plot.domainByVariable[d]);
        var axis = d3.select(this);

        if (self.transitionEnabled()) {
          axis = axis.transition();
        }

        axis.call(self.plot.x.axis);
      });
      xAxis.exit().remove();
      var yAxis = self.svgG.selectAll(yAxisSelector).data(self.plot.variables);
      var yAxisMerge = yAxis.enter().appendSelector(yAxisSelector).merge(yAxis);
      yAxisMerge.classed(noGuidesClass, !conf.guides).attr("transform", function (d, i) {
        return "translate(0," + i * self.plot.size + ")";
      });
      yAxisMerge.each(function (d) {
        self.plot.y.scale.domain(self.plot.domainByVariable[d]);
        var axis = d3.select(this);

        if (self.transitionEnabled()) {
          axis = axis.transition();
        }

        axis.call(self.plot.y.axis);
      });
      yAxis.exit().remove();
      var cellClass = self.prefixClass("cell");
      var cell = self.svgG.selectAll("." + cellClass).data(self.utils.cross(self.plot.variables, self.plot.variables));
      var cellEnter = cell.enter().appendSelector("g." + cellClass);
      cellEnter.filter(function (d) {
        return d.i === d.j;
      }).append("text");
      var cellMerge = cellEnter.merge(cell);
      cellMerge.attr("transform", function (d) {
        return "translate(" + (n - d.i - 1) * self.plot.size + "," + d.j * self.plot.size + ")";
      });

      if (conf.brush) {
        this.drawBrush(cellMerge);
      }

      cellMerge.each(plotSubplot); //Labels

      cellMerge.select("text").attr("x", conf.padding).attr("y", conf.padding).attr("dy", ".71em").text(function (d) {
        return self.plot.labelByVariable[d.x];
      });
      cell.exit().remove();

      function plotSubplot(p) {
        var plot = self.plot;
        plot.subplots.push(p);
        var cell = d3.select(this);
        plot.x.scale.domain(plot.domainByVariable[p.x]);
        plot.y.scale.domain(plot.domainByVariable[p.y]);
        var frameClass = self.prefixClass("frame");
        cell.selectOrAppend("rect." + frameClass).attr("class", frameClass).attr("x", conf.padding / 2).attr("y", conf.padding / 2).attr("width", plot.size - conf.padding).attr("height", plot.size - conf.padding);

        p.update = function () {
          var subplot = this;
          var layerClass = self.prefixClass('layer');
          var layer = cell.selectAll("g." + layerClass).data(self.plot.groupedData);
          var layerMerge = layer.enter().appendSelector("g." + layerClass).merge(layer);
          var dots = layerMerge.selectAll("circle").data(function (d) {
            return d.values;
          });
          var dotsMerge = dots.enter().append("circle").merge(dots);
          var dotsT = dotsMerge;

          if (self.transitionEnabled()) {
            dotsT = dotsMerge.transition();
          }

          dotsT.attr("cx", function (d) {
            return plot.x.map(d, subplot.x);
          }).attr("cy", function (d) {
            return plot.y.map(d, subplot.y);
          }).attr("r", self.config.dotRadius);

          if (plot.seriesColor) {
            layerMerge.style("fill", plot.seriesColor);
          } else if (plot.color) {
            dotsMerge.style("fill", plot.color);
          }

          if (plot.tooltip) {
            dotsMerge.on("mouseover", function (d) {
              var html = "(" + plot.x.value(d, subplot.x) + ", " + plot.y.value(d, subplot.y) + ")";
              var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;

              if (group || group === 0) {
                group = plot.groupToLabel[group];
                html += "<br/>";
                var label = self.config.groups.label;

                if (label) {
                  html += label + ": ";
                }

                html += group;
              }

              self.showTooltip(html);
            }).on("mouseout", function (d) {
              self.hideTooltip();
            });
          }

          dots.exit().remove();
          layer.exit().remove();
        };

        p.update();
      }
    }
  }, {
    key: "drawBrush",
    value: function drawBrush(cell) {
      var self = this;
      var hiddenClass = self.plot.hiddenClass = self.prefixClass("hidden");
      var brush = d3.brush() // .x(self.plot.x.scale)
      // .y(self.plot.y.scale)
      .on("start", brushstart).on("brush", brushmove).on("end", brushend);
      brush.extent([[0, 0], [self.plot.size, self.plot.size]]);
      cell.selectOrAppend("g.brush-container").call(brush);
      self.clearBrush(); // Clear the previously-active brush, if any.

      function brushstart(p) {
        if (self.plot.brushCell !== this) {
          self.clearBrush();
          self.plot.x.scale.domain(self.plot.domainByVariable[p.x]);
          self.plot.y.scale.domain(self.plot.domainByVariable[p.y]);
          self.plot.brushCell = this;
          self.plot.brush = brush;
        }
      } // Highlight the selected circles.


      function brushmove(p) {
        var s = d3.event.selection;
        if (!s) return;
        var e = s.map(function (_) {
          return [self.plot.x.scale.invert(_[0]), self.plot.y.scale.invert(_[1])];
        }); // console.log(e);

        self.svgG.selectAll("circle").classed(hiddenClass, function (d) {
          var x = parseFloat(d[p.x]),
              y = parseFloat(d[p.y]);
          return e[0][0] > x || x > e[1][0] || e[1][1] > y || y > e[0][1];
        });
      } // If the brush is empty, select all circles.


      function brushend() {
        if (!d3.event.selection) self.svgG.selectAll("." + hiddenClass).classed(hiddenClass, false);
      }
    }
  }, {
    key: "clearBrush",
    value: function clearBrush() {
      var self = this;

      if (!self.plot.brushCell) {
        return;
      }

      self.plot.brush.move(d3.select(self.plot.brushCell), null);
      self.svgG.selectAll("." + self.plot.hiddenClass).classed(self.plot.hiddenClass, false);
      self.plot.brushCell = null;
    }
  }]);

  return ScatterPlotMatrix;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.ScatterPlotMatrix = ScatterPlotMatrix;

},{"./chart-with-color-groups":31,"./d3":35,"./legend":41,"./scatterplot":45,"./utils":48}],45:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScatterPlot = exports.ScatterPlotConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var ScatterPlotConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(ScatterPlotConfig, _ChartWithColorGroups); //show axis guides
  //show tooltip on dot hover


  function ScatterPlotConfig(custom) {
    var _this;

    _classCallCheck(this, ScatterPlotConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlotConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'scatterplot';
    _this.guides = false;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return d[key];
      },
      // x value accessor
      orient: "bottom",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.y = {
      // Y axis config
      title: '',
      // axis label,
      key: 1,
      value: function value(d, key) {
        return d[key];
      },
      // y value accessor
      orient: "left",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.groups = {
      key: 2
    };
    _this.dotRadius = 2;

    _this.dotId = function (d, i) {
      return undefined;
    };

    _this.transition = true;

    _this.onDotHover = function (d, i) {};

    _this.onDotHoverOut = function (d, i) {};

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_this), custom);
    }

    return _this;
  }

  return ScatterPlotConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.ScatterPlotConfig = ScatterPlotConfig;

var ScatterPlot =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(ScatterPlot, _ChartWithColorGroups2);

  function ScatterPlot(placeholderSelector, data, config) {
    _classCallCheck(this, ScatterPlot);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlot).call(this, placeholderSelector, data, new ScatterPlotConfig(config)));
  }

  _createClass(ScatterPlot, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(ScatterPlot.prototype), "setConfig", this).call(this, new ScatterPlotConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(ScatterPlot.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.computePlotSize();
      this.setupX();
      this.setupY();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);
      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.x.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.x.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.x.scale.domain(domain);

      if (this.config.guides) {
        x.axis.tickSize(-plot.height);
      }
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;
      /*
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       */

      y.value = function (d) {
        return conf.value(d, conf.key);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (this.config.guides) {
        y.axis.tickSize(-plot.width);
      }

      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.y.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.y.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.y.scale.domain(domain); // plot.y.scale.domain([d3.min(data, plot.y.value)-1, d3.max(data, plot.y.value)+1]);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(ScatterPlot.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.updateDots();
    }
  }, {
    key: "updateDots",
    value: function updateDots() {
      var self = this;
      var plot = self.plot;
      var data = plot.data;
      var layerClass = self.prefixClass('layer');
      var dotClass = this.dotClass = self.prefixClass('dot');
      self.dotsContainerClass = self.prefixClass('dots-container');
      var dotsContainer = self.svgG.selectOrAppend("g." + self.dotsContainerClass);
      var layer = dotsContainer.selectAll("g." + layerClass).data(plot.groupedData);
      var layerEnter = layer.enter().appendSelector("g." + layerClass);
      var layerMerge = layerEnter.merge(layer);
      var dots = layerMerge.selectAll('.' + dotClass).data(function (d) {
        return d.values;
      });
      var dotsEnter = dots.enter().append("circle").attr("class", dotClass);
      var dotsMerge = dotsEnter.merge(dots);
      var dotsT = dotsMerge;

      if (self.transitionEnabled()) {
        dotsT = dotsMerge.transition();
      }

      dotsT.attr("r", self.config.dotRadius).attr("cx", plot.x.map).attr("cy", plot.y.map).attr("id", this.config.dotId);

      if (plot.tooltip) {
        dotsMerge.on("mouseover", function (d) {
          var html = "(" + plot.x.value(d) + ", " + plot.y.value(d) + ")";
          var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;

          if (group || group === 0) {
            group = plot.groupToLabel[group];
            html += "<br/>";
            var label = self.config.groups.label;

            if (label) {
              html += label + ": ";
            }

            html += group;
          }

          self.showTooltip(html);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      dotsMerge.on("mouseover.onDotHover", this.config.onDotHover);
      dotsMerge.on("mouseout.onDotHoverOut", this.config.onDotHoverOut);

      if (plot.seriesColor) {
        layerMerge.style("fill", plot.seriesColor);
      } else if (plot.color) {
        dotsMerge.style("fill", plot.color);
      }

      dots.exit().remove();
      layer.exit().remove();
    }
  }]);

  return ScatterPlot;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.ScatterPlot = ScatterPlot;

},{"./chart-with-color-groups":31,"./d3":35,"./utils":48}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tdistr = tdistr;
/*
 * https://gist.github.com/benrasmusen/1261977
 * NAME
 * 
 * statistics-distributions.js - JavaScript library for calculating
 *   critical values and upper probabilities of common statistical
 *   distributions
 * 
 * SYNOPSIS
 * 
 * 
 *   // Chi-squared-crit (2 degrees of freedom, 95th percentile = 0.05 level
 *   chisqrdistr(2, .05)
 *   
 *   // u-crit (95th percentile = 0.05 level)
 *   udistr(.05);
 *   
 *   // t-crit (1 degree of freedom, 99.5th percentile = 0.005 level) 
 *   tdistr(1,.005);
 *   
 *   // F-crit (1 degree of freedom in numerator, 3 degrees of freedom 
 *   //         in denominator, 99th percentile = 0.01 level)
 *   fdistr(1,3,.01);
 *   
 *   // upper probability of the u distribution (u = -0.85): Q(u) = 1-G(u)
 *   uprob(-0.85);
 *   
 *   // upper probability of the chi-square distribution
 *   // (3 degrees of freedom, chi-squared = 6.25): Q = 1-G
 *   chisqrprob(3,6.25);
 *   
 *   // upper probability of the t distribution
 *   // (3 degrees of freedom, t = 6.251): Q = 1-G
 *   tprob(3,6.251);
 *   
 *   // upper probability of the F distribution
 *   // (3 degrees of freedom in numerator, 5 degrees of freedom in
 *   //  denominator, F = 6.25): Q = 1-G
 *   fprob(3,5,.625);
 * 
 * 
 *  DESCRIPTION
 * 
 * This library calculates percentage points (5 significant digits) of the u
 * (standard normal) distribution, the student's t distribution, the
 * chi-square distribution and the F distribution. It can also calculate the
 * upper probability (5 significant digits) of the u (standard normal), the
 * chi-square, the t and the F distribution.
 * 
 * These critical values are needed to perform statistical tests, like the u
 * test, the t test, the F test and the chi-squared test, and to calculate
 * confidence intervals.
 * 
 * If you are interested in more precise algorithms you could look at:
 *   StatLib: http://lib.stat.cmu.edu/apstat/ ; 
 *   Applied Statistics Algorithms by Griffiths, P. and Hill, I.D.
 *   , Ellis Horwood: Chichester (1985)
 * 
 * BUGS 
 * 
 * This port was produced from the Perl module Statistics::Distributions
 * that has had no bug reports in several years.  If you find a bug then
 * please double-check that JavaScript does not thing the numbers you are
 * passing in are strings.  (You can subtract 0 from them as you pass them
 * in so that "5" is properly understood to be 5.)  If you have passed in a
 * number then please contact the author
 * 
 * AUTHOR
 * 
 * Ben Tilly <btilly@gmail.com>
 * 
 * Originl Perl version by Michael Kospach <mike.perl@gmx.at>
 * 
 * Nice formating, simplification and bug repair by Matthias Trautner Kromann
 * <mtk@id.cbs.dk>
 * 
 * COPYRIGHT 
 * 
 * Copyright 2008 Ben Tilly.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the same terms as Perl itself.  This means under either the Perl
 * Artistic License or the GPL v1 or later.
 */

var SIGNIFICANT = 5; // number of significant digits to be returned

function chisqrdistr($n, $p) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* degree of freedom */
  }

  if ($p <= 0 || $p > 1) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subchisqr($n - 0, $p - 0));
}

function udistr($p) {
  if ($p > 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subu($p - 0));
}

function tdistr($n, $p) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
  }

  if ($p <= 0 || $p >= 1) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subt($n - 0, $p - 0));
}

function fdistr($n, $m, $p) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* first degree of freedom */
  }

  if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {
    throw "Invalid m: $m\n";
    /* second degree of freedom */
  }

  if ($p <= 0 || $p > 1) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subf($n - 0, $m - 0, $p - 0));
}

function uprob($x) {
  return precision_string(_subuprob($x - 0));
}

function chisqrprob($n, $x) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* degree of freedom */
  }

  return precision_string(_subchisqrprob($n - 0, $x - 0));
}

function tprob($n, $x) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* degree of freedom */
  }

  return precision_string(_subtprob($n - 0, $x - 0));
}

function fprob($n, $m, $x) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* first degree of freedom */
  }

  if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {
    throw "Invalid m: $m\n";
    /* second degree of freedom */
  }

  return precision_string(_subfprob($n - 0, $m - 0, $x - 0));
}

function _subfprob($n, $m, $x) {
  var $p;

  if ($x <= 0) {
    $p = 1;
  } else if ($m % 2 == 0) {
    var $z = $m / ($m + $n * $x);
    var $a = 1;

    for (var $i = $m - 2; $i >= 2; $i -= 2) {
      $a = 1 + ($n + $i - 2) / $i * $z * $a;
    }

    $p = 1 - Math.pow(1 - $z, $n / 2 * $a);
  } else if ($n % 2 == 0) {
    var $z = $n * $x / ($m + $n * $x);
    var $a = 1;

    for (var $i = $n - 2; $i >= 2; $i -= 2) {
      $a = 1 + ($m + $i - 2) / $i * $z * $a;
    }

    $p = Math.pow(1 - $z, $m / 2) * $a;
  } else {
    var $y = Math.atan2(Math.sqrt($n * $x / $m), 1);
    var $z = Math.pow(Math.sin($y), 2);
    var $a = $n == 1 ? 0 : 1;

    for (var $i = $n - 2; $i >= 3; $i -= 2) {
      $a = 1 + ($m + $i - 2) / $i * $z * $a;
    }

    var $b = Math.PI;

    for (var $i = 2; $i <= $m - 1; $i += 2) {
      $b *= ($i - 1) / $i;
    }

    var $p1 = 2 / $b * Math.sin($y) * Math.pow(Math.cos($y), $m) * $a;
    $z = Math.pow(Math.cos($y), 2);
    $a = $m == 1 ? 0 : 1;

    for (var $i = $m - 2; $i >= 3; $i -= 2) {
      $a = 1 + ($i - 1) / $i * $z * $a;
    }

    $p = max(0, $p1 + 1 - 2 * $y / Math.PI - 2 / Math.PI * Math.sin($y) * Math.cos($y) * $a);
  }

  return $p;
}

function _subchisqrprob($n, $x) {
  var $p;

  if ($x <= 0) {
    $p = 1;
  } else if ($n > 100) {
    $p = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));
  } else if ($x > 400) {
    $p = 0;
  } else {
    var $a;
    var $i;
    var $i1;

    if ($n % 2 != 0) {
      $p = 2 * _subuprob(Math.sqrt($x));
      $a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);
      $i1 = 1;
    } else {
      $p = $a = Math.exp(-$x / 2);
      $i1 = 2;
    }

    for ($i = $i1; $i <= $n - 2; $i += 2) {
      $a *= $x / $i;
      $p += $a;
    }
  }

  return $p;
}

function _subu($p) {
  var $y = -Math.log(4 * $p * (1 - $p));
  var $x = Math.sqrt($y * (1.570796288 + $y * (.03706987906 + $y * (-.8364353589E-3 + $y * (-.2250947176E-3 + $y * (.6841218299E-5 + $y * (0.5824238515E-5 + $y * (-.104527497E-5 + $y * (.8360937017E-7 + $y * (-.3231081277E-8 + $y * (.3657763036E-10 + $y * .6936233982E-12)))))))))));
  if ($p > .5) $x = -$x;
  return $x;
}

function _subuprob($x) {
  var $p = 0;
  /* if ($absx > 100) */

  var $absx = Math.abs($x);

  if ($absx < 1.9) {
    $p = Math.pow(1 + $absx * (.049867347 + $absx * (.0211410061 + $absx * (.0032776263 + $absx * (.0000380036 + $absx * (.0000488906 + $absx * .000005383))))), -16) / 2;
  } else if ($absx <= 100) {
    for (var $i = 18; $i >= 1; $i--) {
      $p = $i / ($absx + $p);
    }

    $p = Math.exp(-.5 * $absx * $absx) / Math.sqrt(2 * Math.PI) / ($absx + $p);
  }

  if ($x < 0) $p = 1 - $p;
  return $p;
}

function _subt($n, $p) {
  if ($p >= 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  }

  if ($p == 0.5) {
    return 0;
  } else if ($p < 0.5) {
    return -_subt($n, 1 - $p);
  }

  var $u = _subu($p);

  var $u2 = Math.pow($u, 2);
  var $a = ($u2 + 1) / 4;
  var $b = ((5 * $u2 + 16) * $u2 + 3) / 96;
  var $c = (((3 * $u2 + 19) * $u2 + 17) * $u2 - 15) / 384;
  var $d = ((((79 * $u2 + 776) * $u2 + 1482) * $u2 - 1920) * $u2 - 945) / 92160;
  var $e = (((((27 * $u2 + 339) * $u2 + 930) * $u2 - 1782) * $u2 - 765) * $u2 + 17955) / 368640;
  var $x = $u * (1 + ($a + ($b + ($c + ($d + $e / $n) / $n) / $n) / $n) / $n);

  if ($n <= Math.pow(log10($p), 2) + 3) {
    var $round;

    do {
      var $p1 = _subtprob($n, $x);

      var $n1 = $n + 1;
      var $delta = ($p1 - $p) / Math.exp(($n1 * Math.log($n1 / ($n + $x * $x)) + Math.log($n / $n1 / 2 / Math.PI) - 1 + (1 / $n1 - 1 / $n) / 6) / 2);
      $x += $delta;
      $round = round_to_precision($delta, Math.abs(integer(log10(Math.abs($x)) - 4)));
    } while ($x && $round != 0);
  }

  return $x;
}

function _subtprob($n, $x) {
  var $a;
  var $b;
  var $w = Math.atan2($x / Math.sqrt($n), 1);
  var $z = Math.pow(Math.cos($w), 2);
  var $y = 1;

  for (var $i = $n - 2; $i >= 2; $i -= 2) {
    $y = 1 + ($i - 1) / $i * $z * $y;
  }

  if ($n % 2 == 0) {
    $a = Math.sin($w) / 2;
    $b = .5;
  } else {
    $a = $n == 1 ? 0 : Math.sin($w) * Math.cos($w) / Math.PI;
    $b = .5 + $w / Math.PI;
  }

  return max(0, 1 - $b - $a * $y);
}

function _subf($n, $m, $p) {
  var $x;

  if ($p >= 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  }

  if ($p == 1) {
    $x = 0;
  } else if ($m == 1) {
    $x = 1 / Math.pow(_subt($n, 0.5 - $p / 2), 2);
  } else if ($n == 1) {
    $x = Math.pow(_subt($m, $p / 2), 2);
  } else if ($m == 2) {
    var $u = _subchisqr($m, 1 - $p);

    var $a = $m - 2;
    $x = 1 / ($u / $m * (1 + (($u - $a) / 2 + (((4 * $u - 11 * $a) * $u + $a * (7 * $m - 10)) / 24 + (((2 * $u - 10 * $a) * $u + $a * (17 * $m - 26)) * $u - $a * $a * (9 * $m - 6)) / 48 / $n) / $n) / $n));
  } else if ($n > $m) {
    $x = 1 / _subf2($m, $n, 1 - $p);
  } else {
    $x = _subf2($n, $m, $p);
  }

  return $x;
}

function _subf2($n, $m, $p) {
  var $u = _subchisqr($n, $p);

  var $n2 = $n - 2;
  var $x = $u / $n * (1 + (($u - $n2) / 2 + (((4 * $u - 11 * $n2) * $u + $n2 * (7 * $n - 10)) / 24 + (((2 * $u - 10 * $n2) * $u + $n2 * (17 * $n - 26)) * $u - $n2 * $n2 * (9 * $n - 6)) / 48 / $m) / $m) / $m);
  var $delta;

  do {
    var $z = Math.exp((($n + $m) * Math.log(($n + $m) / ($n * $x + $m)) + ($n - 2) * Math.log($x) + Math.log($n * $m / ($n + $m)) - Math.log(4 * Math.PI) - (1 / $n + 1 / $m - 1 / ($n + $m)) / 6) / 2);
    $delta = (_subfprob($n, $m, $x) - $p) / $z;
    $x += $delta;
  } while (Math.abs($delta) > 3e-4);

  return $x;
}

function _subchisqr($n, $p) {
  var $x;

  if ($p > 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  } else if ($p == 1) {
    $x = 0;
  } else if ($n == 1) {
    $x = Math.pow(_subu($p / 2), 2);
  } else if ($n == 2) {
    $x = -2 * Math.log($p);
  } else {
    var $u = _subu($p);

    var $u2 = $u * $u;
    $x = max(0, $n + Math.sqrt(2 * $n) * $u + 2 / 3 * ($u2 - 1) + $u * ($u2 - 7) / 9 / Math.sqrt(2 * $n) - 2 / 405 / $n * ($u2 * (3 * $u2 + 7) - 16));

    if ($n <= 100) {
      var $x0;
      var $p1;
      var $z;

      do {
        $x0 = $x;

        if ($x < 0) {
          $p1 = 1;
        } else if ($n > 100) {
          $p1 = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));
        } else if ($x > 400) {
          $p1 = 0;
        } else {
          var $i0;
          var $a;

          if ($n % 2 != 0) {
            $p1 = 2 * _subuprob(Math.sqrt($x));
            $a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);
            $i0 = 1;
          } else {
            $p1 = $a = Math.exp(-$x / 2);
            $i0 = 2;
          }

          for (var $i = $i0; $i <= $n - 2; $i += 2) {
            $a *= $x / $i;
            $p1 += $a;
          }
        }

        $z = Math.exp((($n - 1) * Math.log($x / $n) - Math.log(4 * Math.PI * $x) + $n - $x - 1 / $n / 6) / 2);
        $x += ($p1 - $p) / $z;
        $x = round_to_precision($x, 5);
      } while ($n < 31 && Math.abs($x0 - $x) > 1e-4);
    }
  }

  return $x;
}

function log10($n) {
  return Math.log($n) / Math.log(10);
}

function max() {
  var $max = arguments[0];

  for (var $i = 0; i < arguments.length; i++) {
    if ($max < arguments[$i]) $max = arguments[$i];
  }

  return $max;
}

function min() {
  var $min = arguments[0];

  for (var $i = 0; i < arguments.length; i++) {
    if ($min > arguments[$i]) $min = arguments[$i];
  }

  return $min;
}

function precision($x) {
  return Math.abs(integer(log10(Math.abs($x)) - SIGNIFICANT));
}

function precision_string($x) {
  if ($x) {
    return round_to_precision($x, precision($x));
  } else {
    return "0";
  }
}

function round_to_precision($x, $p) {
  $x = $x * Math.pow(10, $p);
  $x = Math.round($x);
  return $x / Math.pow(10, $p);
}

function integer($i) {
  if ($i > 0) return Math.floor($i);else return Math.ceil($i);
}

},{}],47:[function(require,module,exports){
"use strict";

var _statisticsDistributions = require("./statistics-distributions");

var su = module.exports.StatisticsUtils = {};
su.sampleCorrelation = require('simple-statistics/src/sample_correlation');
su.linearRegression = require('simple-statistics/src/linear_regression');
su.linearRegressionLine = require('simple-statistics/src/linear_regression_line');
su.errorFunction = require('simple-statistics/src/error_function');
su.standardDeviation = require('simple-statistics/src/standard_deviation');
su.sampleStandardDeviation = require('simple-statistics/src/sample_standard_deviation');
su.variance = require('simple-statistics/src/variance');
su.mean = require('simple-statistics/src/mean');
su.zScore = require('simple-statistics/src/z_score');

su.standardError = function (arr) {
  return Math.sqrt(su.variance(arr) / (arr.length - 1));
};

su.quantile = require('simple-statistics/src/quantile');

su.tValue = function (degreesOfFreedom, criticalProbability) {
  //as in http://stattrek.com/online-calculator/t-distribution.aspx
  return (0, _statisticsDistributions.tdistr)(degreesOfFreedom, criticalProbability);
};

},{"./statistics-distributions":46,"simple-statistics/src/error_function":12,"simple-statistics/src/linear_regression":13,"simple-statistics/src/linear_regression_line":14,"simple-statistics/src/mean":15,"simple-statistics/src/quantile":16,"simple-statistics/src/sample_correlation":19,"simple-statistics/src/sample_standard_deviation":21,"simple-statistics/src/standard_deviation":23,"simple-statistics/src/variance":26,"simple-statistics/src/z_score":27}],48:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Utils = void 0;

var d3 = _interopRequireWildcard(require("./d3"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};

  if (obj != null) {
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Utils =
/*#__PURE__*/
function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: "deepExtend",
    // usage example deepExtend({}, objA, objB); => should work similar to $.extend(true, {}, objA, objB);
    value: function deepExtend(out) {
      var utils = this;
      var emptyOut = {};

      if (!out && arguments.length > 1 && Array.isArray(arguments[1])) {
        out = [];
      }

      out = out || {};

      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        if (!source) continue;

        for (var key in source) {
          if (!source.hasOwnProperty(key)) {
            continue;
          }

          var isArray = Array.isArray(out[key]);
          var isObject = utils.isObject(out[key]);
          var srcObj = utils.isObject(source[key]);

          if (isObject && !isArray && srcObj) {
            utils.deepExtend(out[key], source[key]);
          } else {
            out[key] = source[key];
          }
        }
      }

      return out;
    }
  }, {
    key: "mergeDeep",
    value: function mergeDeep(target, source) {
      var output = Object.assign({}, target);

      if (Utils.isObjectNotArray(target) && Utils.isObjectNotArray(source)) {
        Object.keys(source).forEach(function (key) {
          if (Utils.isObjectNotArray(source[key])) {
            if (!(key in target)) Object.assign(output, _defineProperty({}, key, source[key]));else output[key] = Utils.mergeDeep(target[key], source[key]);
          } else {
            Object.assign(output, _defineProperty({}, key, source[key]));
          }
        });
      }

      return output;
    }
  }, {
    key: "cross",
    value: function cross(a, b) {
      var c = [],
          n = a.length,
          m = b.length,
          i,
          j;

      for (i = -1; ++i < n;) {
        for (j = -1; ++j < m;) {
          c.push({
            x: a[i],
            i: i,
            y: b[j],
            j: j
          });
        }
      }

      return c;
    }
  }, {
    key: "inferVariables",
    value: function inferVariables(data, groupKey, includeGroup) {
      var res = [];

      if (!data) {
        return res;
      }

      if (data.length) {
        var d = data[0];

        if (d instanceof Array) {
          res = d.map(function (v, i) {
            return i;
          });
        } else if (_typeof(d) === 'object') {
          for (var prop in d) {
            if (!d.hasOwnProperty(prop)) continue;
            res.push(prop);
          }
        }
      }

      if (groupKey !== null && groupKey !== undefined && !includeGroup) {
        var index = res.indexOf(groupKey);

        if (index > -1) {
          res.splice(index, 1);
        }
      }

      return res;
    }
  }, {
    key: "isObjectNotArray",
    value: function isObjectNotArray(item) {
      return item && _typeof(item) === 'object' && !Array.isArray(item) && item !== null;
    }
  }, {
    key: "isArray",
    value: function isArray(item) {
      return Array.isArray(item);
    }
  }, {
    key: "isObject",
    value: function isObject(a) {
      return a !== null && _typeof(a) === 'object';
    }
  }, {
    key: "isNumber",
    value: function isNumber(a) {
      return !isNaN(a) && typeof a === 'number';
    }
  }, {
    key: "isFunction",
    value: function isFunction(a) {
      return typeof a === 'function';
    }
  }, {
    key: "isDate",
    value: function isDate(a) {
      return Object.prototype.toString.call(a) === '[object Date]';
    }
  }, {
    key: "isString",
    value: function isString(a) {
      return typeof a === 'string' || a instanceof String;
    }
  }, {
    key: "insertOrAppendSelector",
    value: function insertOrAppendSelector(parent, selector, operation, before) {
      var selectorParts = selector.split(/([\.\#])/);
      var element = parent[operation](selectorParts.shift(), before); //":first-child"

      while (selectorParts.length > 1) {
        var selectorModifier = selectorParts.shift();
        var selectorItem = selectorParts.shift();

        if (selectorModifier === ".") {
          element = element.classed(selectorItem, true);
        } else if (selectorModifier === "#") {
          element = element.attr('id', selectorItem);
        }
      }

      return element;
    }
  }, {
    key: "insertSelector",
    value: function insertSelector(parent, selector, before) {
      return Utils.insertOrAppendSelector(parent, selector, "insert", before);
    }
  }, {
    key: "appendSelector",
    value: function appendSelector(parent, selector) {
      return Utils.insertOrAppendSelector(parent, selector, "append");
    }
  }, {
    key: "selectOrAppend",
    value: function selectOrAppend(parent, selector, element) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        if (element) {
          return parent.append(element);
        }

        return Utils.appendSelector(parent, selector);
      }

      return selection;
    }
  }, {
    key: "selectOrInsert",
    value: function selectOrInsert(parent, selector, before) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        return Utils.insertSelector(parent, selector, before);
      }

      return selection;
    }
  }, {
    key: "linearGradient",
    value: function linearGradient(svg, gradientId, range, x1, y1, x2, y2) {
      var defs = Utils.selectOrAppend(svg, "defs");
      var linearGradient = defs.append("linearGradient").attr("id", gradientId);
      linearGradient.attr("x1", x1 + "%").attr("y1", y1 + "%").attr("x2", x2 + "%").attr("y2", y2 + "%"); //Append multiple color stops by using D3's data/enter step

      var stops = linearGradient.selectAll("stop").data(range);
      var stopsMerge = stops.enter().append("stop").merge(stops);
      stopsMerge.attr("offset", function (d, i) {
        return i / (range.length - 1);
      }).attr("stop-color", function (d) {
        return d;
      });
      stops.exit().remove();
    }
  }, {
    key: "guid",
    value: function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    } //places textString in textObj, adds an ellipsis if text can't fit in width

  }, {
    key: "placeTextWithEllipsis",
    value: function placeTextWithEllipsis(textD3Obj, textString, width) {
      var textObj = textD3Obj.node();
      textObj.textContent = textString;
      var margin = 0;
      var ellipsisLength = 9; //ellipsis is needed

      if (textObj.getComputedTextLength() > width + margin) {
        for (var x = textString.length - 3; x > 0; x -= 1) {
          if (textObj.getSubStringLength(0, x) + ellipsisLength <= width + margin) {
            textObj.textContent = textString.substring(0, x) + "...";
            return true;
          }
        }

        textObj.textContent = "..."; //can't place at all

        return true;
      }

      return false;
    }
  }, {
    key: "placeTextWithEllipsisAndTooltip",
    value: function placeTextWithEllipsisAndTooltip(textD3Obj, textString, width, tooltip) {
      var ellipsisPlaced = Utils.placeTextWithEllipsis(textD3Obj, textString, width);

      if (ellipsisPlaced && tooltip) {
        textD3Obj.on("mouseover", function (d) {
          tooltip.transition().duration(200).style("opacity", .9);
          tooltip.html(textString).style("left", d3.event.pageX + 5 + "px").style("top", d3.event.pageY - 28 + "px");
        });
        textD3Obj.on("mouseout", function (d) {
          tooltip.transition().duration(500).style("opacity", 0);
        });
      }
    }
  }, {
    key: "getFontSize",
    value: function getFontSize(element) {
      return window.getComputedStyle(element, null).getPropertyValue("font-size");
    }
  }, {
    key: "capitalizeFirstLetter",
    value: function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
  }, {
    key: "createScale",
    value: function createScale(scaleName) {
      var scaleFunctionName = 'scale' + Utils.capitalizeFirstLetter(scaleName);

      try {
        return d3[scaleFunctionName]();
      } catch (e) {
        throw 'ODC-D3 - scale not supported: ' + scaleName + ' (' + scaleFunctionName + ')';
      }
    }
  }, {
    key: "createAxis",
    value: function createAxis(orient, scale) {
      var axisFnName = 'axis' + Utils.capitalizeFirstLetter(orient);

      try {
        return d3[axisFnName](scale);
      } catch (e) {
        throw 'ODC-D3 - axis orient not supported: ' + orient;
      }
    }
  }]);

  return Utils;
}();

exports.Utils = Utils;
Utils.SQRT_2 = 1.41421356237;

Utils.sanitizeHeight = function (height, container) {
  return height || parseInt(container.style('height'), 10) || 400;
};

Utils.sanitizeWidth = function (width, container) {
  return width || parseInt(container.style('width'), 10) || 960;
};

Utils.availableHeight = function (height, container, margin) {
  return Math.max(0, Utils.sanitizeHeight(height, container) - margin.top - margin.bottom);
};

Utils.availableWidth = function (width, container, margin) {
  return Math.max(0, Utils.sanitizeWidth(width, container) - margin.left - margin.right);
};

},{"./d3":35}]},{},[40])(40)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMtY29sbGVjdGlvbi9kaXN0L2QzLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZDMtY29sb3IvZGlzdC9kMy1jb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9kaXN0L2QzLWludGVycG9sYXRlLmpzIiwibm9kZV9tb2R1bGVzL2QzLXN2Zy1sZWdlbmQvaW5kZXhSb2xsdXAuanMiLCJub2RlX21vZHVsZXMvZDMtc3ZnLWxlZ2VuZC9ub2RlX21vZHVsZXMvZDMtYXJyYXkvYnVpbGQvZDMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZDMtc3ZnLWxlZ2VuZC9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvYnVpbGQvZDMtZGlzcGF0Y2guanMiLCJub2RlX21vZHVsZXMvZDMtc3ZnLWxlZ2VuZC9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L2J1aWxkL2QzLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1zdmctbGVnZW5kL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9idWlsZC9kMy1zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9kMy1zdmctbGVnZW5kL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vYnVpbGQvZDMtc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLXRpbWUtZm9ybWF0L2Rpc3QvZDMtdGltZS1mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS9kaXN0L2QzLXRpbWUuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2Vycm9yX2Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9saW5lYXJfcmVncmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvbGluZWFyX3JlZ3Jlc3Npb25fbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvbWVhbi5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvcXVhbnRpbGUuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3F1YW50aWxlX3NvcnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvcXVpY2tzZWxlY3QuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3NhbXBsZV9jb3JyZWxhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvc2FtcGxlX2NvdmFyaWFuY2UuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3NhbXBsZV9zdGFuZGFyZF9kZXZpYXRpb24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3NhbXBsZV92YXJpYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvc3RhbmRhcmRfZGV2aWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zdW0uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3N1bV9udGhfcG93ZXJfZGV2aWF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvdmFyaWFuY2UuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3pfc2NvcmUuanMiLCJzcmMvYmFyLWNoYXJ0LmpzIiwic3JjL2JveC1wbG90LWJhc2UuanMiLCJzcmMvYm94LXBsb3QuanMiLCJzcmMvY2hhcnQtd2l0aC1jb2xvci1ncm91cHMuanMiLCJzcmMvY2hhcnQuanMiLCJzcmMvY29ycmVsYXRpb24tbWF0cml4LmpzIiwic3JjL2QzLWV4dGVuc2lvbnMuanMiLCJzcmMvZDMuanMiLCJzcmMvZGl2ZXJnaW5nLXN0YWNrZWQtYmFyLWNoYXJ0LmpzIiwic3JjL2hlYXRtYXAtdGltZXNlcmllcy5qcyIsInNyYy9oZWF0bWFwLmpzIiwic3JjL2hpc3RvZ3JhbS5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sZWdlbmQuanMiLCJzcmMvbGluZS1jaGFydC5qcyIsInNyYy9yZWdyZXNzaW9uLmpzIiwic3JjL3NjYXR0ZXJwbG90LW1hdHJpeC5qcyIsInNyYy9zY2F0dGVycGxvdC5qcyIsInNyYy9zdGF0aXN0aWNzLWRpc3RyaWJ1dGlvbnMuanMiLCJzcmMvc3RhdGlzdGljcy11dGlscy5qcyIsInNyYy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9jQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3I0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9CQSxJQUFBLHFCQUFBLEdBQUEsT0FBQSxDQUFBLDJCQUFBLENBQUE7O0FBQ0EsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7QUFDQSxJQUFBLE9BQUEsR0FBQSxPQUFBLENBQUEsVUFBQSxDQUFBOztBQUNBLElB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QyxHQUFHLElBQUksQ0FBSixJQUFBLENBQVIsQ0FBQTtBQUNBLFVBQUksQ0FBQyxHQUFHLElBQUksQ0FBSixJQUFBLENBQVIsQ0FBQTtBQUNBLFVBQUksQ0FBQyxHQUFHLElBQUksQ0FBSixJQUFBLENBQVIsQ0FBQTs7QUFHQSxNQUFBLENBQUMsQ0FBRCxLQUFBLEdBQVUsVUFBQSxDQUFBLEVBQUM7QUFBQSxlQUFJLE1BQU0sQ0FBTixDQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLEVBQUosQ0FBSSxDQUFKO0FBQVgsT0FBQTs7QUFDQSxNQUFBLENBQUMsQ0FBRCxLQUFBLEdBQVUsVUFBQSxDQUFBLEVBQUM7QUFBQSxlQUFJLE1BQU0sQ0FBTixDQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLEVBQUosQ0FBSSxDQUFKO0FBQVgsT0FBQTs7QUFDQSxNQUFBLENBQUMsQ0FBRCxLQUFBLEdBQVUsVUFBQSxDQUFBLEVBQUM7QUFBQSxlQUFJLE1BQU0sQ0FBTixDQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLEVBQUosQ0FBSSxDQUFKO0FBQVgsT0FBQTs7QUFFQSxNQUFBLENBQUMsQ0FBRCxZQUFBLEdBQUEsRUFBQTtBQUNBLE1BQUEsQ0FBQyxDQUFELFlBQUEsR0FBQSxFQUFBO0FBR0EsTUFBQSxJQUFJLENBQUosSUFBQSxDQUFBLFFBQUEsR0FBcUIsQ0FBQyxDQUFDLE1BQU0sQ0FBTixDQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBdkIsTUFBQTtBQUNBLE1BQUEsSUFBSSxDQUFKLElBQUEsQ0FBQSxRQUFBLEdBQXFCLENBQUMsQ0FBQyxNQUFNLENBQU4sQ0FBQSxDQUFBLE1BQUEsQ0FBQSxJQUFBLENBQXZCLE1BQUE7QUFFQSxNQUFBLENBQUMsQ0FBRCxNQUFBLEdBQVc7QUFDUCxRQUFBLEdBQUcsRUFESSxTQUFBO0FBRVAsUUFBQSxLQUFLLEVBRkUsRUFBQTtBQUdQLFFBQUEsTUFBTSxFQUhDLEVBQUE7QUFJUCxRQUFBLFFBQVEsRUFKRCxJQUFBO0FBS1As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RUFBQTtBQUNBOztBQUdELFNBQUEsS0FBQSxDQUFBLEVBQUEsRUFBQSxFQUFBLEVBQXdCO0FBRXZCLE1BQUksRUFBRSxJQUFGLENBQUEsSUFBVyxFQUFFLElBQWpCLENBQUEsRUFBd0I7QUFDdkIsVUFBQSxpQkFBQTtBQUNBOztBQUVELE1BQUksRUFBRSxJQUFOLEdBQUEsRUFBZTtBQUNkLFdBQUEsQ0FBQTtBQURELEdBQUEsTUFFTyxJQUFJLEVBQUUsR0FBTixHQUFBLEVBQWM7QUFDcEIsV0FBTyxDQUFFLEtBQUssQ0FBQSxFQUFBLEVBQUssSUFBbkIsRUFBYyxDQUFkO0FBQ0E7O0FBRUQsTUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFkLEVBQWMsQ0FBZDs7QUFDQSxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUosR0FBQSxDQUFBLEVBQUEsRUFBVixDQUFVLENBQVY7QUFFQSxNQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBSixDQUFBLElBQVQsQ0FBQTtBQUNBLE1BQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFBLEdBQUEsR0FBRCxFQUFBLElBQUEsR0FBQSxHQUFELENBQUEsSUFBVCxFQUFBO0FBQ0EsTUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBQSxHQUFBLEdBQUQsRUFBQSxJQUFBLEdBQUEsR0FBRCxFQUFBLElBQUEsR0FBQSxHQUFELEVBQUEsSUFBVCxHQUFBO0FBQ0EsTUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFBLEdBQUEsR0FBRCxHQUFBLElBQUEsR0FBQSxHQUFELElBQUEsSUFBQSxHQUFBLEdBQUQsSUFBQSxJQUFBLEdBQUEsR0FBRCxHQUFBLElBQVQsS0FBQTtBQUVBLE1BQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFBLEdBQUEsR0FBRCxHQUFBLElBQUEsR0FBQSxHQUFELEdBQUEsSUFBQSxHQUFBLEdBQUQsSUFBQSxJQUFBLEdBQUEsR0FBRCxHQUFBLElBQUEsR0FBQSxHQUFELEtBQUEsSUFBVCxNQUFBO0FBR0EsTUFB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LENBQUEsRUFBWSxLQUFLLENBQUwsYUFBQSxDQUFBLEtBQUEsRUFBQSxTQUFBLElBQXdDLE1BQU0sQ0FBOUMsSUFBQSxHQUFzRCxNQUFNLENBQS9FLEtBQU8sQ0FBUDtDQXhNSyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY29sbGVjdGlvbi8gdjEuMC43IENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZml4ID0gXCIkXCI7XG5cbmZ1bmN0aW9uIE1hcCgpIHt9XG5cbk1hcC5wcm90b3R5cGUgPSBtYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWFwLFxuICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByZWZpeCArIGtleTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICB9LFxuICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBrZXlzLnB1c2gocHJvcGVydHkuc2xpY2UoMSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgdmFsdWVzLnB1c2godGhpc1twcm9wZXJ0eV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG4gIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGVudHJpZXMucHVzaCh7a2V5OiBwcm9wZXJ0eS5zbGljZSgxKSwgdmFsdWU6IHRoaXNbcHJvcGVydHldfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgKytzaXplO1xuICAgIHJldHVybiBzaXplO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24oZikge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBmKHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eS5zbGljZSgxKSwgdGhpcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1hcChvYmplY3QsIGYpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXA7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcblxuICAvLyBJbmRleCBhcnJheSBieSBudW1lcmljIGluZGV4IG9yIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICBvO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYobyA9IG9iamVjdFtpXSwgaSwgb2JqZWN0KSwgbyk7XG4gIH1cblxuICAvLyBDb252ZXJ0IG9iamVjdCB0byBtYXAuXG4gIGVsc2UgaWYgKG9iamVjdCkgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcblxuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiBuZXN0KCkge1xuICB2YXIga2V5cyA9IFtdLFxuICAgICAgc29ydEtleXMgPSBbXSxcbiAgICAgIHNvcnRWYWx1ZXMsXG4gICAgICByb2xsdXAsXG4gICAgICBuZXN0O1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpIHtcbiAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGFycmF5LnNvcnQoc29ydFZhbHVlcyk7XG4gICAgICByZXR1cm4gcm9sbHVwICE9IG51bGwgPyByb2xsdXAoYXJyYXkpIDogYXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcbiAgICAgICAga2V5VmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZXNCeUtleSA9IG1hcCgpLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVJlc3VsdCgpO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyBcIlwiKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlc0J5S2V5LmVhY2goZnVuY3Rpb24odmFsdWVzLCBrZXkpIHtcbiAgICAgIHNldFJlc3VsdChyZXN1bHQsIGtleSwgYXBwbHkodmFsdWVzLCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyaWVzKG1hcCQkMSwgZGVwdGgpIHtcbiAgICBpZiAoKytkZXB0aCA+IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwJCQxO1xuICAgIHZhciBhcnJheSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoIC0gMV07XG4gICAgaWYgKHJvbGx1cCAhPSBudWxsICYmIGRlcHRoID49IGtleXMubGVuZ3RoKSBhcnJheSA9IG1hcCQkMS5lbnRyaWVzKCk7XG4gICAgZWxzZSBhcnJheSA9IFtdLCBtYXAkJDEuZWFjaChmdW5jdGlvbih2LCBrKSB7IGFycmF5LnB1c2goe2tleTogaywgdmFsdWVzOiBlbnRyaWVzKHYsIGRlcHRoKX0pOyB9KTtcbiAgICByZXR1cm4gc29ydEtleSAhPSBudWxsID8gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7IH0pIDogYXJyYXk7XG4gIH1cblxuICByZXR1cm4gbmVzdCA9IHtcbiAgICBvYmplY3Q6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlT2JqZWN0LCBzZXRPYmplY3QpOyB9LFxuICAgIG1hcDogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCk7IH0sXG4gICAgZW50cmllczogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGVudHJpZXMoYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKSwgMCk7IH0sXG4gICAga2V5OiBmdW5jdGlvbihkKSB7IGtleXMucHVzaChkKTsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydEtleXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydFZhbHVlczogZnVuY3Rpb24ob3JkZXIpIHsgc29ydFZhbHVlcyA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcbiAgICByb2xsdXA6IGZ1bmN0aW9uKGYpIHsgcm9sbHVwID0gZjsgcmV0dXJuIG5lc3Q7IH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0KCkge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIHNldE9iamVjdChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFwKCkge1xuICByZXR1cm4gbWFwKCk7XG59XG5cbmZ1bmN0aW9uIHNldE1hcChtYXAkJDEsIGtleSwgdmFsdWUpIHtcbiAgbWFwJCQxLnNldChrZXksIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gU2V0KCkge31cblxudmFyIHByb3RvID0gbWFwLnByb3RvdHlwZTtcblxuU2V0LnByb3RvdHlwZSA9IHNldC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZXQsXG4gIGhhczogcHJvdG8uaGFzLFxuICBhZGQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFsdWUgKz0gXCJcIjtcbiAgICB0aGlzW3ByZWZpeCArIHZhbHVlXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IHByb3RvLnJlbW92ZSxcbiAgY2xlYXI6IHByb3RvLmNsZWFyLFxuICB2YWx1ZXM6IHByb3RvLmtleXMsXG4gIHNpemU6IHByb3RvLnNpemUsXG4gIGVtcHR5OiBwcm90by5lbXB0eSxcbiAgZWFjaDogcHJvdG8uZWFjaFxufTtcblxuZnVuY3Rpb24gc2V0KG9iamVjdCwgZikge1xuICB2YXIgc2V0ID0gbmV3IFNldDtcblxuICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU2V0KSBvYmplY3QuZWFjaChmdW5jdGlvbih2YWx1ZSkgeyBzZXQuYWRkKHZhbHVlKTsgfSk7XG5cbiAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaXTigJlzIGFuIGFycmF5LlxuICBlbHNlIGlmIChvYmplY3QpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gb2JqZWN0Lmxlbmd0aDtcbiAgICBpZiAoZiA9PSBudWxsKSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChvYmplY3RbaV0pO1xuICAgIGVsc2Ugd2hpbGUgKCsraSA8IG4pIHNldC5hZGQoZihvYmplY3RbaV0sIGksIG9iamVjdCkpO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn1cblxuZnVuY3Rpb24ga2V5cyhtYXApIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiB2YWx1ZXMobWFwKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG5mdW5jdGlvbiBlbnRyaWVzKG1hcCkge1xuICB2YXIgZW50cmllcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe2tleToga2V5LCB2YWx1ZTogbWFwW2tleV19KTtcbiAgcmV0dXJuIGVudHJpZXM7XG59XG5cbmV4cG9ydHMubmVzdCA9IG5lc3Q7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5rZXlzID0ga2V5cztcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuZXhwb3J0cy5lbnRyaWVzID0gZW50cmllcztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY29sb3IvIHYxLjIuMyBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZGVmaW5lKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG4gIHJldHVybiBwcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIENvbG9yKCkge31cblxudmFyIGRhcmtlciA9IDAuNztcbnZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4MyA9IC9eIyhbMC05YS1mXXszfSkkLyxcbiAgICByZUhleDYgPSAvXiMoWzAtOWEtZl17Nn0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlSSwgcmVJLCByZUldICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlUCwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVJLCByZUksIHJlSSwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlUCwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xhXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIik7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmhleCgpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkgKyBcIlwiO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4My5leGVjKGZvcm1hdCkpID8gKG0gPSBwYXJzZUludChtWzFdLCAxNiksIG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHgwZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpKSAvLyAjZjAwXG4gICAgICA6IChtID0gcmVIZXg2LmV4ZWMoZm9ybWF0KSkgPyByZ2JuKHBhcnNlSW50KG1bMV0sIDE2KSkgLy8gI2ZmMDAwMFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSlcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIHJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnIgJiYgdGhpcy5yIDw9IDI1NSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5nICYmIHRoaXMuZyA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMuYiAmJiB0aGlzLmIgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIiNcIiArIGhleCh0aGlzLnIpICsgaGV4KHRoaXMuZykgKyBoZXgodGhpcy5iKTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICAgIHJldHVybiAoYSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwiKVxuICAgICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLnIpIHx8IDApKSArIFwiLCBcIlxuICAgICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmcpIHx8IDApKSArIFwiLCBcIlxuICAgICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmIpIHx8IDApKVxuICAgICAgICArIChhID09PSAxID8gXCIpXCIgOiBcIiwgXCIgKyBhICsgXCIpXCIpO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9XG59KSk7XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cblxudmFyIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwO1xudmFyIHJhZDJkZWcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwczovL2JldGEub2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbnZhciBLID0gMTgsXG4gICAgWG4gPSAwLjk2NDIyLFxuICAgIFluID0gMSxcbiAgICBabiA9IDAuODI1MjEsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkge1xuICAgIGlmIChpc05hTihvLmgpKSByZXR1cm4gbmV3IExhYihvLmwsIDAsIDAsIG8ub3BhY2l0eSk7XG4gICAgdmFyIGggPSBvLmggKiBkZWcycmFkO1xuICAgIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xuICB9XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSByZ2IybHJnYihvLnIpLFxuICAgICAgZyA9IHJnYjJscmdiKG8uZyksXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIyMjUwNDUgKiByICsgMC43MTY4Nzg2ICogZyArIDAuMDYwNjE2OSAqIGIpIC8gWW4pLCB4LCB6O1xuICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB4ID0geiA9IHk7IGVsc2Uge1xuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xuICAgIHogPSB4eXoybGFiKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZyArIDAuNzE0MTczMyAqIGIpIC8gWm4pO1xuICB9XG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBuZXcgTGFiKGwsIDAsIDAsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gbGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBsYWJDb252ZXJ0KGwpIDogbmV3IExhYihsLCBhLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxuICAgICAgbHJnYjJyZ2IoLTAuOTc4NzY4NCAqIHggKyAxLjkxNjE0MTUgKiB5ICsgMC4wMzM0NTQwICogeiksXG4gICAgICBscmdiMnJnYiggMC4wNzE5NDUzICogeCAtIDAuMjI4OTkxNCAqIHkgKyAxLjQwNTI0MjcgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiBscmdiMnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IybHJnYih4KSB7XG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBuZXcgSGNsKG8uaCwgby5jLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMYWIpKSBvID0gbGFiQ29udmVydChvKTtcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCwgby5sLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogcmFkMmRlZztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gbGNoKGwsIGMsIGgsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5jID0gK2M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhjbCwgaGNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGFiQ29udmVydCh0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuXG52YXIgQSA9IC0wLjE0ODYxLFxuICAgIEIgPSArMS43ODI3NyxcbiAgICBDID0gLTAuMjkyMjcsXG4gICAgRCA9IC0wLjkwNjQ5LFxuICAgIEUgPSArMS45NzI5NCxcbiAgICBFRCA9IEUgKiBELFxuICAgIEVCID0gRSAqIEIsXG4gICAgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXhDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHJldHVybiBuZXcgQ3ViZWhlbGl4KG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpLFxuICAgICAgYmwgPSBiIC0gbCxcbiAgICAgIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRCxcbiAgICAgIHMgPSBNYXRoLnNxcnQoayAqIGsgKyBibCAqIGJsKSAvIChFICogbCAqICgxIC0gbCkpLCAvLyBOYU4gaWYgbD0wIG9yIGw9MVxuICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIHJhZDJkZWcgLSAxMjAgOiBOYU47XG4gIHJldHVybiBuZXcgQ3ViZWhlbGl4KGggPCAwID8gaCArIDM2MCA6IGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY3ViZWhlbGl4Q29udmVydChoKSA6IG5ldyBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEN1YmVoZWxpeCwgY3ViZWhlbGl4LCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gaXNOYU4odGhpcy5oKSA/IDAgOiAodGhpcy5oICsgMTIwKSAqIGRlZzJyYWQsXG4gICAgICAgIGwgPSArdGhpcy5sLFxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcbiAgICAgICAgY29zaCA9IE1hdGguY29zKGgpLFxuICAgICAgICBzaW5oID0gTWF0aC5zaW4oaCk7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICAyNTUgKiAobCArIGEgKiAoQSAqIGNvc2ggKyBCICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEMgKiBjb3NoICsgRCAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5leHBvcnRzLmNvbG9yID0gY29sb3I7XG5leHBvcnRzLnJnYiA9IHJnYjtcbmV4cG9ydHMuaHNsID0gaHNsO1xuZXhwb3J0cy5sYWIgPSBsYWI7XG5leHBvcnRzLmhjbCA9IGhjbDtcbmV4cG9ydHMubGNoID0gbGNoO1xuZXhwb3J0cy5ncmF5ID0gZ3JheTtcbmV4cG9ydHMuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1pbnRlcnBvbGF0ZS8gdjEuMy4yIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtY29sb3InKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1jb2xvciddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzQ29sb3IpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG5mdW5jdGlvbiBiYXNpcyQxKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaXNDbG9zZWQodmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIHQgKiBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XG4gIHJldHVybiBhID0gTWF0aC5wb3coYSwgeSksIGIgPSBNYXRoLnBvdyhiLCB5KSAtIGEsIHkgPSAxIC8geSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhhICsgdCAqIGIsIHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5mdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbnZhciByZ2IgPSAoZnVuY3Rpb24gcmdiR2FtbWEoeSkge1xuICB2YXIgY29sb3IgPSBnYW1tYSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gZDNDb2xvci5yZ2Ioc3RhcnQpKS5yLCAoZW5kID0gZDNDb2xvci5yZ2IoZW5kKSkuciksXG4gICAgICAgIGcgPSBjb2xvcihzdGFydC5nLCBlbmQuZyksXG4gICAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuciA9IHIodCk7XG4gICAgICBzdGFydC5nID0gZyh0KTtcbiAgICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICByZ2IuZ2FtbWEgPSByZ2JHYW1tYTtcblxuICByZXR1cm4gcmdiO1xufSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3I7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBkM0NvbG9yLnJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvci5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IuciA9IHIodCk7XG4gICAgICBjb2xvci5nID0gZyh0KTtcbiAgICAgIGNvbG9yLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMkMSk7XG52YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuXG5mdW5jdGlvbiBhcnJheShhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gdmFsdWUoYVtpXSwgYltpXSk7XG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRhdGUoYSwgYikge1xuICB2YXIgZCA9IG5ldyBEYXRlO1xuICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZC5zZXRUaW1lKGEgKyBiICogdCksIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG51bWJlcihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgYiAqIHQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9iamVjdChhLCBiKSB7XG4gIHZhciBpID0ge30sXG4gICAgICBjID0ge30sXG4gICAgICBrO1xuXG4gIGlmIChhID09PSBudWxsIHx8IHR5cGVvZiBhICE9PSBcIm9iamVjdFwiKSBhID0ge307XG4gIGlmIChiID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKSBiID0ge307XG5cbiAgZm9yIChrIGluIGIpIHtcbiAgICBpZiAoayBpbiBhKSB7XG4gICAgICBpW2tdID0gdmFsdWUoYVtrXSwgYltrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNba10gPSBiW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLFxuICAgIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsdWUoYSwgYikge1xuICB2YXIgdCA9IHR5cGVvZiBiLCBjO1xuICByZXR1cm4gYiA9PSBudWxsIHx8IHQgPT09IFwiYm9vbGVhblwiID8gY29uc3RhbnQoYilcbiAgICAgIDogKHQgPT09IFwibnVtYmVyXCIgPyBudW1iZXJcbiAgICAgIDogdCA9PT0gXCJzdHJpbmdcIiA/ICgoYyA9IGQzQ29sb3IuY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgZDNDb2xvci5jb2xvciA/IHJnYlxuICAgICAgOiBiIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVcbiAgICAgIDogQXJyYXkuaXNBcnJheShiKSA/IGFycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGRpc2NyZXRlKHJhbmdlKSB7XG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh1ZSQxKGEsIGIpIHtcbiAgdmFyIGkgPSBodWUoK2EsICtiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgeCA9IGkodCk7XG4gICAgcmV0dXJuIHggLSAzNjAgKiBNYXRoLmZsb29yKHggLyAzNjApO1xuICB9O1xufVxuXG5mdW5jdGlvbiByb3VuZChhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKyBiICogdCk7XG4gIH07XG59XG5cbnZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxudmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxuZnVuY3Rpb24gZGVjb21wb3NlKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuXG52YXIgY3NzTm9kZSxcbiAgICBjc3NSb290LFxuICAgIGNzc1ZpZXcsXG4gICAgc3ZnTm9kZTtcblxuZnVuY3Rpb24gcGFyc2VDc3ModmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBcIm5vbmVcIikgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIWNzc05vZGUpIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLCBjc3NSb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBjc3NWaWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNzc05vZGUuc3R5bGUudHJhbnNmb3JtID0gdmFsdWU7XG4gIHZhbHVlID0gY3NzVmlldy5nZXRDb21wdXRlZFN0eWxlKGNzc1Jvb3QuYXBwZW5kQ2hpbGQoY3NzTm9kZSksIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIik7XG4gIGNzc1Jvb3QucmVtb3ZlQ2hpbGQoY3NzTm9kZSk7XG4gIHZhbHVlID0gdmFsdWUuc2xpY2UoNywgLTEpLnNwbGl0KFwiLFwiKTtcbiAgcmV0dXJuIGRlY29tcG9zZSgrdmFsdWVbMF0sICt2YWx1ZVsxXSwgK3ZhbHVlWzJdLCArdmFsdWVbM10sICt2YWx1ZVs0XSwgK3ZhbHVlWzVdKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZUNzcywgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbnZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlU3ZnLCBcIiwgXCIsIFwiKVwiLCBcIilcIik7XG5cbnZhciByaG8gPSBNYXRoLlNRUlQyLFxuICAgIHJobzIgPSAyLFxuICAgIHJobzQgPSA0LFxuICAgIGVwc2lsb24yID0gMWUtMTI7XG5cbmZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG59XG5cbi8vIHAwID0gW3V4MCwgdXkwLCB3MF1cbi8vIHAxID0gW3V4MSwgdXkxLCB3MV1cbmZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sXG4gICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgIGR5ID0gdXkxIC0gdXkwLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIGksXG4gICAgICBTO1xuXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIHJobztcbiAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdXgwICsgdCAqIGR4LFxuICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICBdO1xuICAgIH07XG4gIH1cblxuICAvLyBHZW5lcmFsIGNhc2UuXG4gIGVsc2Uge1xuICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksXG4gICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLFxuICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICB1ID0gdzAgLyAocmhvMiAqIGQxKSAqIChjb3NocjAgKiB0YW5oKHJobyAqIHMgKyByMCkgLSBzaW5oKHIwKSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgIHV5MCArIHUgKiBkeSxcbiAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgIF07XG4gICAgfTtcbiAgfVxuXG4gIGkuZHVyYXRpb24gPSBTICogMTAwMDtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gaHNsKGh1ZSQkMSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlJCQxKChzdGFydCA9IGQzQ29sb3IuaHNsKHN0YXJ0KSkuaCwgKGVuZCA9IGQzQ29sb3IuaHNsKGVuZCkpLmgpLFxuICAgICAgICBzID0gbm9nYW1tYShzdGFydC5zLCBlbmQucyksXG4gICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LnMgPSBzKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaHNsJDEgPSBoc2woaHVlKTtcbnZhciBoc2xMb25nID0gaHNsKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBsYWIoc3RhcnQsIGVuZCkge1xuICB2YXIgbCA9IG5vZ2FtbWEoKHN0YXJ0ID0gZDNDb2xvci5sYWIoc3RhcnQpKS5sLCAoZW5kID0gZDNDb2xvci5sYWIoZW5kKSkubCksXG4gICAgICBhID0gbm9nYW1tYShzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gbm9nYW1tYShzdGFydC5iLCBlbmQuYiksXG4gICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGNsKGh1ZSQkMSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlJCQxKChzdGFydCA9IGQzQ29sb3IuaGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGQzQ29sb3IuaGNsKGVuZCkpLmgpLFxuICAgICAgICBjID0gbm9nYW1tYShzdGFydC5jLCBlbmQuYyksXG4gICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaGNsJDEgPSBoY2woaHVlKTtcbnZhciBoY2xMb25nID0gaGNsKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaHVlJCQxKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSQkMSgoc3RhcnQgPSBkM0NvbG9yLmN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBkM0NvbG9yLmN1YmVoZWxpeChlbmQpKS5oKSxcbiAgICAgICAgICBzID0gbm9nYW1tYShzdGFydC5zLCBlbmQucyksXG4gICAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4LmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG5cbiAgICByZXR1cm4gY3ViZWhlbGl4O1xuICB9KSgxKTtcbn1cblxudmFyIGN1YmVoZWxpeCQxID0gY3ViZWhlbGl4KGh1ZSk7XG52YXIgY3ViZWhlbGl4TG9uZyA9IGN1YmVoZWxpeChub2dhbW1hKTtcblxuZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBxdWFudGl6ZShpbnRlcnBvbGF0b3IsIG4pIHtcbiAgdmFyIHNhbXBsZXMgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKGkgLyAobiAtIDEpKTtcbiAgcmV0dXJuIHNhbXBsZXM7XG59XG5cbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVBcnJheSA9IGFycmF5O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJhc2lzID0gYmFzaXMkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZURhdGUgPSBkYXRlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZURpc2NyZXRlID0gZGlzY3JldGU7XG5leHBvcnRzLmludGVycG9sYXRlSHVlID0gaHVlJDE7XG5leHBvcnRzLmludGVycG9sYXRlTnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU9iamVjdCA9IG9iamVjdDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVN0cmluZyA9IHN0cmluZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVab29tID0gem9vbTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2IgPSByZ2I7XG5leHBvcnRzLmludGVycG9sYXRlUmdiQmFzaXMgPSByZ2JCYXNpcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZCA9IHJnYkJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbCA9IGhzbCQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbExvbmcgPSBoc2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUxhYiA9IGxhYjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIY2wgPSBoY2wkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIY2xMb25nID0gaGNsTG9uZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXggPSBjdWJlaGVsaXgkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4TG9uZztcbmV4cG9ydHMucGllY2V3aXNlID0gcGllY2V3aXNlO1xuZXhwb3J0cy5xdWFudGl6ZSA9IHF1YW50aXplO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLXNjYWxlJyksIHJlcXVpcmUoJ2QzLWFycmF5JykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1zZWxlY3Rpb24nLCAnZDMtZm9ybWF0JywgJ2QzLWRpc3BhdGNoJywgJ2QzLXNjYWxlJywgJ2QzLWFycmF5J10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5pbmRleFJvbGx1cCA9IGdsb2JhbC5pbmRleFJvbGx1cCB8fCB7fSksZ2xvYmFsLmQzU2VsZWN0aW9uLGdsb2JhbC5kM0Zvcm1hdCxnbG9iYWwuZDNEaXNwYXRjaCxnbG9iYWwuZDNTY2FsZSxnbG9iYWwuZDNBcnJheSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNTZWxlY3Rpb24sZDNGb3JtYXQsZDNEaXNwYXRjaCxkM1NjYWxlLGQzQXJyYXkpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxudmFyIGQzX2lkZW50aXR5ID0gZnVuY3Rpb24gZDNfaWRlbnRpdHkoZCkge1xuICByZXR1cm4gZDtcbn07XG5cbnZhciBkM19yZXZlcnNlID0gZnVuY3Rpb24gZDNfcmV2ZXJzZShhcnIpIHtcbiAgdmFyIG1pcnJvciA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBtaXJyb3JbaV0gPSBhcnJbbCAtIGkgLSAxXTtcbiAgfVxuICByZXR1cm4gbWlycm9yO1xufTtcblxuLy9UZXh0IHdyYXBwaW5nIGNvZGUgYWRhcHRlZCBmcm9tIE1pa2UgQm9zdG9ja1xudmFyIGQzX3RleHRXcmFwcGluZyA9IGZ1bmN0aW9uIGQzX3RleHRXcmFwcGluZyh0ZXh0LCB3aWR0aCkge1xuICB0ZXh0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0ID0gZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLFxuICAgICAgICB3b3JkcyA9IHRleHQudGV4dCgpLnNwbGl0KC9cXHMrLykucmV2ZXJzZSgpLFxuICAgICAgICB3b3JkLFxuICAgICAgICBsaW5lID0gW10sXG4gICAgICAgIGxpbmVOdW1iZXIgPSAwLFxuICAgICAgICBsaW5lSGVpZ2h0ID0gMS4yLFxuICAgICAgICAvL2Vtc1xuICAgIHkgPSB0ZXh0LmF0dHIoXCJ5XCIpLFxuICAgICAgICBkeSA9IHBhcnNlRmxvYXQodGV4dC5hdHRyKFwiZHlcIikpIHx8IDAsXG4gICAgICAgIHRzcGFuID0gdGV4dC50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCBkeSArIFwiZW1cIik7XG5cbiAgICB3aGlsZSAod29yZCA9IHdvcmRzLnBvcCgpKSB7XG4gICAgICBsaW5lLnB1c2god29yZCk7XG4gICAgICB0c3Bhbi50ZXh0KGxpbmUuam9pbihcIiBcIikpO1xuICAgICAgaWYgKHRzcGFuLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA+IHdpZHRoICYmIGxpbmUubGVuZ3RoID4gMSkge1xuICAgICAgICBsaW5lLnBvcCgpO1xuICAgICAgICB0c3Bhbi50ZXh0KGxpbmUuam9pbihcIiBcIikpO1xuICAgICAgICBsaW5lID0gW3dvcmRdO1xuICAgICAgICB0c3BhbiA9IHRleHQuYXBwZW5kKFwidHNwYW5cIikuYXR0cihcInhcIiwgMCkuYXR0cihcImR5XCIsIGxpbmVIZWlnaHQgKyBkeSArIFwiZW1cIikudGV4dCh3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGQzX21lcmdlTGFiZWxzID0gZnVuY3Rpb24gZDNfbWVyZ2VMYWJlbHMoKSB7XG4gIHZhciBnZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICB2YXIgbGFiZWxzID0gYXJndW1lbnRzWzFdO1xuICB2YXIgZG9tYWluID0gYXJndW1lbnRzWzJdO1xuICB2YXIgcmFuZ2UgPSBhcmd1bWVudHNbM107XG4gIHZhciBsYWJlbERlbGltaXRlciA9IGFyZ3VtZW50c1s0XTtcblxuICBpZiAoKHR5cGVvZiBsYWJlbHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihsYWJlbHMpKSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKSByZXR1cm4gZ2VuO1xuXG4gICAgdmFyIGkgPSBsYWJlbHMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgZ2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsYWJlbHMucHVzaChnZW5baV0pO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWxzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBjdXN0b21MYWJlbHMgPSBbXTtcbiAgICB2YXIgZ2VuTGVuZ3RoID0gZ2VuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZ2VuTGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjdXN0b21MYWJlbHMucHVzaChsYWJlbHMoe1xuICAgICAgICBpOiBfaSxcbiAgICAgICAgZ2VuTGVuZ3RoOiBnZW5MZW5ndGgsXG4gICAgICAgIGdlbmVyYXRlZExhYmVsczogZ2VuLFxuICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICBsYWJlbERlbGltaXRlcjogbGFiZWxEZWxpbWl0ZXJcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1c3RvbUxhYmVscztcbiAgfVxuXG4gIHJldHVybiBnZW47XG59O1xuXG52YXIgZDNfbGluZWFyTGVnZW5kID0gZnVuY3Rpb24gZDNfbGluZWFyTGVnZW5kKHNjYWxlLCBjZWxscywgbGFiZWxGb3JtYXQpIHtcbiAgdmFyIGRhdGEgPSBbXTtcblxuICBpZiAoY2VsbHMubGVuZ3RoID4gMSkge1xuICAgIGRhdGEgPSBjZWxscztcbiAgfSBlbHNlIHtcbiAgICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgIGluY3JlbWVudCA9IChkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdIC0gZG9tYWluWzBdKSAvIChjZWxscyAtIDEpO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgY2VsbHM7IGkrKykge1xuICAgICAgZGF0YS5wdXNoKGRvbWFpblswXSArIGkgKiBpbmNyZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYWJlbHMgPSBkYXRhLm1hcChsYWJlbEZvcm1hdCk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBsYWJlbHM6IGxhYmVscyxcbiAgICBmZWF0dXJlOiBmdW5jdGlvbiBmZWF0dXJlKGQpIHtcbiAgICAgIHJldHVybiBzY2FsZShkKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgZDNfcXVhbnRMZWdlbmQgPSBmdW5jdGlvbiBkM19xdWFudExlZ2VuZChzY2FsZSwgbGFiZWxGb3JtYXQsIGxhYmVsRGVsaW1pdGVyKSB7XG4gIHZhciBsYWJlbHMgPSBzY2FsZS5yYW5nZSgpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgIHZhciBpbnZlcnQgPSBzY2FsZS5pbnZlcnRFeHRlbnQoZCk7XG4gICAgcmV0dXJuIGxhYmVsRm9ybWF0KGludmVydFswXSkgKyBcIiBcIiArIGxhYmVsRGVsaW1pdGVyICsgXCIgXCIgKyBsYWJlbEZvcm1hdChpbnZlcnRbMV0pO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGRhdGE6IHNjYWxlLnJhbmdlKCksXG4gICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgZmVhdHVyZTogZDNfaWRlbnRpdHlcbiAgfTtcbn07XG5cbnZhciBkM19vcmRpbmFsTGVnZW5kID0gZnVuY3Rpb24gZDNfb3JkaW5hbExlZ2VuZChzY2FsZSkge1xuICByZXR1cm4ge1xuICAgIGRhdGE6IHNjYWxlLmRvbWFpbigpLFxuICAgIGxhYmVsczogc2NhbGUuZG9tYWluKCksXG4gICAgZmVhdHVyZTogZnVuY3Rpb24gZmVhdHVyZShkKSB7XG4gICAgICByZXR1cm4gc2NhbGUoZCk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGQzX2NlbGxPdmVyID0gZnVuY3Rpb24gZDNfY2VsbE92ZXIoY2VsbERpc3BhdGNoZXIsIGQsIG9iaikge1xuICBjZWxsRGlzcGF0Y2hlci5jYWxsKFwiY2VsbG92ZXJcIiwgb2JqLCBkKTtcbn07XG5cbnZhciBkM19jZWxsT3V0ID0gZnVuY3Rpb24gZDNfY2VsbE91dChjZWxsRGlzcGF0Y2hlciwgZCwgb2JqKSB7XG4gIGNlbGxEaXNwYXRjaGVyLmNhbGwoXCJjZWxsb3V0XCIsIG9iaiwgZCk7XG59O1xuXG52YXIgZDNfY2VsbENsaWNrID0gZnVuY3Rpb24gZDNfY2VsbENsaWNrKGNlbGxEaXNwYXRjaGVyLCBkLCBvYmopIHtcbiAgY2VsbERpc3BhdGNoZXIuY2FsbChcImNlbGxjbGlja1wiLCBvYmosIGQpO1xufTtcblxudmFyIGhlbHBlciA9IHtcbiAgZDNfZHJhd1NoYXBlczogZnVuY3Rpb24gZDNfZHJhd1NoYXBlcyhzaGFwZSwgc2hhcGVzLCBzaGFwZUhlaWdodCwgc2hhcGVXaWR0aCwgc2hhcGVSYWRpdXMsIHBhdGgpIHtcbiAgICBpZiAoc2hhcGUgPT09IFwicmVjdFwiKSB7XG4gICAgICBzaGFwZXMuYXR0cihcImhlaWdodFwiLCBzaGFwZUhlaWdodCkuYXR0cihcIndpZHRoXCIsIHNoYXBlV2lkdGgpO1xuICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgIHNoYXBlcy5hdHRyKFwiclwiLCBzaGFwZVJhZGl1cyk7XG4gICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gXCJsaW5lXCIpIHtcbiAgICAgIHNoYXBlcy5hdHRyKFwieDFcIiwgMCkuYXR0cihcIngyXCIsIHNoYXBlV2lkdGgpLmF0dHIoXCJ5MVwiLCAwKS5hdHRyKFwieTJcIiwgMCk7XG4gICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgIHNoYXBlcy5hdHRyKFwiZFwiLCBwYXRoKTtcbiAgICB9XG4gIH0sXG5cbiAgZDNfYWRkVGV4dDogZnVuY3Rpb24gZDNfYWRkVGV4dChzdmcsIGVudGVyLCBsYWJlbHMsIGNsYXNzUHJlZml4LCBsYWJlbFdpZHRoKSB7XG4gICAgZW50ZXIuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcImxhYmVsXCIpO1xuICAgIHZhciB0ZXh0ID0gc3ZnLnNlbGVjdEFsbChcImcuXCIgKyBjbGFzc1ByZWZpeCArIFwiY2VsbCB0ZXh0LlwiICsgY2xhc3NQcmVmaXggKyBcImxhYmVsXCIpLmRhdGEobGFiZWxzKS50ZXh0KGQzX2lkZW50aXR5KTtcblxuICAgIGlmIChsYWJlbFdpZHRoKSB7XG4gICAgICBzdmcuc2VsZWN0QWxsKFwiZy5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsIHRleHQuXCIgKyBjbGFzc1ByZWZpeCArIFwibGFiZWxcIikuY2FsbChkM190ZXh0V3JhcHBpbmcsIGxhYmVsV2lkdGgpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9LFxuXG4gIGQzX2NhbGNUeXBlOiBmdW5jdGlvbiBkM19jYWxjVHlwZShzY2FsZSwgYXNjZW5kaW5nLCBjZWxscywgbGFiZWxzLCBsYWJlbEZvcm1hdCwgbGFiZWxEZWxpbWl0ZXIpIHtcbiAgICB2YXIgdHlwZSA9IHNjYWxlLmludmVydEV4dGVudCA/IGQzX3F1YW50TGVnZW5kKHNjYWxlLCBsYWJlbEZvcm1hdCwgbGFiZWxEZWxpbWl0ZXIpIDogc2NhbGUudGlja3MgPyBkM19saW5lYXJMZWdlbmQoc2NhbGUsIGNlbGxzLCBsYWJlbEZvcm1hdCkgOiBkM19vcmRpbmFsTGVnZW5kKHNjYWxlKTtcblxuICAgIC8vZm9yIGQzLnNjYWxlU2VxdWVudGlhbCB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHJhbmdlIGZ1bmN0aW9uXG4gICAgdmFyIHJhbmdlID0gc2NhbGUucmFuZ2UgJiYgc2NhbGUucmFuZ2UoKSB8fCBzY2FsZS5kb21haW4oKTtcbiAgICB0eXBlLmxhYmVscyA9IGQzX21lcmdlTGFiZWxzKHR5cGUubGFiZWxzLCBsYWJlbHMsIHNjYWxlLmRvbWFpbigpLCByYW5nZSwgbGFiZWxEZWxpbWl0ZXIpO1xuXG4gICAgaWYgKGFzY2VuZGluZykge1xuICAgICAgdHlwZS5sYWJlbHMgPSBkM19yZXZlcnNlKHR5cGUubGFiZWxzKTtcbiAgICAgIHR5cGUuZGF0YSA9IGQzX3JldmVyc2UodHlwZS5kYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfSxcblxuICBkM19maWx0ZXJDZWxsczogZnVuY3Rpb24gZDNfZmlsdGVyQ2VsbHModHlwZSwgY2VsbEZpbHRlcikge1xuICAgIHZhciBmaWx0ZXJDZWxscyA9IHR5cGUuZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiB7IGRhdGE6IGQsIGxhYmVsOiB0eXBlLmxhYmVsc1tpXSB9O1xuICAgIH0pLmZpbHRlcihjZWxsRmlsdGVyKTtcbiAgICB2YXIgZGF0YVZhbHVlcyA9IGZpbHRlckNlbGxzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuZGF0YTtcbiAgICB9KTtcbiAgICB2YXIgbGFiZWxWYWx1ZXMgPSBmaWx0ZXJDZWxscy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmxhYmVsO1xuICAgIH0pO1xuICAgIHR5cGUuZGF0YSA9IHR5cGUuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkYXRhVmFsdWVzLmluZGV4T2YoZCkgIT09IC0xO1xuICAgIH0pO1xuICAgIHR5cGUubGFiZWxzID0gdHlwZS5sYWJlbHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gbGFiZWxWYWx1ZXMuaW5kZXhPZihkKSAhPT0gLTE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH0sXG5cbiAgZDNfcGxhY2VtZW50OiBmdW5jdGlvbiBkM19wbGFjZW1lbnQob3JpZW50LCBjZWxsLCBjZWxsVHJhbnMsIHRleHQsIHRleHRUcmFucywgbGFiZWxBbGlnbikge1xuICAgIGNlbGwuYXR0cihcInRyYW5zZm9ybVwiLCBjZWxsVHJhbnMpO1xuICAgIHRleHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnMpO1xuICAgIGlmIChvcmllbnQgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICB0ZXh0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgbGFiZWxBbGlnbik7XG4gICAgfVxuICB9LFxuXG4gIGQzX2FkZEV2ZW50czogZnVuY3Rpb24gZDNfYWRkRXZlbnRzKGNlbGxzLCBkaXNwYXRjaGVyKSB7XG4gICAgY2VsbHMub24oXCJtb3VzZW92ZXIubGVnZW5kXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBkM19jZWxsT3ZlcihkaXNwYXRjaGVyLCBkLCB0aGlzKTtcbiAgICB9KS5vbihcIm1vdXNlb3V0LmxlZ2VuZFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgZDNfY2VsbE91dChkaXNwYXRjaGVyLCBkLCB0aGlzKTtcbiAgICB9KS5vbihcImNsaWNrLmxlZ2VuZFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgZDNfY2VsbENsaWNrKGRpc3BhdGNoZXIsIGQsIHRoaXMpO1xuICAgIH0pO1xuICB9LFxuXG4gIGQzX3RpdGxlOiBmdW5jdGlvbiBkM190aXRsZShzdmcsIHRpdGxlLCBjbGFzc1ByZWZpeCwgdGl0bGVXaWR0aCkge1xuICAgIGlmICh0aXRsZSAhPT0gXCJcIikge1xuICAgICAgdmFyIHRpdGxlVGV4dCA9IHN2Zy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgY2xhc3NQcmVmaXggKyBcImxlZ2VuZFRpdGxlXCIpO1xuXG4gICAgICB0aXRsZVRleHQuZGF0YShbdGl0bGVdKS5lbnRlcigpLmFwcGVuZChcInRleHRcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJsZWdlbmRUaXRsZVwiKTtcblxuICAgICAgc3ZnLnNlbGVjdEFsbChcInRleHQuXCIgKyBjbGFzc1ByZWZpeCArIFwibGVnZW5kVGl0bGVcIikudGV4dCh0aXRsZSk7XG5cbiAgICAgIGlmICh0aXRsZVdpZHRoKSB7XG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgY2xhc3NQcmVmaXggKyBcImxlZ2VuZFRpdGxlXCIpLmNhbGwoZDNfdGV4dFdyYXBwaW5nLCB0aXRsZVdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlbGxzU3ZnID0gc3ZnLnNlbGVjdChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJsZWdlbmRDZWxsc1wiKTtcbiAgICAgIHZhciB5T2Zmc2V0ID0gc3ZnLnNlbGVjdChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJsZWdlbmRUaXRsZVwiKS5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgfSlbMF0sXG4gICAgICAgICAgeE9mZnNldCA9IC1jZWxsc1N2Zy5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRCQm94KCkueDtcbiAgICAgIH0pWzBdO1xuICAgICAgY2VsbHNTdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHhPZmZzZXQgKyBcIixcIiArIHlPZmZzZXQgKyBcIilcIik7XG4gICAgfVxuICB9LFxuXG4gIGQzX2RlZmF1bHRMb2NhbGU6IHtcbiAgICBmb3JtYXQ6IGQzRm9ybWF0LmZvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGQzRm9ybWF0LmZvcm1hdFByZWZpeFxuICB9LFxuXG4gIGQzX2RlZmF1bHRGb3JtYXRTcGVjaWZpZXI6IFwiLjAxZlwiLFxuXG4gIGQzX2RlZmF1bHREZWxpbWl0ZXI6IFwidG9cIlxufTtcblxuZnVuY3Rpb24gY29sb3IoKSB7XG4gIHZhciBzY2FsZSA9IGQzU2NhbGUuc2NhbGVMaW5lYXIoKSxcbiAgICAgIHNoYXBlID0gXCJyZWN0XCIsXG4gICAgICBzaGFwZVdpZHRoID0gMTUsXG4gICAgICBzaGFwZUhlaWdodCA9IDE1LFxuICAgICAgc2hhcGVSYWRpdXMgPSAxMCxcbiAgICAgIHNoYXBlUGFkZGluZyA9IDIsXG4gICAgICBjZWxscyA9IFs1XSxcbiAgICAgIGNlbGxGaWx0ZXIgPSB2b2lkIDAsXG4gICAgICBsYWJlbHMgPSBbXSxcbiAgICAgIGNsYXNzUHJlZml4ID0gXCJcIixcbiAgICAgIHVzZUNsYXNzID0gZmFsc2UsXG4gICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICBsb2NhbGUgPSBoZWxwZXIuZDNfZGVmYXVsdExvY2FsZSxcbiAgICAgIHNwZWNpZmllciA9IGhlbHBlci5kM19kZWZhdWx0Rm9ybWF0U3BlY2lmaWVyLFxuICAgICAgbGFiZWxPZmZzZXQgPSAxMCxcbiAgICAgIGxhYmVsQWxpZ24gPSBcIm1pZGRsZVwiLFxuICAgICAgbGFiZWxEZWxpbWl0ZXIgPSBoZWxwZXIuZDNfZGVmYXVsdERlbGltaXRlcixcbiAgICAgIGxhYmVsV3JhcCA9IHZvaWQgMCxcbiAgICAgIG9yaWVudCA9IFwidmVydGljYWxcIixcbiAgICAgIGFzY2VuZGluZyA9IGZhbHNlLFxuICAgICAgcGF0aCA9IHZvaWQgMCxcbiAgICAgIHRpdGxlV2lkdGggPSB2b2lkIDAsXG4gICAgICBsZWdlbmREaXNwYXRjaGVyID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcImNlbGxvdmVyXCIsIFwiY2VsbG91dFwiLCBcImNlbGxjbGlja1wiKTtcblxuICBmdW5jdGlvbiBsZWdlbmQoc3ZnKSB7XG4gICAgdmFyIHR5cGUgPSBoZWxwZXIuZDNfY2FsY1R5cGUoc2NhbGUsIGFzY2VuZGluZywgY2VsbHMsIGxhYmVscywgbG9jYWxlLmZvcm1hdChzcGVjaWZpZXIpLCBsYWJlbERlbGltaXRlciksXG4gICAgICAgIGxlZ2VuZEcgPSBzdmcuc2VsZWN0QWxsKFwiZ1wiKS5kYXRhKFtzY2FsZV0pO1xuXG4gICAgbGVnZW5kRy5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJsZWdlbmRDZWxsc1wiKTtcblxuICAgIGlmIChjZWxsRmlsdGVyKSB7XG4gICAgICBoZWxwZXIuZDNfZmlsdGVyQ2VsbHModHlwZSwgY2VsbEZpbHRlcik7XG4gICAgfVxuXG4gICAgdmFyIGNlbGwgPSBzdmcuc2VsZWN0KFwiLlwiICsgY2xhc3NQcmVmaXggKyBcImxlZ2VuZENlbGxzXCIpLnNlbGVjdEFsbChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpLmRhdGEodHlwZS5kYXRhKTtcblxuICAgIHZhciBjZWxsRW50ZXIgPSBjZWxsLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcImNlbGxcIik7XG4gICAgY2VsbEVudGVyLmFwcGVuZChzaGFwZSkuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJzd2F0Y2hcIik7XG5cbiAgICB2YXIgc2hhcGVzID0gc3ZnLnNlbGVjdEFsbChcImcuXCIgKyBjbGFzc1ByZWZpeCArIFwiY2VsbCBcIiArIHNoYXBlICsgXCIuXCIgKyBjbGFzc1ByZWZpeCArIFwic3dhdGNoXCIpLmRhdGEodHlwZS5kYXRhKTtcblxuICAgIC8vYWRkIGV2ZW50IGhhbmRsZXJzXG4gICAgaGVscGVyLmQzX2FkZEV2ZW50cyhjZWxsRW50ZXIsIGxlZ2VuZERpc3BhdGNoZXIpO1xuXG4gICAgY2VsbC5leGl0KCkudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBzaGFwZXMuZXhpdCgpLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG5cbiAgICBzaGFwZXMgPSBzaGFwZXMubWVyZ2Uoc2hhcGVzKTtcblxuICAgIGhlbHBlci5kM19kcmF3U2hhcGVzKHNoYXBlLCBzaGFwZXMsIHNoYXBlSGVpZ2h0LCBzaGFwZVdpZHRoLCBzaGFwZVJhZGl1cywgcGF0aCk7XG4gICAgdmFyIHRleHQgPSBoZWxwZXIuZDNfYWRkVGV4dChzdmcsIGNlbGxFbnRlciwgdHlwZS5sYWJlbHMsIGNsYXNzUHJlZml4LCBsYWJlbFdyYXApO1xuXG4gICAgLy8gd2UgbmVlZCB0byBtZXJnZSB0aGUgc2VsZWN0aW9uLCBvdGhlcndpc2UgY2hhbmdlcyBpbiB0aGUgbGVnZW5kIChlLmcuIGNoYW5nZSBvZiBvcmllbnRhdGlvbikgYXJlIGFwcGxpZWQgb25seSB0byB0aGUgbmV3IGNlbGxzIGFuZCBub3QgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgY2VsbCA9IGNlbGxFbnRlci5tZXJnZShjZWxsKTtcblxuICAgIC8vIHNldHMgcGxhY2VtZW50XG4gICAgdmFyIHRleHRTaXplID0gdGV4dC5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpO1xuICAgIH0pLFxuICAgICAgICBzaGFwZVNpemUgPSBzaGFwZXMubm9kZXMoKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmdldEJCb3goKTtcbiAgICB9KTtcbiAgICAvL3NldHMgc2NhbGVcbiAgICAvL2V2ZXJ5dGhpbmcgaXMgZmlsbCBleGNlcHQgZm9yIGxpbmUgd2hpY2ggaXMgc3Ryb2tlLFxuICAgIGlmICghdXNlQ2xhc3MpIHtcbiAgICAgIGlmIChzaGFwZSA9PSBcImxpbmVcIikge1xuICAgICAgICBzaGFwZXMuc3R5bGUoXCJzdHJva2VcIiwgdHlwZS5mZWF0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlcy5zdHlsZShcImZpbGxcIiwgdHlwZS5mZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcGVzLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gY2xhc3NQcmVmaXggKyBcInN3YXRjaCBcIiArIHR5cGUuZmVhdHVyZShkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjZWxsVHJhbnMgPSB2b2lkIDAsXG4gICAgICAgIHRleHRUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dEFsaWduID0gbGFiZWxBbGlnbiA9PSBcInN0YXJ0XCIgPyAwIDogbGFiZWxBbGlnbiA9PSBcIm1pZGRsZVwiID8gMC41IDogMTtcblxuICAgIC8vcG9zaXRpb25zIGNlbGxzIGFuZCB0ZXh0XG4gICAgaWYgKG9yaWVudCA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbFNpemUgPSB0ZXh0U2l6ZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZC5oZWlnaHQsIHNoYXBlU2l6ZVtpXS5oZWlnaHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjZWxsVHJhbnMgPSBmdW5jdGlvbiBjZWxsVHJhbnMoZCwgaSkge1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBkM0FycmF5LnN1bShjZWxsU2l6ZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsIFwiICsgKGhlaWdodCArIGkgKiBzaGFwZVBhZGRpbmcpICsgXCIpXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGV4dFRyYW5zID0gZnVuY3Rpb24gdGV4dFRyYW5zKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoIFwiICsgKHNoYXBlU2l6ZVtpXS53aWR0aCArIHNoYXBlU2l6ZVtpXS54ICsgbGFiZWxPZmZzZXQpICsgXCIsIFwiICsgKHNoYXBlU2l6ZVtpXS55ICsgc2hhcGVTaXplW2ldLmhlaWdodCAvIDIgKyA1KSArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKG9yaWVudCA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIGNlbGxUcmFucyA9IGZ1bmN0aW9uIGNlbGxUcmFucyhkLCBpKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIGkgKiAoc2hhcGVTaXplW2ldLndpZHRoICsgc2hhcGVQYWRkaW5nKSArIFwiLDApXCI7XG4gICAgICB9O1xuICAgICAgdGV4dFRyYW5zID0gZnVuY3Rpb24gdGV4dFRyYW5zKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKHNoYXBlU2l6ZVtpXS53aWR0aCAqIHRleHRBbGlnbiArIHNoYXBlU2l6ZVtpXS54KSArIFwiLFxcbiAgICAgICAgICBcIiArIChzaGFwZVNpemVbaV0uaGVpZ2h0ICsgc2hhcGVTaXplW2ldLnkgKyBsYWJlbE9mZnNldCArIDgpICsgXCIpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGhlbHBlci5kM19wbGFjZW1lbnQob3JpZW50LCBjZWxsLCBjZWxsVHJhbnMsIHRleHQsIHRleHRUcmFucywgbGFiZWxBbGlnbik7XG4gICAgaGVscGVyLmQzX3RpdGxlKHN2ZywgdGl0bGUsIGNsYXNzUHJlZml4LCB0aXRsZVdpZHRoKTtcblxuICAgIGNlbGwudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgfVxuXG4gIGxlZ2VuZC5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgc2NhbGUgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNlbGxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZWxscztcbiAgICBpZiAoXy5sZW5ndGggPiAxIHx8IF8gPj0gMikge1xuICAgICAgY2VsbHMgPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5jZWxsRmlsdGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZWxsRmlsdGVyO1xuICAgIGNlbGxGaWx0ZXIgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlID0gZnVuY3Rpb24gKF8sIGQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZTtcbiAgICBpZiAoXyA9PSBcInJlY3RcIiB8fCBfID09IFwiY2lyY2xlXCIgfHwgXyA9PSBcImxpbmVcIiB8fCBfID09IFwicGF0aFwiICYmIHR5cGVvZiBkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzaGFwZSA9IF87XG4gICAgICBwYXRoID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGVXaWR0aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVXaWR0aDtcbiAgICBzaGFwZVdpZHRoID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGVIZWlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlSGVpZ2h0O1xuICAgIHNoYXBlSGVpZ2h0ID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGVSYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlUmFkaXVzO1xuICAgIHNoYXBlUmFkaXVzID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGVQYWRkaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZVBhZGRpbmc7XG4gICAgc2hhcGVQYWRkaW5nID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbHM7XG4gICAgbGFiZWxzID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbEFsaWduID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbEFsaWduO1xuICAgIGlmIChfID09IFwic3RhcnRcIiB8fCBfID09IFwiZW5kXCIgfHwgXyA9PSBcIm1pZGRsZVwiKSB7XG4gICAgICBsYWJlbEFsaWduID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubG9jYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb2NhbGU7XG4gICAgbG9jYWxlID0gZDNGb3JtYXQuZm9ybWF0TG9jYWxlKF8pO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsRm9ybWF0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsZWdlbmQubG9jYWxlKCkuZm9ybWF0KHNwZWNpZmllcik7XG4gICAgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0U3BlY2lmaWVyKF8pO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsT2Zmc2V0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbE9mZnNldDtcbiAgICBsYWJlbE9mZnNldCA9ICtfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsRGVsaW1pdGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbERlbGltaXRlcjtcbiAgICBsYWJlbERlbGltaXRlciA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxXcmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbFdyYXA7XG4gICAgbGFiZWxXcmFwID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC51c2VDbGFzcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdXNlQ2xhc3M7XG4gICAgaWYgKF8gPT09IHRydWUgfHwgXyA9PT0gZmFsc2UpIHtcbiAgICAgIHVzZUNsYXNzID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgXyA9IF8udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoXyA9PSBcImhvcml6b250YWxcIiB8fCBfID09IFwidmVydGljYWxcIikge1xuICAgICAgb3JpZW50ID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuYXNjZW5kaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhc2NlbmRpbmc7XG4gICAgYXNjZW5kaW5nID0gISFfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNsYXNzUHJlZml4ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFzc1ByZWZpeDtcbiAgICBjbGFzc1ByZWZpeCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIHRpdGxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVdpZHRoO1xuICAgIHRpdGxlV2lkdGggPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnRleHRXcmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0ZXh0V3JhcDtcbiAgICB0ZXh0V3JhcCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gbGVnZW5kRGlzcGF0Y2hlci5vbi5hcHBseShsZWdlbmREaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGVnZW5kRGlzcGF0Y2hlciA/IGxlZ2VuZCA6IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBsZWdlbmQ7XG59XG5cbmZ1bmN0aW9uIHNpemUoKSB7XG4gIHZhciBzY2FsZSA9IGQzU2NhbGUuc2NhbGVMaW5lYXIoKSxcbiAgICAgIHNoYXBlID0gXCJyZWN0XCIsXG4gICAgICBzaGFwZVdpZHRoID0gMTUsXG4gICAgICBzaGFwZVBhZGRpbmcgPSAyLFxuICAgICAgY2VsbHMgPSBbNV0sXG4gICAgICBjZWxsRmlsdGVyID0gdm9pZCAwLFxuICAgICAgbGFiZWxzID0gW10sXG4gICAgICBjbGFzc1ByZWZpeCA9IFwiXCIsXG4gICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICBsb2NhbGUgPSBoZWxwZXIuZDNfZGVmYXVsdExvY2FsZSxcbiAgICAgIHNwZWNpZmllciA9IGhlbHBlci5kM19kZWZhdWx0Rm9ybWF0U3BlY2lmaWVyLFxuICAgICAgbGFiZWxPZmZzZXQgPSAxMCxcbiAgICAgIGxhYmVsQWxpZ24gPSBcIm1pZGRsZVwiLFxuICAgICAgbGFiZWxEZWxpbWl0ZXIgPSBoZWxwZXIuZDNfZGVmYXVsdERlbGltaXRlcixcbiAgICAgIGxhYmVsV3JhcCA9IHZvaWQgMCxcbiAgICAgIG9yaWVudCA9IFwidmVydGljYWxcIixcbiAgICAgIGFzY2VuZGluZyA9IGZhbHNlLFxuICAgICAgcGF0aCA9IHZvaWQgMCxcbiAgICAgIHRpdGxlV2lkdGggPSB2b2lkIDAsXG4gICAgICBsZWdlbmREaXNwYXRjaGVyID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcImNlbGxvdmVyXCIsIFwiY2VsbG91dFwiLCBcImNlbGxjbGlja1wiKTtcblxuICBmdW5jdGlvbiBsZWdlbmQoc3ZnKSB7XG4gICAgdmFyIHR5cGUgPSBoZWxwZXIuZDNfY2FsY1R5cGUoc2NhbGUsIGFzY2VuZGluZywgY2VsbHMsIGxhYmVscywgbG9jYWxlLmZvcm1hdChzcGVjaWZpZXIpLCBsYWJlbERlbGltaXRlciksXG4gICAgICAgIGxlZ2VuZEcgPSBzdmcuc2VsZWN0QWxsKFwiZ1wiKS5kYXRhKFtzY2FsZV0pO1xuXG4gICAgaWYgKGNlbGxGaWx0ZXIpIHtcbiAgICAgIGhlbHBlci5kM19maWx0ZXJDZWxscyh0eXBlLCBjZWxsRmlsdGVyKTtcbiAgICB9XG5cbiAgICBsZWdlbmRHLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcImxlZ2VuZENlbGxzXCIpO1xuXG4gICAgdmFyIGNlbGwgPSBzdmcuc2VsZWN0KFwiLlwiICsgY2xhc3NQcmVmaXggKyBcImxlZ2VuZENlbGxzXCIpLnNlbGVjdEFsbChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpLmRhdGEodHlwZS5kYXRhKTtcbiAgICB2YXIgY2VsbEVudGVyID0gY2VsbC5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpO1xuICAgIGNlbGxFbnRlci5hcHBlbmQoc2hhcGUpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwic3dhdGNoXCIpO1xuXG4gICAgdmFyIHNoYXBlcyA9IHN2Zy5zZWxlY3RBbGwoXCJnLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGwgXCIgKyBzaGFwZSArIFwiLlwiICsgY2xhc3NQcmVmaXggKyBcInN3YXRjaFwiKTtcblxuICAgIC8vYWRkIGV2ZW50IGhhbmRsZXJzXG4gICAgaGVscGVyLmQzX2FkZEV2ZW50cyhjZWxsRW50ZXIsIGxlZ2VuZERpc3BhdGNoZXIpO1xuXG4gICAgY2VsbC5leGl0KCkudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcblxuICAgIHNoYXBlcy5leGl0KCkudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBzaGFwZXMgPSBzaGFwZXMubWVyZ2Uoc2hhcGVzKTtcblxuICAgIC8vY3JlYXRlcyBzaGFwZVxuICAgIGlmIChzaGFwZSA9PT0gXCJsaW5lXCIpIHtcbiAgICAgIGhlbHBlci5kM19kcmF3U2hhcGVzKHNoYXBlLCBzaGFwZXMsIDAsIHNoYXBlV2lkdGgpO1xuICAgICAgc2hhcGVzLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgdHlwZS5mZWF0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVscGVyLmQzX2RyYXdTaGFwZXMoc2hhcGUsIHNoYXBlcywgdHlwZS5mZWF0dXJlLCB0eXBlLmZlYXR1cmUsIHR5cGUuZmVhdHVyZSwgcGF0aCk7XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBoZWxwZXIuZDNfYWRkVGV4dChzdmcsIGNlbGxFbnRlciwgdHlwZS5sYWJlbHMsIGNsYXNzUHJlZml4LCBsYWJlbFdyYXApO1xuXG4gICAgLy8gd2UgbmVlZCB0byBtZXJnZSB0aGUgc2VsZWN0aW9uLCBvdGhlcndpc2UgY2hhbmdlcyBpbiB0aGUgbGVnZW5kIChlLmcuIGNoYW5nZSBvZiBvcmllbnRhdGlvbikgYXJlIGFwcGxpZWQgb25seSB0byB0aGUgbmV3IGNlbGxzIGFuZCBub3QgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgY2VsbCA9IGNlbGxFbnRlci5tZXJnZShjZWxsKTtcblxuICAgIC8vc2V0cyBwbGFjZW1lbnRcblxuICAgIHZhciB0ZXh0U2l6ZSA9IHRleHQubm9kZXMoKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmdldEJCb3goKTtcbiAgICB9KSxcbiAgICAgICAgc2hhcGVTaXplID0gc2hhcGVzLm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgYmJveCA9IGQuZ2V0QkJveCgpO1xuICAgICAgdmFyIHN0cm9rZSA9IHNjYWxlKHR5cGUuZGF0YVtpXSk7XG5cbiAgICAgIGlmIChzaGFwZSA9PT0gXCJsaW5lXCIgJiYgb3JpZW50ID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICBiYm94LmhlaWdodCA9IGJib3guaGVpZ2h0ICsgc3Ryb2tlO1xuICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gXCJsaW5lXCIgJiYgb3JpZW50ID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgYmJveC53aWR0aCA9IGJib3gud2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmJveDtcbiAgICB9KTtcblxuICAgIHZhciBtYXhIID0gZDNBcnJheS5tYXgoc2hhcGVTaXplLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuaGVpZ2h0ICsgZC55O1xuICAgIH0pLFxuICAgICAgICBtYXhXID0gZDNBcnJheS5tYXgoc2hhcGVTaXplLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQud2lkdGggKyBkLng7XG4gICAgfSk7XG5cbiAgICB2YXIgY2VsbFRyYW5zID0gdm9pZCAwLFxuICAgICAgICB0ZXh0VHJhbnMgPSB2b2lkIDAsXG4gICAgICAgIHRleHRBbGlnbiA9IGxhYmVsQWxpZ24gPT0gXCJzdGFydFwiID8gMCA6IGxhYmVsQWxpZ24gPT0gXCJtaWRkbGVcIiA/IDAuNSA6IDE7XG5cbiAgICAvL3Bvc2l0aW9ucyBjZWxscyBhbmQgdGV4dFxuICAgIGlmIChvcmllbnQgPT09IFwidmVydGljYWxcIikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGxTaXplID0gdGV4dFNpemUubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGQuaGVpZ2h0LCBzaGFwZVNpemVbaV0uaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB5ID0gc2hhcGUgPT0gXCJjaXJjbGVcIiB8fCBzaGFwZSA9PSBcImxpbmVcIiA/IHNoYXBlU2l6ZVswXS5oZWlnaHQgLyAyIDogMDtcbiAgICAgICAgY2VsbFRyYW5zID0gZnVuY3Rpb24gY2VsbFRyYW5zKGQsIGkpIHtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gZDNBcnJheS5zdW0oY2VsbFNpemUuc2xpY2UoMCwgaSkpO1xuXG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsIFwiICsgKHkgKyBoZWlnaHQgKyBpICogc2hhcGVQYWRkaW5nKSArIFwiKVwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRleHRUcmFucyA9IGZ1bmN0aW9uIHRleHRUcmFucyhkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKCBcIiArIChtYXhXICsgbGFiZWxPZmZzZXQpICsgXCIsXFxuICAgICAgICAgIFwiICsgKHNoYXBlU2l6ZVtpXS55ICsgc2hhcGVTaXplW2ldLmhlaWdodCAvIDIgKyA1KSArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKG9yaWVudCA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNlbGxUcmFucyA9IGZ1bmN0aW9uIGNlbGxUcmFucyhkLCBpKSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gZDNBcnJheS5zdW0oc2hhcGVTaXplLnNsaWNlKDAsIGkpLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQud2lkdGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHkgPSBzaGFwZSA9PSBcImNpcmNsZVwiIHx8IHNoYXBlID09IFwibGluZVwiID8gbWF4SCAvIDIgOiAwO1xuICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArICh3aWR0aCArIGkgKiBzaGFwZVBhZGRpbmcpICsgXCIsIFwiICsgeSArIFwiKVwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBzaGFwZSA9PSBcImxpbmVcIiA/IG1heEggLyAyIDogbWF4SDtcbiAgICAgICAgdGV4dFRyYW5zID0gZnVuY3Rpb24gdGV4dFRyYW5zKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoIFwiICsgKHNoYXBlU2l6ZVtpXS53aWR0aCAqIHRleHRBbGlnbiArIHNoYXBlU2l6ZVtpXS54KSArIFwiLFxcbiAgICAgICAgICAgICAgXCIgKyAob2Zmc2V0ICsgbGFiZWxPZmZzZXQpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIGhlbHBlci5kM19wbGFjZW1lbnQob3JpZW50LCBjZWxsLCBjZWxsVHJhbnMsIHRleHQsIHRleHRUcmFucywgbGFiZWxBbGlnbik7XG4gICAgaGVscGVyLmQzX3RpdGxlKHN2ZywgdGl0bGUsIGNsYXNzUHJlZml4LCB0aXRsZVdpZHRoKTtcblxuICAgIGNlbGwudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgfVxuXG4gIGxlZ2VuZC5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgc2NhbGUgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNlbGxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZWxscztcbiAgICBpZiAoXy5sZW5ndGggPiAxIHx8IF8gPj0gMikge1xuICAgICAgY2VsbHMgPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5jZWxsRmlsdGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZWxsRmlsdGVyO1xuICAgIGNlbGxGaWx0ZXIgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlID0gZnVuY3Rpb24gKF8sIGQpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZTtcbiAgICBpZiAoXyA9PSBcInJlY3RcIiB8fCBfID09IFwiY2lyY2xlXCIgfHwgXyA9PSBcImxpbmVcIikge1xuICAgICAgc2hhcGUgPSBfO1xuICAgICAgcGF0aCA9IGQ7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlV2lkdGggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlV2lkdGg7XG4gICAgc2hhcGVXaWR0aCA9ICtfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlUGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVQYWRkaW5nO1xuICAgIHNoYXBlUGFkZGluZyA9ICtfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVscyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxzO1xuICAgIGxhYmVscyA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxBbGlnbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxBbGlnbjtcbiAgICBpZiAoXyA9PSBcInN0YXJ0XCIgfHwgXyA9PSBcImVuZFwiIHx8IF8gPT0gXCJtaWRkbGVcIikge1xuICAgICAgbGFiZWxBbGlnbiA9IF87XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxvY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG9jYWxlO1xuICAgIGxvY2FsZSA9IGQzRm9ybWF0LmZvcm1hdExvY2FsZShfKTtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbEZvcm1hdCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGVnZW5kLmxvY2FsZSgpLmZvcm1hdChzcGVjaWZpZXIpO1xuICAgIHNwZWNpZmllciA9IGQzRm9ybWF0LmZvcm1hdFNwZWNpZmllcihfKTtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbE9mZnNldCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxPZmZzZXQ7XG4gICAgbGFiZWxPZmZzZXQgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbERlbGltaXRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxEZWxpbWl0ZXI7XG4gICAgbGFiZWxEZWxpbWl0ZXIgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsV3JhcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxXcmFwO1xuICAgIGxhYmVsV3JhcCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgXyA9IF8udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoXyA9PSBcImhvcml6b250YWxcIiB8fCBfID09IFwidmVydGljYWxcIikge1xuICAgICAgb3JpZW50ID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuYXNjZW5kaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhc2NlbmRpbmc7XG4gICAgYXNjZW5kaW5nID0gISFfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNsYXNzUHJlZml4ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFzc1ByZWZpeDtcbiAgICBjbGFzc1ByZWZpeCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIHRpdGxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVdpZHRoO1xuICAgIHRpdGxlV2lkdGggPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLm9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IGxlZ2VuZERpc3BhdGNoZXIub24uYXBwbHkobGVnZW5kRGlzcGF0Y2hlciwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxlZ2VuZERpc3BhdGNoZXIgPyBsZWdlbmQgOiB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gbGVnZW5kO1xufVxuXG5mdW5jdGlvbiBzeW1ib2woKSB7XG4gIHZhciBzY2FsZSA9IGQzU2NhbGUuc2NhbGVMaW5lYXIoKSxcbiAgICAgIHNoYXBlID0gXCJwYXRoXCIsXG4gICAgICBzaGFwZVdpZHRoID0gMTUsXG4gICAgICBzaGFwZUhlaWdodCA9IDE1LFxuICAgICAgc2hhcGVSYWRpdXMgPSAxMCxcbiAgICAgIHNoYXBlUGFkZGluZyA9IDUsXG4gICAgICBjZWxscyA9IFs1XSxcbiAgICAgIGNlbGxGaWx0ZXIgPSB2b2lkIDAsXG4gICAgICBsYWJlbHMgPSBbXSxcbiAgICAgIGNsYXNzUHJlZml4ID0gXCJcIixcbiAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgIGxvY2FsZSA9IGhlbHBlci5kM19kZWZhdWx0TG9jYWxlLFxuICAgICAgc3BlY2lmaWVyID0gaGVscGVyLmQzX2RlZmF1bHRGb3JtYXRTcGVjaWZpZXIsXG4gICAgICBsYWJlbEFsaWduID0gXCJtaWRkbGVcIixcbiAgICAgIGxhYmVsT2Zmc2V0ID0gMTAsXG4gICAgICBsYWJlbERlbGltaXRlciA9IGhlbHBlci5kM19kZWZhdWx0RGVsaW1pdGVyLFxuICAgICAgbGFiZWxXcmFwID0gdm9pZCAwLFxuICAgICAgb3JpZW50ID0gXCJ2ZXJ0aWNhbFwiLFxuICAgICAgYXNjZW5kaW5nID0gZmFsc2UsXG4gICAgICB0aXRsZVdpZHRoID0gdm9pZCAwLFxuICAgICAgbGVnZW5kRGlzcGF0Y2hlciA9IGQzRGlzcGF0Y2guZGlzcGF0Y2goXCJjZWxsb3ZlclwiLCBcImNlbGxvdXRcIiwgXCJjZWxsY2xpY2tcIik7XG5cbiAgZnVuY3Rpb24gbGVnZW5kKHN2Zykge1xuICAgIHZhciB0eXBlID0gaGVscGVyLmQzX2NhbGNUeXBlKHNjYWxlLCBhc2NlbmRpbmcsIGNlbGxzLCBsYWJlbHMsIGxvY2FsZS5mb3JtYXQoc3BlY2lmaWVyKSwgbGFiZWxEZWxpbWl0ZXIpLFxuICAgICAgICBsZWdlbmRHID0gc3ZnLnNlbGVjdEFsbChcImdcIikuZGF0YShbc2NhbGVdKTtcblxuICAgIGlmIChjZWxsRmlsdGVyKSB7XG4gICAgICBoZWxwZXIuZDNfZmlsdGVyQ2VsbHModHlwZSwgY2VsbEZpbHRlcik7XG4gICAgfVxuXG4gICAgbGVnZW5kRy5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJsZWdlbmRDZWxsc1wiKTtcblxuICAgIHZhciBjZWxsID0gc3ZnLnNlbGVjdChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJsZWdlbmRDZWxsc1wiKS5zZWxlY3RBbGwoXCIuXCIgKyBjbGFzc1ByZWZpeCArIFwiY2VsbFwiKS5kYXRhKHR5cGUuZGF0YSk7XG4gICAgdmFyIGNlbGxFbnRlciA9IGNlbGwuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwiY2VsbFwiKTtcbiAgICBjZWxsRW50ZXIuYXBwZW5kKHNoYXBlKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcInN3YXRjaFwiKTtcblxuICAgIHZhciBzaGFwZXMgPSBzdmcuc2VsZWN0QWxsKFwiZy5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsIFwiICsgc2hhcGUgKyBcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJzd2F0Y2hcIik7XG5cbiAgICAvL2FkZCBldmVudCBoYW5kbGVyc1xuICAgIGhlbHBlci5kM19hZGRFdmVudHMoY2VsbEVudGVyLCBsZWdlbmREaXNwYXRjaGVyKTtcblxuICAgIC8vcmVtb3ZlIG9sZCBzaGFwZXNcbiAgICBjZWxsLmV4aXQoKS50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuICAgIHNoYXBlcy5leGl0KCkudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcbiAgICBzaGFwZXMgPSBzaGFwZXMubWVyZ2Uoc2hhcGVzKTtcblxuICAgIGhlbHBlci5kM19kcmF3U2hhcGVzKHNoYXBlLCBzaGFwZXMsIHNoYXBlSGVpZ2h0LCBzaGFwZVdpZHRoLCBzaGFwZVJhZGl1cywgdHlwZS5mZWF0dXJlKTtcbiAgICB2YXIgdGV4dCA9IGhlbHBlci5kM19hZGRUZXh0KHN2ZywgY2VsbEVudGVyLCB0eXBlLmxhYmVscywgY2xhc3NQcmVmaXgsIGxhYmVsV3JhcCk7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIHRoZSBzZWxlY3Rpb24sIG90aGVyd2lzZSBjaGFuZ2VzIGluIHRoZSBsZWdlbmQgKGUuZy4gY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBhcmUgYXBwbGllZCBvbmx5IHRvIHRoZSBuZXcgY2VsbHMgYW5kIG5vdCB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBjZWxsID0gY2VsbEVudGVyLm1lcmdlKGNlbGwpO1xuXG4gICAgLy8gc2V0cyBwbGFjZW1lbnRcbiAgICB2YXIgdGV4dFNpemUgPSB0ZXh0Lm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5nZXRCQm94KCk7XG4gICAgfSksXG4gICAgICAgIHNoYXBlU2l6ZSA9IHNoYXBlcy5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpO1xuICAgIH0pO1xuXG4gICAgdmFyIG1heEggPSBkM0FycmF5Lm1heChzaGFwZVNpemUsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5oZWlnaHQ7XG4gICAgfSksXG4gICAgICAgIG1heFcgPSBkM0FycmF5Lm1heChzaGFwZVNpemUsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC53aWR0aDtcbiAgICB9KTtcblxuICAgIHZhciBjZWxsVHJhbnMgPSB2b2lkIDAsXG4gICAgICAgIHRleHRUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dEFsaWduID0gbGFiZWxBbGlnbiA9PSBcInN0YXJ0XCIgPyAwIDogbGFiZWxBbGlnbiA9PSBcIm1pZGRsZVwiID8gMC41IDogMTtcblxuICAgIC8vcG9zaXRpb25zIGNlbGxzIGFuZCB0ZXh0XG4gICAgaWYgKG9yaWVudCA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbFNpemUgPSB0ZXh0U2l6ZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgobWF4SCwgZC5oZWlnaHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjZWxsVHJhbnMgPSBmdW5jdGlvbiBjZWxsVHJhbnMoZCwgaSkge1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBkM0FycmF5LnN1bShjZWxsU2l6ZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsIFwiICsgKGhlaWdodCArIGkgKiBzaGFwZVBhZGRpbmcpICsgXCIgKVwiO1xuICAgICAgICB9O1xuICAgICAgICB0ZXh0VHJhbnMgPSBmdW5jdGlvbiB0ZXh0VHJhbnMoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSggXCIgKyAobWF4VyArIGxhYmVsT2Zmc2V0KSArIFwiLFxcbiAgICAgICAgICAgICAgXCIgKyAoc2hhcGVTaXplW2ldLnkgKyBzaGFwZVNpemVbaV0uaGVpZ2h0IC8gMiArIDUpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAob3JpZW50ID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgY2VsbFRyYW5zID0gZnVuY3Rpb24gY2VsbFRyYW5zKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKCBcIiArIGkgKiAobWF4VyArIHNoYXBlUGFkZGluZykgKyBcIiwwKVwiO1xuICAgICAgfTtcbiAgICAgIHRleHRUcmFucyA9IGZ1bmN0aW9uIHRleHRUcmFucyhkLCBpKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSggXCIgKyAoc2hhcGVTaXplW2ldLndpZHRoICogdGV4dEFsaWduICsgc2hhcGVTaXplW2ldLngpICsgXCIsXFxuICAgICAgICAgICAgICBcIiArIChtYXhIICsgbGFiZWxPZmZzZXQpICsgXCIpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGhlbHBlci5kM19wbGFjZW1lbnQob3JpZW50LCBjZWxsLCBjZWxsVHJhbnMsIHRleHQsIHRleHRUcmFucywgbGFiZWxBbGlnbik7XG4gICAgaGVscGVyLmQzX3RpdGxlKHN2ZywgdGl0bGUsIGNsYXNzUHJlZml4LCB0aXRsZVdpZHRoKTtcbiAgICBjZWxsLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gIH1cblxuICBsZWdlbmQuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgIHNjYWxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5jZWxscyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VsbHM7XG4gICAgaWYgKF8ubGVuZ3RoID4gMSB8fCBfID49IDIpIHtcbiAgICAgIGNlbGxzID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2VsbEZpbHRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VsbEZpbHRlcjtcbiAgICBjZWxsRmlsdGVyID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlUGFkZGluZztcbiAgICBzaGFwZVBhZGRpbmcgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVscztcbiAgICBsYWJlbHMgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsQWxpZ24gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsQWxpZ247XG4gICAgaWYgKF8gPT0gXCJzdGFydFwiIHx8IF8gPT0gXCJlbmRcIiB8fCBfID09IFwibWlkZGxlXCIpIHtcbiAgICAgIGxhYmVsQWxpZ24gPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sb2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvY2FsZTtcbiAgICBsb2NhbGUgPSBkM0Zvcm1hdC5mb3JtYXRMb2NhbGUoXyk7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxGb3JtYXQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxlZ2VuZC5sb2NhbGUoKS5mb3JtYXQoc3BlY2lmaWVyKTtcbiAgICBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXRTcGVjaWZpZXIoXyk7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxPZmZzZXQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsT2Zmc2V0O1xuICAgIGxhYmVsT2Zmc2V0ID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxEZWxpbWl0ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsRGVsaW1pdGVyO1xuICAgIGxhYmVsRGVsaW1pdGVyID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbFdyYXAgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsV3JhcDtcbiAgICBsYWJlbFdyYXAgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLm9yaWVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50O1xuICAgIF8gPSBfLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKF8gPT0gXCJob3Jpem9udGFsXCIgfHwgXyA9PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgIG9yaWVudCA9IF87XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmFzY2VuZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYXNjZW5kaW5nO1xuICAgIGFzY2VuZGluZyA9ICEhXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5jbGFzc1ByZWZpeCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xhc3NQcmVmaXg7XG4gICAgY2xhc3NQcmVmaXggPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnRpdGxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZTtcbiAgICB0aXRsZSA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGVXaWR0aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGVXaWR0aDtcbiAgICB0aXRsZVdpZHRoID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBsZWdlbmREaXNwYXRjaGVyLm9uLmFwcGx5KGxlZ2VuZERpc3BhdGNoZXIsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsZWdlbmREaXNwYXRjaGVyID8gbGVnZW5kIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGxlZ2VuZDtcbn1cblxudmFyIHRocmVzaG9sZExhYmVscyA9IGZ1bmN0aW9uIHRocmVzaG9sZExhYmVscyhfcmVmKSB7XG4gIHZhciBpID0gX3JlZi5pLFxuICAgICAgZ2VuTGVuZ3RoID0gX3JlZi5nZW5MZW5ndGgsXG4gICAgICBnZW5lcmF0ZWRMYWJlbHMgPSBfcmVmLmdlbmVyYXRlZExhYmVscyxcbiAgICAgIGxhYmVsRGVsaW1pdGVyID0gX3JlZi5sYWJlbERlbGltaXRlcjtcblxuICBpZiAoaSA9PT0gMCkge1xuICAgIHZhciB2YWx1ZXMgPSBnZW5lcmF0ZWRMYWJlbHNbaV0uc3BsaXQoXCIgXCIgKyBsYWJlbERlbGltaXRlciArIFwiIFwiKTtcbiAgICByZXR1cm4gXCJMZXNzIHRoYW4gXCIgKyB2YWx1ZXNbMV07XG4gIH0gZWxzZSBpZiAoaSA9PT0gZ2VuTGVuZ3RoIC0gMSkge1xuICAgIHZhciBfdmFsdWVzID0gZ2VuZXJhdGVkTGFiZWxzW2ldLnNwbGl0KFwiIFwiICsgbGFiZWxEZWxpbWl0ZXIgKyBcIiBcIik7XG4gICAgcmV0dXJuIF92YWx1ZXNbMF0gKyBcIiBvciBtb3JlXCI7XG4gIH1cbiAgcmV0dXJuIGdlbmVyYXRlZExhYmVsc1tpXTtcbn07XG5cbnZhciBsZWdlbmRIZWxwZXJzID0ge1xuICB0aHJlc2hvbGRMYWJlbHM6IHRocmVzaG9sZExhYmVsc1xufTtcblxudmFyIGluZGV4ID0ge1xuICBsZWdlbmRDb2xvcjogY29sb3IsXG4gIGxlZ2VuZFNpemU6IHNpemUsXG4gIGxlZ2VuZFN5bWJvbDogc3ltYm9sLFxuICBsZWdlbmRIZWxwZXJzOiBsZWdlbmRIZWxwZXJzXG59O1xuXG5leHBvcnRzLmxlZ2VuZENvbG9yID0gY29sb3I7XG5leHBvcnRzLmxlZ2VuZFNpemUgPSBzaXplO1xuZXhwb3J0cy5sZWdlbmRTeW1ib2wgPSBzeW1ib2w7XG5leHBvcnRzLmxlZ2VuZEhlbHBlcnMgPSBsZWdlbmRIZWxwZXJzO1xuZXhwb3J0c1snZGVmYXVsdCddID0gaW5kZXg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleFJvbGx1cC5qcy5tYXBcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtYXJyYXkvIFZlcnNpb24gMS4wLjEuIENvcHlyaWdodCAyMDE2IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlzZWN0b3IoY29tcGFyZSkge1xuICAgIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoY29tcGFyZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfSxcbiAgICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQsIHgpIHtcbiAgICAgIHJldHVybiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuICB2YXIgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG4gIHZhciBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5cbiAgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xuICB9XG5cbiAgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xuICB9XG5cbiAgZnVuY3Rpb24gdmFyaWFuY2UoYXJyYXksIGYpIHtcbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgbSA9IDAsXG4gICAgICAgIGEsXG4gICAgICAgIGQsXG4gICAgICAgIHMgPSAwLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIGogPSAwO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKCFpc05hTihhID0gbnVtYmVyKGFycmF5W2ldKSkpIHtcbiAgICAgICAgICBkID0gYSAtIG07XG4gICAgICAgICAgbSArPSBkIC8gKytqO1xuICAgICAgICAgIHMgKz0gZCAqIChhIC0gbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICghaXNOYU4oYSA9IG51bWJlcihmKGFycmF5W2ldLCBpLCBhcnJheSkpKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChqID4gMSkgcmV0dXJuIHMgLyAoaiAtIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV2aWF0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIHYgPSB2YXJpYW5jZShhcnJheSwgZik7XG4gICAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW50KGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYztcblxuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGMgPSBiOyBicmVhazsgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikgYSA9IGI7XG4gICAgICAgIGlmIChjIDwgYikgYyA9IGI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYyA9IGI7IGJyZWFrOyB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikgYSA9IGI7XG4gICAgICAgIGlmIChjIDwgYikgYyA9IGI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFthLCBjXTtcbiAgfVxuXG4gIHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiAgdmFyIG1hcCA9IGFycmF5Lm1hcDtcblxuICBmdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKSB8IDAsXG4gICAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHJhbmdlW2ldID0gc3RhcnQgKyBpICogc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICB2YXIgZTEwID0gTWF0aC5zcXJ0KDUwKTtcbiAgdmFyIGU1ID0gTWF0aC5zcXJ0KDEwKTtcbiAgdmFyIGUyID0gTWF0aC5zcXJ0KDIpO1xuICBmdW5jdGlvbiB0aWNrcyhzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgICB2YXIgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgcmV0dXJuIHJhbmdlKFxuICAgICAgTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCkgKiBzdGVwLFxuICAgICAgTWF0aC5mbG9vcihzdG9wIC8gc3RlcCkgKiBzdGVwICsgc3RlcCAvIDIsIC8vIGluY2x1c2l2ZVxuICAgICAgc3RlcFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgICB2YXIgc3RlcDAgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgICBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLFxuICAgICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gICAgaWYgKGVycm9yID49IGUxMCkgc3RlcDEgKj0gMTA7XG4gICAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAxICo9IDU7XG4gICAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAxICo9IDI7XG4gICAgcmV0dXJuIHN0b3AgPCBzdGFydCA/IC1zdGVwMSA6IHN0ZXAxO1xuICB9XG5cbiAgZnVuY3Rpb24gc3R1cmdlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIpICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpc3RvZ3JhbSgpIHtcbiAgICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgICAgZG9tYWluID0gZXh0ZW50LFxuICAgICAgICB0aHJlc2hvbGQgPSBzdHVyZ2VzO1xuXG4gICAgZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICB4LFxuICAgICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHh6ID0gZG9tYWluKHZhbHVlcyksXG4gICAgICAgICAgeDAgPSB4elswXSxcbiAgICAgICAgICB4MSA9IHh6WzFdLFxuICAgICAgICAgIHR6ID0gdGhyZXNob2xkKHZhbHVlcywgeDAsIHgxKTtcblxuICAgICAgLy8gQ29udmVydCBudW1iZXIgb2YgdGhyZXNob2xkcyBpbnRvIHVuaWZvcm0gdGhyZXNob2xkcy5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHR6ID0gdGlja3MoeDAsIHgxLCB0eik7XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgdGhyZXNob2xkcyBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgICB2YXIgbSA9IHR6Lmxlbmd0aDtcbiAgICAgIHdoaWxlICh0elswXSA8PSB4MCkgdHouc2hpZnQoKSwgLS1tO1xuICAgICAgd2hpbGUgKHR6W20gLSAxXSA+PSB4MSkgdHoucG9wKCksIC0tbTtcblxuICAgICAgdmFyIGJpbnMgPSBuZXcgQXJyYXkobSArIDEpLFxuICAgICAgICAgIGJpbjtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBiaW5zLlxuICAgICAgZm9yIChpID0gMDsgaSA8PSBtOyArK2kpIHtcbiAgICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgICBiaW4ueDAgPSBpID4gMCA/IHR6W2kgLSAxXSA6IHgwO1xuICAgICAgICBiaW4ueDEgPSBpIDwgbSA/IHR6W2ldIDogeDE7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc2lnbiBkYXRhIHRvIGJpbnMgYnkgdmFsdWUsIGlnbm9yaW5nIGFueSBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICAgIGlmICh4MCA8PSB4ICYmIHggPD0geDEpIHtcbiAgICAgICAgICBiaW5zW2Jpc2VjdFJpZ2h0KHR6LCB4LCAwLCBtKV0ucHVzaChkYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmlucztcbiAgICB9XG5cbiAgICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgaGlzdG9ncmFtLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW19bMF0sIF9bMV1dKSwgaGlzdG9ncmFtKSA6IGRvbWFpbjtcbiAgICB9O1xuXG4gICAgaGlzdG9ncmFtLnRocmVzaG9sZHMgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aHJlc2hvbGQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IEFycmF5LmlzQXJyYXkoXykgPyBjb25zdGFudChzbGljZS5jYWxsKF8pKSA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdGhyZXNob2xkO1xuICAgIH07XG5cbiAgICByZXR1cm4gaGlzdG9ncmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpbGUoYXJyYXksIHAsIGYpIHtcbiAgICBpZiAoZiA9PSBudWxsKSBmID0gbnVtYmVyO1xuICAgIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gICAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpIHJldHVybiArZihhcnJheVswXSwgMCwgYXJyYXkpO1xuICAgIGlmIChwID49IDEpIHJldHVybiArZihhcnJheVtuIC0gMV0sIG4gLSAxLCBhcnJheSk7XG4gICAgdmFyIG4sXG4gICAgICAgIGggPSAobiAtIDEpICogcCxcbiAgICAgICAgaSA9IE1hdGguZmxvb3IoaCksXG4gICAgICAgIGEgPSArZihhcnJheVtpXSwgaSwgYXJyYXkpLFxuICAgICAgICBiID0gK2YoYXJyYXlbaSArIDFdLCBpICsgMSwgYXJyYXkpO1xuICAgIHJldHVybiBhICsgKGIgLSBhKSAqIChoIC0gaSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlZG1hbkRpYWNvbmlzKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMiAqIChxdWFudGlsZSh2YWx1ZXMsIDAuNzUpIC0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSkgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY290dCh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heChhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGI7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBiID4gYSkgYSA9IGI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBtZWFuKGFycmF5LCBmKSB7XG4gICAgdmFyIHMgPSAwLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIGogPSBuO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghaXNOYU4oYSA9IG51bWJlcihhcnJheVtpXSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghaXNOYU4oYSA9IG51bWJlcihmKGFycmF5W2ldLCBpLCBhcnJheSkpKSkgcyArPSBhOyBlbHNlIC0tajtcbiAgICB9XG5cbiAgICBpZiAoaikgcmV0dXJuIHMgLyBqO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVkaWFuKGFycmF5LCBmKSB7XG4gICAgdmFyIG51bWJlcnMgPSBbXSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgYSxcbiAgICAgICAgaSA9IC0xO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghaXNOYU4oYSA9IG51bWJlcihhcnJheVtpXSkpKSBudW1iZXJzLnB1c2goYSk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpc05hTihhID0gbnVtYmVyKGYoYXJyYXlbaV0sIGksIGFycmF5KSkpKSBudW1iZXJzLnB1c2goYSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1YW50aWxlKG51bWJlcnMuc29ydChhc2NlbmRpbmcpLCAwLjUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoYXJyYXlzKSB7XG4gICAgdmFyIG4gPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICBtLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIGogPSAwLFxuICAgICAgICBtZXJnZWQsXG4gICAgICAgIGFycmF5O1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG5cbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLW0gPj0gMCkge1xuICAgICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBtaW4oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBiO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYjsgYnJlYWs7IH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYjsgYnJlYWs7IH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFpcnMoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICAgIHdoaWxlIChpIDwgbikgcGFpcnNbaV0gPSBbcCwgcCA9IGFycmF5WysraV1dO1xuICAgIHJldHVybiBwYWlycztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcm11dGUoYXJyYXksIGluZGV4ZXMpIHtcbiAgICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSBwZXJtdXRlc1tpXSA9IGFycmF5W2luZGV4ZXNbaV1dO1xuICAgIHJldHVybiBwZXJtdXRlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW4oYXJyYXksIGNvbXBhcmUpIHtcbiAgICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbixcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIHhpLFxuICAgICAgICB4aiA9IGFycmF5W2pdO1xuXG4gICAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb21wYXJlKHhpID0gYXJyYXlbaV0sIHhqKSA8IDAgfHwgY29tcGFyZSh4aiwgeGopICE9PSAwKSB4aiA9IHhpLCBqID0gaTtcblxuICAgIGlmIChjb21wYXJlKHhqLCB4aikgPT09IDApIHJldHVybiBqO1xuICB9XG5cbiAgZnVuY3Rpb24gc2h1ZmZsZShhcnJheSwgaTAsIGkxKSB7XG4gICAgdmFyIG0gPSAoaTEgPT0gbnVsbCA/IGFycmF5Lmxlbmd0aCA6IGkxKSAtIChpMCA9IGkwID09IG51bGwgPyAwIDogK2kwKSxcbiAgICAgICAgdCxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlIChtKSB7XG4gICAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgICB0ID0gYXJyYXlbbSArIGkwXTtcbiAgICAgIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdO1xuICAgICAgYXJyYXlbaSArIGkwXSA9IHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3VtKGFycmF5LCBmKSB7XG4gICAgdmFyIHMgPSAwLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBpID0gLTE7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGEgPSArYXJyYXlbaV0pIHMgKz0gYTsgLy8gTm90ZTogemVybyBhbmQgbnVsbCBhcmUgZXF1aXZhbGVudC5cbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoYSA9ICtmKGFycmF5W2ldLCBpLCBhcnJheSkpIHMgKz0gYTtcbiAgICB9XG5cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zcG9zZShtYXRyaXgpIHtcbiAgICBpZiAoIShuID0gbWF0cml4Lmxlbmd0aCkpIHJldHVybiBbXTtcbiAgICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07KSB7XG4gICAgICBmb3IgKHZhciBqID0gLTEsIG4sIHJvdyA9IHRyYW5zcG9zZVtpXSA9IG5ldyBBcnJheShuKTsgKytqIDwgbjspIHtcbiAgICAgICAgcm93W2pdID0gbWF0cml4W2pdW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3NlO1xuICB9XG5cbiAgZnVuY3Rpb24gbGVuZ3RoKGQpIHtcbiAgICByZXR1cm4gZC5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiB6aXAoKSB7XG4gICAgcmV0dXJuIHRyYW5zcG9zZShhcmd1bWVudHMpO1xuICB9XG5cbiAgZXhwb3J0cy5iaXNlY3QgPSBiaXNlY3RSaWdodDtcbiAgZXhwb3J0cy5iaXNlY3RSaWdodCA9IGJpc2VjdFJpZ2h0O1xuICBleHBvcnRzLmJpc2VjdExlZnQgPSBiaXNlY3RMZWZ0O1xuICBleHBvcnRzLmFzY2VuZGluZyA9IGFzY2VuZGluZztcbiAgZXhwb3J0cy5iaXNlY3RvciA9IGJpc2VjdG9yO1xuICBleHBvcnRzLmRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nO1xuICBleHBvcnRzLmRldmlhdGlvbiA9IGRldmlhdGlvbjtcbiAgZXhwb3J0cy5leHRlbnQgPSBleHRlbnQ7XG4gIGV4cG9ydHMuaGlzdG9ncmFtID0gaGlzdG9ncmFtO1xuICBleHBvcnRzLnRocmVzaG9sZEZyZWVkbWFuRGlhY29uaXMgPSBmcmVlZG1hbkRpYWNvbmlzO1xuICBleHBvcnRzLnRocmVzaG9sZFNjb3R0ID0gc2NvdHQ7XG4gIGV4cG9ydHMudGhyZXNob2xkU3R1cmdlcyA9IHN0dXJnZXM7XG4gIGV4cG9ydHMubWF4ID0gbWF4O1xuICBleHBvcnRzLm1lYW4gPSBtZWFuO1xuICBleHBvcnRzLm1lZGlhbiA9IG1lZGlhbjtcbiAgZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuICBleHBvcnRzLm1pbiA9IG1pbjtcbiAgZXhwb3J0cy5wYWlycyA9IHBhaXJzO1xuICBleHBvcnRzLnBlcm11dGUgPSBwZXJtdXRlO1xuICBleHBvcnRzLnF1YW50aWxlID0gcXVhbnRpbGU7XG4gIGV4cG9ydHMucmFuZ2UgPSByYW5nZTtcbiAgZXhwb3J0cy5zY2FuID0gc2NhbjtcbiAgZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgZXhwb3J0cy5zdW0gPSBzdW07XG4gIGV4cG9ydHMudGlja3MgPSB0aWNrcztcbiAgZXhwb3J0cy50aWNrU3RlcCA9IHRpY2tTdGVwO1xuICBleHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbiAgZXhwb3J0cy52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICBleHBvcnRzLnppcCA9IHppcDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1kaXNwYXRjaC8gVmVyc2lvbiAxLjAuMS4gQ29weXJpZ2h0IDIwMTYgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG5vb3AgPSB7dmFsdWU6IGZ1bmN0aW9uKCkge319O1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICAgIF9bdF0gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgICB0aGlzLl8gPSBfO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICAgIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gICAgfSk7XG4gIH1cblxuICBEaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICAgIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICAgIHQsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgICB9LFxuICAgIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBleHBvcnRzLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpOyIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZm9ybWF0LyBWZXJzaW9uIDEuMC4yLiBDb3B5cmlnaHQgMjAxNiBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4gIC8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuICAvLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbiAgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbCh4LCBwKSB7XG4gICAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gICAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAgIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICAgIHJldHVybiBbXG4gICAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICAgK3guc2xpY2UoaSArIDEpXG4gICAgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cG9uZW50KHgpIHtcbiAgICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEdyb3VwKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICB0ID0gW10sXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdCh4LCBwKSB7XG4gICAgeCA9IHgudG9QcmVjaXNpb24ocCk7XG5cbiAgICBvdXQ6IGZvciAodmFyIG4gPSB4Lmxlbmd0aCwgaSA9IDEsIGkwID0gLTEsIGkxOyBpIDwgbjsgKytpKSB7XG4gICAgICBzd2l0Y2ggKHhbaV0pIHtcbiAgICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiMFwiOiBpZiAoaTAgPT09IDApIGkwID0gaTsgaTEgPSBpOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVcIjogYnJlYWsgb3V0O1xuICAgICAgICBkZWZhdWx0OiBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpMCA+IDAgPyB4LnNsaWNlKDAsIGkwKSArIHguc2xpY2UoaTEgKyAxKSA6IHg7XG4gIH1cblxuICB2YXIgcHJlZml4RXhwb25lbnQ7XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4QXV0byh4LCBwKSB7XG4gICAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICAgIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICAgIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICAgIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsKHgsIE1hdGgubWF4KDAsIHAgKyBpIC0gMSkpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3VuZGVkKHgsIHApIHtcbiAgICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gICAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICAgIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG4gIH1cblxuICB2YXIgZm9ybWF0VHlwZXMgPSB7XG4gICAgXCJcIjogZm9ybWF0RGVmYXVsdCxcbiAgICBcIiVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gKHggKiAxMDApLnRvRml4ZWQocCk7IH0sXG4gICAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXG4gICAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICAgIFwiZFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDEwKTsgfSxcbiAgICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxuICAgIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gICAgXCJnXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7IH0sXG4gICAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXG4gICAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gICAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gICAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gICAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgXCJ4XCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpOyB9XG4gIH07XG5cbiAgLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt0eXBlXVxuICB2YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KFthLXolXSk/JC9pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcblxuICAgIHZhciBtYXRjaCxcbiAgICAgICAgZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiLFxuICAgICAgICBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLFxuICAgICAgICBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsXG4gICAgICAgIHN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCIsXG4gICAgICAgIHplcm8gPSAhIW1hdGNoWzVdLFxuICAgICAgICB3aWR0aCA9IG1hdGNoWzZdICYmICttYXRjaFs2XSxcbiAgICAgICAgY29tbWEgPSAhIW1hdGNoWzddLFxuICAgICAgICBwcmVjaXNpb24gPSBtYXRjaFs4XSAmJiArbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgICAgIHR5cGUgPSBtYXRjaFs5XSB8fCBcIlwiO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gTWFwIGludmFsaWQgdHlwZXMgdG8gdGhlIGRlZmF1bHQgZm9ybWF0LlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgdHlwZSA9IFwiXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIHRoaXMuZmlsbCA9IGZpbGw7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMuc2lnbiA9IHNpZ247XG4gICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgdGhpcy56ZXJvID0gemVybztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb21tYSA9IGNvbW1hO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgICArIHRoaXMuYWxpZ25cbiAgICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMucHJlY2lzaW9uID09IG51bGwgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgICArIHRoaXMudHlwZTtcbiAgfTtcblxuICB2YXIgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdExvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgJiYgbG9jYWxlLnRob3VzYW5kcyA/IGZvcm1hdEdyb3VwKGxvY2FsZS5ncm91cGluZywgbG9jYWxlLnRob3VzYW5kcykgOiBpZGVudGl0eSxcbiAgICAgICAgY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksXG4gICAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbDtcblxuICAgIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIpIHtcbiAgICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMF0gOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzFdIDogL1slcF0vLnRlc3QodHlwZSkgPyBcIiVcIiA6IFwiXCI7XG5cbiAgICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICAgIG1heWJlU3VmZml4ID0gIXR5cGUgfHwgL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/ICh0eXBlID8gNiA6IDEyKVxuICAgICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuXG4gICAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgICAgdmFsdWVTdWZmaXggPSBzdWZmaXgsXG4gICAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG5lZ2F0aXZlIHRvIHBvc2l0aXZlLCBhbmQgY29tcHV0ZSB0aGUgcHJlZml4LlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCAtMCBpcyBub3QgbGVzcyB0aGFuIDAsIGJ1dCAxIC8gLTAgaXMhXG4gICAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSAodmFsdWUgPCAwIHx8IDEgLyB2YWx1ZSA8IDApICYmICh2YWx1ZSAqPSAtMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgICAgdmFsdWUgPSBmb3JtYXRUeXBlKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHZhbHVlIHdhcyBuZWdhdGl2ZSwgaXQgbWF5IGJlIHJvdW5kZWQgdG8gemVybyBkdXJpbmdcbiAgICAgICAgICAvLyBmb3JtYXR0aW5nOyB0cmVhdCB0aGlzIGFzIChwb3NpdGl2ZSkgemVyby5cbiAgICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCAoNDggPCBjICYmIGMgPCA1OClcbiAgICAgICAgICAgICAgICAgIHx8ICh0eXBlID09PSBcInhcIiAmJiA5NiA8IGMgJiYgYyA8IDEwMylcbiAgICAgICAgICAgICAgICAgIHx8ICh0eXBlID09PSBcIlhcIiAmJiA2NCA8IGMgJiYgYyA8IDcxKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBcIi1cIikgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICAgIHZhbHVlU3VmZml4ID0gdmFsdWVTdWZmaXggKyAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICAgIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgICBjYXNlIFwiPFwiOiByZXR1cm4gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZztcbiAgICAgICAgICBjYXNlIFwiPVwiOiByZXR1cm4gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICBjYXNlIFwiXlwiOiByZXR1cm4gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgIH1cblxuICAgICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzcGVjaWZpZXIgKyBcIlwiO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBuZXdGb3JtYXQsXG4gICAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICAgIH07XG4gIH1cblxuICB2YXIgbG9jYWxlO1xuICBkZWZhdWx0TG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gICAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICAgIGV4cG9ydHMuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgICBleHBvcnRzLmZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG4gICAgcmV0dXJuIGxvY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvbkZpeGVkKHN0ZXApIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgLWV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uUm91bmQoc3RlcCwgbWF4KSB7XG4gICAgc3RlcCA9IE1hdGguYWJzKHN0ZXApLCBtYXggPSBNYXRoLmFicyhtYXgpIC0gc3RlcDtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQobWF4KSAtIGV4cG9uZW50KHN0ZXApKSArIDE7XG4gIH1cblxuICBleHBvcnRzLmZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICBleHBvcnRzLmZvcm1hdExvY2FsZSA9IGZvcm1hdExvY2FsZTtcbiAgZXhwb3J0cy5mb3JtYXRTcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXI7XG4gIGV4cG9ydHMucHJlY2lzaW9uRml4ZWQgPSBwcmVjaXNpb25GaXhlZDtcbiAgZXhwb3J0cy5wcmVjaXNpb25QcmVmaXggPSBwcmVjaXNpb25QcmVmaXg7XG4gIGV4cG9ydHMucHJlY2lzaW9uUm91bmQgPSBwcmVjaXNpb25Sb3VuZDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zY2FsZS8gVmVyc2lvbiAxLjAuMy4gQ29weXJpZ2h0IDIwMTYgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1hcnJheScpLCByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLWZvcm1hdCcpLCByZXF1aXJlKCdkMy10aW1lJyksIHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLWNvbG9yJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1hcnJheScsICdkMy1jb2xsZWN0aW9uJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLWZvcm1hdCcsICdkMy10aW1lJywgJ2QzLXRpbWUtZm9ybWF0JywgJ2QzLWNvbG9yJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLGQzQXJyYXksZDNDb2xsZWN0aW9uLGQzSW50ZXJwb2xhdGUsZDNGb3JtYXQsZDNUaW1lLGQzVGltZUZvcm1hdCxkM0NvbG9yKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIG1hcCQxID0gYXJyYXkubWFwO1xuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcblxuICB2YXIgaW1wbGljaXQgPSB7bmFtZTogXCJpbXBsaWNpdFwifTtcblxuICBmdW5jdGlvbiBvcmRpbmFsKHJhbmdlKSB7XG4gICAgdmFyIGluZGV4ID0gZDNDb2xsZWN0aW9uLm1hcCgpLFxuICAgICAgICBkb21haW4gPSBbXSxcbiAgICAgICAgdW5rbm93biA9IGltcGxpY2l0O1xuXG4gICAgcmFuZ2UgPSByYW5nZSA9PSBudWxsID8gW10gOiBzbGljZS5jYWxsKHJhbmdlKTtcblxuICAgIGZ1bmN0aW9uIHNjYWxlKGQpIHtcbiAgICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgICAgaWYgKCFpKSB7XG4gICAgICAgIGlmICh1bmtub3duICE9PSBpbXBsaWNpdCkgcmV0dXJuIHVua25vd247XG4gICAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VbKGkgLSAxKSAlIHJhbmdlLmxlbmd0aF07XG4gICAgfVxuXG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgICBkb21haW4gPSBbXSwgaW5kZXggPSBkM0NvbGxlY3Rpb24ubWFwKCk7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4LmhhcyhrZXkgPSAoZCA9IF9baV0pICsgXCJcIikpIGluZGV4LnNldChrZXksIGRvbWFpbi5wdXNoKGQpKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG9yZGluYWwoKVxuICAgICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFuZCgpIHtcbiAgICB2YXIgc2NhbGUgPSBvcmRpbmFsKCkudW5rbm93bih1bmRlZmluZWQpLFxuICAgICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgYmFuZHdpZHRoLFxuICAgICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgICBhbGlnbiA9IDAuNTtcblxuICAgIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBuID0gZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICAgIHN0YXJ0ID0gcmFuZ2VbcmV2ZXJzZSAtIDBdLFxuICAgICAgICAgIHN0b3AgPSByYW5nZVsxIC0gcmV2ZXJzZV07XG4gICAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgc3RhcnQgKz0gKHN0b3AgLSBzdGFydCAtIHN0ZXAgKiAobiAtIHBhZGRpbmdJbm5lcikpICogYWxpZ247XG4gICAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgICB2YXIgdmFsdWVzID0gZDNBcnJheS5yYW5nZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgICB9XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiByYW5nZSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYmFuZHdpZHRoO1xuICAgIH07XG5cbiAgICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9O1xuXG4gICAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICAgIH07XG5cbiAgICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gcGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICAgIH07XG5cbiAgICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gICAgfTtcblxuICAgIHNjYWxlLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdPdXRlcjtcbiAgICB9O1xuXG4gICAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbGlnbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IGFsaWduO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYmFuZCgpXG4gICAgICAgICAgLmRvbWFpbihkb21haW4oKSlcbiAgICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAgIC5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKVxuICAgICAgICAgIC5hbGlnbihhbGlnbik7XG4gICAgfTtcblxuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludGlzaChzY2FsZSkge1xuICAgIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICAgIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gICAgZGVsZXRlIHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBvaW50aXNoKGNvcHkoKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50KCkge1xuICAgIHJldHVybiBwb2ludGlzaChiYW5kKCkucGFkZGluZ0lubmVyKDEpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgICByZXR1cm4gK3g7XG4gIH1cblxuICB2YXIgdW5pdCA9IFswLCAxXTtcblxuICBmdW5jdGlvbiBkZWludGVycG9sYXRlKGEsIGIpIHtcbiAgICByZXR1cm4gKGIgLT0gKGEgPSArYSkpXG4gICAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgICAgOiBjb25zdGFudChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGVDbGFtcChkZWludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciBkID0gZGVpbnRlcnBvbGF0ZShhID0gK2EsIGIgPSArYik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geCA8PSBhID8gMCA6IHggPj0gYiA/IDEgOiBkKHgpOyB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgciA9IHJlaW50ZXJwb2xhdGUoYSA9ICthLCBiID0gK2IpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQgPD0gMCA/IGEgOiB0ID49IDEgPyBiIDogcih0KTsgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSkge1xuICAgIHZhciBkMCA9IGRvbWFpblswXSwgZDEgPSBkb21haW5bMV0sIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV07XG4gICAgaWYgKGQxIDwgZDApIGQwID0gZGVpbnRlcnBvbGF0ZShkMSwgZDApLCByMCA9IHJlaW50ZXJwb2xhdGUocjEsIHIwKTtcbiAgICBlbHNlIGQwID0gZGVpbnRlcnBvbGF0ZShkMCwgZDEpLCByMCA9IHJlaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gcjAoZDAoeCkpOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gICAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcbiAgICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgICAgaSA9IC0xO1xuXG4gICAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gICAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgZFtpXSA9IGRlaW50ZXJwb2xhdGUoZG9tYWluW2ldLCBkb21haW5baSArIDFdKTtcbiAgICAgIHJbaV0gPSByZWludGVycG9sYXRlKHJhbmdlW2ldLCByYW5nZVtpICsgMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgaSA9IGQzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xuICAgICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0XG4gICAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShzb3VyY2UuaW50ZXJwb2xhdGUoKSlcbiAgICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKTtcbiAgfVxuXG4gIC8vIGRlaW50ZXJwb2xhdGUoYSwgYikoeCkgdGFrZXMgYSBkb21haW4gdmFsdWUgeCBpbiBbYSxiXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgdCBpbiBbMCwxXS5cbiAgLy8gcmVpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdLlxuICBmdW5jdGlvbiBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUkJCwgcmVpbnRlcnBvbGF0ZSkge1xuICAgIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgICByYW5nZSA9IHVuaXQsXG4gICAgICAgIGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZSxcbiAgICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgICAgcGllY2V3aXNlLFxuICAgICAgICBvdXRwdXQsXG4gICAgICAgIGlucHV0O1xuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHBpZWNld2lzZSA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgICAgb3V0cHV0ID0gaW5wdXQgPSBudWxsO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UoZG9tYWluLCByYW5nZSwgY2xhbXAgPyBkZWludGVycG9sYXRlQ2xhbXAoZGVpbnRlcnBvbGF0ZSQkKSA6IGRlaW50ZXJwb2xhdGUkJCwgaW50ZXJwb2xhdGUpKSkoK3gpO1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiAoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlLCBkb21haW4sIGRlaW50ZXJwb2xhdGUsIGNsYW1wID8gcmVpbnRlcnBvbGF0ZUNsYW1wKHJlaW50ZXJwb2xhdGUpIDogcmVpbnRlcnBvbGF0ZSkpKSgreSk7XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcCQxLmNhbGwoXywgbnVtYmVyKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCByZXNjYWxlKCkpIDogY2xhbXA7XG4gICAgfTtcblxuICAgIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGU7XG4gICAgfTtcblxuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrRm9ybWF0KGRvbWFpbiwgY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBzdGFydCA9IGRvbWFpblswXSxcbiAgICAgICAgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sXG4gICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCksXG4gICAgICAgIHByZWNpc2lvbjtcbiAgICBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICAgIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IGQzRm9ybWF0LnByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgICByZXR1cm4gZDNGb3JtYXQuZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlwiOlxuICAgICAgY2FzZSBcImVcIjpcbiAgICAgIGNhc2UgXCJnXCI6XG4gICAgICBjYXNlIFwicFwiOlxuICAgICAgY2FzZSBcInJcIjoge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImZcIjpcbiAgICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChzcGVjaWZpZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gICAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgICByZXR1cm4gZDNBcnJheS50aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgICB9O1xuXG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICAgIHJldHVybiB0aWNrRm9ybWF0KGRvbWFpbigpLCBjb3VudCwgc3BlY2lmaWVyKTtcbiAgICB9O1xuXG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICAgIGkgPSBkLmxlbmd0aCAtIDEsXG4gICAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LFxuICAgICAgICAgIHN0YXJ0ID0gZFswXSxcbiAgICAgICAgICBzdG9wID0gZFtpXSxcbiAgICAgICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCwgc3RvcCwgbik7XG5cbiAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXAsIE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwLCBuKTtcbiAgICAgICAgZFswXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIGRbaV0gPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgZG9tYWluKGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcblxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXIpO1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgICB2YXIgZG9tYWluID0gWzAsIDFdO1xuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuICt4O1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gICAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAkMS5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKS5kb21haW4oZG9tYWluKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBuaWNlKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICAgIHZhciBpMCA9IDAsXG4gICAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgICAgeDEgPSBkb21haW5baTFdLFxuICAgICAgICB0O1xuXG4gICAgaWYgKHgxIDwgeDApIHtcbiAgICAgIHQgPSBpMCwgaTAgPSBpMSwgaTEgPSB0O1xuICAgICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgfVxuXG4gICAgZG9tYWluW2kwXSA9IGludGVydmFsLmZsb29yKHgwKTtcbiAgICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUkMShhLCBiKSB7XG4gICAgcmV0dXJuIChiID0gTWF0aC5sb2coYiAvIGEpKVxuICAgICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHggLyBhKSAvIGI7IH1cbiAgICAgICAgOiBjb25zdGFudChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIHJldHVybiBhIDwgMFxuICAgICAgICA/IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIC1NYXRoLnBvdygtYiwgdCkgKiBNYXRoLnBvdygtYSwgMSAtIHQpOyB9XG4gICAgICAgIDogZnVuY3Rpb24odCkgeyByZXR1cm4gTWF0aC5wb3coYiwgdCkgKiBNYXRoLnBvdyhhLCAxIC0gdCk7IH07XG4gIH1cblxuICBmdW5jdGlvbiBwb3cxMCh4KSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG4gIH1cblxuICBmdW5jdGlvbiBwb3dwKGJhc2UpIHtcbiAgICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5wb3coYmFzZSwgeCk7IH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgICByZXR1cm4gYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5sb2dcbiAgICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICAgIHx8IChiYXNlID0gTWF0aC5sb2coYmFzZSksIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHgpIC8gYmFzZTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC1mKC14KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nKCkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSQxLCByZWludGVycG9sYXRlKS5kb21haW4oWzEsIDEwXSksXG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgICAgYmFzZSA9IDEwLFxuICAgICAgICBsb2dzID0gbG9ncCgxMCksXG4gICAgICAgIHBvd3MgPSBwb3dwKDEwKTtcblxuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICBsb2dzID0gbG9ncChiYXNlKSwgcG93cyA9IHBvd3AoYmFzZSk7XG4gICAgICBpZiAoZG9tYWluKClbMF0gPCAwKSBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuXG4gICAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhc2UgPSArXywgcmVzY2FsZSgpKSA6IGJhc2U7XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICAgIH07XG5cbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICAgIHUgPSBkWzBdLFxuICAgICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgcjtcblxuICAgICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICAgIGogPSBsb2dzKHYpLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgayxcbiAgICAgICAgICB0LFxuICAgICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgICAgeiA9IFtdO1xuXG4gICAgICBpZiAoIShiYXNlICUgMSkgJiYgaiAtIGkgPCBuKSB7XG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpIC0gMSwgaiA9IE1hdGgucm91bmQoaikgKyAxO1xuICAgICAgICBpZiAodSA+IDApIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgZm9yIChrID0gMSwgcCA9IHBvd3MoaSk7IGsgPCBiYXNlOyArK2spIHtcbiAgICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6ID0gZDNBcnJheS50aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHIgPyB6LnJldmVyc2UoKSA6IHo7XG4gICAgfTtcblxuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xuICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0KHNwZWNpZmllcik7XG4gICAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gc3BlY2lmaWVyO1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgICByZXR1cm4gaSA8PSBrID8gc3BlY2lmaWVyKGQpIDogXCJcIjtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgICAgY2VpbDogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmNlaWwobG9ncyh4KSkpOyB9XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKS5iYXNlKGJhc2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFpc2UoeCwgZXhwb25lbnQpIHtcbiAgICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvdygpIHtcbiAgICB2YXIgZXhwb25lbnQgPSAxLFxuICAgICAgICBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSksXG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICAgIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgICAgcmV0dXJuIChiID0gcmFpc2UoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZShhLCBleHBvbmVudCkpKVxuICAgICAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHJhaXNlKHgsIGV4cG9uZW50KSAtIGEpIC8gYjsgfVxuICAgICAgICAgIDogY29uc3RhbnQoYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgICBiID0gcmFpc2UoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZShhLCBleHBvbmVudCkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHJhaXNlKGEgKyBiICogdCwgMSAvIGV4cG9uZW50KTsgfTtcbiAgICB9XG5cbiAgICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIGRvbWFpbihkb21haW4oKSkpIDogZXhwb25lbnQ7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKS5leHBvbmVudChleHBvbmVudCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNxcnQoKSB7XG4gICAgcmV0dXJuIHBvdygpLmV4cG9uZW50KDAuNSk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGlsZSQxKCkge1xuICAgIHZhciBkb21haW4gPSBbXSxcbiAgICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgICAgdGhyZXNob2xkcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgICB0aHJlc2hvbGRzID0gbmV3IEFycmF5KG4gLSAxKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IGQzQXJyYXkucXVhbnRpbGUoZG9tYWluLCBpIC8gbik7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gcmFuZ2VbZDNBcnJheS5iaXNlY3QodGhyZXNob2xkcywgeCldO1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgICBdO1xuICAgIH07XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgICAgZG9tYWluLnNvcnQoZDNBcnJheS5hc2NlbmRpbmcpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWFudGlsZSQxKClcbiAgICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgICAucmFuZ2UocmFuZ2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgICB2YXIgeDAgPSAwLFxuICAgICAgICB4MSA9IDEsXG4gICAgICAgIG4gPSAxLFxuICAgICAgICBkb21haW4gPSBbMC41XSxcbiAgICAgICAgcmFuZ2UgPSBbMCwgMV07XG5cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoeCA8PSB4KSByZXR1cm4gcmFuZ2VbZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAwLCBuKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBpID0gLTE7XG4gICAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF0sIHgxID0gK19bMV0sIHJlc2NhbGUoKSkgOiBbeDAsIHgxXTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gKHJhbmdlID0gc2xpY2UuY2FsbChfKSkubGVuZ3RoIC0gMSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgICAgOiBpID49IG4gPyBbZG9tYWluW24gLSAxXSwgeDFdXG4gICAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1YW50aXplKClcbiAgICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAgIC5yYW5nZShyYW5nZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICAgIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICAgIG4gPSAxO1xuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2QzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildO1xuICAgIH1cblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgICAgLnJhbmdlKHJhbmdlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgdmFyIGR1cmF0aW9uU2Vjb25kID0gMTAwMDtcbiAgdmFyIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbiAgdmFyIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjA7XG4gIHZhciBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0O1xuICB2YXIgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xuICB2YXIgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzA7XG4gIHZhciBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcbiAgZnVuY3Rpb24gZGF0ZSh0KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbnVtYmVyJDEodCkge1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSB7XG4gICAgdmFyIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlLCBkM0ludGVycG9sYXRlLmludGVycG9sYXRlTnVtYmVyKSxcbiAgICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQoXCIuJUxcIiksXG4gICAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgICAgZm9ybWF0TWludXRlID0gZm9ybWF0KFwiJUk6JU1cIiksXG4gICAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQoXCIlSSAlcFwiKSxcbiAgICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICAgIGZvcm1hdFdlZWsgPSBmb3JtYXQoXCIlYiAlZFwiKSxcbiAgICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQoXCIlQlwiKSxcbiAgICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gICAgdmFyIHRpY2tJbnRlcnZhbHMgPSBbXG4gICAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbc2Vjb25kLCAxNSwgMTUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbbWludXRlLCAgNSwgIDUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgICBbICBob3VyLCAgMSwgICAgICBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICBob3VyLCAxMiwgMTIgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgICBbICB3ZWVrLCAgMSwgICAgICBkdXJhdGlvbldlZWsgIF0sXG4gICAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgICBbICB5ZWFyLCAgMSwgICAgICBkdXJhdGlvblllYXIgIF1cbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgICByZXR1cm4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgICA6IGRheShkYXRlKSA8IGRhdGUgPyBmb3JtYXRIb3VyXG4gICAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgaWYgKGludGVydmFsID09IG51bGwpIGludGVydmFsID0gMTA7XG5cbiAgICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxuICAgICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGludGVydmFsIGlzIGFscmVhZHkgYSB0aW1lIGludGVydmFsIGFuZCB1c2UgaXQuXG4gICAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgICBpID0gZDNBcnJheS5iaXNlY3RvcihmdW5jdGlvbihpKSB7IHJldHVybiBpWzJdOyB9KS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgICAgICBpZiAoaSA9PT0gdGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICAgIGludGVydmFsID0geWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChpKSB7XG4gICAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgICBpbnRlcnZhbCA9IGlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcCA9IGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIGludGVydmFsKTtcbiAgICAgICAgICBpbnRlcnZhbCA9IG1pbGxpc2Vjb25kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICAgIH07XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihtYXAkMS5jYWxsKF8sIG51bWJlciQxKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gICAgfTtcblxuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgICAgdDAgPSBkWzBdLFxuICAgICAgICAgIHQxID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICAgIHQ7XG4gICAgICBpZiAocikgdCA9IHQwLCB0MCA9IHQxLCB0MSA9IHQ7XG4gICAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgICAgdCA9IHQgPyB0LnJhbmdlKHQwLCB0MSArIDEpIDogW107IC8vIGluY2x1c2l2ZSBzdG9wXG4gICAgICByZXR1cm4gciA/IHQucmV2ZXJzZSgpIDogdDtcbiAgICB9O1xuXG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IHRpY2tGb3JtYXQgOiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICB9O1xuXG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgICA/IGRvbWFpbihuaWNlKGQsIGludGVydmFsKSlcbiAgICAgICAgICA6IHNjYWxlO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29weShzY2FsZSwgY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZSgpIHtcbiAgICByZXR1cm4gY2FsZW5kYXIoZDNUaW1lLnRpbWVZZWFyLCBkM1RpbWUudGltZU1vbnRoLCBkM1RpbWUudGltZVdlZWssIGQzVGltZS50aW1lRGF5LCBkM1RpbWUudGltZUhvdXIsIGQzVGltZS50aW1lTWludXRlLCBkM1RpbWUudGltZVNlY29uZCwgZDNUaW1lLnRpbWVNaWxsaXNlY29uZCwgZDNUaW1lRm9ybWF0LnRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGNUaW1lKCkge1xuICAgIHJldHVybiBjYWxlbmRhcihkM1RpbWUudXRjWWVhciwgZDNUaW1lLnV0Y01vbnRoLCBkM1RpbWUudXRjV2VlaywgZDNUaW1lLnV0Y0RheSwgZDNUaW1lLnV0Y0hvdXIsIGQzVGltZS51dGNNaW51dGUsIGQzVGltZS51dGNTZWNvbmQsIGQzVGltZS51dGNNaWxsaXNlY29uZCwgZDNUaW1lRm9ybWF0LnV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyMDAwLCAwLCAxKSwgRGF0ZS5VVEMoMjAwMCwgMCwgMildKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9ycyhzKSB7XG4gICAgcmV0dXJuIHMubWF0Y2goLy57Nn0vZykubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBcIiNcIiArIHg7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2F0ZWdvcnkxMCA9IGNvbG9ycyhcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKTtcblxuICB2YXIgY2F0ZWdvcnkyMGIgPSBjb2xvcnMoXCIzOTNiNzk1MjU0YTM2YjZlY2Y5YzllZGU2Mzc5Mzk4Y2EyNTJiNWNmNmJjZWRiOWM4YzZkMzFiZDllMzllN2JhNTJlN2NiOTQ4NDNjMzlhZDQ5NGFkNjYxNmJlNzk2OWM3YjQxNzNhNTUxOTRjZTZkYmRkZTllZDZcIik7XG5cbiAgdmFyIGNhdGVnb3J5MjBjID0gY29sb3JzKFwiMzE4MmJkNmJhZWQ2OWVjYWUxYzZkYmVmZTY1NTBkZmQ4ZDNjZmRhZTZiZmRkMGEyMzFhMzU0NzRjNDc2YTFkOTliYzdlOWMwNzU2YmIxOWU5YWM4YmNiZGRjZGFkYWViNjM2MzYzOTY5Njk2YmRiZGJkZDlkOWQ5XCIpO1xuXG4gIHZhciBjYXRlZ29yeTIwID0gY29sb3JzKFwiMWY3N2I0YWVjN2U4ZmY3ZjBlZmZiYjc4MmNhMDJjOThkZjhhZDYyNzI4ZmY5ODk2OTQ2N2JkYzViMGQ1OGM1NjRiYzQ5Yzk0ZTM3N2MyZjdiNmQyN2Y3ZjdmYzdjN2M3YmNiZDIyZGJkYjhkMTdiZWNmOWVkYWU1XCIpO1xuXG4gIHZhciBjdWJlaGVsaXgkMSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KDMwMCwgMC41LCAwLjApLCBkM0NvbG9yLmN1YmVoZWxpeCgtMjQwLCAwLjUsIDEuMCkpO1xuXG4gIHZhciB3YXJtID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoLTEwMCwgMC43NSwgMC4zNSksIGQzQ29sb3IuY3ViZWhlbGl4KDgwLCAxLjUwLCAwLjgpKTtcblxuICB2YXIgY29vbCA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KDI2MCwgMC43NSwgMC4zNSksIGQzQ29sb3IuY3ViZWhlbGl4KDgwLCAxLjUwLCAwLjgpKTtcblxuICB2YXIgcmFpbmJvdyA9IGQzQ29sb3IuY3ViZWhlbGl4KCk7XG5cbiAgZnVuY3Rpb24gcmFpbmJvdyQxKHQpIHtcbiAgICBpZiAodCA8IDAgfHwgdCA+IDEpIHQgLT0gTWF0aC5mbG9vcih0KTtcbiAgICB2YXIgdHMgPSBNYXRoLmFicyh0IC0gMC41KTtcbiAgICByYWluYm93LmggPSAzNjAgKiB0IC0gMTAwO1xuICAgIHJhaW5ib3cucyA9IDEuNSAtIDEuNSAqIHRzO1xuICAgIHJhaW5ib3cubCA9IDAuOCAtIDAuOSAqIHRzO1xuICAgIHJldHVybiByYWluYm93ICsgXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbXAocmFuZ2UpIHtcbiAgICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHZpcmlkaXMgPSByYW1wKGNvbG9ycyhcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSk7XG5cbiAgdmFyIG1hZ21hID0gcmFtcChjb2xvcnMoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMDkwMjAyMGIwMjAyMGQwMzAzMGYwMzAzMTIwNDA0MTQwNTA0MTYwNjA1MTgwNjA1MWEwNzA2MWMwODA3MWUwOTA3MjAwYTA4MjIwYjA5MjQwYzA5MjYwZDBhMjkwZTBiMmIxMDBiMmQxMTBjMmYxMjBkMzExMzBkMzQxNDBlMzYxNTBlMzgxNjBmM2IxODBmM2QxOTEwM2YxYTEwNDIxYzEwNDQxZDExNDcxZTExNDkyMDExNGIyMTExNGUyMjExNTAyNDEyNTMyNTEyNTUyNzEyNTgyOTExNWEyYTExNWMyYzExNWYyZDExNjEyZjExNjMzMTExNjUzMzEwNjczNDEwNjkzNjEwNmIzODEwNmMzOTBmNmUzYjBmNzAzZDBmNzEzZjBmNzI0MDBmNzQ0MjBmNzU0NDBmNzY0NTEwNzc0NzEwNzg0OTEwNzg0YTEwNzk0YzExN2E0ZTExN2I0ZjEyN2I1MTEyN2M1MjEzN2M1NDEzN2Q1NjE0N2Q1NzE1N2U1OTE1N2U1YTE2N2U1YzE2N2Y1ZDE3N2Y1ZjE4N2Y2MDE4ODA2MjE5ODA2NDFhODA2NTFhODA2NzFiODA2ODFjODE2YTFjODE2YjFkODE2ZDFkODE2ZTFlODE3MDFmODE3MjFmODE3MzIwODE3NTIxODE3NjIxODE3ODIyODE3OTIyODI3YjIzODI3YzIzODI3ZTI0ODI4MDI1ODI4MTI1ODE4MzI2ODE4NDI2ODE4NjI3ODE4ODI3ODE4OTI4ODE4YjI5ODE4YzI5ODE4ZTJhODE5MDJhODE5MTJiODE5MzJiODA5NDJjODA5NjJjODA5ODJkODA5OTJkODA5YjJlN2Y5YzJlN2Y5ZTJmN2ZhMDJmN2ZhMTMwN2VhMzMwN2VhNTMxN2VhNjMxN2RhODMyN2RhYTMzN2RhYjMzN2NhZDM0N2NhZTM0N2JiMDM1N2JiMjM1N2JiMzM2N2FiNTM2N2FiNzM3NzliODM3NzliYTM4NzhiYzM5NzhiZDM5NzdiZjNhNzdjMDNhNzZjMjNiNzVjNDNjNzVjNTNjNzRjNzNkNzNjODNlNzNjYTNlNzJjYzNmNzFjZDQwNzFjZjQwNzBkMDQxNmZkMjQyNmZkMzQzNmVkNTQ0NmRkNjQ1NmNkODQ1NmNkOTQ2NmJkYjQ3NmFkYzQ4NjlkZTQ5NjhkZjRhNjhlMDRjNjdlMjRkNjZlMzRlNjVlNDRmNjRlNTUwNjRlNzUyNjNlODUzNjJlOTU0NjJlYTU2NjFlYjU3NjBlYzU4NjBlZDVhNWZlZTViNWVlZjVkNWVmMDVmNWVmMTYwNWRmMjYyNWRmMjY0NWNmMzY1NWNmNDY3NWNmNDY5NWNmNTZiNWNmNjZjNWNmNjZlNWNmNzcwNWNmNzcyNWNmODc0NWNmODc2NWNmOTc4NWRmOTc5NWRmOTdiNWRmYTdkNWVmYTdmNWVmYTgxNWZmYjgzNWZmYjg1NjBmYjg3NjFmYzg5NjFmYzhhNjJmYzhjNjNmYzhlNjRmYzkwNjVmZDkyNjZmZDk0NjdmZDk2NjhmZDk4NjlmZDlhNmFmZDliNmJmZTlkNmNmZTlmNmRmZWExNmVmZWEzNmZmZWE1NzFmZWE3NzJmZWE5NzNmZWFhNzRmZWFjNzZmZWFlNzdmZWIwNzhmZWIyN2FmZWI0N2JmZWI2N2NmZWI3N2VmZWI5N2ZmZWJiODFmZWJkODJmZWJmODRmZWMxODVmZWMyODdmZWM0ODhmZWM2OGFmZWM4OGNmZWNhOGRmZWNjOGZmZWNkOTBmZWNmOTJmZWQxOTRmZWQzOTVmZWQ1OTdmZWQ3OTlmZWQ4OWFmZGRhOWNmZGRjOWVmZGRlYTBmZGUwYTFmZGUyYTNmZGUzYTVmZGU1YTdmZGU3YTlmZGU5YWFmZGViYWNmY2VjYWVmY2VlYjBmY2YwYjJmY2YyYjRmY2Y0YjZmY2Y2YjhmY2Y3YjlmY2Y5YmJmY2ZiYmRmY2ZkYmZcIikpO1xuXG4gIHZhciBpbmZlcm5vID0gcmFtcChjb2xvcnMoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMGEwMjAyMGMwMjAyMGUwMzAyMTAwNDAzMTIwNDAzMTQwNTA0MTcwNjA0MTkwNzA1MWIwODA1MWQwOTA2MWYwYTA3MjIwYjA3MjQwYzA4MjYwZDA4MjkwZTA5MmIxMDA5MmQxMTBhMzAxMjBhMzIxNDBiMzQxNTBiMzcxNjBiMzkxODBjM2MxOTBjM2UxYjBjNDExYzBjNDMxZTBjNDUxZjBjNDgyMTBjNGEyMzBjNGMyNDBjNGYyNjBjNTEyODBiNTMyOTBiNTUyYjBiNTcyZDBiNTkyZjBhNWIzMTBhNWMzMjBhNWUzNDBhNWYzNjA5NjEzODA5NjIzOTA5NjMzYjA5NjQzZDA5NjUzZTA5NjY0MDBhNjc0MjBhNjg0NDBhNjg0NTBhNjk0NzBiNmE0OTBiNmE0YTBjNmI0YzBjNmI0ZDBkNmM0ZjBkNmM1MTBlNmM1MjBlNmQ1NDBmNmQ1NTBmNmQ1NzEwNmU1OTEwNmU1YTExNmU1YzEyNmU1ZDEyNmU1ZjEzNmU2MTEzNmU2MjE0NmU2NDE1NmU2NTE1NmU2NzE2NmU2OTE2NmU2YTE3NmU2YzE4NmU2ZDE4NmU2ZjE5NmU3MTE5NmU3MjFhNmU3NDFhNmU3NTFiNmU3NzFjNmQ3ODFjNmQ3YTFkNmQ3YzFkNmQ3ZDFlNmQ3ZjFlNmM4MDFmNmM4MjIwNmM4NDIwNmI4NTIxNmI4NzIxNmI4ODIyNmE4YTIyNmE4YzIzNjk4ZDIzNjk4ZjI0Njk5MDI1Njg5MjI1Njg5MzI2Njc5NTI2Njc5NzI3NjY5ODI3NjY5YTI4NjU5YjI5NjQ5ZDI5NjQ5ZjJhNjNhMDJhNjNhMjJiNjJhMzJjNjFhNTJjNjBhNjJkNjBhODJlNWZhOTJlNWVhYjJmNWVhZDMwNWRhZTMwNWNiMDMxNWJiMTMyNWFiMzMyNWFiNDMzNTliNjM0NThiNzM1NTdiOTM1NTZiYTM2NTViYzM3NTRiZDM4NTNiZjM5NTJjMDNhNTFjMTNhNTBjMzNiNGZjNDNjNGVjNjNkNGRjNzNlNGNjODNmNGJjYTQwNGFjYjQxNDljYzQyNDhjZTQzNDdjZjQ0NDZkMDQ1NDVkMjQ2NDRkMzQ3NDNkNDQ4NDJkNTRhNDFkNzRiM2ZkODRjM2VkOTRkM2RkYTRlM2NkYjUwM2JkZDUxM2FkZTUyMzhkZjUzMzdlMDU1MzZlMTU2MzVlMjU3MzRlMzU5MzNlNDVhMzFlNTVjMzBlNjVkMmZlNzVlMmVlODYwMmRlOTYxMmJlYTYzMmFlYjY0MjllYjY2MjhlYzY3MjZlZDY5MjVlZTZhMjRlZjZjMjNlZjZlMjFmMDZmMjBmMTcxMWZmMTczMWRmMjc0MWNmMzc2MWJmMzc4MTlmNDc5MThmNTdiMTdmNTdkMTVmNjdlMTRmNjgwMTNmNzgyMTJmNzg0MTBmODg1MGZmODg3MGVmODg5MGNmOThiMGJmOThjMGFmOThlMDlmYTkwMDhmYTkyMDdmYTk0MDdmYjk2MDZmYjk3MDZmYjk5MDZmYjliMDZmYjlkMDdmYzlmMDdmY2ExMDhmY2EzMDlmY2E1MGFmY2E2MGNmY2E4MGRmY2FhMGZmY2FjMTFmY2FlMTJmY2IwMTRmY2IyMTZmY2I0MThmYmI2MWFmYmI4MWRmYmJhMWZmYmJjMjFmYmJlMjNmYWMwMjZmYWMyMjhmYWM0MmFmYWM2MmRmOWM3MmZmOWM5MzJmOWNiMzVmOGNkMzdmOGNmM2FmN2QxM2RmN2QzNDBmNmQ1NDNmNmQ3NDZmNWQ5NDlmNWRiNGNmNGRkNGZmNGRmNTNmNGUxNTZmM2UzNWFmM2U1NWRmMmU2NjFmMmU4NjVmMmVhNjlmMWVjNmRmMWVkNzFmMWVmNzVmMWYxNzlmMmYyN2RmMmY0ODJmM2Y1ODZmM2Y2OGFmNGY4OGVmNWY5OTJmNmZhOTZmOGZiOWFmOWZjOWRmYWZkYTFmY2ZmYTRcIikpO1xuXG4gIHZhciBwbGFzbWEgPSByYW1wKGNvbG9ycyhcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSk7XG5cbiAgZnVuY3Rpb24gc2VxdWVudGlhbChpbnRlcnBvbGF0b3IpIHtcbiAgICB2YXIgeDAgPSAwLFxuICAgICAgICB4MSA9IDEsXG4gICAgICAgIGNsYW1wID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICB2YXIgdCA9ICh4IC0geDApIC8gKHgxIC0geDApO1xuICAgICAgcmV0dXJuIGludGVycG9sYXRvcihjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKSA6IHQpO1xuICAgIH1cblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF0sIHgxID0gK19bMV0sIHNjYWxlKSA6IFt4MCwgeDFdO1xuICAgIH07XG5cbiAgICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgICB9O1xuXG4gICAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VxdWVudGlhbChpbnRlcnBvbGF0b3IpLmRvbWFpbihbeDAsIHgxXSkuY2xhbXAoY2xhbXApO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbiAgfVxuXG4gIGV4cG9ydHMuc2NhbGVCYW5kID0gYmFuZDtcbiAgZXhwb3J0cy5zY2FsZVBvaW50ID0gcG9pbnQ7XG4gIGV4cG9ydHMuc2NhbGVJZGVudGl0eSA9IGlkZW50aXR5O1xuICBleHBvcnRzLnNjYWxlTGluZWFyID0gbGluZWFyO1xuICBleHBvcnRzLnNjYWxlTG9nID0gbG9nO1xuICBleHBvcnRzLnNjYWxlT3JkaW5hbCA9IG9yZGluYWw7XG4gIGV4cG9ydHMuc2NhbGVJbXBsaWNpdCA9IGltcGxpY2l0O1xuICBleHBvcnRzLnNjYWxlUG93ID0gcG93O1xuICBleHBvcnRzLnNjYWxlU3FydCA9IHNxcnQ7XG4gIGV4cG9ydHMuc2NhbGVRdWFudGlsZSA9IHF1YW50aWxlJDE7XG4gIGV4cG9ydHMuc2NhbGVRdWFudGl6ZSA9IHF1YW50aXplO1xuICBleHBvcnRzLnNjYWxlVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICBleHBvcnRzLnNjYWxlVGltZSA9IHRpbWU7XG4gIGV4cG9ydHMuc2NhbGVVdGMgPSB1dGNUaW1lO1xuICBleHBvcnRzLnNjaGVtZUNhdGVnb3J5MTAgPSBjYXRlZ29yeTEwO1xuICBleHBvcnRzLnNjaGVtZUNhdGVnb3J5MjBiID0gY2F0ZWdvcnkyMGI7XG4gIGV4cG9ydHMuc2NoZW1lQ2F0ZWdvcnkyMGMgPSBjYXRlZ29yeTIwYztcbiAgZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTIwID0gY2F0ZWdvcnkyMDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHQgPSBjdWJlaGVsaXgkMTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZVJhaW5ib3cgPSByYWluYm93JDE7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVXYXJtID0gd2FybTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUNvb2wgPSBjb29sO1xuICBleHBvcnRzLmludGVycG9sYXRlVmlyaWRpcyA9IHZpcmlkaXM7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVNYWdtYSA9IG1hZ21hO1xuICBleHBvcnRzLmludGVycG9sYXRlSW5mZXJubyA9IGluZmVybm87XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVQbGFzbWEgPSBwbGFzbWE7XG4gIGV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsID0gc2VxdWVudGlhbDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zZWxlY3Rpb24vIFZlcnNpb24gMS4wLjIuIENvcHlyaWdodCAyMDE2IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG4gIHZhciBuYW1lc3BhY2VzID0ge1xuICAgIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHhodG1sOiB4aHRtbCxcbiAgICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbiAgfTtcblxuICBmdW5jdGlvbiBuYW1lc3BhY2UobmFtZSkge1xuICAgIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gICAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0b3IobmFtZSkge1xuICAgIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHZhciBuZXh0SWQgPSAwO1xuXG4gIGZ1bmN0aW9uIGxvY2FsKCkge1xuICAgIHJldHVybiBuZXcgTG9jYWw7XG4gIH1cblxuICBmdW5jdGlvbiBMb2NhbCgpIHtcbiAgICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xuICB9XG5cbiAgTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBMb2NhbCxcbiAgICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIG5vZGVbaWRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl87XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYXRjaGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQubWF0Y2hlcykge1xuICAgICAgdmFyIHZlbmRvck1hdGNoZXMgPSBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgICB8fCBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgIHx8IGVsZW1lbnQub01hdGNoZXNTZWxlY3RvcjtcbiAgICAgIG1hdGNoZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHZlbmRvck1hdGNoZXMuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXRjaGVyJDEgPSBtYXRjaGVyO1xuXG4gIHZhciBmaWx0ZXJFdmVudHMgPSB7fTtcblxuICBleHBvcnRzLmV2ZW50ID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIGVsZW1lbnQkMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoIShcIm9ubW91c2VlbnRlclwiIGluIGVsZW1lbnQkMSkpIHtcbiAgICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gICAgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgOCkpKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBmdW5jdGlvbihldmVudDEpIHtcbiAgICAgIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgaW5kZXgsIGdyb3VwKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICAgIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25bKytpXSA9IG87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICAgIHZhciB3cmFwID0gZmlsdGVyRXZlbnRzLmhhc093blByb3BlcnR5KHR5cGVuYW1lLnR5cGUpID8gZmlsdGVyQ29udGV4dExpc3RlbmVyIDogY29udGV4dExpc3RlbmVyO1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBpLCBncm91cCkge1xuICAgICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8uY2FwdHVyZSA9IGNhcHR1cmUpO1xuICAgICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBjYXB0dXJlOiBjYXB0dXJlfTtcbiAgICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX29uKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICAgIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICAgIGlmIChjYXB0dXJlID09IG51bGwpIGNhcHR1cmUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgY2FwdHVyZSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICAgIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50O1xuICAgIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV4cG9ydHMuZXZlbnQ7XG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNvdXJjZUV2ZW50KCkge1xuICAgIHZhciBjdXJyZW50ID0gZXhwb3J0cy5ldmVudCwgc291cmNlO1xuICAgIHdoaWxlIChzb3VyY2UgPSBjdXJyZW50LnNvdXJjZUV2ZW50KSBjdXJyZW50ID0gc291cmNlO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQobm9kZSwgZXZlbnQpIHtcbiAgICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcblxuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZShub2RlKSB7XG4gICAgdmFyIGV2ZW50ID0gc291cmNlRXZlbnQoKTtcbiAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgcmV0dXJuIHBvaW50KG5vZGUsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vbmUoKSB7fVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdChzZWxlY3QpIHtcbiAgICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdEFsbChzZWxlY3QpIHtcbiAgICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2ZpbHRlcihtYXRjaCkge1xuICAgIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyJDEobWF0Y2gpO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BhcnNlKHVwZGF0ZSkge1xuICAgIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZW50ZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gICAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG4gIH1cblxuICBFbnRlck5vZGUucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBrZXlQcmVmaXggPSBcIiRcIjsgLy8gUHJvdGVjdCBhZ2FpbnN0IGtleXMgbGlrZSDigJxfX3Byb3RvX1/igJ0uXG5cbiAgZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAgIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAgIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gICAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gICAgdmFyIGksXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVCeUtleVZhbHVlID0ge30sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICAgIGtleVZhbHVlO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gICAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAgIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICAgIGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVzW2ldXSA9PT0gbm9kZSkpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2RhdGEodmFsdWUsIGtleSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGRhdGEgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBqID0gLTE7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICAgIGRhdGEgPSB2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cyksXG4gICAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gICAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICAgIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9leGl0KCkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9tZXJnZShzZWxlY3Rpb24pIHtcblxuICAgIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX29yZGVyKCkge1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gbm9kZS5uZXh0U2libGluZykgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3NvcnQoY29tcGFyZSkge1xuICAgIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2NhbGwoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICAgIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9ub2RlcygpIHtcbiAgICB2YXIgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBpID0gLTE7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBub2Rlc1srK2ldID0gdGhpczsgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX25vZGUoKSB7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9zaXplKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7ICsrc2l6ZTsgfSk7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9lYWNoKGNhbGxiYWNrKSB7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Vmlldyhub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG5vZGU7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICAgIDogZGVmYXVsdFZpZXcobm9kZSA9IHRoaXMubm9kZSgpKVxuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbClcbiAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG4gIH1cblxuICBDbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICAgIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25faHRtbCh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFpc2UoKSB7XG4gICAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9yYWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvd2VyKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzU2libGluZykgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fbG93ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fYXBwZW5kKG5hbWUpIHtcbiAgICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9pbnNlcnQobmFtZSwgYmVmb3JlKSB7XG4gICAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBzZWxlY3RvcihiZWZvcmUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fcmVtb3ZlKCkge1xuICAgIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9kYXR1bSh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXG4gICAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gICAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZGlzcGF0Y2godHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBbbnVsbF07XG5cbiAgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICAgIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCByb290KTtcbiAgfVxuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gICAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICAgIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gICAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gICAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICAgIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gICAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gICAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gICAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICAgIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICAgIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICAgIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gICAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICAgIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gICAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICAgIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gICAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgICBvbjogc2VsZWN0aW9uX29uLFxuICAgIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2hcbiAgfTtcblxuICBmdW5jdGlvbiBzZWxlY3Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBuZXcgU2VsZWN0aW9uKFtkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgICA6IG5ldyBTZWxlY3Rpb24oW3NlbGVjdG9yID09IG51bGwgPyBbXSA6IHNlbGVjdG9yXSwgcm9vdCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaChub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gcG9pbnQobm9kZSwgdG91Y2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlcyhub2RlLCB0b3VjaGVzKSB7XG4gICAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgcG9pbnRzID0gbmV3IEFycmF5KG4pOyBpIDwgbjsgKytpKSB7XG4gICAgICBwb2ludHNbaV0gPSBwb2ludChub2RlLCB0b3VjaGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZXhwb3J0cy5jcmVhdG9yID0gY3JlYXRvcjtcbiAgZXhwb3J0cy5sb2NhbCA9IGxvY2FsO1xuICBleHBvcnRzLm1hdGNoZXIgPSBtYXRjaGVyJDE7XG4gIGV4cG9ydHMubW91c2UgPSBtb3VzZTtcbiAgZXhwb3J0cy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGV4cG9ydHMubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG4gIGV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xuICBleHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbiAgZXhwb3J0cy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIGV4cG9ydHMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgZXhwb3J0cy5zZWxlY3RvckFsbCA9IHNlbGVjdG9yQWxsO1xuICBleHBvcnRzLnRvdWNoID0gdG91Y2g7XG4gIGV4cG9ydHMudG91Y2hlcyA9IHRvdWNoZXM7XG4gIGV4cG9ydHMud2luZG93ID0gZGVmYXVsdFZpZXc7XG4gIGV4cG9ydHMuY3VzdG9tRXZlbnQgPSBjdXN0b21FdmVudDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10aW1lLWZvcm1hdC8gdjIuMS4zIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtdGltZScpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXRpbWUnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1RpbWUpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBsb2NhbERhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkLnkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xufVxuXG5mdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xufVxuXG5mdW5jdGlvbiBuZXdZZWFyKHkpIHtcbiAgcmV0dXJuIHt5OiB5LCBtOiAwLCBkOiAxLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsXG4gICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICBsb2NhbGVfc2hvcnRXZWVrZGF5cyA9IGxvY2FsZS5zaG9ydERheXMsXG4gICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICB2YXIgcGVyaW9kUmUgPSBmb3JtYXRSZShsb2NhbGVfcGVyaW9kcyksXG4gICAgICBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxuICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICB2YXIgZm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImZcIjogZm9ybWF0TWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgXCJRXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXAsXG4gICAgXCJzXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBmb3JtYXRTZWNvbmRzLFxuICAgIFwidVwiOiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5LFxuICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBmb3JtYXRXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5LFxuICAgIFwiV1wiOiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBudWxsLFxuICAgIFwiWFwiOiBudWxsLFxuICAgIFwieVwiOiBmb3JtYXRZZWFyLFxuICAgIFwiWVwiOiBmb3JtYXRGdWxsWWVhcixcbiAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0VVRDU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRVVENXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRVVENNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcImZcIjogZm9ybWF0VVRDTWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBmb3JtYXRVVENIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdFVUQ0hvdXIxMixcbiAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRVVENNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdFVUQ01vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRVVENQZXJpb2QsXG4gICAgXCJRXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXAsXG4gICAgXCJzXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxuICAgIFwidVwiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyTW9uZGF5LFxuICAgIFwiVVwiOiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBmb3JtYXRVVENXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyU3VuZGF5LFxuICAgIFwiV1wiOiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBudWxsLFxuICAgIFwiWFwiOiBudWxsLFxuICAgIFwieVwiOiBmb3JtYXRVVENZZWFyLFxuICAgIFwiWVwiOiBmb3JtYXRVVENGdWxsWWVhcixcbiAgICBcIlpcIjogZm9ybWF0VVRDWm9uZSxcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICB2YXIgcGFyc2VzID0ge1xuICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcbiAgICBcIkFcIjogcGFyc2VXZWVrZGF5LFxuICAgIFwiYlwiOiBwYXJzZVNob3J0TW9udGgsXG4gICAgXCJCXCI6IHBhcnNlTW9udGgsXG4gICAgXCJjXCI6IHBhcnNlTG9jYWxlRGF0ZVRpbWUsXG4gICAgXCJkXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBwYXJzZU1pY3Jvc2Vjb25kcyxcbiAgICBcIkhcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJJXCI6IHBhcnNlSG91cjI0LFxuICAgIFwialwiOiBwYXJzZURheU9mWWVhcixcbiAgICBcIkxcIjogcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IHBhcnNlTWludXRlcyxcbiAgICBcInBcIjogcGFyc2VQZXJpb2QsXG4gICAgXCJRXCI6IHBhcnNlVW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogcGFyc2VVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgIFwidVwiOiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogcGFyc2VXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogcGFyc2VMb2NhbGVEYXRlLFxuICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXG4gICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICBcIllcIjogcGFyc2VGdWxsWWVhcixcbiAgICBcIlpcIjogcGFyc2Vab25lLFxuICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgLy8gVGhlc2UgcmVjdXJzaXZlIGRpcmVjdGl2ZSBkZWZpbml0aW9ucyBtdXN0IGJlIGRlZmVycmVkLlxuICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCBmb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgdXRjRm9ybWF0cyk7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgc3RyaW5nID0gW10sXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFkLFxuICAgICAgICAgIGZvcm1hdDtcblxuICAgICAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSBkYXRlID0gbmV3IERhdGUoK2RhdGUpO1xuXG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICBpZiAoKHBhZCA9IHBhZHNbYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSBzcGVjaWZpZXIuY2hhckF0KCsraSk7XG4gICAgICAgICAgZWxzZSBwYWQgPSBjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCI7XG4gICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkKTtcbiAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3UGFyc2Uoc3BlY2lmaWVyLCBuZXdEYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIGQgPSBuZXdZZWFyKDE5MDApLFxuICAgICAgICAgIGkgPSBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZyArPSBcIlwiLCAwKSxcbiAgICAgICAgICB3ZWVrLCBkYXk7XG4gICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gSWYgYSBVTklYIHRpbWVzdGFtcCBpcyBzcGVjaWZpZWQsIHJldHVybiBpdC5cbiAgICAgIGlmIChcIlFcIiBpbiBkKSByZXR1cm4gbmV3IERhdGUoZC5RKTtcblxuICAgICAgLy8gVGhlIGFtLXBtIGZsYWcgaXMgMCBmb3IgQU0sIGFuZCAxIGZvciBQTS5cbiAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuXG4gICAgICAvLyBDb252ZXJ0IGRheS1vZi13ZWVrIGFuZCB3ZWVrLW9mLXllYXIgdG8gZGF5LW9mLXllYXIuXG4gICAgICBpZiAoXCJWXCIgaW4gZCkge1xuICAgICAgICBpZiAoZC5WIDwgMSB8fCBkLlYgPiA1MykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSAxO1xuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICAgIHdlZWsgPSB1dGNEYXRlKG5ld1llYXIoZC55KSksIGRheSA9IHdlZWsuZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgd2VlayA9IGRheSA+IDQgfHwgZGF5ID09PSAwID8gZDNUaW1lLnV0Y01vbmRheS5jZWlsKHdlZWspIDogZDNUaW1lLnV0Y01vbmRheSh3ZWVrKTtcbiAgICAgICAgICB3ZWVrID0gZDNUaW1lLnV0Y0RheS5vZmZzZXQod2VlaywgKGQuViAtIDEpICogNyk7XG4gICAgICAgICAgZC55ID0gd2Vlay5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgIGQubSA9IHdlZWsuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICBkLmQgPSB3ZWVrLmdldFVUQ0RhdGUoKSArIChkLncgKyA2KSAlIDc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2VlayA9IG5ld0RhdGUobmV3WWVhcihkLnkpKSwgZGF5ID0gd2Vlay5nZXREYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyBkM1RpbWUudGltZU1vbmRheS5jZWlsKHdlZWspIDogZDNUaW1lLnRpbWVNb25kYXkod2Vlayk7XG4gICAgICAgICAgd2VlayA9IGQzVGltZS50aW1lRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0RGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IFwidVwiIGluIGQgPyBkLnUgJSA3IDogXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICBkYXkgPSBcIlpcIiBpbiBkID8gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpIDogbmV3RGF0ZShuZXdZZWFyKGQueSkpLmdldERheSgpO1xuICAgICAgICBkLm0gPSAwO1xuICAgICAgICBkLmQgPSBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF5ICsgNSkgJSA3IDogZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgdGltZSB6b25lIGlzIHNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRDIGFuZCB0aGVuXG4gICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgZC5IICs9IGQuWiAvIDEwMCB8IDA7XG4gICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICByZXR1cm4gbmV3RGF0ZShkKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgYyxcbiAgICAgICAgcGFyc2U7XG5cbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckF0KGkrKyk7XG4gICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gcGVyaW9kUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQucCA9IHBlcmlvZExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSBzaG9ydFdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gd2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0TW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gbW9udGhMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGVUaW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX3RpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgZm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIGxvY2FsRGF0ZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCB1dGNEYXRlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifSxcbiAgICBudW1iZXJSZSA9IC9eXFxzKlxcZCsvLCAvLyBub3RlOiBpZ25vcmVzIG5leHQgZGlyZWN0aXZlXG4gICAgcGVyY2VudFJlID0gL14lLyxcbiAgICByZXF1b3RlUmUgPSAvW1xcXFxeJCorP3xbXFxdKCkue31dL2c7XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICB2YXIgbWFwID0ge30sIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIG1hcFtuYW1lc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGk7XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC51ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlcklTTyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlYgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/Ly5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLlogPSBuWzFdID8gMCA6IC0oblsyXSArIChuWzNdIHx8IFwiMDBcIikpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9udGhOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZk1vbnRoKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gIHJldHVybiBuID8gKGQubSA9IDAsIGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG91cjI0KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWludXRlcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaWNyb3NlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDYpKTtcbiAgcmV0dXJuIG4gPyAoZC5MID0gTWF0aC5mbG9vcihuWzBdIC8gMTAwMCksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsUGVyY2VudChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml4VGltZXN0YW1wKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5RID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml4VGltZXN0YW1wU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQuUSA9ICgrblswXSkgKiAxMDAwLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgZDNUaW1lLnRpbWVEYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHJldHVybiBkYXkgPT09IDAgPyA3IDogZGF5O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZVN1bmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcklTTyhkLCBwKSB7XG4gIHZhciBkYXkgPSBkLmdldERheSgpO1xuICBkID0gKGRheSA+PSA0IHx8IGRheSA9PT0gMCkgPyBkM1RpbWUudGltZVRodXJzZGF5KGQpIDogZDNUaW1lLnRpbWVUaHVyc2RheS5jZWlsKGQpO1xuICByZXR1cm4gcGFkKGQzVGltZS50aW1lVGh1cnNkYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpLCBkKSArIChkM1RpbWUudGltZVllYXIoZCkuZ2V0RGF5KCkgPT09IDQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlclN1bmRheShkKSB7XG4gIHJldHVybiBkLmdldERheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZU1vbmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudXRjRGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDU2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRvdyA9IGQuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiBkb3cgPT09IDAgPyA3IDogZG93O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjU3VuZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08oZCwgcCkge1xuICB2YXIgZGF5ID0gZC5nZXRVVENEYXkoKTtcbiAgZCA9IChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gZDNUaW1lLnV0Y1RodXJzZGF5KGQpIDogZDNUaW1lLnV0Y1RodXJzZGF5LmNlaWwoZCk7XG4gIHJldHVybiBwYWQoZDNUaW1lLnV0Y1RodXJzZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSArIChkM1RpbWUudXRjWWVhcihkKS5nZXRVVENEYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNNb25kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcbiAgcmV0dXJuIFwiKzAwMDBcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TGl0ZXJhbFBlcmNlbnQoKSB7XG4gIHJldHVybiBcIiVcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcChkKSB7XG4gIHJldHVybiArZDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMoZCkge1xuICByZXR1cm4gTWF0aC5mbG9vcigrZCAvIDEwMDApO1xufVxuXG52YXIgbG9jYWxlO1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXG4gIGRhdGU6IFwiJS1tLyUtZC8lWVwiLFxuICB0aW1lOiBcIiUtSTolTTolUyAlcFwiLFxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn0pO1xuXG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICBleHBvcnRzLnRpbWVGb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLnRpbWVQYXJzZSA9IGxvY2FsZS5wYXJzZTtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBsb2NhbGUudXRjRm9ybWF0O1xuICBleHBvcnRzLnV0Y1BhcnNlID0gbG9jYWxlLnV0Y1BhcnNlO1xuICByZXR1cm4gbG9jYWxlO1xufVxuXG52YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nXG4gICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICA6IGV4cG9ydHMudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvTmF0aXZlKHN0cmluZykge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xufVxuXG52YXIgcGFyc2VJc28gPSArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIilcbiAgICA/IHBhcnNlSXNvTmF0aXZlXG4gICAgOiBleHBvcnRzLnV0Y1BhcnNlKGlzb1NwZWNpZmllcik7XG5cbmV4cG9ydHMudGltZUZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuZXhwb3J0cy50aW1lRm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xuZXhwb3J0cy5pc29Gb3JtYXQgPSBmb3JtYXRJc287XG5leHBvcnRzLmlzb1BhcnNlID0gcGFyc2VJc287XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUvIHYxLjAuMTAgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciB0MCA9IG5ldyBEYXRlLFxuICAgIHQxID0gbmV3IERhdGU7XG5cbmZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQsIGZpZWxkKSB7XG5cbiAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gIH1cblxuICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZmxvb3JpKGRhdGUpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkMCA9IGludGVydmFsKGRhdGUpLFxuICAgICAgICBkMSA9IGludGVydmFsLmNlaWwoZGF0ZSk7XG4gICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gIH07XG5cbiAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgdmFyIHJhbmdlID0gW10sIHByZXZpb3VzO1xuICAgIHN0YXJ0ID0gaW50ZXJ2YWwuY2VpbChzdGFydCk7XG4gICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgIGRvIHJhbmdlLnB1c2gocHJldmlvdXMgPSBuZXcgRGF0ZSgrc3RhcnQpKSwgb2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCk7XG4gICAgd2hpbGUgKHByZXZpb3VzIDwgc3RhcnQgJiYgc3RhcnQgPCBzdG9wKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB7XG4gICAgICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKCsrc3RlcCA8PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgLTEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGVsc2Ugd2hpbGUgKC0tc3RlcCA+PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgKzEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIGludGVydmFsLmV2ZXJ5ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICByZXR1cm4gIWlzRmluaXRlKHN0ZXApIHx8ICEoc3RlcCA+IDApID8gbnVsbFxuICAgICAgICAgIDogIShzdGVwID4gMSkgPyBpbnRlcnZhbFxuICAgICAgICAgIDogaW50ZXJ2YWwuZmlsdGVyKGZpZWxkXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24oZCkgeyByZXR1cm4gZmllbGQoZCkgJSBzdGVwID09PSAwOyB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZCkgeyByZXR1cm4gaW50ZXJ2YWwuY291bnQoMCwgZCkgJSBzdGVwID09PSAwOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufVxuXG52YXIgbWlsbGlzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgLy8gbm9vcFxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbm1pbGxpc2Vjb25kLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICBrID0gTWF0aC5mbG9vcihrKTtcbiAgaWYgKCFpc0Zpbml0ZShrKSB8fCAhKGsgPiAwKSkgcmV0dXJuIG51bGw7XG4gIGlmICghKGsgPiAxKSkgcmV0dXJuIG1pbGxpc2Vjb25kO1xuICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBrKSAqIGspO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGspO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBrO1xuICB9KTtcbn07XG52YXIgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmQucmFuZ2U7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDFlMztcbnZhciBkdXJhdGlvbk1pbnV0ZSA9IDZlNDtcbnZhciBkdXJhdGlvbkhvdXIgPSAzNmU1O1xudmFyIGR1cmF0aW9uRGF5ID0gODY0ZTU7XG52YXIgZHVyYXRpb25XZWVrID0gNjA0OGU1O1xuXG52YXIgc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gZHVyYXRpb25TZWNvbmQpICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uU2Vjb25kO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG59KTtcbnZhciBzZWNvbmRzID0gc2Vjb25kLnJhbmdlO1xuXG52YXIgbWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gZHVyYXRpb25NaW51dGUpICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG59KTtcbnZhciBtaW51dGVzID0gbWludXRlLnJhbmdlO1xuXG52YXIgaG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlICUgZHVyYXRpb25Ib3VyO1xuICBpZiAob2Zmc2V0IDwgMCkgb2Zmc2V0ICs9IGR1cmF0aW9uSG91cjtcbiAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoKCtkYXRlIC0gb2Zmc2V0KSAvIGR1cmF0aW9uSG91cikgKiBkdXJhdGlvbkhvdXIgKyBvZmZzZXQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG59KTtcbnZhciBob3VycyA9IGhvdXIucmFuZ2U7XG5cbnZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbn0pO1xudmFyIGRheXMgPSBkYXkucmFuZ2U7XG5cbmZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbnZhciBzdW5kYXkgPSB3ZWVrZGF5KDApO1xudmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XG52YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG52YXIgd2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcbnZhciB0aHVyc2RheSA9IHdlZWtkYXkoNCk7XG52YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbnZhciBzYXR1cmRheSA9IHdlZWtkYXkoNik7XG5cbnZhciBzdW5kYXlzID0gc3VuZGF5LnJhbmdlO1xudmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG52YXIgdHVlc2RheXMgPSB0dWVzZGF5LnJhbmdlO1xudmFyIHdlZG5lc2RheXMgPSB3ZWRuZXNkYXkucmFuZ2U7XG52YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG52YXIgZnJpZGF5cyA9IGZyaWRheS5yYW5nZTtcbnZhciBzYXR1cmRheXMgPSBzYXR1cmRheS5yYW5nZTtcblxudmFyIG1vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldERhdGUoMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCkgKyAoZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xufSk7XG52YXIgbW9udGhzID0gbW9udGgucmFuZ2U7XG5cbnZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnllYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xudmFyIHllYXJzID0geWVhci5yYW5nZTtcblxudmFyIHV0Y01pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENTZWNvbmRzKDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG59KTtcbnZhciB1dGNNaW51dGVzID0gdXRjTWludXRlLnJhbmdlO1xuXG52YXIgdXRjSG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNaW51dGVzKDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0hvdXJzKCk7XG59KTtcbnZhciB1dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG5cbnZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgLSAxO1xufSk7XG52YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcblxuZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG52YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbnZhciB1dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xudmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xudmFyIHV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG52YXIgdXRjVGh1cnNkYXkgPSB1dGNXZWVrZGF5KDQpO1xudmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG52YXIgdXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG52YXIgdXRjU3VuZGF5cyA9IHV0Y1N1bmRheS5yYW5nZTtcbnZhciB1dGNNb25kYXlzID0gdXRjTW9uZGF5LnJhbmdlO1xudmFyIHV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheS5yYW5nZTtcbnZhciB1dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5LnJhbmdlO1xudmFyIHV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5LnJhbmdlO1xudmFyIHV0Y0ZyaWRheXMgPSB1dGNGcmlkYXkucmFuZ2U7XG52YXIgdXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXkucmFuZ2U7XG5cbnZhciB1dGNNb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKTtcbn0pO1xudmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuXG52YXIgdXRjWWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG51dGNZZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcbnZhciB1dGNZZWFycyA9IHV0Y1llYXIucmFuZ2U7XG5cbmV4cG9ydHMudGltZUludGVydmFsID0gbmV3SW50ZXJ2YWw7XG5leHBvcnRzLnRpbWVNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy50aW1lTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG5leHBvcnRzLnRpbWVTZWNvbmQgPSBzZWNvbmQ7XG5leHBvcnRzLnRpbWVTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudXRjU2Vjb25kID0gc2Vjb25kO1xuZXhwb3J0cy51dGNTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudGltZU1pbnV0ZSA9IG1pbnV0ZTtcbmV4cG9ydHMudGltZU1pbnV0ZXMgPSBtaW51dGVzO1xuZXhwb3J0cy50aW1lSG91ciA9IGhvdXI7XG5leHBvcnRzLnRpbWVIb3VycyA9IGhvdXJzO1xuZXhwb3J0cy50aW1lRGF5ID0gZGF5O1xuZXhwb3J0cy50aW1lRGF5cyA9IGRheXM7XG5leHBvcnRzLnRpbWVXZWVrID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lV2Vla3MgPSBzdW5kYXlzO1xuZXhwb3J0cy50aW1lU3VuZGF5ID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lU3VuZGF5cyA9IHN1bmRheXM7XG5leHBvcnRzLnRpbWVNb25kYXkgPSBtb25kYXk7XG5leHBvcnRzLnRpbWVNb25kYXlzID0gbW9uZGF5cztcbmV4cG9ydHMudGltZVR1ZXNkYXkgPSB0dWVzZGF5O1xuZXhwb3J0cy50aW1lVHVlc2RheXMgPSB0dWVzZGF5cztcbmV4cG9ydHMudGltZVdlZG5lc2RheSA9IHdlZG5lc2RheTtcbmV4cG9ydHMudGltZVdlZG5lc2RheXMgPSB3ZWRuZXNkYXlzO1xuZXhwb3J0cy50aW1lVGh1cnNkYXkgPSB0aHVyc2RheTtcbmV4cG9ydHMudGltZVRodXJzZGF5cyA9IHRodXJzZGF5cztcbmV4cG9ydHMudGltZUZyaWRheSA9IGZyaWRheTtcbmV4cG9ydHMudGltZUZyaWRheXMgPSBmcmlkYXlzO1xuZXhwb3J0cy50aW1lU2F0dXJkYXkgPSBzYXR1cmRheTtcbmV4cG9ydHMudGltZVNhdHVyZGF5cyA9IHNhdHVyZGF5cztcbmV4cG9ydHMudGltZU1vbnRoID0gbW9udGg7XG5leHBvcnRzLnRpbWVNb250aHMgPSBtb250aHM7XG5leHBvcnRzLnRpbWVZZWFyID0geWVhcjtcbmV4cG9ydHMudGltZVllYXJzID0geWVhcnM7XG5leHBvcnRzLnV0Y01pbnV0ZSA9IHV0Y01pbnV0ZTtcbmV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZXM7XG5leHBvcnRzLnV0Y0hvdXIgPSB1dGNIb3VyO1xuZXhwb3J0cy51dGNIb3VycyA9IHV0Y0hvdXJzO1xuZXhwb3J0cy51dGNEYXkgPSB1dGNEYXk7XG5leHBvcnRzLnV0Y0RheXMgPSB1dGNEYXlzO1xuZXhwb3J0cy51dGNXZWVrID0gdXRjU3VuZGF5O1xuZXhwb3J0cy51dGNXZWVrcyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1N1bmRheTtcbmV4cG9ydHMudXRjU3VuZGF5cyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y01vbmRheSA9IHV0Y01vbmRheTtcbmV4cG9ydHMudXRjTW9uZGF5cyA9IHV0Y01vbmRheXM7XG5leHBvcnRzLnV0Y1R1ZXNkYXkgPSB1dGNUdWVzZGF5O1xuZXhwb3J0cy51dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXlzO1xuZXhwb3J0cy51dGNXZWRuZXNkYXkgPSB1dGNXZWRuZXNkYXk7XG5leHBvcnRzLnV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXlzO1xuZXhwb3J0cy51dGNUaHVyc2RheSA9IHV0Y1RodXJzZGF5O1xuZXhwb3J0cy51dGNUaHVyc2RheXMgPSB1dGNUaHVyc2RheXM7XG5leHBvcnRzLnV0Y0ZyaWRheSA9IHV0Y0ZyaWRheTtcbmV4cG9ydHMudXRjRnJpZGF5cyA9IHV0Y0ZyaWRheXM7XG5leHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjU2F0dXJkYXk7XG5leHBvcnRzLnV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5cztcbmV4cG9ydHMudXRjTW9udGggPSB1dGNNb250aDtcbmV4cG9ydHMudXRjTW9udGhzID0gdXRjTW9udGhzO1xuZXhwb3J0cy51dGNZZWFyID0gdXRjWWVhcjtcbmV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFycztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogKipbR2F1c3NpYW4gZXJyb3IgZnVuY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24pKipcbiAqXG4gKiBUaGUgYGVycm9yRnVuY3Rpb24oeC8oc2QgKiBNYXRoLnNxcnQoMikpKWAgaXMgdGhlIHByb2JhYmlsaXR5IHRoYXQgYSB2YWx1ZSBpbiBhXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uIHdpdGggc3RhbmRhcmQgZGV2aWF0aW9uIHNkIGlzIHdpdGhpbiB4IG9mIHRoZSBtZWFuLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG51bWVyaWNhbCBhcHByb3hpbWF0aW9uIHRvIHRoZSBleGFjdCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfSBlcnJvciBlc3RpbWF0aW9uXG4gKiBAZXhhbXBsZVxuICogZXJyb3JGdW5jdGlvbigxKS50b0ZpeGVkKDIpOyAvLyA9PiAnMC44NCdcbiAqL1xuZnVuY3Rpb24gZXJyb3JGdW5jdGlvbih4Lyo6IG51bWJlciAqLykvKjogbnVtYmVyICovIHtcbiAgICB2YXIgdCA9IDEgLyAoMSArIDAuNSAqIE1hdGguYWJzKHgpKTtcbiAgICB2YXIgdGF1ID0gdCAqIE1hdGguZXhwKC1NYXRoLnBvdyh4LCAyKSAtXG4gICAgICAgIDEuMjY1NTEyMjMgK1xuICAgICAgICAxLjAwMDAyMzY4ICogdCArXG4gICAgICAgIDAuMzc0MDkxOTYgKiBNYXRoLnBvdyh0LCAyKSArXG4gICAgICAgIDAuMDk2Nzg0MTggKiBNYXRoLnBvdyh0LCAzKSAtXG4gICAgICAgIDAuMTg2Mjg4MDYgKiBNYXRoLnBvdyh0LCA0KSArXG4gICAgICAgIDAuMjc4ODY4MDcgKiBNYXRoLnBvdyh0LCA1KSAtXG4gICAgICAgIDEuMTM1MjAzOTggKiBNYXRoLnBvdyh0LCA2KSArXG4gICAgICAgIDEuNDg4NTE1ODcgKiBNYXRoLnBvdyh0LCA3KSAtXG4gICAgICAgIDAuODIyMTUyMjMgKiBNYXRoLnBvdyh0LCA4KSArXG4gICAgICAgIDAuMTcwODcyNzcgKiBNYXRoLnBvdyh0LCA5KSk7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgICByZXR1cm4gMSAtIHRhdTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGF1IC0gMTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXJyb3JGdW5jdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogW1NpbXBsZSBsaW5lYXIgcmVncmVzc2lvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfbGluZWFyX3JlZ3Jlc3Npb24pXG4gKiBpcyBhIHNpbXBsZSB3YXkgdG8gZmluZCBhIGZpdHRlZCBsaW5lXG4gKiBiZXR3ZWVuIGEgc2V0IG9mIGNvb3JkaW5hdGVzLiBUaGlzIGFsZ29yaXRobSBmaW5kcyB0aGUgc2xvcGUgYW5kIHktaW50ZXJjZXB0IG9mIGEgcmVncmVzc2lvbiBsaW5lXG4gKiB1c2luZyB0aGUgbGVhc3Qgc3VtIG9mIHNxdWFyZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGF0YSBhbiBhcnJheSBvZiB0d28tZWxlbWVudCBvZiBhcnJheXMsXG4gKiBsaWtlIGBbWzAsIDFdLCBbMiwgM11dYFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgc2xvcGUgYW5kIGludGVyc2VjdCBvZiByZWdyZXNzaW9uIGxpbmVcbiAqIEBleGFtcGxlXG4gKiBsaW5lYXJSZWdyZXNzaW9uKFtbMCwgMF0sIFsxLCAxXV0pOyAvLyA9PiB7IG06IDEsIGI6IDAgfVxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uKGRhdGEvKjogQXJyYXk8QXJyYXk8bnVtYmVyPj4gKi8pLyo6IHsgbTogbnVtYmVyLCBiOiBudW1iZXIgfSAqLyB7XG5cbiAgICB2YXIgbSwgYjtcblxuICAgIC8vIFN0b3JlIGRhdGEgbGVuZ3RoIGluIGEgbG9jYWwgdmFyaWFibGUgdG8gcmVkdWNlXG4gICAgLy8gcmVwZWF0ZWQgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgLy9pZiB0aGVyZSdzIG9ubHkgb25lIHBvaW50LCBhcmJpdHJhcmlseSBjaG9vc2UgYSBzbG9wZSBvZiAwXG4gICAgLy9hbmQgYSB5LWludGVyY2VwdCBvZiB3aGF0ZXZlciB0aGUgeSBvZiB0aGUgaW5pdGlhbCBwb2ludCBpc1xuICAgIGlmIChkYXRhTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBiID0gZGF0YVswXVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbml0aWFsaXplIG91ciBzdW1zIGFuZCBzY29wZSB0aGUgYG1gIGFuZCBgYmBcbiAgICAgICAgLy8gdmFyaWFibGVzIHRoYXQgZGVmaW5lIHRoZSBsaW5lLlxuICAgICAgICB2YXIgc3VtWCA9IDAsIHN1bVkgPSAwLFxuICAgICAgICAgICAgc3VtWFggPSAwLCBzdW1YWSA9IDA7XG5cbiAgICAgICAgLy8gVXNlIGxvY2FsIHZhcmlhYmxlcyB0byBncmFiIHBvaW50IHZhbHVlc1xuICAgICAgICAvLyB3aXRoIG1pbmltYWwgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICAgICAgdmFyIHBvaW50LCB4LCB5O1xuXG4gICAgICAgIC8vIEdhdGhlciB0aGUgc3VtIG9mIGFsbCB4IHZhbHVlcywgdGhlIHN1bSBvZiBhbGxcbiAgICAgICAgLy8geSB2YWx1ZXMsIGFuZCB0aGUgc3VtIG9mIHheMiBhbmQgKHgqeSkgZm9yIGVhY2hcbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIG1hdGggbm90YXRpb24sIHRoZXNlIHdvdWxkIGJlIFNTX3gsIFNTX3ksIFNTX3h4LCBhbmQgU1NfeHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHggPSBwb2ludFswXTtcbiAgICAgICAgICAgIHkgPSBwb2ludFsxXTtcblxuICAgICAgICAgICAgc3VtWCArPSB4O1xuICAgICAgICAgICAgc3VtWSArPSB5O1xuXG4gICAgICAgICAgICBzdW1YWCArPSB4ICogeDtcbiAgICAgICAgICAgIHN1bVhZICs9IHggKiB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYG1gIGlzIHRoZSBzbG9wZSBvZiB0aGUgcmVncmVzc2lvbiBsaW5lXG4gICAgICAgIG0gPSAoKGRhdGFMZW5ndGggKiBzdW1YWSkgLSAoc3VtWCAqIHN1bVkpKSAvXG4gICAgICAgICAgICAoKGRhdGFMZW5ndGggKiBzdW1YWCkgLSAoc3VtWCAqIHN1bVgpKTtcblxuICAgICAgICAvLyBgYmAgaXMgdGhlIHktaW50ZXJjZXB0IG9mIHRoZSBsaW5lLlxuICAgICAgICBiID0gKHN1bVkgLyBkYXRhTGVuZ3RoKSAtICgobSAqIHN1bVgpIC8gZGF0YUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGJvdGggdmFsdWVzIGFzIGFuIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBtOiBtLFxuICAgICAgICBiOiBiXG4gICAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhclJlZ3Jlc3Npb247XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIEdpdmVuIHRoZSBvdXRwdXQgb2YgYGxpbmVhclJlZ3Jlc3Npb25gOiBhbiBvYmplY3RcbiAqIHdpdGggYG1gIGFuZCBgYmAgdmFsdWVzIGluZGljYXRpbmcgc2xvcGUgYW5kIGludGVyY2VwdCxcbiAqIHJlc3BlY3RpdmVseSwgZ2VuZXJhdGUgYSBsaW5lIGZ1bmN0aW9uIHRoYXQgdHJhbnNsYXRlc1xuICogeCB2YWx1ZXMgaW50byB5IHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWIgb2JqZWN0IHdpdGggYG1gIGFuZCBgYmAgbWVtYmVycywgcmVwcmVzZW50aW5nXG4gKiBzbG9wZSBhbmQgaW50ZXJzZWN0IG9mIGRlc2lyZWQgbGluZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBtZXRob2QgdGhhdCBjb21wdXRlcyB5LXZhbHVlIGF0IGFueSBnaXZlblxuICogeC12YWx1ZSBvbiB0aGUgbGluZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbCA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24oW1swLCAwXSwgWzEsIDFdXSkpO1xuICogbCgwKSAvLyA9IDBcbiAqIGwoMikgLy8gPSAyXG4gKiBsaW5lYXJSZWdyZXNzaW9uTGluZSh7IGI6IDAsIG06IDEgfSkoMSk7IC8vID0+IDFcbiAqIGxpbmVhclJlZ3Jlc3Npb25MaW5lKHsgYjogMSwgbTogMSB9KSgxKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uTGluZShtYi8qOiB7IGI6IG51bWJlciwgbTogbnVtYmVyIH0qLykvKjogRnVuY3Rpb24gKi8ge1xuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgYSBgeWAgdmFsdWUgZm9yIGVhY2hcbiAgICAvLyB4IHZhbHVlIGl0IGlzIGdpdmVuLCBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIGBiYCBhbmQgYGFgXG4gICAgLy8gdGhhdCB3ZSBqdXN0IGNvbXB1dGVkLlxuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBtYi5iICsgKG1iLm0gKiB4KTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHN1bSA9IHJlcXVpcmUoJy4vc3VtJyk7XG5cbi8qKlxuICogVGhlIG1lYW4sIF9hbHNvIGtub3duIGFzIGF2ZXJhZ2VfLFxuICogaXMgdGhlIHN1bSBvZiBhbGwgdmFsdWVzIG92ZXIgdGhlIG51bWJlciBvZiB2YWx1ZXMuXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhpcyBydW5zIG9uIGBPKG4pYCwgbGluZWFyIHRpbWUgaW4gcmVzcGVjdCB0byB0aGUgYXJyYXlcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gb25lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWFuXG4gKiBAZXhhbXBsZVxuICogbWVhbihbMCwgMTBdKTsgLy8gPT4gNVxuICovXG5mdW5jdGlvbiBtZWFuKHggLyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIC8vIFRoZSBtZWFuIG9mIG5vIG51bWJlcnMgaXMgbnVsbFxuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtKHgpIC8geC5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVhbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBxdWFudGlsZVNvcnRlZCA9IHJlcXVpcmUoJy4vcXVhbnRpbGVfc29ydGVkJyk7XG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCcuL3F1aWNrc2VsZWN0Jyk7XG5cbi8qKlxuICogVGhlIFtxdWFudGlsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUpOlxuICogdGhpcyBpcyBhIHBvcHVsYXRpb24gcXVhbnRpbGUsIHNpbmNlIHdlIGFzc3VtZSB0byBrbm93IHRoZSBlbnRpcmVcbiAqIGRhdGFzZXQgaW4gdGhpcyBsaWJyYXJ5LiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICogW1F1YW50aWxlcyBvZiBhIFBvcHVsYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUjUXVhbnRpbGVzX29mX2FfcG9wdWxhdGlvbilcbiAqIGFsZ29yaXRobSBmcm9tIHdpa2lwZWRpYS5cbiAqXG4gKiBTYW1wbGUgaXMgYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2YgbnVtYmVycyxcbiAqIGFuZCBwIGlzIGVpdGhlciBhIGRlY2ltYWwgbnVtYmVyIGZyb20gMCB0byAxIG9yIGFuIGFycmF5IG9mIGRlY2ltYWxcbiAqIG51bWJlcnMgZnJvbSAwIHRvIDEuXG4gKiBJbiB0ZXJtcyBvZiBhIGsvcSBxdWFudGlsZSwgcCA9IGsvcSAtIGl0J3MganVzdCBkZWFsaW5nIHdpdGggZnJhY3Rpb25zIG9yIGRlYWxpbmdcbiAqIHdpdGggZGVjaW1hbCB2YWx1ZXMuXG4gKiBXaGVuIHAgaXMgYW4gYXJyYXksIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlzIGFsc28gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYXBwcm9wcmlhdGVcbiAqIHF1YW50aWxlcyBpbiBpbnB1dCBvcmRlclxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHAgdGhlIGRlc2lyZWQgcXVhbnRpbGUsIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge251bWJlcn0gcXVhbnRpbGVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZShbMywgNiwgNywgOCwgOCwgOSwgMTAsIDEzLCAxNSwgMTYsIDIwXSwgMC41KTsgLy8gPT4gOVxuICovXG5mdW5jdGlvbiBxdWFudGlsZSh4IC8qOiBBcnJheTxudW1iZXI+ICovLCBwIC8qOiBBcnJheTxudW1iZXI+IHwgbnVtYmVyICovKSB7XG4gICAgdmFyIGNvcHkgPSB4LnNsaWNlKCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgICAvLyByZWFycmFuZ2UgZWxlbWVudHMgc28gdGhhdCBlYWNoIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIHJlcXVlc3RlZFxuICAgICAgICAvLyBxdWFudGlsZSBpcyBvbiBhIHBsYWNlIGl0IHdvdWxkIGJlIGlmIHRoZSBhcnJheSB3YXMgZnVsbHkgc29ydGVkXG4gICAgICAgIG11bHRpUXVhbnRpbGVTZWxlY3QoY29weSwgcCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0ZWQgcXVhbnRpbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcXVhbnRpbGVTb3J0ZWQoY29weSwgcFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IHF1YW50aWxlSW5kZXgoY29weS5sZW5ndGgsIHApO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChjb3B5LCBpZHgsIDAsIGNvcHkubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBxdWFudGlsZVNvcnRlZChjb3B5LCBwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlU2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoayAlIDEgPT09IDApIHtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgayA9IE1hdGguZmxvb3Ioayk7XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIGsgKyAxLCBrICsgMSwgcmlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbXVsdGlRdWFudGlsZVNlbGVjdChhcnIsIHApIHtcbiAgICB2YXIgaW5kaWNlcyA9IFswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHF1YW50aWxlSW5kZXgoYXJyLmxlbmd0aCwgcFtpXSkpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2goYXJyLmxlbmd0aCAtIDEpO1xuICAgIGluZGljZXMuc29ydChjb21wYXJlKTtcblxuICAgIHZhciBzdGFjayA9IFswLCBpbmRpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgciA9IE1hdGguY2VpbChzdGFjay5wb3AoKSk7XG4gICAgICAgIHZhciBsID0gTWF0aC5mbG9vcihzdGFjay5wb3AoKSk7XG4gICAgICAgIGlmIChyIC0gbCA8PSAxKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IoKGwgKyByKSAvIDIpO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChhcnIsIGluZGljZXNbbV0sIGluZGljZXNbbF0sIGluZGljZXNbcl0pO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobCwgbSwgbSwgcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlSW5kZXgobGVuIC8qOiBudW1iZXIgKi8sIHAgLyo6IG51bWJlciAqLykvKjpudW1iZXIqLyB7XG4gICAgdmFyIGlkeCA9IGxlbiAqIHA7XG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgaW5kZXhcbiAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG4gICAgfSBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMCwgZGlyZWN0bHkgcmV0dXJuIHRoZSBmaXJzdCBpbmRleFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgaW5kZXggaXMgbm90IGludGVnZXIsIHJldHVybiB0aGUgbmV4dCBpbmRleCBpbiBhcnJheVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGlkeCkgLSAxO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHJldHVybiB0aGUgbWlkZGxlIG9mIHR3byBpbmRpY2VzXG4gICAgICAgIC8vIGFyb3VuZCBxdWFudGlsZSB0byBpbmRpY2F0ZSB0aGF0IHdlIG5lZWQgYW4gYXZlcmFnZSB2YWx1ZSBvZiB0aGUgdHdvXG4gICAgICAgIHJldHVybiBpZHggLSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgaW5kZXhcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgaW5kZXhcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVhbnRpbGU7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHF1YW50aWxlczogd2hlbiB5b3Uga25vd1xuICogdGhhdCB0aGUgb3JkZXIgaXMgc29ydGVkLCB5b3UgZG9uJ3QgbmVlZCB0byByZS1zb3J0IGl0LCBhbmQgdGhlIGNvbXB1dGF0aW9uc1xuICogYXJlIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gcCBkZXNpcmVkIHF1YW50aWxlOiBhIG51bWJlciBiZXR3ZWVuIDAgdG8gMSwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBxdWFudGlsZSB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHAgaXggb3V0c2lkZSBvZiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDFcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVTb3J0ZWQoWzMsIDYsIDcsIDgsIDgsIDksIDEwLCAxMywgMTUsIDE2LCAyMF0sIDAuNSk7IC8vID0+IDlcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQoeCAvKjogQXJyYXk8bnVtYmVyPiAqLywgcCAvKjogbnVtYmVyICovKS8qOm51bWJlciovIHtcbiAgICB2YXIgaWR4ID0geC5sZW5ndGggKiBwO1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3F1YW50aWxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50LicpO1xuICAgIH0gZWxzZSBpZiAocCA8IDAgfHwgcCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxdWFudGlsZXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEnKTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFt4Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIDAsIGRpcmVjdGx5IHJldHVybiB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFswXTtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgcCBpcyBub3QgaW50ZWdlciwgcmV0dXJuIHRoZSBuZXh0IGVsZW1lbnQgaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHhbTWF0aC5jZWlsKGlkeCkgLSAxXTtcbiAgICB9IGVsc2UgaWYgKHgubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhpcyBudW1iZXJcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHZhbHVlLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgcmV0dXJuICh4W2lkeCAtIDFdICsgeFtpZHhdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgdmFsdWVcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgeCB2YWx1ZSBhdCB0aGUgaW5kZXguXG4gICAgICAgIHJldHVybiB4W2lkeF07XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YW50aWxlU29ydGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBxdWlja3NlbGVjdDtcblxuLyoqXG4gKiBSZWFycmFuZ2UgaXRlbXMgaW4gYGFycmAgc28gdGhhdCBhbGwgaXRlbXMgaW4gYFtsZWZ0LCBrXWAgcmFuZ2UgYXJlIHRoZSBzbWFsbGVzdC5cbiAqIFRoZSBga2AtdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIGAoayAtIGxlZnQgKyAxKWAtdGggc21hbGxlc3QgdmFsdWUgaW4gYFtsZWZ0LCByaWdodF1gLlxuICpcbiAqIEltcGxlbWVudHMgRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxveWQtUml2ZXN0X2FsZ29yaXRobVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFyciBpbnB1dCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGsgcGl2b3QgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCByaWdodCBpbmRleFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXJyID0gWzY1LCAyOCwgNTksIDMzLCAyMSwgNTYsIDIyLCA5NSwgNTAsIDEyLCA5MCwgNTMsIDI4LCA3NywgMzldO1xuICogcXVpY2tzZWxlY3QoYXJyLCA4KTtcbiAqIC8vID0gWzM5LCAyOCwgMjgsIDMzLCAyMSwgMTIsIDIyLCA1MCwgNTMsIDU2LCA1OSwgNjUsIDkwLCA3NywgOTVdXG4gKi9cbmZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciAvKjogQXJyYXk8bnVtYmVyPiAqLywgayAvKjogbnVtYmVyICovLCBsZWZ0IC8qOiBudW1iZXIgKi8sIHJpZ2h0IC8qOiBudW1iZXIgKi8pIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCAwO1xuICAgIHJpZ2h0ID0gcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKTtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgLy8gNjAwIGFuZCAwLjUgYXJlIGFyYml0cmFyeSBjb25zdGFudHMgY2hvc2VuIGluIHRoZSBvcmlnaW5hbCBwYXBlciB0byBtaW5pbWl6ZSBleGVjdXRpb24gdGltZVxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbik7XG4gICAgICAgICAgICBpZiAobSAtIG4gLyAyIDwgMCkgc2QgKj0gLTE7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChhcnJbcmlnaHRdID4gdCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChhcnJbaV0gPCB0KSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2pdID4gdCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycltsZWZ0XSA9PT0gdCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBzYW1wbGVDb3ZhcmlhbmNlID0gcmVxdWlyZSgnLi9zYW1wbGVfY292YXJpYW5jZScpO1xudmFyIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uID0gcmVxdWlyZSgnLi9zYW1wbGVfc3RhbmRhcmRfZGV2aWF0aW9uJyk7XG5cbi8qKlxuICogVGhlIFtjb3JyZWxhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db3JyZWxhdGlvbl9hbmRfZGVwZW5kZW5jZSkgaXNcbiAqIGEgbWVhc3VyZSBvZiBob3cgY29ycmVsYXRlZCB0d28gZGF0YXNldHMgYXJlLCBiZXR3ZWVuIC0xIGFuZCAxXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGZpcnN0IGlucHV0XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHkgc2Vjb25kIGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzYW1wbGUgY29ycmVsYXRpb25cbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVDb3JyZWxhdGlvbihbMSwgMiwgMywgNCwgNSwgNl0sIFsyLCAyLCAzLCA0LCA1LCA2MF0pLnRvRml4ZWQoMik7XG4gKiAvLyA9PiAnMC42OSdcbiAqL1xuZnVuY3Rpb24gc2FtcGxlQ29ycmVsYXRpb24oeC8qOiBBcnJheTxudW1iZXI+ICovLCB5Lyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIHZhciBjb3YgPSBzYW1wbGVDb3ZhcmlhbmNlKHgsIHkpLFxuICAgICAgICB4c3RkID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeCksXG4gICAgICAgIHlzdGQgPSBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih5KTtcblxuICAgIHJldHVybiBjb3YgLyB4c3RkIC8geXN0ZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVDb3JyZWxhdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBtZWFuID0gcmVxdWlyZSgnLi9tZWFuJyk7XG5cbi8qKlxuICogW1NhbXBsZSBjb3ZhcmlhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYW1wbGVfbWVhbl9hbmRfc2FtcGxlQ292YXJpYW5jZSkgb2YgdHdvIGRhdGFzZXRzOlxuICogaG93IG11Y2ggZG8gdGhlIHR3byBkYXRhc2V0cyBtb3ZlIHRvZ2V0aGVyP1xuICogeCBhbmQgeSBhcmUgdHdvIGRhdGFzZXRzLCByZXByZXNlbnRlZCBhcyBhcnJheXMgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBzYW1wbGUgb2YgdHdvIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geSBhIHNhbXBsZSBvZiB0d28gb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggYW5kIHkgZG8gbm90IGhhdmUgZXF1YWwgbGVuZ3Roc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggb3IgeSBoYXZlIGxlbmd0aCBvZiBvbmUgb3IgbGVzc1xuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIGNvdmFyaWFuY2VcbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVDb3ZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1LCA2XSwgWzYsIDUsIDQsIDMsIDIsIDFdKTsgLy8gPT4gLTMuNVxuICovXG5mdW5jdGlvbiBzYW1wbGVDb3ZhcmlhbmNlKHggLyo6QXJyYXk8bnVtYmVyPiovLCB5IC8qOkFycmF5PG51bWJlcj4qLykvKjpudW1iZXIqLyB7XG5cbiAgICAvLyBUaGUgdHdvIGRhdGFzZXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggd2hpY2ggbXVzdCBiZSBtb3JlIHRoYW4gMVxuICAgIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIHNhbXBsZXMgd2l0aCBlcXVhbCBsZW5ndGhzJyk7XG4gICAgfVxuXG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzIGluIGVhY2ggc2FtcGxlJyk7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBtZWFuIG9mIGVhY2ggZGF0YXNldCBzbyB0aGF0IHdlIGNhbiBqdWRnZSBlYWNoXG4gICAgLy8gdmFsdWUgb2YgdGhlIGRhdGFzZXQgZmFpcmx5IGFzIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIG1lYW4uIHRoaXNcbiAgICAvLyB3YXksIGlmIG9uZSBkYXRhc2V0IGlzIFsxLCAyLCAzXSBhbmQgWzIsIDMsIDRdLCB0aGVpciBjb3ZhcmlhbmNlXG4gICAgLy8gZG9lcyBub3Qgc3VmZmVyIGJlY2F1c2Ugb2YgdGhlIGRpZmZlcmVuY2UgaW4gYWJzb2x1dGUgdmFsdWVzXG4gICAgdmFyIHhtZWFuID0gbWVhbih4KSxcbiAgICAgICAgeW1lYW4gPSBtZWFuKHkpLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBvZiB2YWx1ZXMsIHRoZSBjb3ZhcmlhbmNlIGluY3JlYXNlcyB3aGVuIHRoZWlyXG4gICAgLy8gZGlmZmVyZW5jZSBmcm9tIHRoZSBtZWFuIGlzIGFzc29jaWF0ZWQgLSBpZiBib3RoIGFyZSB3ZWxsIGFib3ZlXG4gICAgLy8gb3IgaWYgYm90aCBhcmUgd2VsbCBiZWxvd1xuICAgIC8vIHRoZSBtZWFuLCB0aGUgY292YXJpYW5jZSBpbmNyZWFzZXMgc2lnbmlmaWNhbnRseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9ICh4W2ldIC0geG1lYW4pICogKHlbaV0gLSB5bWVhbik7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIHRoZSBjb3ZhcmlhbmNlIGlzIHdlaWdodGVkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGRhdGFzZXRzLlxuICAgIHJldHVybiBzdW0gLyBiZXNzZWxzQ29ycmVjdGlvbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVDb3ZhcmlhbmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHNhbXBsZVZhcmlhbmNlID0gcmVxdWlyZSgnLi9zYW1wbGVfdmFyaWFuY2UnKTtcblxuLyoqXG4gKiBUaGUgW3NhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfZGV2aWF0aW9uI1NhbXBsZV9zdGFuZGFyZF9kZXZpYXRpb24pXG4gKiBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHNhbXBsZSB2YXJpYW5jZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXQgYXJyYXlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVTdGFuZGFyZERldmlhdGlvbihbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pLnRvRml4ZWQoMik7XG4gKiAvLyA9PiAnMi4xNCdcbiAqL1xuZnVuY3Rpb24gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeC8qOkFycmF5PG51bWJlcj4qLykvKjpudW1iZXIqLyB7XG4gICAgLy8gVGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBubyBudW1iZXJzIGlzIG51bGxcbiAgICB2YXIgc2FtcGxlVmFyaWFuY2VYID0gc2FtcGxlVmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydChzYW1wbGVWYXJpYW5jZVgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHN1bU50aFBvd2VyRGV2aWF0aW9ucyA9IHJlcXVpcmUoJy4vc3VtX250aF9wb3dlcl9kZXZpYXRpb25zJyk7XG5cbi8qKlxuICogVGhlIFtzYW1wbGUgdmFyaWFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhcmlhbmNlI1NhbXBsZV92YXJpYW5jZSlcbiAqIGlzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW4uIFRoZSBzYW1wbGUgdmFyaWFuY2VcbiAqIGlzIGRpc3Rpbmd1aXNoZWQgZnJvbSB0aGUgdmFyaWFuY2UgYnkgdGhlIHVzYWdlIG9mIFtCZXNzZWwncyBDb3JyZWN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZXNzZWwnc19jb3JyZWN0aW9uKTpcbiAqIGluc3RlYWQgb2YgZGl2aWRpbmcgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgYnkgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQsXG4gKiBpdCBpcyBkaXZpZGVkIGJ5IHRoZSBsZW5ndGggbWludXMgb25lLiBUaGlzIGNvcnJlY3RzIHRoZSBiaWFzIGluIGVzdGltYXRpbmdcbiAqIGEgdmFsdWUgZnJvbSBhIHNldCB0aGF0IHlvdSBkb24ndCBrbm93IGlmIGZ1bGwuXG4gKlxuICogUmVmZXJlbmNlczpcbiAqICogW1dvbGZyYW0gTWF0aFdvcmxkIG9uIFNhbXBsZSBWYXJpYW5jZV0oaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TYW1wbGVWYXJpYW5jZS5odG1sKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiB0d28gb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gMlxuICogQHJldHVybiB7bnVtYmVyfSBzYW1wbGUgdmFyaWFuY2VcbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVWYXJpYW5jZShbMSwgMiwgMywgNCwgNV0pOyAvLyA9PiAyLjVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlVmFyaWFuY2UoeCAvKjogQXJyYXk8bnVtYmVyPiAqLykvKjpudW1iZXIqLyB7XG4gICAgLy8gVGhlIHZhcmlhbmNlIG9mIG5vIG51bWJlcnMgaXMgbnVsbFxuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYW1wbGVWYXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gZGF0YSBwb2ludHMnKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtU3F1YXJlZERldmlhdGlvbnNWYWx1ZSA9IHN1bU50aFBvd2VyRGV2aWF0aW9ucyh4LCAyKTtcblxuICAgIC8vIHRoaXMgaXMgQmVzc2VscycgQ29ycmVjdGlvbjogYW4gYWRqdXN0bWVudCBtYWRlIHRvIHNhbXBsZSBzdGF0aXN0aWNzXG4gICAgLy8gdGhhdCBhbGxvd3MgZm9yIHRoZSByZWR1Y2VkIGRlZ3JlZSBvZiBmcmVlZG9tIGVudGFpbGVkIGluIGNhbGN1bGF0aW5nXG4gICAgLy8gdmFsdWVzIGZyb20gc2FtcGxlcyByYXRoZXIgdGhhbiBjb21wbGV0ZSBwb3B1bGF0aW9ucy5cbiAgICB2YXIgYmVzc2Vsc0NvcnJlY3Rpb24gPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICAvLyBGaW5kIHRoZSBtZWFuIHZhbHVlIG9mIHRoYXQgbGlzdFxuICAgIHJldHVybiBzdW1TcXVhcmVkRGV2aWF0aW9uc1ZhbHVlIC8gYmVzc2Vsc0NvcnJlY3Rpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FtcGxlVmFyaWFuY2U7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG52YXIgdmFyaWFuY2UgPSByZXF1aXJlKCcuL3ZhcmlhbmNlJyk7XG5cbi8qKlxuICogVGhlIFtzdGFuZGFyZCBkZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfZGV2aWF0aW9uKVxuICogaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YXJpYW5jZS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIHRoZSBwb3B1bGF0aW9uXG4gKiBzdGFuZGFyZCBkZXZpYXRpb24uIEl0J3MgdXNlZnVsIGZvciBtZWFzdXJpbmcgdGhlIGFtb3VudFxuICogb2YgdmFyaWF0aW9uIG9yIGRpc3BlcnNpb24gaW4gYSBzZXQgb2YgdmFsdWVzLlxuICpcbiAqIFN0YW5kYXJkIGRldmlhdGlvbiBpcyBvbmx5IGFwcHJvcHJpYXRlIGZvciBmdWxsLXBvcHVsYXRpb24ga25vd2xlZGdlOiBmb3JcbiAqIHNhbXBsZXMgb2YgYSBwb3B1bGF0aW9uLCB7QGxpbmsgc2FtcGxlU3RhbmRhcmREZXZpYXRpb259IGlzXG4gKiBtb3JlIGFwcHJvcHJpYXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc3RhbmRhcmQgZGV2aWF0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyaWFuY2UoWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gNFxuICogc3RhbmRhcmREZXZpYXRpb24oWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBzdGFuZGFyZERldmlhdGlvbih4IC8qOiBBcnJheTxudW1iZXI+ICovKS8qOm51bWJlciovIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciB2ID0gdmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFuZGFyZERldmlhdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogT3VyIGRlZmF1bHQgc3VtIGlzIHRoZSBbS2FoYW4tQmFidXNrYSBhbGdvcml0aG1dKGh0dHBzOi8vcGRmcy5zZW1hbnRpY3NjaG9sYXIub3JnLzE3NjAvN2Q0NjdjZGExZDAyNzdhZDI3MmRlYjIxMTM1MzMxMzFkYzA5LnBkZikuXG4gKiBUaGlzIG1ldGhvZCBpcyBhbiBpbXByb3ZlbWVudCBvdmVyIHRoZSBjbGFzc2ljYWxcbiAqIFtLYWhhbiBzdW1tYXRpb24gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYWhhbl9zdW1tYXRpb25fYWxnb3JpdGhtKS5cbiAqIEl0IGFpbXMgYXQgY29tcHV0aW5nIHRoZSBzdW0gb2YgYSBsaXN0IG9mIG51bWJlcnMgd2hpbGUgY29ycmVjdGluZyBmb3JcbiAqIGZsb2F0aW5nLXBvaW50IGVycm9ycy4gVHJhZGl0aW9uYWxseSwgc3VtcyBhcmUgY2FsY3VsYXRlZCBhcyBtYW55XG4gKiBzdWNjZXNzaXZlIGFkZGl0aW9ucywgZWFjaCBvbmUgd2l0aCBpdHMgb3duIGZsb2F0aW5nLXBvaW50IHJvdW5kb2ZmLiBUaGVzZVxuICogbG9zc2VzIGluIHByZWNpc2lvbiBhZGQgdXAgYXMgdGhlIG51bWJlciBvZiBudW1iZXJzIGluY3JlYXNlcy4gVGhpcyBhbHRlcm5hdGl2ZVxuICogYWxnb3JpdGhtIGlzIG1vcmUgYWNjdXJhdGUgdGhhbiB0aGUgc2ltcGxlIHdheSBvZiBjYWxjdWxhdGluZyBzdW1zIGJ5IHNpbXBsZVxuICogYWRkaXRpb24uXG4gKlxuICogVGhpcyBydW5zIG9uIGBPKG4pYCwgbGluZWFyIHRpbWUgaW4gcmVzcGVjdCB0byB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHN1bSBvZiBhbGwgaW5wdXQgbnVtYmVyc1xuICogQGV4YW1wbGVcbiAqIHN1bShbMSwgMiwgM10pOyAvLyA9PiA2XG4gKi9cbmZ1bmN0aW9uIHN1bSh4Lyo6IEFycmF5PG51bWJlcj4gKi8pLyo6IG51bWJlciAqLyB7XG5cbiAgICAvLyBJZiB0aGUgYXJyYXkgaXMgZW1wdHksIHdlIG5lZWRuJ3QgYm90aGVyIGNvbXB1dGluZyBpdHMgc3VtXG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemluZyB0aGUgc3VtIGFzIHRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIGFycmF5XG4gICAgdmFyIHN1bSA9IHhbMF07XG5cbiAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIHRoZSBmbG9hdGluZy1wb2ludCBlcnJvciBjb3JyZWN0aW9uXG4gICAgdmFyIGNvcnJlY3Rpb24gPSAwO1xuXG4gICAgdmFyIHRyYW5zaXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IHN1bSArIHhbaV07XG5cbiAgICAgICAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY29ycmVjdGlvbiBpbiBhIGRpZmZlcmVudCBmYXNoaW9uXG4gICAgICAgIC8vIGlmIHRoZSBuZXcgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBhYnNvbHV0ZSBzdW1cbiAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPj0gTWF0aC5hYnMoeFtpXSkpIHtcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gKz0gKChzdW0gLSB0cmFuc2l0aW9uKSArIHhbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29ycmVjdGlvbiArPSAoKHhbaV0gLSB0cmFuc2l0aW9uKSArIHN1bSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gPSB0cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIFJldHVybmluZyB0aGUgY29ycmVjdGVkIHN1bVxuICAgIHJldHVybiBzdW0gKyBjb3JyZWN0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1bTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBtZWFuID0gcmVxdWlyZSgnLi9tZWFuJyk7XG5cbi8qKlxuICogVGhlIHN1bSBvZiBkZXZpYXRpb25zIHRvIHRoZSBOdGggcG93ZXIuXG4gKiBXaGVuIG49MiBpdCdzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zLlxuICogV2hlbiBuPTMgaXQncyB0aGUgc3VtIG9mIGN1YmVkIGRldmlhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4XG4gKiBAcGFyYW0ge251bWJlcn0gbiBwb3dlclxuICogQHJldHVybnMge251bWJlcn0gc3VtIG9mIG50aCBwb3dlciBkZXZpYXRpb25zXG4gKiBAZXhhbXBsZVxuICogdmFyIGlucHV0ID0gWzEsIDIsIDNdO1xuICogLy8gc2luY2UgdGhlIHZhcmlhbmNlIG9mIGEgc2V0IGlzIHRoZSBtZWFuIHNxdWFyZWRcbiAqIC8vIGRldmlhdGlvbnMsIHdlIGNhbiBjYWxjdWxhdGUgdGhhdCB3aXRoIHN1bU50aFBvd2VyRGV2aWF0aW9uczpcbiAqIHZhciB2YXJpYW5jZSA9IHN1bU50aFBvd2VyRGV2aWF0aW9ucyhpbnB1dCkgLyBpbnB1dC5sZW5ndGg7XG4gKi9cbmZ1bmN0aW9uIHN1bU50aFBvd2VyRGV2aWF0aW9ucyh4Lyo6IEFycmF5PG51bWJlcj4gKi8sIG4vKjogbnVtYmVyICovKS8qOm51bWJlciovIHtcbiAgICB2YXIgbWVhblZhbHVlID0gbWVhbih4KSxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgdGVtcFZhbHVlLFxuICAgICAgICBpO1xuXG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb246IHdoZW4gbiBpcyAyICh3ZSdyZSBjb21wdXRpbmcgYSBudW1iZXIgc3F1YXJlZCksXG4gICAgLy8gbXVsdGlwbHlpbmcgdGhlIG51bWJlciBieSBpdHNlbGYgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiB1c2luZ1xuICAgIC8vIHRoZSBNYXRoLnBvdyBtZXRob2QuXG4gICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgICAgICBzdW0gKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4W2ldIC0gbWVhblZhbHVlLCBuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdW07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VtTnRoUG93ZXJEZXZpYXRpb25zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHN1bU50aFBvd2VyRGV2aWF0aW9ucyA9IHJlcXVpcmUoJy4vc3VtX250aF9wb3dlcl9kZXZpYXRpb25zJyk7XG5cbi8qKlxuICogVGhlIFt2YXJpYW5jZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYW5jZSlcbiAqIGlzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW4uXG4gKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB2YXJpYW5jZSwgbm90IHNhbXBsZSB2YXJpYW5jZTpcbiAqIHNlZSB0aGUgYHNhbXBsZVZhcmlhbmNlYCBtZXRob2QgaWYgeW91IHdhbnQgYSBzYW1wbGUgbWVhc3VyZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBwb3B1bGF0aW9uIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB2YXJpYW5jZTogYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cbiAqIHplcm8gaW5kaWNhdGVzIHRoYXQgYWxsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHgncyBsZW5ndGggaXMgMFxuICogQGV4YW1wbGVcbiAqIHZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1LCA2XSk7IC8vID0+IDIuOTE2NjY2NjY2NjY2NjY2NVxuICovXG5mdW5jdGlvbiB2YXJpYW5jZSh4Lyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIC8vIFRoZSB2YXJpYW5jZSBvZiBubyBudW1iZXJzIGlzIG51bGxcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludCcpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIG1lYW4gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGJldHdlZW4gdGhlXG4gICAgLy8gbWVhbiB2YWx1ZSBhbmQgZWFjaCB2YWx1ZS5cbiAgICByZXR1cm4gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgsIDIpIC8geC5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFyaWFuY2U7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIFRoZSBbWi1TY29yZSwgb3IgU3RhbmRhcmQgU2NvcmVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfc2NvcmUpLlxuICpcbiAqIFRoZSBzdGFuZGFyZCBzY29yZSBpcyB0aGUgbnVtYmVyIG9mIHN0YW5kYXJkIGRldmlhdGlvbnMgYW4gb2JzZXJ2YXRpb25cbiAqIG9yIGRhdHVtIGlzIGFib3ZlIG9yIGJlbG93IHRoZSBtZWFuLiBUaHVzLCBhIHBvc2l0aXZlIHN0YW5kYXJkIHNjb3JlXG4gKiByZXByZXNlbnRzIGEgZGF0dW0gYWJvdmUgdGhlIG1lYW4sIHdoaWxlIGEgbmVnYXRpdmUgc3RhbmRhcmQgc2NvcmVcbiAqIHJlcHJlc2VudHMgYSBkYXR1bSBiZWxvdyB0aGUgbWVhbi4gSXQgaXMgYSBkaW1lbnNpb25sZXNzIHF1YW50aXR5XG4gKiBvYnRhaW5lZCBieSBzdWJ0cmFjdGluZyB0aGUgcG9wdWxhdGlvbiBtZWFuIGZyb20gYW4gaW5kaXZpZHVhbCByYXdcbiAqIHNjb3JlIGFuZCB0aGVuIGRpdmlkaW5nIHRoZSBkaWZmZXJlbmNlIGJ5IHRoZSBwb3B1bGF0aW9uIHN0YW5kYXJkXG4gKiBkZXZpYXRpb24uXG4gKlxuICogVGhlIHotc2NvcmUgaXMgb25seSBkZWZpbmVkIGlmIG9uZSBrbm93cyB0aGUgcG9wdWxhdGlvbiBwYXJhbWV0ZXJzO1xuICogaWYgb25lIG9ubHkgaGFzIGEgc2FtcGxlIHNldCwgdGhlbiB0aGUgYW5hbG9nb3VzIGNvbXB1dGF0aW9uIHdpdGhcbiAqIHNhbXBsZSBtZWFuIGFuZCBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIHlpZWxkcyB0aGVcbiAqIFN0dWRlbnQncyB0LXN0YXRpc3RpYy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFuZGFyZERldmlhdGlvblxuICogQHJldHVybiB7bnVtYmVyfSB6IHNjb3JlXG4gKiBAZXhhbXBsZVxuICogelNjb3JlKDc4LCA4MCwgNSk7IC8vID0+IC0wLjRcbiAqL1xuZnVuY3Rpb24gelNjb3JlKHgvKjpudW1iZXIqLywgbWVhbi8qOm51bWJlciovLCBzdGFuZGFyZERldmlhdGlvbi8qOm51bWJlciovKS8qOm51bWJlciovIHtcbiAgICByZXR1cm4gKHggLSBtZWFuKSAvIHN0YW5kYXJkRGV2aWF0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHpTY29yZTtcbiIsImltcG9ydCB7Q2hhcnRXaXRoQ29sb3JHcm91cHMsIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7TGVnZW5kfSBmcm9tIFwiLi9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBCYXJDaGFydENvbmZpZyBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnIHtcblxuICAgIHN2Z0NsYXNzID0gdGhpcy5jc3NDbGFzc1ByZWZpeCArICdiYXItY2hhcnQnO1xuICAgIHNob3dMZWdlbmQgPSB0cnVlO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTtcbiAgICB4ID0gey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsXG4gICAgICAgIGtleTogMCxcbiAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IFV0aWxzLmlzTnVtYmVyKGQpID8gZCA6IGRba2V5XSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzY2FsZTogXCJvcmRpbmFsXCIsXG4gICAgICAgIG9yaWVudDogXCJib3R0b21cIixcbiAgICAgICAgdGlja3M6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHkgPSB7Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICBrZXk6IDEsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBVdGlscy5pc051bWJlcihkKSA/IGQgOiBkW2tleV0sIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsLFxuICAgICAgICBvcmllbnQ6IFwibGVmdFwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgdHJhbnNpdGlvbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYXJDaGFydCBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzIHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEJhckNoYXJ0Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgQmFyQ2hhcnRDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54ID0ge307XG4gICAgICAgIHRoaXMucGxvdC55ID0ge307XG5cbiAgICAgICAgdGhpcy5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgdGhpcy5zZXR1cFkoKTtcbiAgICAgICAgdGhpcy5zZXR1cFgoKTtcbiAgICAgICAgdGhpcy5zZXR1cEdyb3VwU3RhY2tzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBZRG9tYWluKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBzZXR1cFgoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLng7XG5cbiAgICAgICAgLyogKlxuICAgICAgICAgKiB2YWx1ZSBhY2Nlc3NvciAtIHJldHVybnMgdGhlIHZhbHVlIHRvIGVuY29kZSBmb3IgYSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICAgICAgICogc2NhbGUgLSBtYXBzIHZhbHVlIHRvIGEgdmlzdWFsIGRpc3BsYXkgZW5jb2RpbmcsIHN1Y2ggYXMgYSBwaXhlbCBwb3NpdGlvbi5cbiAgICAgICAgICogbWFwIGZ1bmN0aW9uIC0gbWFwcyBmcm9tIGRhdGEgdmFsdWUgdG8gZGlzcGxheSB2YWx1ZVxuICAgICAgICAgKiBheGlzIC0gc2V0cyB1cCBheGlzXG4gICAgICAgICAqKi9cbiAgICAgICAgeC52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZShkLCBjb25mLmtleSk7XG4gICAgICAgIHguc2NhbGUgPSBkMy5zY2FsZUJhbmQoKS5yYW5nZShbMCwgcGxvdC53aWR0aF0pLnBhZGRpbmdJbm5lciguMDgpO1xuICAgICAgICB4Lm1hcCA9IGQgPT4geC5zY2FsZSh4LnZhbHVlKGQpKTtcblxuICAgICAgICB4LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB4LnNjYWxlKTtcbiAgICAgICAgaWYgKGNvbmYudGlja3MpIHtcbiAgICAgICAgICAgIHguYXhpcy50aWNrcyhjb25mLnRpY2tzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb21haW4gPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5jb25maWcuc2VyaWVzKSB7XG4gICAgICAgICAgICBkb21haW4gPSBkMy5tYXAoZGF0YSwgeC52YWx1ZSkua2V5cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tYWluID0gZDMubWFwKGRhdGFbMF0udmFsdWVzLCB4LnZhbHVlKS5rZXlzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB5LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlKGQsIGNvbmYua2V5KTtcbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFtwbG90LmhlaWdodCwgMF0pO1xuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcblxuICAgIH07XG5cbiAgICBzZXR1cFlEb21haW4oKSB7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICB2YXIgeVN0YWNrTWF4ID0gZDMubWF4KHBsb3QubGF5ZXJzLCBsYXllciA9PiBkMy5tYXgobGF5ZXIucG9pbnRzLCBkID0+IGQueTAgKyBkLnkpKTtcblxuXG4gICAgICAgIC8vIHZhciBtaW4gPSBkMy5taW4oZGF0YSwgcz0+ZDMubWluKHMudmFsdWVzLCBwbG90LnkudmFsdWUpKTtcbiAgICAgICAgdmFyIG1heCA9IHlTdGFja01heDtcbiAgICAgICAgZG9tYWluID0gWzAsIG1heF07XG5cbiAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnIHBsb3QueS5zY2FsZS5kb21haW4nLCBwbG90Lnkuc2NhbGUuZG9tYWluKCkpO1xuICAgIH1cblxuICAgIHNldHVwR3JvdXBTdGFja3MoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5ncm91cERhdGEoKTtcblxuICAgICAgICB2YXIgeTBzID0gW107XG4gICAgICAgIHRoaXMucGxvdC5ncm91cGVkRGF0YS5mb3JFYWNoKHM9PiB7XG4gICAgICAgICAgICBzLnBvaW50cyA9IHMudmFsdWVzLm1hcCh2PT5zZWxmLm1hcFRvUG9pbnQodikpO1xuICAgICAgICAgICAgcy5wb2ludHMuZm9yRWFjaCgocCwgaSk9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZZMCA9IHkwc1tpXTtcbiAgICAgICAgICAgICAgICBpZighcHJldlkwKSBwcmV2WTAgPSAwO1xuICAgICAgICAgICAgICAgIHAueTAgPSBwcmV2WTA7XG4gICAgICAgICAgICAgICAgeTBzW2ldID0gcC55K3ByZXZZMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsb3QubGF5ZXJzID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuXG4gICAgfVxuXG4gICAgbWFwVG9Qb2ludCh2YWx1ZSkge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBsb3QueC52YWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHBsb3QueS52YWx1ZSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGRyYXdBeGlzWCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueDtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy14JykgKyBcIi5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSArIChzZWxmLmNvbmZpZy5ndWlkZXMgPyAnJyA6ICcuJyArIHNlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKTtcblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueC5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChwbG90LndpZHRoIC8gMikgKyBcIixcIiArIChwbG90Lm1hcmdpbi5ib3R0b20pICsgXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNZKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzLXknKSArIFwiLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpICsgKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nICsgc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKTtcblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueS5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1wbG90Lm1hcmdpbi5sZWZ0ICsgXCIsXCIgKyAocGxvdC5oZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cblxuICAgIGRyYXdCYXJzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsYXllcnMnLCBwbG90LmxheWVycyk7XG5cbiAgICAgICAgdmFyIGxheWVyQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKFwibGF5ZXJcIik7XG5cbiAgICAgICAgdmFyIGJhckNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcImJhclwiKTtcbiAgICAgICAgdmFyIGxheWVyID0gc2VsZi5zdmdHLnNlbGVjdEFsbChcIi5cIiArIGxheWVyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LmxheWVycyk7XG5cbiAgICAgICAgdmFyIGxheWVyTWVyZ2UgPSBsYXllci5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgbGF5ZXJDbGFzcykubWVyZ2UobGF5ZXIpO1xuXG4gICAgICAgIHZhciBiYXIgPSBsYXllck1lcmdlLnNlbGVjdEFsbChcIi5cIiArIGJhckNsYXNzKVxuICAgICAgICAgICAgLmRhdGEoZCA9PiBkLnBvaW50cyk7XG5cbiAgICAgICAgdmFyIGJhckVudGVyID0gYmFyLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBiYXJDbGFzcyk7XG4gICAgICAgIHZhciBiYXJSZWN0RW50ZXIgPSBiYXJFbnRlci5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMSk7XG4gICAgICAgIHZhciBiYXJNZXJnZSA9IGJhckVudGVyLm1lcmdlKGJhcik7XG5cbiAgICAgICAgdmFyIGJhclJlY3QgPSBiYXJNZXJnZS5zZWxlY3QoXCJyZWN0XCIpO1xuXG4gICAgICAgIHZhciBiYXJSZWN0VCA9IGJhclJlY3Q7XG4gICAgICAgIHZhciBiYXJUID0gYmFyTWVyZ2U7XG4gICAgICAgIHZhciBsYXllclQgPSBsYXllck1lcmdlO1xuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBiYXJSZWN0VCA9IGJhclJlY3QudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgYmFyVCA9IGJhck1lcmdlLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGxheWVyVCA9IGxheWVyTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyRW50ZXIuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgcGxvdC54LnNjYWxlKGQueCkgKyBcIixcIiArIChwbG90Lnkuc2NhbGUoZC55MCkpICsgXCIpXCI7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeURvbWFpbiA9IHBsb3QueS5zY2FsZS5kb21haW4oKTtcbiAgICAgICAgYmFyVC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBwbG90Lnguc2NhbGUoZC54KSArIFwiLFwiICsgKHBsb3QueS5zY2FsZShkLnkwICsgZC55KSkgKyBcIilcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhclJlY3RFbnRlclxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAwKTtcbiAgICAgICAgYmFyUmVjdFRcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiBwbG90Lnkuc2NhbGUoZC55MCkgLSBwbG90Lnkuc2NhbGUoZC55MCArIGQueSAtIHlEb21haW5bMF0pKTtcblxuXG4gICAgICAgIGlmICh0aGlzLnBsb3Quc2VyaWVzQ29sb3IpIHtcbiAgICAgICAgICAgIGxheWVyVFxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCB0aGlzLnBsb3Quc2VyaWVzQ29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsb3QudG9vbHRpcCkge1xuICAgICAgICAgICAgYmFyTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChkLnkpO1xuICAgICAgICAgICAgfSkub24oXCJtb3VzZW91dFwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXllci5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGJhci5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWCgpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWSgpO1xuICAgICAgICB0aGlzLmRyYXdCYXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbn1cbiIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBCb3hQbG90QmFzZUNvbmZpZyBleHRlbmRzIENoYXJ0Q29uZmlne1xuXG4gICAgc3ZnQ2xhc3MgPSB0aGlzLmNzc0NsYXNzUHJlZml4ICsgJ2JveC1wbG90JztcbiAgICBzaG93VG9vbHRpcCA9IHRydWU7XG4gICAgeCA9IHsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbFxuICAgICAgICB2YWx1ZTogcyA9PiBzLmtleSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBndWlkZXM6IGZhbHNlLCAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICAgICAgb3JpZW50OiAnYm90dG9tJyxcblxuICAgIH07XG4gICAgeSA9IHsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgdmFsdWU6IGQgPT4gZCwgLy8geSB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgb3JpZW50OiAnbGVmdCcsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4xLFxuICAgICAgICBndWlkZXM6IHRydWUgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgfTtcbiAgICBRMSA9IGQgPT4gZC52YWx1ZXMuUTE7XG4gICAgUTIgPSBkID0+IGQudmFsdWVzLlEyO1xuICAgIFEzID0gZCA9PiBkLnZhbHVlcy5RMztcbiAgICBXbCA9IGQgPT4gZC52YWx1ZXMud2hpc2tlckxvdztcbiAgICBXaCA9IGQgPT4gZC52YWx1ZXMud2hpc2tlckhpZ2g7XG4gICAgb3V0bGllcnM9IGQ9PiBkLnZhbHVlcy5vdXRsaWVycztcbiAgICBvdXRsaWVyVmFsdWUgPSAoZCxpKT0+IGQ7XG4gICAgb3V0bGllckxhYmVsID0gKGQsaSk9PiBkO1xuICAgIG1pbkJveFdpZHRoID0gMzU7XG4gICAgbWF4Qm94V2lkdGggPSAxMDA7XG5cbiAgICB0cmFuc2l0aW9uID0gdHJ1ZTtcbiAgICBjb2xvciA9ICB1bmRlZmluZWQ7Ly8gc3RyaW5nIG9yIGZ1bmN0aW9uIHJldHVybmluZyBjb2xvcidzIHZhbHVlIGZvciBjb2xvciBzY2FsZVxuICAgIGQzQ29sb3JDYXRlZ29yeT0gJ2NhdGVnb3J5MTAnO1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQm94UGxvdEJhc2UgZXh0ZW5kcyBDaGFydHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEJveFBsb3RCYXNlQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBCb3hQbG90QmFzZUNvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpe1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICBzdXBlci5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgdGhpcy5wbG90LnggPSB7fTtcbiAgICAgICAgdGhpcy5wbG90LnkgPSB7fTtcblxuICAgICAgICB0aGlzLnBsb3QuZGF0YSA9IHRoaXMuZ2V0RGF0YVRvUGxvdCgpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuICAgICAgICB0aGlzLnNldHVwWCgpO1xuXG4gICAgICAgIHRoaXMuc2V0dXBDb2xvcigpO1xuXG4gICAgfVxuXG4gICAgZ2V0RGF0YVRvUGxvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBzZXR1cFgoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLng7XG5cbiAgICAgICAgeC52YWx1ZSA9IGNvbmYudmFsdWU7XG4gICAgICAgIHguc2NhbGUgPSBkMy5zY2FsZUJhbmQoKS5yYW5nZShbMCwgcGxvdC53aWR0aF0pO1xuICAgICAgICB4Lm1hcCA9IGQgPT4geC5zY2FsZSh4LnZhbHVlKGQpKTtcblxuICAgICAgICB4LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB4LnNjYWxlKTtcbiAgICAgICAgaWYoY29uZi5ndWlkZXMpe1xuICAgICAgICAgICAgeC5heGlzLnRpY2tTaXplKC1wbG90LmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb21haW4gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IGRhdGEubWFwKHgudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC54LnNjYWxlLmRvbWFpbihkb21haW4pO1xuXG4gICAgfTtcblxuICAgIHNldHVwWSgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHkgPSBwbG90Lnk7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgeS52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZS5jYWxsKHRoaXMuY29uZmlnLCBkKTtcbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFtwbG90LmhlaWdodCwgMF0pO1xuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcbiAgICAgICAgaWYgKGNvbmYudGlja3MpIHtcbiAgICAgICAgICAgIHkuYXhpcy50aWNrcyhjb25mLnRpY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBpZihjb25mLmd1aWRlcyl7XG4gICAgICAgICAgICB5LmF4aXMudGlja1NpemUoLXBsb3Qud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0dXBZRG9tYWluKCk7XG4gICAgfTtcblxuICAgIHNldHVwWURvbWFpbigpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdLCB5TWluLCB5TWF4O1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIGxldCBxMSA9IGMuUTEoZCksIFxuICAgICAgICAgICAgICAgIHEzID0gYy5RMyhkKSwgXG4gICAgICAgICAgICAgICAgd2wgPSBjLldsKGQpLCBcbiAgICAgICAgICAgICAgICB3aCA9IGMuV2goZCksXG4gICAgICAgICAgICAgICAgb3V0bGllcnMgPSBjLm91dGxpZXJzKGQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAob3V0bGllcnMpIHtcbiAgICAgICAgICAgICAgICBvdXRsaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChvLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGMub3V0bGllclZhbHVlKG8sIGkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3bCkgeyB2YWx1ZXMucHVzaCh3bCkgfVxuICAgICAgICAgICAgaWYgKHExKSB7IHZhbHVlcy5wdXNoKHExKSB9XG4gICAgICAgICAgICBpZiAocTMpIHsgdmFsdWVzLnB1c2gocTMpIH1cbiAgICAgICAgICAgIGlmICh3aCkgeyB2YWx1ZXMucHVzaCh3aCkgfVxuICAgICAgICB9KTtcbiAgICAgICAgeU1pbiA9IGQzLm1pbih2YWx1ZXMpO1xuICAgICAgICB5TWF4ID0gZDMubWF4KHZhbHVlcyk7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoeU1heC15TWluKSogdGhpcy5jb25maWcueS5kb21haW5NYXJnaW47XG4gICAgICAgIHlNaW4tPW1hcmdpbjtcbiAgICAgICAgeU1heCs9bWFyZ2luO1xuICAgICAgICB2YXIgZG9tYWluID0gWyB5TWluLCB5TWF4IF0gO1xuXG4gICAgICAgIHBsb3QueS5zY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICB9XG5cbiAgICBkcmF3QXhpc1goKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLng7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteCcpICsgXCIuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzJykgKyAoYXhpc0NvbmYuZ3VpZGVzID8gJycgOiAnLicgKyBzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnguYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAocGxvdC53aWR0aC8yKSArXCIsXCIrIChwbG90Lm1hcmdpbi5ib3R0b20pICtcIilcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCItMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYubGFiZWwpO1xuICAgIH07XG5cbiAgICBkcmF3QXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpICsgXCIuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzJykgKyAoYXhpc0NvbmYuZ3VpZGVzID8gJycgOiAnLicgKyBzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC55LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiICsgc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLXBsb3QubWFyZ2luLmxlZnQgKyBcIixcIiArIChwbG90LmhlaWdodCAvIDIpICsgXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIGRyYXdCb3hQbG90cygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcGxvdCA9IHNlbGYucGxvdCxcbiAgICAgICAgICAgIGNvbmZpZyA9IHNlbGYuY29uZmlnLFxuICAgICAgICAgICAgYm94cGxvdENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImJveHBsb3QtaXRlbVwiKVxuICAgICAgICBcbiAgICAgICAgdmFyIGJveHBsb3RzID0gc2VsZi5zdmdHLnNlbGVjdEFsbCgnLicrYm94cGxvdENsYXNzKS5kYXRhKHBsb3QuZGF0YSk7XG4gICAgICAgIHZhciBib3hwbG90RW50ZXIgPSBib3hwbG90cy5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGJveHBsb3RDbGFzcylcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcblxuICAgICAgICB2YXIgYm94cGxvdHNNZXJnZSA9IGJveHBsb3RFbnRlci5tZXJnZShib3hwbG90cyk7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDEwMDA7XG4gICAgICAgIHZhciBib3hwbG90c1QgPSBib3hwbG90c01lcmdlO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBib3hwbG90c1QgPSBib3hwbG90c01lcmdlLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGJveHBsb3RzVC5kZWxheShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgKiBkdXJhdGlvbiAvIHBsb3QuZGF0YS5sZW5ndGggfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGJveHBsb3RzVFxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgcGxvdC5jb2xvcilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAwLjc1KVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLGkpID0+J3RyYW5zbGF0ZSgnICsgKHBsb3QueC5tYXAoZCxpKSArIHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuMDUpICsgJywgMCknKVxuICAgICAgICBib3hwbG90cy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIGJveFdpZHRoID0gIWNvbmZpZy5tYXhCb3hXaWR0aCA/IHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuOSA6IE1hdGgubWluKGNvbmZpZy5tYXhCb3hXaWR0aCwgTWF0aC5tYXgoY29uZmlnLm1pbkJveFdpZHRoLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjkpKTtcbiAgICAgICAgdmFyIGJveExlZnQgID0gcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC40NSAtIGJveFdpZHRoLzI7XG4gICAgICAgIHZhciBib3hSaWdodCA9IHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuNDUgKyBib3hXaWR0aC8yO1xuXG4gICAgICAgIHZhciBib3hDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJib3hcIik7XG5cbiAgICAgICAgYm94cGxvdEVudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBib3hDbGFzcylcbiAgICAgICAgICAgIC8vIHRvb2x0aXAgZXZlbnRzXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gJ1EzOiAnK2NvbmZpZy5RMyhkLGkpKyc8YnIvPlEyOiAnK2NvbmZpZy5RMihkLGkpKyc8YnIvPlExOiAnK2NvbmZpZy5RMShkLGkpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Rvb2x0aXAoaHRtbClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBib3hSZWN0cyA9IGJveHBsb3RzTWVyZ2Uuc2VsZWN0KCdyZWN0LicrYm94Q2xhc3MpO1xuXG4gICAgICAgIHZhciBib3hSZWN0c1QgPSBib3hSZWN0cztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGJveFJlY3RzVCA9IGJveFJlY3RzLnRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJveFJlY3RzVC5hdHRyKCd5JywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGNvbmZpZy5RMyhkKSkpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBib3hXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKCd4JywgYm94TGVmdCApXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsaSkgPT4gTWF0aC5hYnMocGxvdC55LnNjYWxlKGNvbmZpZy5RMyhkKSkgLSBwbG90Lnkuc2NhbGUoY29uZmlnLlExKGQpKSkgfHwgMSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcGxvdC5jb2xvcik7XG5cbiAgICAgICAgLy8gbWVkaWFuIGxpbmVcbiAgICAgICAgdmFyIG1lZGlhbkNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnbWVkaWFuJyk7XG4gICAgICAgIGJveHBsb3RFbnRlci5hcHBlbmQoJ2xpbmUnKS5hdHRyKCdjbGFzcycsIG1lZGlhbkNsYXNzKTtcblxuICAgICAgICB2YXIgbWVkaWFuTGluZSA9IGJveHBsb3RzTWVyZ2Uuc2VsZWN0KCdsaW5lLicrbWVkaWFuQ2xhc3MpO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgbWVkaWFuTGluZSA9IG1lZGlhbkxpbmUudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhbkxpbmVcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGJveExlZnQpXG4gICAgICAgICAgICAuYXR0cigneTEnLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoY29uZmlnLlEyKGQpKSlcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIGJveFJpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGNvbmZpZy5RMihkKSkpO1xuXG5cbiAgICAgICAgLy93aGlza2Vyc1xuXG4gICAgICAgIHZhciB3aGlza2VyQ2xhc3M9IHNlbGYucHJlZml4Q2xhc3MoXCJ3aGlza2VyXCIpLFxuICAgICAgICAgICAgdGlja0NsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImJveHBsb3QtdGlja1wiKTtcblxuICAgICAgICB2YXIgd2hpc2tlcnMgPSBbe2tleTogJ2xvdycsIHZhbHVlOiBjb25maWcuV2x9LCB7a2V5OiAnaGlnaCcsIHZhbHVlOiBjb25maWcuV2h9XTtcblxuICAgICAgICBib3hwbG90RW50ZXIuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgIHdoaXNrZXJzLmZvckVhY2goZj0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZi52YWx1ZShkKSkge1xuICAgICAgICAgICAgICAgICAgICBib3guYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcGxvdC5jb2xvcihkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgd2hpc2tlckNsYXNzKycgJyArIGJveHBsb3RDbGFzcysnLScrZi5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBib3guYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcGxvdC5jb2xvcihkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgdGlja0NsYXNzKycgJyArIGJveHBsb3RDbGFzcysnLScrZi5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB3aGlza2Vycy5mb3JFYWNoKGYgPT4ge1xuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gKGYua2V5ID09PSAnbG93JykgPyBjb25maWcuUTEgOiBjb25maWcuUTM7XG5cbiAgICAgICAgICAgIHZhciB3aGlza2VyID0gYm94cGxvdHNNZXJnZS5zZWxlY3QoJy4nK3doaXNrZXJDbGFzcysnLicrYm94cGxvdENsYXNzKyctJytmLmtleSk7XG4gICAgICAgICAgICB2YXIgdGljayA9IGJveHBsb3RzTWVyZ2Uuc2VsZWN0KCcuJyt0aWNrQ2xhc3MrJy4nK2JveHBsb3RDbGFzcysnLScrZi5rZXkpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB3aGlza2VyID0gd2hpc2tlci50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGljaz10aWNrLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaXNrZXJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjQ1IClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoZi52YWx1ZShkKSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC40NSApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGVuZHBvaW50KGQpKSk7XG5cbiAgICAgICAgICAgIHRpY2tcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBib3hMZWZ0IClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoZi52YWx1ZShkKSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgYm94UmlnaHQgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIChkLGkpID0+IHBsb3QueS5zY2FsZShmLnZhbHVlKGQpKSk7XG5cbiAgICAgICAgICAgIGJveHBsb3RFbnRlci5zZWxlY3RBbGwoJy4nK2JveHBsb3RDbGFzcysnLScrZi5rZXkpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChmLnZhbHVlKGQpKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8gb3V0bGllcnNcbiAgICAgICAgdmFyIG91dGxpZXJDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJvdXRsaWVyXCIpO1xuICAgICAgICB2YXIgb3V0bGllcnMgPSBib3hwbG90c01lcmdlLnNlbGVjdEFsbCgnLicrb3V0bGllckNsYXNzKS5kYXRhKChkLGkpID0+IGNvbmZpZy5vdXRsaWVycyhkLGkpIHx8IFtdKTtcblxuICAgICAgICB2YXIgb3V0bGllckVudGVyQ2lyY2xlID0gb3V0bGllcnMuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBvdXRsaWVyQ2xhc3MpXG4gICAgICAgICAgICAuc3R5bGUoJ3otaW5kZXgnLCA5MDAwKTtcblxuICAgICAgICBvdXRsaWVyRW50ZXJDaXJjbGVcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGksIGopIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGNvbmZpZy5vdXRsaWVyTGFiZWwoZCxpKSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQsIGksIGopIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG91dGxpZXJzTWVyZ2UgPSBvdXRsaWVyRW50ZXJDaXJjbGUubWVyZ2Uob3V0bGllcnMpO1xuICAgICAgICB2YXIgb3V0bGllcnNUID0gb3V0bGllcnNNZXJnZTtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIG91dGxpZXJzVCA9IG91dGxpZXJzTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIG91dGxpZXJzVFxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC40NSlcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIChkLGkpID0+IHBsb3QueS5zY2FsZShjb25maWcub3V0bGllclZhbHVlKGQsaSkpKVxuICAgICAgICAgICAgLmF0dHIoJ3InLCAnMycpO1xuICAgICAgICBvdXRsaWVycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICB9XG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1goKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1koKTtcbiAgICAgICAgdGhpcy5kcmF3Qm94UGxvdHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHNldHVwQ29sb3IoKSB7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgaWYoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpe1xuICAgICAgICAgICAgdmFyIGNvbG9yU2NoZW1lQ2F0ZWdvcnkgPSAnc2NoZW1lJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkgPSBkMy5zY2FsZU9yZGluYWwoZDNbY29sb3JTY2hlbWVDYXRlZ29yeV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvclZhbHVlID0gY29uZi5jb2xvcjtcbiAgICAgICAgaWYgKGNvbG9yVmFsdWUgJiYgdHlwZW9mIGNvbG9yVmFsdWUgPT09ICdzdHJpbmcnIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpe1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gY29sb3JWYWx1ZTtcbiAgICAgICAgfWVsc2UgaWYodGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkpe1xuICAgICAgICAgICAgc2VsZi5wbG90LmNvbG9yVmFsdWU9Y29sb3JWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IGQgPT4gIHNlbGYucGxvdC5jb2xvckNhdGVnb3J5KHRoaXMucGxvdC54LnZhbHVlKGQpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7Qm94UGxvdEJhc2UsIEJveFBsb3RCYXNlQ29uZmlnfSBmcm9tIFwiLi9ib3gtcGxvdC1iYXNlXCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHtTdGF0aXN0aWNzVXRpbHN9IGZyb20gJy4vc3RhdGlzdGljcy11dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBCb3hQbG90Q29uZmlnIGV4dGVuZHMgQm94UGxvdEJhc2VDb25maWd7XG5cbiAgICBzdmdDbGFzcyA9IHRoaXMuY3NzQ2xhc3NQcmVmaXggKyAnYm94LXBsb3QnO1xuICAgIHNob3dMZWdlbmQgPSB0cnVlO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTtcbiAgICB5ID0gey8vIFkgYXhpcyBjb25maWdcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihkKSB7IHJldHVybiB0aGlzLnkua2V5PT09dW5kZWZpbmVkID8gZCA6IGRbdGhpcy55LmtleV19ICwgLy8geSB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgb3JpZW50OiAnbGVmdCcsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4xLFxuICAgICAgICBndWlkZXM6IHRydWUgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgfTtcbiAgICBzZXJpZXMgPSBmYWxzZTtcbiAgICBncm91cHM9e1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRoaXMuZ3JvdXBzLmtleT09PXVuZGVmaW5lZCA/ICcnIDogZFt0aGlzLmdyb3Vwcy5rZXldfSAgLCAvLyBncm91cGluZyB2YWx1ZSBhY2Nlc3NvcixcbiAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgIGRpc3BsYXlWYWx1ZTogdW5kZWZpbmVkIC8vIG9wdGlvbmFsIGZ1bmN0aW9uIHJldHVybmluZyBkaXNwbGF5IHZhbHVlIChzZXJpZXMgbGFiZWwpIGZvciBnaXZlbiBncm91cCB2YWx1ZSwgb3Igb2JqZWN0L2FycmF5IG1hcHBpbmcgdmFsdWUgdG8gZGlzcGxheSB2YWx1ZVxuICAgIH07XG4gICAgdHVrZXk9IGZhbHNlO1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCb3hQbG90IGV4dGVuZHMgQm94UGxvdEJhc2V7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBCb3hQbG90Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBCb3hQbG90Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGdldERhdGFUb1Bsb3QoKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZiA9IHNlbGYuY29uZmlnO1xuICAgICAgICBzZWxmLnBsb3QuZ3JvdXBpbmdFbmFibGVkID0gdGhpcy5pc0dyb3VwaW5nRW5hYmxlZCgpO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBpZighc2VsZi5wbG90Lmdyb3VwaW5nRW5hYmxlZCApe1xuICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gIFt7XG4gICAgICAgICAgICAgICAga2V5OiAnJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgc2VsZi5wbG90LmRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpZihzZWxmLmNvbmZpZy5zZXJpZXMpe1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cGVkRGF0YSA9ICBkYXRhLm1hcChzPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybntcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcy5sYWJlbCB8fCBzLmtleSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcy52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwVmFsdWUgPSBkID0+IGNvbmYuZ3JvdXBzLnZhbHVlLmNhbGwoY29uZiwgZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gZDMubmVzdCgpLmtleSh0aGlzLnBsb3QuZ3JvdXBWYWx1ZSkuZW50cmllcyhkYXRhKTtcblxuICAgICAgICAgICAgICAgIHZhciBnZXREaXNwbGF5VmFsdWU9IGsgPT4gaztcbiAgICAgICAgICAgICAgICBpZihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoVXRpbHMuaXNGdW5jdGlvbihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXREaXNwbGF5VmFsdWUgPSBrPT5zZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKGspIHx8IGs7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKFV0aWxzLmlzT2JqZWN0KHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldERpc3BsYXlWYWx1ZSA9IGsgPT4gc2VsZi5jb25maWcuZ3JvdXBzLmRpc3BsYXlWYWx1ZVtrXSB8fCBrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cGVkRGF0YS5mb3JFYWNoKGcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnLmtleSA9IGdldERpc3BsYXlWYWx1ZShnLmtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucGxvdC5kYXRhTGVuZ3RoID0gZDMuc3VtKHRoaXMucGxvdC5ncm91cGVkRGF0YSwgcz0+cy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhLmZvckVhY2gocz0+e1xuICAgICAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkocy52YWx1ZXMpKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBzLnZhbHVlcy5tYXAoZD0+cGFyc2VGbG9hdChzZWxmLmNvbmZpZy55LnZhbHVlLmNhbGwoc2VsZi5jb25maWcsIGQpKSk7XG4gICAgICAgICAgICBzLnZhbHVlcy5RMSA9IFN0YXRpc3RpY3NVdGlscy5xdWFudGlsZSh2YWx1ZXMsIDAuMjUpO1xuICAgICAgICAgICAgcy52YWx1ZXMuUTIgPSBTdGF0aXN0aWNzVXRpbHMucXVhbnRpbGUodmFsdWVzLCAwLjUpO1xuICAgICAgICAgICAgcy52YWx1ZXMuUTMgPSBTdGF0aXN0aWNzVXRpbHMucXVhbnRpbGUodmFsdWVzLCAwLjc1KTtcbiAgICAgICAgICAgIHZhciBJUVIgPSAgcy52YWx1ZXMuUTMgLSBzLnZhbHVlcy5RMTtcblxuICAgICAgICAgICAgaWYoIXNlbGYuY29uZmlnLnR1a2V5KXtcbiAgICAgICAgICAgICAgICBzLnZhbHVlcy53aGlza2VyTG93ID0gZDMubWluKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcy52YWx1ZXMud2hpc2tlckhpZ2ggPSBkMy5tYXgodmFsdWVzKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHMudmFsdWVzLndoaXNrZXJMb3cgPSBzLnZhbHVlcy5RMSAtIDEuNSpJUVI7XG4gICAgICAgICAgICAgICAgcy52YWx1ZXMud2hpc2tlckhpZ2ggPSBzLnZhbHVlcy5RMyArIDEuNSpJUVI7XG4gICAgICAgICAgICAgICAgcy52YWx1ZXMub3V0bGllcnMgPSB2YWx1ZXMuZmlsdGVyKGQ9PiBkPHMudmFsdWVzLndoaXNrZXJMb3cgfHwgZD5zLnZhbHVlcy53aGlza2VySGlnaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmLnBsb3QuZ3JvdXBlZERhdGE7XG4gICAgfVxuXG4gICAgaXNHcm91cGluZ0VuYWJsZWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNlcmllcyB8fCAhISh0aGlzLmNvbmZpZy5ncm91cHMgJiYgdGhpcy5jb25maWcuZ3JvdXBzLnZhbHVlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSBcIi4vbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWcgZXh0ZW5kcyBDaGFydENvbmZpZ3tcblxuICAgIHNob3dMZWdlbmQ9dHJ1ZTtcbiAgICBmb3JjZUxlZ2VuZD1mYWxzZTtcbiAgICBsZWdlbmQ9e1xuICAgICAgICB3aWR0aDogODAsXG4gICAgICAgIG1hcmdpbjogMTAsXG4gICAgICAgIHNoYXBlV2lkdGg6IDIwXG4gICAgfTtcbiAgICBncm91cHM9e1xuICAgICAgICBrZXk6IDIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihkKSB7IHJldHVybiBkW3RoaXMuZ3JvdXBzLmtleV19ICAsIC8vIGdyb3VwaW5nIHZhbHVlIGFjY2Vzc29yLFxuICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgZGlzcGxheVZhbHVlOiB1bmRlZmluZWQgLy8gb3B0aW9uYWwgZnVuY3Rpb24gcmV0dXJuaW5nIGRpc3BsYXkgdmFsdWUgKHNlcmllcyBsYWJlbCkgZm9yIGdpdmVuIGdyb3VwIHZhbHVlLCBvciBvYmplY3QvYXJyYXkgbWFwcGluZyB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgfTtcbiAgICBzZXJpZXMgPSBmYWxzZTtcbiAgICBjb2xvciA9ICB1bmRlZmluZWQ7Ly8gc3RyaW5nIG9yIGZ1bmN0aW9uIHJldHVybmluZyBjb2xvcidzIHZhbHVlIGZvciBjb2xvciBzY2FsZVxuICAgIGQzQ29sb3JDYXRlZ29yeT0gJ2NhdGVnb3J5MTAnO1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2hhcnRXaXRoQ29sb3JHcm91cHMgZXh0ZW5kcyBDaGFydHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBDaGFydFdpdGhDb2xvckdyb3Vwc0NvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpe1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuXG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG4gICAgICAgXG4gICAgICAgIHRoaXMucGxvdC5zaG93TGVnZW5kID0gY29uZi5zaG93TGVnZW5kO1xuICAgICAgICB0aGlzLnNldHVwR3JvdXBzKCk7XG4gICAgICAgIHRoaXMucGxvdC5kYXRhID0gdGhpcy5nZXREYXRhVG9QbG90KCk7XG4gICAgICAgIHRoaXMuZ3JvdXBEYXRhKCk7XG5cbiAgICAgICAgaWYodGhpcy5wbG90LnNob3dMZWdlbmQpe1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnk7XG4gICAgICAgICAgICBpZighc2NhbGUuZG9tYWluKCkgfHwgIXRoaXMuY29uZmlnLmZvcmNlTGVnZW5kICYmIHNjYWxlLmRvbWFpbigpLmxlbmd0aDwyKXtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3Quc2hvd0xlZ2VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5yaWdodCA9IGNvbmYubWFyZ2luLnJpZ2h0ICsgY29uZi5sZWdlbmQud2lkdGgrY29uZi5sZWdlbmQubWFyZ2luKjI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaXNHcm91cGluZ0VuYWJsZWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNlcmllcyB8fCAhISh0aGlzLmNvbmZpZy5ncm91cHMgJiYgdGhpcy5jb25maWcuZ3JvdXBzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBjb21wdXRlR3JvdXBDb2xvckRvbWFpbigpe1xuICAgICAgICB2YXIgbWFwID0gZDMuc2V0KHRoaXMuZGF0YSwgZCA9PiB0aGlzLnBsb3QuZ3JvdXBWYWx1ZShkKSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtYXApLm1hcChkPT5tYXBbZF0pO1xuICAgIH1cblxuICAgIHNldHVwR3JvdXBzKCkge1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC5ncm91cGluZ0VuYWJsZWQgPSB0aGlzLmlzR3JvdXBpbmdFbmFibGVkKCk7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgaWYodGhpcy5wbG90Lmdyb3VwaW5nRW5hYmxlZCl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBUb0xhYmVsID0ge307XG4gICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5zZXJpZXMpe1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5ncm91cFZhbHVlID0gcyA9PiBzLmtleTtcbiAgICAgICAgICAgICAgICBkb21haW4gPSB0aGlzLmNvbXB1dGVHcm91cENvbG9yRG9tYWluKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChzPT57XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cFRvTGFiZWxbcy5rZXldID0gcy5sYWJlbHx8cy5rZXk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5ncm91cFZhbHVlID0gZCA9PiBjb25mLmdyb3Vwcy52YWx1ZS5jYWxsKGNvbmYsIGQpO1xuICAgICAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuY29tcHV0ZUdyb3VwQ29sb3JEb21haW4oKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0TGFiZWw9IGsgPT4gaztcbiAgICAgICAgICAgICAgICBpZihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoVXRpbHMuaXNGdW5jdGlvbihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMYWJlbCA9IGs9PnNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUoaykgfHwgaztcbiAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoVXRpbHMuaXNPYmplY3Qoc2VsZi5jb25maWcuZ3JvdXBzLmRpc3BsYXlWYWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TGFiZWwgPSBrID0+IHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWVba10gfHwgaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb21haW4uZm9yRWFjaChrPT57XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cFRvTGFiZWxba10gPSBnZXRMYWJlbChrKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5wbG90Lmdyb3VwVmFsdWUgPSBkID0+IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbG90Lmdyb3VwQ29sb3JEb21haW4gPSBkb21haW47XG4gICAgICAgIGlmKGNvbmYuZDNDb2xvckNhdGVnb3J5KXtcbiAgICAgICAgICAgIHZhciBjb2xvclNjaGVtZUNhdGVnb3J5ID0gJ3NjaGVtZScrVXRpbHMuY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGNvbmYuZDNDb2xvckNhdGVnb3J5KTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvckNhdGVnb3J5ID0gZDMuc2NhbGVPcmRpbmFsKGQzW2NvbG9yU2NoZW1lQ2F0ZWdvcnldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3JWYWx1ZSA9IGNvbmYuY29sb3I7XG5cbiAgICAgICAgaWYgKGNvbG9yVmFsdWUpe1xuICAgICAgICAgICAgaWYodHlwZW9mIGNvbG9yVmFsdWUgPT09ICdzdHJpbmcnIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpe1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IGNvbG9yVmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LnNlcmllc0NvbG9yID0gdGhpcy5wbG90LmNvbG9yO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gY29sb3JWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3Quc2VyaWVzQ29sb3IgPSB0aGlzLnBsb3QuY29sb3I7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9tYWluLm1hcCh2PT50aGlzLnBsb3Quc2VyaWVzQ29sb3Ioe2tleTogdn0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSA9IGQzLnNjYWxlT3JkaW5hbChyYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKGRvbWFpbik7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9ZWxzZSBpZih0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuY29sb3JWYWx1ZT1jb2xvclZhbHVlO1xuICAgICAgICAgICAgc2VsZi5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKGRvbWFpbik7XG5cbiAgICAgICAgICAgIHRoaXMucGxvdC5zZXJpZXNDb2xvciA9IHMgPT4gIHNlbGYucGxvdC5jb2xvckNhdGVnb3J5KHMua2V5KTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IGQgPT4gIHNlbGYucGxvdC5jb2xvckNhdGVnb3J5KHRoaXMucGxvdC5ncm91cFZhbHVlKGQpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IHRoaXMucGxvdC5zZXJpZXNDb2xvciA9IHM9PiAnYmxhY2snXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdyb3VwRGF0YSgpe1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICBpZighc2VsZi5wbG90Lmdyb3VwaW5nRW5hYmxlZCApe1xuICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gIFt7XG4gICAgICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgc2VsZi5wbG90LmRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAgIGlmKHNlbGYuY29uZmlnLnNlcmllcyl7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gIGRhdGEubWFwKHM9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJue1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBzLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBzLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEgPSBkMy5uZXN0KCkua2V5KHRoaXMucGxvdC5ncm91cFZhbHVlKS5lbnRyaWVzKGRhdGEpO1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cGVkRGF0YS5mb3JFYWNoKGcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnLmxhYmVsID0gc2VsZi5wbG90Lmdyb3VwVG9MYWJlbFtnLmtleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucGxvdC5kYXRhTGVuZ3RoID0gZDMuc3VtKHRoaXMucGxvdC5ncm91cGVkRGF0YSwgcz0+cy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMucGxvdC5zZXJpZXNDb2xvclxuXG4gICAgfVxuXG4gICAgZ2V0RGF0YVRvUGxvdCgpe1xuICAgICAgICBpZighdGhpcy5wbG90Lmdyb3VwaW5nRW5hYmxlZCB8fCAhdGhpcy5lbmFibGVkR3JvdXBzKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maWx0ZXIoZCA9PiB0aGlzLmVuYWJsZWRHcm91cHMuaW5kZXhPZih0aGlzLnBsb3QuZ3JvdXBWYWx1ZShkKSk+LTEpO1xuICAgIH1cblxuXG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdXBkYXRlTGVnZW5kKCkge1xuXG4gICAgICAgIHZhciBzZWxmID10aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcblxuICAgICAgICB2YXIgc2NhbGUgPSBwbG90LmNvbG9yQ2F0ZWdvcnk7XG5cbiAgICAgICAgaWYoIXNjYWxlLmRvbWFpbigpIHx8ICF0aGlzLmNvbmZpZy5mb3JjZUxlZ2VuZCAmJiBzY2FsZS5kb21haW4oKS5sZW5ndGg8Mil7XG4gICAgICAgICAgICBwbG90LnNob3dMZWdlbmQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFwbG90LnNob3dMZWdlbmQpe1xuICAgICAgICAgICAgaWYocGxvdC5sZWdlbmQgJiYgcGxvdC5sZWdlbmQuY29udGFpbmVyKXtcbiAgICAgICAgICAgICAgICBwbG90LmxlZ2VuZC5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBsZWdlbmRYID0gdGhpcy5wbG90LndpZHRoICsgdGhpcy5jb25maWcubGVnZW5kLm1hcmdpbjtcbiAgICAgICAgdmFyIGxlZ2VuZFkgPSB0aGlzLmNvbmZpZy5sZWdlbmQubWFyZ2luO1xuXG4gICAgICAgIHBsb3QubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLnN2ZywgdGhpcy5zdmdHLCBzY2FsZSwgbGVnZW5kWCwgbGVnZW5kWSk7XG5cbiAgICAgICAgcGxvdC5sZWdlbmRDb2xvciA9IHBsb3QubGVnZW5kLmNvbG9yKClcbiAgICAgICAgICAgIC5zaGFwZVdpZHRoKHRoaXMuY29uZmlnLmxlZ2VuZC5zaGFwZVdpZHRoKVxuICAgICAgICAgICAgLm9yaWVudCgndmVydGljYWwnKVxuICAgICAgICAgICAgLnNjYWxlKHNjYWxlKVxuICAgICAgICAgICAgLmxhYmVsV3JhcCh0aGlzLmNvbmZpZy5sZWdlbmQud2lkdGgpXG4gICAgICAgICAgICAubGFiZWxzKHNjYWxlLmRvbWFpbigpLm1hcCh2PT5wbG90Lmdyb3VwVG9MYWJlbFt2XSkpO1xuXG5cbiAgICAgICAgcGxvdC5sZWdlbmRDb2xvci5vbignY2VsbGNsaWNrJywgYz0+IHNlbGYub25MZWdlbmRDZWxsQ2xpY2soYykpO1xuICAgICAgICBcbiAgICAgICAgcGxvdC5sZWdlbmQuY29udGFpbmVyXG4gICAgICAgICAgICAuY2FsbChwbG90LmxlZ2VuZENvbG9yKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZENlbGxTdGF0dXNlcygpO1xuICAgIH1cblxuICAgIG9uTGVnZW5kQ2VsbENsaWNrKGNlbGxWYWx1ZSl7XG4gICAgICAgIHRoaXMudXBkYXRlRW5hYmxlZEdyb3VwcyhjZWxsVmFsdWUpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgdXBkYXRlTGVnZW5kQ2VsbFN0YXR1c2VzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucGxvdC5sZWdlbmQuY29udGFpbmVyLnNlbGVjdEFsbChcImcuY2VsbFwiKS5lYWNoKGZ1bmN0aW9uKGNlbGwpe1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBzZWxmLmVuYWJsZWRHcm91cHMgJiYgc2VsZi5lbmFibGVkR3JvdXBzLmluZGV4T2YoY2VsbCk8MDtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwib2RjLWRpc2FibGVkXCIsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVFbmFibGVkR3JvdXBzKGNlbGxWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZEdyb3Vwcykge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkR3JvdXBzID0gdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKCkuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVuYWJsZWRHcm91cHMuaW5kZXhPZihjZWxsVmFsdWUpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZEdyb3Vwcy5wdXNoKGNlbGxWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWRHcm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkR3JvdXBzID0gdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKCkuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc2V0RGF0YShkYXRhKXtcbiAgICAgICAgc3VwZXIuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgdGhpcy5lbmFibGVkR3JvdXBzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBDaGFydENvbmZpZyB7XG4gICAgY3NzQ2xhc3NQcmVmaXggPSBcIm9kYy1cIjtcbiAgICBzdmdDbGFzcyA9IHRoaXMuY3NzQ2xhc3NQcmVmaXggKyAnbXctZDMtY2hhcnQnO1xuICAgIHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIGhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICBtYXJnaW4gPSB7XG4gICAgICAgIGxlZnQ6IDUwLFxuICAgICAgICByaWdodDogMzAsXG4gICAgICAgIHRvcDogMzAsXG4gICAgICAgIGJvdHRvbTogNTBcbiAgICB9O1xuICAgIHNob3dUb29sdGlwID0gZmFsc2U7XG4gICAgdHJhbnNpdGlvbiA9IHRydWU7XG5cbiAgICB0aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aXRsZVNpemU9MjA7XG4gICAgdGl0bGVNYXJnaW49e1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdG9wOiAxNSxcbiAgICAgICAgYm90dG9tOiAyMFxuICAgIH07XG5cbiAgICBzdWJ0aXRsZSA9IHVuZGVmaW5lZDtcbiAgICBzdWJ0aXRsZVNpemU9MTQ7XG4gICAgc3VidGl0bGVNYXJnaW49e1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdG9wOiAxMCxcbiAgICAgICAgYm90dG9tOiAyMFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pIHtcbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGNsYXNzIENoYXJ0IHtcbiAgICB1dGlscyA9IFV0aWxzO1xuICAgIGJhc2VDb250YWluZXI7XG4gICAgc3ZnO1xuICAgIGNvbmZpZztcbiAgICBwbG90ID0ge1xuICAgICAgICBtYXJnaW46IHt9XG4gICAgfTtcbiAgICBfYXR0YWNoZWQgPSB7fTtcbiAgICBfbGF5ZXJzID0ge307XG4gICAgX2V2ZW50cyA9IHt9O1xuICAgIF9pc0F0dGFjaGVkO1xuICAgIF9pc0luaXRpYWxpemVkPWZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5faWQgPSBVdGlscy5ndWlkKCk7XG4gICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBiYXNlIGluc3RhbmNlb2YgQ2hhcnQ7XG5cbiAgICAgICAgdGhpcy5iYXNlQ29udGFpbmVyID0gYmFzZTtcblxuICAgICAgICB0aGlzLnNldENvbmZpZyhjb25maWcpO1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMucG9zdEluaXQoKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IG5ldyBDaGFydENvbmZpZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0Q29uZmlnQWNjZXNzb3JzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuaW5pdFBsb3QoKTtcbiAgICAgICAgc2VsZi5pbml0U3ZnKCk7XG5cbiAgICAgICAgaWYoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpe1xuICAgICAgICAgICAgc2VsZi5pbml0VG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZHJhdygpO1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkPXRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlZHJhdygpe1xuICAgICAgICB0aGlzLmluaXRDb25maWdBY2Nlc3NvcnModHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBwb3N0SW5pdCgpe1xuXG4gICAgfVxuXG4gICAgaW5pdFN2ZygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdmFyIG1hcmdpbiA9IHNlbGYucGxvdC5tYXJnaW47XG4gICAgICAgIHZhciB3aWR0aCA9IHNlbGYuc3ZnV2lkdGggPSBzZWxmLnBsb3Qud2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHNlbGYuc3ZnSGVpZ2h0ID0gIHNlbGYucGxvdC5oZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBpZighc2VsZi5faXNBdHRhY2hlZCl7XG4gICAgICAgICAgICBpZighdGhpcy5faXNJbml0aWFsaXplZCl7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGYuYmFzZUNvbnRhaW5lcikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zdmcgPSBkMy5zZWxlY3Qoc2VsZi5iYXNlQ29udGFpbmVyKS5zZWxlY3RPckFwcGVuZChcInN2Z1wiKS5jbGFzc2VkKGNvbmZpZy5zdmdDbGFzcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHNlbGYuc3ZnXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ2aWV3Qm94XCIsIFwiMCAwIFwiICsgXCIgXCIgKyB3aWR0aCArIFwiIFwiICsgaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcInhNaWRZTWlkIG1lZXRcIilcbiAgICAgICAgICAgIHNlbGYuc3ZnRyA9IHNlbGYuc3ZnLnNlbGVjdE9yQXBwZW5kKFwiZy5tYWluLWdyb3VwXCIpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHNlbGYuYmFzZUNvbnRhaW5lcik7XG4gICAgICAgICAgICBzZWxmLnN2ZyA9IHNlbGYuYmFzZUNvbnRhaW5lci5zdmc7XG4gICAgICAgICAgICBzZWxmLnN2Z0cgPSBzZWxmLnN2Zy5zZWxlY3RPckFwcGVuZChcImcubWFpbi1ncm91cC5cIitjb25maWcuc3ZnQ2xhc3MpXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN2Z0cuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIGlmICghY29uZmlnLndpZHRoIHx8IGNvbmZpZy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgICAgICAgICAgLm9uKFwicmVzaXplLlwiK3NlbGYuX2lkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gc2VsZi5jb25maWcudHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcudHJhbnNpdGlvbj1mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpe1xuICAgICAgICBkMy5zZWxlY3QodGhpcy5iYXNlQ29udGFpbmVyKS5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBkMy5zZWxlY3Qod2luZG93KS5vbihcInJlc2l6ZS5cIiArIHRoaXMuX2lkLCBudWxsKTtcbiAgICB9XG5cbiAgICBpbml0VG9vbHRpcCgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5zaG93VG9vbHRpcCkge1xuICAgICAgICAgICAgaWYoIXNlbGYuX2lzQXR0YWNoZWQgKXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QudG9vbHRpcCA9IGQzLnNlbGVjdChcImJvZHlcIikuc2VsZWN0T3JBcHBlbmQoJ2Rpdi4nK3NlbGYuY29uZmlnLmNzc0NsYXNzUHJlZml4Kyd0b29sdGlwJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC50b29sdGlwPSBzZWxmLmJhc2VDb250YWluZXIucGxvdC50b29sdGlwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc2VsZi5wbG90LnRvb2x0aXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNvbmZpZy5tYXJnaW47XG4gICAgICAgIHRoaXMucGxvdCA9IHRoaXMucGxvdCB8fCB7fTtcbiAgICAgICAgdGhpcy5wbG90Lm1hcmdpbiA9IHtcbiAgICAgICAgICAgIHRvcDogbWFyZ2luLnRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQ6IG1hcmdpbi5sZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IG1hcmdpbi5yaWdodFxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIHRpdGxlTWFyZ2luU2l6ZSA9IDA7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnRpdGxlKXtcbiAgICAgICAgICAgIHRpdGxlTWFyZ2luU2l6ZT0gdGhpcy5jb25maWcudGl0bGVTaXplK3RoaXMuY29uZmlnLnRpdGxlTWFyZ2luLnRvcDtcbiAgICAgICAgICAgIGlmKCF0aGlzLmNvbmZpZy5zdWJ0aXRsZSl7XG4gICAgICAgICAgICAgICAgdGl0bGVNYXJnaW5TaXplICs9IHRoaXMuY29uZmlnLnRpdGxlTWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi50b3A9TWF0aC5tYXgodGhpcy5wbG90Lm1hcmdpbi50b3AsdGl0bGVNYXJnaW5TaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnN1YnRpdGxlKXtcblxuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi50b3A9TWF0aC5tYXgodGhpcy5wbG90Lm1hcmdpbi50b3AsIHRpdGxlTWFyZ2luU2l6ZSt0aGlzLmNvbmZpZy5zdWJ0aXRsZU1hcmdpbi50b3ArdGhpcy5jb25maWcuc3VidGl0bGVTaXplK3RoaXMuY29uZmlnLnN1YnRpdGxlTWFyZ2luLmJvdHRvbSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUaXRsZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnRpdGxlKCk7XG5cbiAgICAgICAgdmFyIGxheWVyTmFtZSwgYXR0YWNobWVudERhdGE7XG4gICAgICAgIGZvciAodmFyIGF0dGFjaG1lbnROYW1lIGluIHRoaXMuX2F0dGFjaGVkKSB7XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnREYXRhID0gZGF0YTtcblxuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRbYXR0YWNobWVudE5hbWVdLnVwZGF0ZShhdHRhY2htZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlVGl0bGUoKSB7XG4gICAgICAgIHZhciB0aXRsZUNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcygncGxvdC10aXRsZScpO1xuICAgICAgICBpZighdGhpcy5jb25maWcudGl0bGUpe1xuICAgICAgICAgICAgdGhpcy5zdmcuc2VsZWN0KFwidGV4dC5cIit0aXRsZUNsYXNzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIit0aXRsZUNsYXNzKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrICh0aGlzLnN2Z1dpZHRoLzIpICtcIixcIisgKHRoaXMuY29uZmlnLnRpdGxlTWFyZ2luLnRvcCkgK1wiKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjAuNWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJjZW50cmFsXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgdGhpcy5jb25maWcudGl0bGVTaXplK1wicHhcIilcbiAgICAgICAgICAgIC50ZXh0KHRoaXMuY29uZmlnLnRpdGxlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTdWJ0aXRsZSgpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKCdwbG90LXN1YnRpdGxlJyk7XG4gICAgICAgIGlmKCF0aGlzLmNvbmZpZy5zdWJ0aXRsZSl7XG4gICAgICAgICAgICB0aGlzLnN2Zy5zZWxlY3QoXCJ0ZXh0LlwiK3N1YnRpdGxlQ2xhc3MpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkgPSB0aGlzLmNvbmZpZy5zdWJ0aXRsZU1hcmdpbi50b3A7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnRpdGxlKXtcbiAgICAgICAgICAgIHkrPXRoaXMuY29uZmlnLnRpdGxlTWFyZ2luLnRvcCt0aGlzLmNvbmZpZy50aXRsZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2Zy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc3VidGl0bGVDbGFzcylcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAodGhpcy5zdmdXaWR0aC8yKSArXCIsXCIrICh5KSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMC41ZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImNlbnRyYWxcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCB0aGlzLmNvbmZpZy5zdWJ0aXRsZVNpemUrXCJweFwiKVxuICAgICAgICAgICAgLnRleHQodGhpcy5jb25maWcuc3VidGl0bGUpO1xuICAgIH1cblxuICAgIGRyYXcoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZShkYXRhKTtcblxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLy9Cb3Jyb3dlZCBmcm9tIGQzLmNoYXJ0XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgb3IgcmV0cmlldmUgYW4gXCJhdHRhY2htZW50XCIgQ2hhcnQuIFRoZSBcImF0dGFjaG1lbnRcIiBjaGFydCdzIGBkcmF3YFxuICAgICAqIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIGNvbnRhaW5pbmcgY2hhcnQncyBgZHJhd2AgbWV0aG9kIGlzXG4gICAgICogaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBleHRlcm5hbEV4YW1wbGUgY2hhcnQtYXR0YWNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0YWNobWVudE5hbWUgTmFtZSBvZiB0aGUgYXR0YWNobWVudFxuICAgICAqIEBwYXJhbSB7Q2hhcnR9IFtjaGFydF0gQ2hhcnQgdG8gcmVnaXN0ZXIgYXMgYSBtaXggaW4gb2YgdGhpcyBjaGFydC4gV2hlblxuICAgICAqICAgICAgICB1bnNwZWNpZmllZCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIGF0dGFjaG1lbnQgcHJldmlvdXNseVxuICAgICAqICAgICAgICByZWdpc3RlcmVkIHdpdGggdGhlIHNwZWNpZmllZCBgYXR0YWNobWVudE5hbWVgIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NoYXJ0fSBSZWZlcmVuY2UgdG8gdGhpcyBjaGFydCAoY2hhaW5hYmxlKS5cbiAgICAgKi9cbiAgICBhdHRhY2goYXR0YWNobWVudE5hbWUsIGNoYXJ0KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNoZWRbYXR0YWNobWVudE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRbYXR0YWNobWVudE5hbWVdID0gY2hhcnQ7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgXG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhbiBldmVudCB0cmlnZ2VyZWQgb24gdGhlIGNoYXJ0LiBTZWUge0BsaW5rXG4gICAgICAgICogQ2hhcnQjb25jZX0gdG8gc3Vic2NyaWJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYW4gZXZlbnQgZm9yIG9uZSBvY2N1cmVuY2UuXG4gICAgICpcbiAgICAgKiBAZXh0ZXJuYWxFeGFtcGxlIHtydW5uYWJsZX0gY2hhcnQtb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtDaGFydEV2ZW50SGFuZGxlcn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudFxuICAgICAqICAgICAgICBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIFZhbHVlIHRvIHNldCBhcyBgdGhpc2Agd2hlbiBpbnZva2luZyB0aGVcbiAgICAgKiAgICAgICAgYGNhbGxiYWNrYC4gRGVmYXVsdHMgdG8gdGhlIGNoYXJ0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NoYXJ0fSBBIHJlZmVyZW5jZSB0byB0aGlzIGNoYXJ0IChjaGFpbmFibGUpLlxuICAgICAqL1xuICAgIG9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCB8fCB0aGlzLFxuICAgICAgICAgICAgX2NoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFuIGV2ZW50IHRyaWdnZXJlZCBvbiB0aGUgY2hhcnQuIFRoaXNcbiAgICAgKiBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYXQgdGhlIG5leHQgb2NjdXJhbmNlIG9mIHRoZSBldmVudCBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiB1bnN1YnNjcmliZWQuIFNlZSB7QGxpbmsgQ2hhcnQjb259IHRvIHN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFuXG4gICAgICogZXZlbnQgaW5kZWZpbml0ZWx5LlxuICAgICAqXG4gICAgICogQGV4dGVybmFsRXhhbXBsZSB7cnVubmFibGV9IGNoYXJ0LW9uY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtDaGFydEV2ZW50SGFuZGxlcn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudFxuICAgICAqICAgICAgICBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIFZhbHVlIHRvIHNldCBhcyBgdGhpc2Agd2hlbiBpbnZva2luZyB0aGVcbiAgICAgKiAgICAgICAgYGNhbGxiYWNrYC4gRGVmYXVsdHMgdG8gdGhlIGNoYXJ0IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2hhcnR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY2hhcnQgKGNoYWluYWJsZSlcbiAgICAgKi9cbiAgICBvbmNlKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIG9uY2UsIGNvbnRleHQpO1xuICAgIH1cblxuXG4gICAgLy9Cb3Jyb3dlZCBmcm9tIGQzLmNoYXJ0XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgb25lIG9yIG1vcmUgY2FsbGJhY2sgZnVuY3Rpb25zIGZyb20gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIHRoZVxuICAgICAqIGNoYXJ0LiBXaGVuIG5vIGFyZ3VtZW50cyBhcmUgc3BlY2lmaWVkLCAqYWxsKiBoYW5kbGVycyB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cbiAgICAgKiBXaGVuIG9ubHkgYSBgbmFtZWAgaXMgc3BlY2lmaWVkLCBhbGwgaGFuZGxlcnMgc3Vic2NyaWJlZCB0byB0aGF0IGV2ZW50IHdpbGxcbiAgICAgKiBiZSB1bnN1YnNjcmliZWQuIFdoZW4gYSBgbmFtZWAgYW5kIGBjYWxsYmFja2AgYXJlIHNwZWNpZmllZCwgb25seSB0aGF0XG4gICAgICogZnVuY3Rpb24gd2lsbCBiZSB1bnN1YnNjcmliZWQgZnJvbSB0aGF0IGV2ZW50LiBXaGVuIGEgYG5hbWVgIGFuZCBgY29udGV4dGBcbiAgICAgKiBhcmUgc3BlY2lmaWVkIChidXQgYGNhbGxiYWNrYCBpcyBvbWl0dGVkKSwgYWxsIGV2ZW50cyBib3VuZCB0byB0aGUgZ2l2ZW5cbiAgICAgKiBldmVudCB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxuICAgICAqXG4gICAgICogQGV4dGVybmFsRXhhbXBsZSB7cnVubmFibGV9IGNoYXJ0LW9mZlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSB1bnN1YnNjcmliZWRcbiAgICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnRIYW5kbGVyfSBbY2FsbGJhY2tdIEZ1bmN0aW9uIHRvIGJlIHVuc3Vic2NyaWJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dHMgdG8gYmUgdW5zdWJzY3JpYmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDaGFydH0gQSByZWZlcmVuY2UgdG8gdGhpcyBjaGFydCAoY2hhaW5hYmxlKS5cbiAgICAgKi9cblxuICAgIG9mZihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgbmFtZXMsIG4sIGV2ZW50cywgZXZlbnQsIGksIGo7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHNcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHMgZm9yIGEgc3BlY2lmaWMgbmFtZVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIHdoYXRldmVyIGNvbWJpbmF0aW9uIG9mIG5hbWUsIGNvbnRleHRcbiAgICAgICAgLy8gYW5kIGNhbGxiYWNrLlxuICAgICAgICBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBPYmplY3Qua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG4gPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuXTtcbiAgICAgICAgICAgIGogPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgPT09IGV2ZW50LmNhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ID09PSBldmVudC5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IG9uIHRoaXMgY2hhcnQgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICAgICAqXG4gICAgICogQGV4dGVybmFsRXhhbXBsZSB7cnVubmFibGV9IGNoYXJ0LXRyaWdnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cyBWYWx1ZXMgd2l0aCB3aGljaCB0byBpbnZva2UgdGhlIHJlZ2lzdGVyZWRcbiAgICAgKiAgICAgICAgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NoYXJ0fSBBIHJlZmVyZW5jZSB0byB0aGlzIGNoYXJ0IChjaGFpbmFibGUpLlxuICAgICAqL1xuICAgIHRyaWdnZXIobmFtZSkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIHZhciBpLCBldjtcblxuICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBldiA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICBldi5jYWxsYmFjay5hcHBseShldi5jb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZ2V0QmFzZUNvbnRhaW5lcigpe1xuICAgICAgICBpZih0aGlzLl9pc0F0dGFjaGVkKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VDb250YWluZXIuc3ZnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkMy5zZWxlY3QodGhpcy5iYXNlQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBnZXRCYXNlQ29udGFpbmVyTm9kZSgpe1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJhc2VDb250YWluZXIoKS5ub2RlKCk7XG4gICAgfVxuXG4gICAgcHJlZml4Q2xhc3MoY2xhenosIGFkZERvdCl7XG4gICAgICAgIHJldHVybiBhZGREb3Q/ICcuJzogJycrdGhpcy5jb25maWcuY3NzQ2xhc3NQcmVmaXgrY2xheno7XG4gICAgfVxuICAgIGNvbXB1dGVQbG90U2l6ZSgpIHtcbiAgICAgICAgdGhpcy5wbG90LndpZHRoID0gVXRpbHMuYXZhaWxhYmxlV2lkdGgodGhpcy5jb25maWcud2lkdGgsIHRoaXMuZ2V0QmFzZUNvbnRhaW5lcigpLCB0aGlzLnBsb3QubWFyZ2luKTtcbiAgICAgICAgdGhpcy5wbG90LmhlaWdodCA9IFV0aWxzLmF2YWlsYWJsZUhlaWdodCh0aGlzLmNvbmZpZy5oZWlnaHQsIHRoaXMuZ2V0QmFzZUNvbnRhaW5lcigpLCB0aGlzLnBsb3QubWFyZ2luKTtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uRW5hYmxlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZCAmJiB0aGlzLmNvbmZpZy50cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIHNob3dUb29sdGlwKGh0bWwpe1xuICAgICAgICBpZighdGhpcy5wbG90LnRvb2x0aXApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxvdC50b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpO1xuICAgICAgICB0aGlzLnBsb3QudG9vbHRpcC5odG1sKGh0bWwpXG4gICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIChkMy5ldmVudC5wYWdlWCArIDUpICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIChkMy5ldmVudC5wYWdlWSAtIDI4KSArIFwicHhcIik7XG4gICAgfVxuXG4gICAgaGlkZVRvb2x0aXAoKXtcbiAgICAgICAgaWYoIXRoaXMucGxvdC50b29sdGlwKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsb3QudG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgIH1cblxuICAgIGluaXRDb25maWdBY2Nlc3NvcnMoY2xlYW4pIHtcbiAgICAgICAgaWYoY2xlYW4pe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcm9wZXJ0eUFjY2Vzc29ycyh0aGlzLHRoaXMsIHRoaXMuY29uZmlnLCBcIiRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0UHJvcGVydHlBY2Nlc3NvcnModGhpcyx0aGlzLCB0aGlzLmNvbmZpZywgXCIkXCIsIHRydWUpO1xuICAgIH1cblxuICAgIHJlbW92ZVByb3BlcnR5QWNjZXNzb3JzKGJpbmRUbyxyZXR1cm5PYmosIHNvdXJjZSwgcHJlZml4KSB7XG4gICAgICAgIHZhciBzZWxmICA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZighc291cmNlLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJpbmRUb1twcmVmaXggKyBpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRQcm9wZXJ0eUFjY2Vzc29ycyhiaW5kVG8scmV0dXJuT2JqLCBzb3VyY2UsIHByZWZpeCwgcmVjdXJzaXZlKSB7XG4gICAgICAgIHZhciBzZWxmICA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZighc291cmNlLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFjY2Vzc29yID0gc2VsZi5pbml0UHJvcGVydHlBY2Nlc3NvcihiaW5kVG8scmV0dXJuT2JqLCBzb3VyY2UsIGksIHByZWZpeCk7XG5cbiAgICAgICAgICAgIGlmKHJlY3Vyc2l2ZSAmJiBVdGlscy5pc09iamVjdE5vdEFycmF5KHNvdXJjZVtpXSkpe1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdFByb3BlcnR5QWNjZXNzb3JzKGFjY2Vzc29yLCBiaW5kVG8sIHNvdXJjZVtpXSwgcHJlZml4LCByZWN1cnNpdmUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0UHJvcGVydHlBY2Nlc3NvcihiaW5kVG8sIHJldHVybk9iaiwgc291cmNlLCBwcm9wZXJ0eUtleSwgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBiaW5kVG9bcHJlZml4ICsgcHJvcGVydHlLZXldID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VbcHJvcGVydHlLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5S2V5XSA9IF87XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuT2JqO1xuICAgICAgICB9O1xuICAgIH1cblxuXG59XG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge1N0YXRpc3RpY3NVdGlsc30gZnJvbSAnLi9zdGF0aXN0aWNzLXV0aWxzJ1xuaW1wb3J0IHtMZWdlbmR9IGZyb20gJy4vbGVnZW5kJ1xuaW1wb3J0IHtTY2F0dGVyUGxvdH0gZnJvbSAnLi9zY2F0dGVycGxvdCdcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBDb3JyZWxhdGlvbk1hdHJpeENvbmZpZyBleHRlbmRzIENoYXJ0Q29uZmlnIHtcblxuICAgIHN2Z0NsYXNzID0gdGhpcy5jc3NDbGFzc1ByZWZpeCsnY29ycmVsYXRpb24tbWF0cml4JztcbiAgICBndWlkZXMgPSBmYWxzZTsgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgc2hvd1Rvb2x0aXAgPSB0cnVlOyAvL3Nob3cgdG9vbHRpcCBvbiBkb3QgaG92ZXJcbiAgICBzaG93TGVnZW5kID0gdHJ1ZTtcbiAgICBoaWdobGlnaHRMYWJlbHMgPSB0cnVlO1xuICAgIHJvdGF0ZUxhYmVsc1ggPSB0cnVlO1xuICAgIHJvdGF0ZUxhYmVsc1kgPSB0cnVlO1xuICAgIHZhcmlhYmxlcyA9IHtcbiAgICAgICAgbGFiZWxzOiB1bmRlZmluZWQsXG4gICAgICAgIGtleXM6IFtdLCAvL29wdGlvbmFsIGFycmF5IG9mIHZhcmlhYmxlIGtleXNcbiAgICAgICAgdmFsdWU6IChkLCB2YXJpYWJsZUtleSkgPT4gcGFyc2VGbG9hdChkW3ZhcmlhYmxlS2V5XSksIC8vIHZhcmlhYmxlIHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIHNjYWxlOiBcIm9yZGluYWxcIlxuICAgIH07XG4gICAgY29ycmVsYXRpb24gPSB7XG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBkb21haW46IFstMSwgLTAuNzUsIC0wLjUsIDAsIDAuNSwgMC43NSwgMV0sXG4gICAgICAgIHJhbmdlOiBbXCJkYXJrYmx1ZVwiLCBcImJsdWVcIiwgXCJsaWdodHNreWJsdWVcIiwgXCJ3aGl0ZVwiLCBcIm9yYW5nZXJlZFwiLCBcImNyaW1zb25cIiwgXCJkYXJrcmVkXCJdLFxuICAgICAgICB2YWx1ZTogKHhWYWx1ZXMsIHlWYWx1ZXMpID0+IFN0YXRpc3RpY3NVdGlscy5zYW1wbGVDb3JyZWxhdGlvbih4VmFsdWVzLCB5VmFsdWVzKVxuXG4gICAgfTtcbiAgICBjZWxsID0ge1xuICAgICAgICBzaGFwZTogXCJlbGxpcHNlXCIsIC8vcG9zc2libGUgdmFsdWVzOiByZWN0LCBjaXJjbGUsIGVsbGlwc2VcbiAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICBzaXplTWluOiAxNSxcbiAgICAgICAgc2l6ZU1heDogMjUwLFxuICAgICAgICBwYWRkaW5nOiAxXG4gICAgfTtcbiAgICBtYXJnaW4gPSB7XG4gICAgICAgIGxlZnQ6IDYwLFxuICAgICAgICByaWdodDogNTAsXG4gICAgICAgIHRvcDogMzAsXG4gICAgICAgIGJvdHRvbTogNjBcbiAgICB9O1xuICAgIGdyb3Vwcz17XG4gICAgICAgIGtleTogbnVsbCxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChjdXN0b20pIHtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvcnJlbGF0aW9uTWF0cml4IGV4dGVuZHMgQ2hhcnQge1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgQ29ycmVsYXRpb25NYXRyaXhDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBDb3JyZWxhdGlvbk1hdHJpeENvbmZpZyhjb25maWcpKTtcblxuICAgIH1cblxuICAgIGluaXRQbG90KCkge1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNvbmZpZy5tYXJnaW47XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdGhpcy5wbG90LnggPSB7fTtcbiAgICAgICAgdGhpcy5wbG90LmNvcnJlbGF0aW9uID0ge1xuICAgICAgICAgICAgbWF0cml4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZWxsczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sb3I6IHt9LFxuICAgICAgICAgICAgc2hhcGU6IHt9XG4gICAgICAgIH07XG5cblxuICAgICAgICB0aGlzLnNldHVwVmFyaWFibGVzKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGg7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlck5vZGUgPSB0aGlzLmdldEJhc2VDb250YWluZXJOb2RlKCk7XG4gICAgICAgIHRoaXMucGxvdC5wbGFjZWhvbGRlck5vZGUgPSBwbGFjZWhvbGRlck5vZGU7XG5cbiAgICAgICAgdmFyIHBhcmVudFdpZHRoID0gcGxhY2Vob2xkZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBpZiAod2lkdGgpIHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnBsb3QuY2VsbFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFNpemUgPSBNYXRoLm1heChjb25mLmNlbGwuc2l6ZU1pbiwgTWF0aC5taW4oY29uZi5jZWxsLnNpemVNYXgsICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSAvIHRoaXMucGxvdC52YXJpYWJsZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jZWxsU2l6ZSA9IHRoaXMuY29uZmlnLmNlbGwuc2l6ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnBsb3QuY2VsbFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFNpemUgPSBNYXRoLm1heChjb25mLmNlbGwuc2l6ZU1pbiwgTWF0aC5taW4oY29uZi5jZWxsLnNpemVNYXgsIChwYXJlbnRXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSAvIHRoaXMucGxvdC52YXJpYWJsZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5wbG90LmNlbGxTaXplICogdGhpcy5wbG90LnZhcmlhYmxlcy5sZW5ndGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoO1xuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcGxhY2Vob2xkZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxvdC53aWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG4gICAgICAgIHRoaXMucGxvdC5oZWlnaHQgPSB0aGlzLnBsb3Qud2lkdGg7XG5cbiAgICAgICAgdGhpcy5zZXR1cFZhcmlhYmxlc1NjYWxlcygpO1xuICAgICAgICB0aGlzLnNldHVwQ29ycmVsYXRpb25TY2FsZXMoKTtcbiAgICAgICAgdGhpcy5zZXR1cENvcnJlbGF0aW9uTWF0cml4KCk7XG5cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFZhcmlhYmxlc1NjYWxlcygpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcudmFyaWFibGVzO1xuXG4gICAgICAgIC8qICpcbiAgICAgICAgICogdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAgICAgICAqIHNjYWxlIC0gbWFwcyB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzIGEgcGl4ZWwgcG9zaXRpb24uXG4gICAgICAgICAqIG1hcCBmdW5jdGlvbiAtIG1hcHMgZnJvbSBkYXRhIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICogYXhpcyAtIHNldHMgdXAgYXhpc1xuICAgICAgICAgKiovXG4gICAgICAgIHgudmFsdWUgPSBjb25mLnZhbHVlO1xuICAgICAgICB4LnNjYWxlID0gZDMuc2NhbGVCYW5kKCkucmFuZ2UoW3Bsb3Qud2lkdGgsIDBdKTtcbiAgICAgICAgeC5tYXAgPSBkID0+IHguc2NhbGUoeC52YWx1ZShkKSk7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBDb3JyZWxhdGlvblNjYWxlcygpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBjb3JyQ29uZiA9IHRoaXMuY29uZmlnLmNvcnJlbGF0aW9uO1xuXG4gICAgICAgIHBsb3QuY29ycmVsYXRpb24uY29sb3Iuc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb3JyQ29uZi5zY2FsZSkuZG9tYWluKGNvcnJDb25mLmRvbWFpbikucmFuZ2UoY29yckNvbmYucmFuZ2UpO1xuICAgICAgICB2YXIgc2hhcGUgPSBwbG90LmNvcnJlbGF0aW9uLnNoYXBlID0ge307XG5cbiAgICAgICAgdmFyIGNlbGxDb25mID0gdGhpcy5jb25maWcuY2VsbDtcbiAgICAgICAgc2hhcGUudHlwZSA9IGNlbGxDb25mLnNoYXBlO1xuXG4gICAgICAgIHZhciBzaGFwZVNpemUgPSBwbG90LmNlbGxTaXplIC0gY2VsbENvbmYucGFkZGluZyAqIDI7XG4gICAgICAgIGlmIChzaGFwZS50eXBlID09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzTWF4ID0gc2hhcGVTaXplIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1c1NjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbMiwgcmFkaXVzTWF4XSk7XG4gICAgICAgICAgICBzaGFwZS5yYWRpdXMgPSBjPT4gc2hhcGUucmFkaXVzU2NhbGUoTWF0aC5hYnMoYy52YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlLnR5cGUgPT0gJ2VsbGlwc2UnKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzTWF4ID0gc2hhcGVTaXplIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1c1NjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbcmFkaXVzTWF4LCAyXSk7XG4gICAgICAgICAgICBzaGFwZS5yYWRpdXNYID0gYz0+IHNoYXBlLnJhZGl1c1NjYWxlKE1hdGguYWJzKGMudmFsdWUpKTtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1c1kgPSByYWRpdXNNYXg7XG5cbiAgICAgICAgICAgIHNoYXBlLnJvdGF0ZVZhbCA9IHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2ID09IDApIHJldHVybiBcIjBcIjtcbiAgICAgICAgICAgICAgICBpZiAodiA8IDApIHJldHVybiBcIi00NVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjQ1XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZS50eXBlID09ICdyZWN0Jykge1xuICAgICAgICAgICAgc2hhcGUuc2l6ZSA9IHNoYXBlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICBzZXR1cFZhcmlhYmxlcygpIHtcblxuICAgICAgICB2YXIgdmFyaWFibGVzQ29uZiA9IHRoaXMuY29uZmlnLnZhcmlhYmxlcztcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHBsb3QuZG9tYWluQnlWYXJpYWJsZSA9IHt9O1xuICAgICAgICBwbG90LnZhcmlhYmxlcyA9IHZhcmlhYmxlc0NvbmYua2V5cztcbiAgICAgICAgaWYgKCFwbG90LnZhcmlhYmxlcyB8fCAhcGxvdC52YXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbG90LnZhcmlhYmxlcyA9IFV0aWxzLmluZmVyVmFyaWFibGVzKGRhdGEsIHRoaXMuY29uZmlnLmdyb3Vwcy5rZXksIHRoaXMuY29uZmlnLmluY2x1ZGVJblBsb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC5sYWJlbHMgPSBbXTtcbiAgICAgICAgcGxvdC5sYWJlbEJ5VmFyaWFibGUgPSB7fTtcbiAgICAgICAgcGxvdC52YXJpYWJsZXMuZm9yRWFjaCgodmFyaWFibGVLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBwbG90LmRvbWFpbkJ5VmFyaWFibGVbdmFyaWFibGVLZXldID0gZDMuZXh0ZW50KGRhdGEsIChkKSA9PiB2YXJpYWJsZXNDb25mLnZhbHVlKGQsIHZhcmlhYmxlS2V5KSk7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB2YXJpYWJsZUtleTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZXNDb25mLmxhYmVscyAmJiB2YXJpYWJsZXNDb25mLmxhYmVscy5sZW5ndGggPiBpbmRleCkge1xuXG4gICAgICAgICAgICAgICAgbGFiZWwgPSB2YXJpYWJsZXNDb25mLmxhYmVsc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbG90LmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIHBsb3QubGFiZWxCeVZhcmlhYmxlW3ZhcmlhYmxlS2V5XSA9IGxhYmVsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhwbG90LmxhYmVsQnlWYXJpYWJsZSk7XG5cbiAgICB9O1xuXG5cbiAgICBzZXR1cENvcnJlbGF0aW9uTWF0cml4KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5wbG90LmNvcnJlbGF0aW9uLm1hdHJpeCA9IFtdO1xuICAgICAgICB2YXIgbWF0cml4Q2VsbHMgPSB0aGlzLnBsb3QuY29ycmVsYXRpb24ubWF0cml4LmNlbGxzID0gW107XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuXG4gICAgICAgIHZhciB2YXJpYWJsZVRvVmFsdWVzID0ge307XG4gICAgICAgIHBsb3QudmFyaWFibGVzLmZvckVhY2goKHYsIGkpID0+IHtcblxuICAgICAgICAgICAgdmFyaWFibGVUb1ZhbHVlc1t2XSA9IGRhdGEubWFwKGQ9PnBsb3QueC52YWx1ZShkLCB2KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3QudmFyaWFibGVzLmZvckVhY2goKHYxLCBpKSA9PiB7XG4gICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICBtYXRyaXgucHVzaChyb3cpO1xuXG4gICAgICAgICAgICBwbG90LnZhcmlhYmxlcy5mb3JFYWNoKCh2MiwgaikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyID0gMTtcbiAgICAgICAgICAgICAgICBpZiAodjEgIT0gdjIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29yciA9IHNlbGYuY29uZmlnLmNvcnJlbGF0aW9uLnZhbHVlKHZhcmlhYmxlVG9WYWx1ZXNbdjFdLCB2YXJpYWJsZVRvVmFsdWVzW3YyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICByb3dWYXI6IHYxLFxuICAgICAgICAgICAgICAgICAgICBjb2xWYXI6IHYyLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGksXG4gICAgICAgICAgICAgICAgICAgIGNvbDogaixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvcnJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGNlbGwpO1xuXG4gICAgICAgICAgICAgICAgbWF0cml4Q2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgdXBkYXRlKG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICAvLyB0aGlzLnVwZGF0ZVxuICAgICAgICB0aGlzLnVwZGF0ZUNlbGxzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFyaWFibGVMYWJlbHMoKTtcblxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5zaG93TGVnZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHVwZGF0ZVZhcmlhYmxlTGFiZWxzKCkge1xuICAgICAgICB0aGlzLnBsb3QubGFiZWxDbGFzcyA9IHRoaXMucHJlZml4Q2xhc3MoXCJsYWJlbFwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVBeGlzWCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNZKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXhpc1goKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBsYWJlbENsYXNzID0gcGxvdC5sYWJlbENsYXNzO1xuICAgICAgICB2YXIgbGFiZWxYQ2xhc3MgPSBsYWJlbENsYXNzICsgXCIteFwiO1xuXG4gICAgICAgIHZhciBsYWJlbHMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIGxhYmVsWENsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGxvdC52YXJpYWJsZXMsIChkLCBpKT0+aSk7XG5cbiAgICAgICAgdmFyIGxhYmVsc01lcmdlID0gbGFiZWxzLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGxhYmVsQ2xhc3MgKyBcIiBcIiArIGxhYmVsWENsYXNzICsgXCIgXCIgKyBsYWJlbFhDbGFzcyArIFwiLVwiICsgaSkubWVyZ2UobGFiZWxzKTtcblxuICAgICAgICBsYWJlbHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiBpICogcGxvdC5jZWxsU2l6ZSArIHBsb3QuY2VsbFNpemUgLyAyKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHBsb3QuaGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAtMilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgNSlcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcblxuICAgICAgICAgICAgLy8gLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImhhbmdpbmdcIilcbiAgICAgICAgICAgIC50ZXh0KHY9PnBsb3QubGFiZWxCeVZhcmlhYmxlW3ZdKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcucm90YXRlTGFiZWxzWCkge1xuICAgICAgICAgICAgbGFiZWxzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJyb3RhdGUoLTQ1LCBcIiArIChpICogcGxvdC5jZWxsU2l6ZSArIHBsb3QuY2VsbFNpemUgLyAyICApICsgXCIsIFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXhXaWR0aCA9IHNlbGYuY29tcHV0ZVhBeGlzTGFiZWxzV2lkdGgoKTtcbiAgICAgICAgbGFiZWxzTWVyZ2UuZWFjaChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIFV0aWxzLnBsYWNlVGV4dFdpdGhFbGxpcHNpc0FuZFRvb2x0aXAoZDMuc2VsZWN0KHRoaXMpLCBsYWJlbCwgbWF4V2lkdGgsIHNlbGYuY29uZmlnLnNob3dUb29sdGlwID8gc2VsZi5wbG90LnRvb2x0aXAgOiBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxhYmVscy5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBsYWJlbENsYXNzID0gcGxvdC5sYWJlbENsYXNzO1xuICAgICAgICB2YXIgbGFiZWxZQ2xhc3MgPSBwbG90LmxhYmVsQ2xhc3MgKyBcIi15XCI7XG4gICAgICAgIHZhciBsYWJlbHMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIGxhYmVsWUNsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGxvdC52YXJpYWJsZXMpO1xuXG4gICAgICAgIHZhciBsYWJlbHNNZXJnZSA9IGxhYmVscy5lbnRlcigpLmFwcGVuZChcInRleHRcIikubWVyZ2UobGFiZWxzKTtcblxuICAgICAgICBsYWJlbHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgKGQsIGkpID0+IGkgKiBwbG90LmNlbGxTaXplICsgcGxvdC5jZWxsU2l6ZSAvIDIpXG4gICAgICAgICAgICAuYXR0cihcImR4XCIsIC0yKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gbGFiZWxDbGFzcyArIFwiIFwiICsgbGFiZWxZQ2xhc3MgKyBcIiBcIiArIGxhYmVsWUNsYXNzICsgXCItXCIgKyBpKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImhhbmdpbmdcIilcbiAgICAgICAgICAgIC50ZXh0KHY9PnBsb3QubGFiZWxCeVZhcmlhYmxlW3ZdKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcucm90YXRlTGFiZWxzWSkge1xuICAgICAgICAgICAgbGFiZWxzTWVyZ2VcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJyb3RhdGUoLTQ1LCBcIiArIDAgKyBcIiwgXCIgKyAoaSAqIHBsb3QuY2VsbFNpemUgKyBwbG90LmNlbGxTaXplIC8gMikgKyBcIilcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFdpZHRoID0gc2VsZi5jb21wdXRlWUF4aXNMYWJlbHNXaWR0aCgpO1xuICAgICAgICBsYWJlbHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgVXRpbHMucGxhY2VUZXh0V2l0aEVsbGlwc2lzQW5kVG9vbHRpcChkMy5zZWxlY3QodGhpcyksIGxhYmVsLCBtYXhXaWR0aCwgc2VsZi5jb25maWcuc2hvd1Rvb2x0aXAgPyBzZWxmLnBsb3QudG9vbHRpcCA6IGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGFiZWxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBjb21wdXRlWUF4aXNMYWJlbHNXaWR0aCgpIHtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5wbG90Lm1hcmdpbi5sZWZ0O1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnJvdGF0ZUxhYmVsc1kpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heFdpZHRoICo9IFV0aWxzLlNRUlRfMjtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gMTE7IC8vdG9kbyBjaGVjayBhY3R1YWwgZm9udCBzaXplXG4gICAgICAgIG1heFdpZHRoIC09IGZvbnRTaXplIC8gMjtcblxuICAgICAgICByZXR1cm4gbWF4V2lkdGg7XG4gICAgfVxuXG4gICAgY29tcHV0ZVhBeGlzTGFiZWxzV2lkdGgob2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcucm90YXRlTGFiZWxzWCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdC5jZWxsU2l6ZSAtIDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnBsb3QubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgc2l6ZSAqPSBVdGlscy5TUVJUXzI7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IDExOyAvL3RvZG8gY2hlY2sgYWN0dWFsIGZvbnQgc2l6ZVxuICAgICAgICBzaXplIC09IGZvbnRTaXplIC8gMjtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgdXBkYXRlQ2VsbHMoKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGNlbGxDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJjZWxsXCIpO1xuICAgICAgICB2YXIgY2VsbFNoYXBlID0gcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS50eXBlO1xuXG4gICAgICAgIHZhciBjZWxscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJnLlwiICsgY2VsbENsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGxvdC5jb3JyZWxhdGlvbi5tYXRyaXguY2VsbHMpO1xuXG4gICAgICAgIHZhciBjZWxsc0VudGVyID0gY2VsbHMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChjZWxsQ2xhc3MsIHRydWUpO1xuICAgICAgICB2YXIgY2VsbHNNZXJnZSA9IGNlbGxzRW50ZXIubWVyZ2UoY2VsbHMpO1xuICAgICAgICBjZWxsc01lcmdlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYz0+IFwidHJhbnNsYXRlKFwiICsgKHBsb3QuY2VsbFNpemUgKiBjLmNvbCArIHBsb3QuY2VsbFNpemUgLyAyKSArIFwiLFwiICsgKHBsb3QuY2VsbFNpemUgKiBjLnJvdyArIHBsb3QuY2VsbFNpemUgLyAyKSArIFwiKVwiKTtcblxuICAgICAgICBjZWxsc01lcmdlLmNsYXNzZWQoc2VsZi5jb25maWcuY3NzQ2xhc3NQcmVmaXggKyBcInNlbGVjdGFibGVcIiwgISFzZWxmLnNjYXR0ZXJQbG90KTtcblxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBcIio6bm90KC5jZWxsLXNoYXBlLVwiICsgY2VsbFNoYXBlICsgXCIpXCI7XG5cbiAgICAgICAgdmFyIHdyb25nU2hhcGVzID0gY2VsbHMuc2VsZWN0QWxsKHNlbGVjdG9yKTtcbiAgICAgICAgd3JvbmdTaGFwZXMucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IGNlbGxzTWVyZ2Uuc2VsZWN0T3JBcHBlbmQoY2VsbFNoYXBlICsgXCIuY2VsbC1zaGFwZS1cIiArIGNlbGxTaGFwZSk7XG5cbiAgICAgICAgaWYgKHBsb3QuY29ycmVsYXRpb24uc2hhcGUudHlwZSA9PSAnY2lyY2xlJykge1xuXG4gICAgICAgICAgICBzaGFwZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5yYWRpdXMpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxvdC5jb3JyZWxhdGlvbi5zaGFwZS50eXBlID09ICdlbGxpcHNlJykge1xuICAgICAgICAgICAgLy8gY2VsbHMuYXR0cihcInRyYW5zZm9ybVwiLCBjPT4gXCJ0cmFuc2xhdGUoMzAwLDE1MCkgcm90YXRlKFwiK3Bsb3QuY29ycmVsYXRpb24uc2hhcGUucm90YXRlVmFsKGMudmFsdWUpK1wiKVwiKTtcbiAgICAgICAgICAgIHNoYXBlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5yYWRpdXNYKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwicnlcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5yYWRpdXNZKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgMClcbiAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIDApXG5cbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBjPT4gXCJyb3RhdGUoXCIgKyBwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnJvdGF0ZVZhbChjLnZhbHVlKSArIFwiKVwiKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHBsb3QuY29ycmVsYXRpb24uc2hhcGUudHlwZSA9PSAncmVjdCcpIHtcbiAgICAgICAgICAgIHNoYXBlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5zaXplKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBsb3QuY29ycmVsYXRpb24uc2hhcGUuc2l6ZSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgLXBsb3QuY2VsbFNpemUgLyAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtcGxvdC5jZWxsU2l6ZSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlcy5zdHlsZShcImZpbGxcIiwgYz0+IHBsb3QuY29ycmVsYXRpb24uY29sb3Iuc2NhbGUoYy52YWx1ZSkpO1xuXG4gICAgICAgIHZhciBtb3VzZW92ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIG1vdXNlb3V0Q2FsbGJhY2tzID0gW107XG5cbiAgICAgICAgaWYgKHBsb3QudG9vbHRpcCkge1xuXG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MucHVzaChjPT4ge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goYz0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5jb25maWcuaGlnaGxpZ2h0TGFiZWxzKSB7XG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0Q2xhc3MgPSBzZWxmLmNvbmZpZy5jc3NDbGFzc1ByZWZpeCArIFwiaGlnaGxpZ2h0XCI7XG4gICAgICAgICAgICB2YXIgeExhYmVsQ2xhc3MgPSBjPT5wbG90LmxhYmVsQ2xhc3MgKyBcIi14LVwiICsgYy5jb2w7XG4gICAgICAgICAgICB2YXIgeUxhYmVsQ2xhc3MgPSBjPT5wbG90LmxhYmVsQ2xhc3MgKyBcIi15LVwiICsgYy5yb3c7XG5cblxuICAgICAgICAgICAgbW91c2VvdmVyQ2FsbGJhY2tzLnB1c2goYz0+IHtcblxuICAgICAgICAgICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgeExhYmVsQ2xhc3MoYykpLmNsYXNzZWQoaGlnaGxpZ2h0Q2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgeUxhYmVsQ2xhc3MoYykpLmNsYXNzZWQoaGlnaGxpZ2h0Q2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb3VzZW91dENhbGxiYWNrcy5wdXNoKGM9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB4TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgeUxhYmVsQ2xhc3MoYykpLmNsYXNzZWQoaGlnaGxpZ2h0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBjZWxsc01lcmdlLm9uKFwibW91c2VvdmVyXCIsIGMgPT4ge1xuICAgICAgICAgICAgbW91c2VvdmVyQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2s9PmNhbGxiYWNrKGMpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGMgPT4ge1xuICAgICAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2s9PmNhbGxiYWNrKGMpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNlbGxzTWVyZ2Uub24oXCJjbGlja1wiLCBjPT4ge1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKFwiY2VsbC1zZWxlY3RlZFwiLCBjKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBjZWxscy5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuXG5cbiAgICB1cGRhdGVMZWdlbmQoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBsZWdlbmRYID0gdGhpcy5wbG90LndpZHRoICsgMTA7XG4gICAgICAgIHZhciBsZWdlbmRZID0gMDtcbiAgICAgICAgdmFyIGJhcldpZHRoID0gMTA7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSB0aGlzLnBsb3QuaGVpZ2h0IC0gMjtcbiAgICAgICAgdmFyIHNjYWxlID0gcGxvdC5jb3JyZWxhdGlvbi5jb2xvci5zY2FsZTtcblxuICAgICAgICBwbG90LmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5zdmcsIHRoaXMuc3ZnRywgc2NhbGUsIGxlZ2VuZFgsIGxlZ2VuZFkpLmxpbmVhckdyYWRpZW50QmFyKGJhcldpZHRoLCBiYXJIZWlnaHQpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBhdHRhY2hTY2F0dGVyUGxvdChjb250YWluZXJTZWxlY3RvciwgY29uZmlnKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cblxuICAgICAgICB2YXIgc2NhdHRlclBsb3RDb25maWcgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IHNlbGYucGxvdC5oZWlnaHQgKyBzZWxmLmNvbmZpZy5tYXJnaW4udG9wICsgc2VsZi5jb25maWcubWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgIHdpZHRoOiBzZWxmLnBsb3QuaGVpZ2h0ICsgc2VsZi5jb25maWcubWFyZ2luLnRvcCArIHNlbGYuY29uZmlnLm1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICBncm91cHM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IHNlbGYuY29uZmlnLmdyb3Vwcy5rZXksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHNlbGYuY29uZmlnLmdyb3Vwcy5sYWJlbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGd1aWRlczogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5zY2F0dGVyUGxvdCA9IHRydWU7XG5cbiAgICAgICAgc2NhdHRlclBsb3RDb25maWcgPSBVdGlscy5kZWVwRXh0ZW5kKHNjYXR0ZXJQbG90Q29uZmlnLCBjb25maWcpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMub24oXCJjZWxsLXNlbGVjdGVkXCIsIGM9PiB7XG5cblxuICAgICAgICAgICAgc2NhdHRlclBsb3RDb25maWcueCA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IGMucm93VmFyLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBzZWxmLnBsb3QubGFiZWxCeVZhcmlhYmxlW2Mucm93VmFyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjYXR0ZXJQbG90Q29uZmlnLnkgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBjLmNvbFZhcixcbiAgICAgICAgICAgICAgICBsYWJlbDogc2VsZi5wbG90LmxhYmVsQnlWYXJpYWJsZVtjLmNvbFZhcl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc2VsZi5zY2F0dGVyUGxvdCAmJiBzZWxmLnNjYXR0ZXJQbG90ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY2F0dGVyUGxvdC5zZXRDb25maWcoc2NhdHRlclBsb3RDb25maWcpLmluaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY2F0dGVyUGxvdCA9IG5ldyBTY2F0dGVyUGxvdChjb250YWluZXJTZWxlY3Rvciwgc2VsZi5kYXRhLCBzY2F0dGVyUGxvdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2goXCJTY2F0dGVyUGxvdFwiLCBzZWxmLnNjYXR0ZXJQbG90KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0pO1xuXG5cbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgRDNFeHRlbnNpb25zIHtcblxuICAgIHN0YXRpYyBleHRlbmQoKSB7XG5cbiAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5lbnRlci5wcm90b3R5cGUuaW5zZXJ0U2VsZWN0b3IgPVxuICAgICAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5pbnNlcnRTZWxlY3Rvcih0aGlzLCBzZWxlY3RvciwgYmVmb3JlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5lbnRlci5wcm90b3R5cGUuYXBwZW5kU2VsZWN0b3IgPVxuICAgICAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5hcHBlbmRTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuYXBwZW5kU2VsZWN0b3IodGhpcywgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLmVudGVyLnByb3RvdHlwZS5zZWxlY3RPckFwcGVuZCA9XG4gICAgICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdE9yQXBwZW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5zZWxlY3RPckFwcGVuZCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUuZW50ZXIucHJvdG90eXBlLnNlbGVjdE9ySW5zZXJ0ID1cbiAgICAgICAgICAgIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0T3JJbnNlcnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuc2VsZWN0T3JJbnNlcnQodGhpcywgc2VsZWN0b3IsIGJlZm9yZSk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICB9XG5cbiAgICBzdGF0aWMgaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBvcGVyYXRpb24sIGJlZm9yZSkge1xuXG4gICAgICAgIHZhciBzZWxlY3RvclBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoLyhbXFwuXFwjXSkvKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBwYXJlbnRbb3BlcmF0aW9uXShzZWxlY3RvclBhcnRzLnNoaWZ0KCksIGJlZm9yZSk7Ly9cIjpmaXJzdC1jaGlsZFwiXG5cbiAgICAgICAgd2hpbGUgKHNlbGVjdG9yUGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yTW9kaWZpZXIgPSBzZWxlY3RvclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JJdGVtID0gc2VsZWN0b3JQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yTW9kaWZpZXIgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuY2xhc3NlZChzZWxlY3Rvckl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvck1vZGlmaWVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmF0dHIoJ2lkJywgc2VsZWN0b3JJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5zZXJ0U2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBcImluc2VydFwiLCBiZWZvcmUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBcImFwcGVuZFwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0T3JBcHBlbmQocGFyZW50LCBzZWxlY3RvciwgZWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gcGFyZW50LnNlbGVjdChzZWxlY3Rvcik7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uZW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuYXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG5cbiAgICBzdGF0aWMgc2VsZWN0T3JJbnNlcnQocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBwYXJlbnQuc2VsZWN0KHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gRDNFeHRlbnNpb25zLmluc2VydFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IsIGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBkMyIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7TGVnZW5kfSBmcm9tIFwiLi9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBEaXZlcmdpbmdTdGFja2VkQmFyQ2hhcnRDb25maWcgZXh0ZW5kcyBDaGFydENvbmZpZ3tcblxuICAgIHN2Z0NsYXNzID0gdGhpcy5jc3NDbGFzc1ByZWZpeCArICdkaXZlcmdpbmctc3RhY2tlZC1iYXItY2hhcnQnO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTtcbiAgICBzaG93TGVnZW5kPXRydWU7XG4gICAgZm9yY2VMZWdlbmQ9ZmFsc2U7XG4gICAgbGVnZW5kPXtcbiAgICAgICAgd2lkdGg6IDgwLFxuICAgICAgICBtYXJnaW46IDEwLFxuICAgICAgICBzaGFwZVdpZHRoOiAyMFxuICAgIH07XG4gICAgeCA9IHsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbFxuICAgICAgICB2YWx1ZTogZCA9PiBkLnZhbHVlcywgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBndWlkZXM6IHRydWUsIC8vc2hvdyBheGlzIGd1aWRlc1xuICAgICAgICBvcmllbnQ6ICd0b3AnLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgZG9tYWluTWFyZ2luOiAwLjAyLFxuICAgIH07XG4gICAgeSA9IHsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgdmFsdWU6IGQgPT4gZC5rZXksIC8vIHkgdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgc2NhbGU6IFwib3JkaW5hbFwiLFxuICAgICAgICBvcmllbnQ6ICdsZWZ0JyxcbiAgICAgICAgZ3VpZGVzOiB0cnVlIC8vc2hvdyBheGlzIGd1aWRlc1xuICAgIH07XG5cbiAgICB0cmFuc2l0aW9uID0gdHJ1ZTtcbiAgICBjb2xvciA9ICB1bmRlZmluZWQ7Ly8gc3RyaW5nIG9yIGZ1bmN0aW9uIHJldHVybmluZyBjb2xvcidzIHZhbHVlIGZvciBjb2xvciBzY2FsZVxuICAgIGQzQ29sb3JDYXRlZ29yeT0gJ2NhdGVnb3J5MTAnO1xuICAgIHNob3dCYXJWYWx1ZXMgPSB0cnVlO1xuXG5cbiAgICBjb2xvclJhbmdlID0gdW5kZWZpbmVkO1xuXG4gICAgY2F0ZWdvcnlOYW1lcyA9IHVuZGVmaW5lZDtcbiAgICBtaWRkbGVWYWx1ZSA9IDA7XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZihjdXN0b20pe1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGl2ZXJnaW5nU3RhY2tlZEJhckNoYXJ0IGV4dGVuZHMgQ2hhcnR7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBEaXZlcmdpbmdTdGFja2VkQmFyQ2hhcnRDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZyl7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IERpdmVyZ2luZ1N0YWNrZWRCYXJDaGFydENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpe1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB0aGlzLnBsb3Quc2hvd0xlZ2VuZCA9IHRoaXMuY29uZmlnLnNob3dMZWdlbmQ7XG4gICAgICAgIGlmKHRoaXMucGxvdC5zaG93TGVnZW5kKXtcbiAgICAgICAgICAgIHRoaXMucGxvdC5tYXJnaW4ucmlnaHQgPSB0aGlzLmNvbmZpZy5tYXJnaW4ucmlnaHQgKyB0aGlzLmNvbmZpZy5sZWdlbmQud2lkdGgrdGhpcy5jb25maWcubGVnZW5kLm1hcmdpbioyO1xuXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuY29tcHV0ZVBsb3RTaXplKCk7XG4gICAgICAgIHRoaXMucGxvdC54ID0ge307XG4gICAgICAgIHRoaXMucGxvdC55ID0ge307XG5cbiAgICAgICAgdGhpcy5wbG90LmRhdGEgPSB0aGlzLmdldERhdGFUb1Bsb3QoKTtcblxuICAgICAgICB0aGlzLnNldHVwWSgpO1xuICAgICAgICB0aGlzLnNldHVwWCgpO1xuXG4gICAgICAgIHRoaXMuc2V0dXBDb2xvcigpO1xuXG4gICAgfVxuXG4gICAgZ2V0RGF0YVRvUGxvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBzZXR1cFgoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLng7XG5cbiAgICAgICAgeC52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZS5jYWxsKHRoaXMuY29uZmlnLCBkKTtcbiAgICAgICAgeC5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlUm91bmQoWzAsIHBsb3Qud2lkdGhdKTtcbiAgICAgICAgeC5tYXAgPSBkID0+IHguc2NhbGUoeC52YWx1ZShkKSk7XG5cbiAgICAgICAgeC5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeC5zY2FsZSk7XG4gICAgICAgIGlmKGNvbmYuZ3VpZGVzKXtcbiAgICAgICAgICAgIHguYXhpcy50aWNrU2l6ZSgtcGxvdC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZGF0YTtcblxuXG4gICAgICAgIHBsb3QuY2F0ZWdvcnlOYW1lcyA9IHRoaXMuY29uZmlnLmNhdGVnb3J5TmFtZXM7XG5cbiAgICAgICAgcGxvdC5uZXV0cmFsSW5kZXggPSBNYXRoLmZsb29yKHBsb3QuY2F0ZWdvcnlOYW1lcy5sZW5ndGgvMik7XG5cbiAgICAgICAgcGxvdC5yb3dzID0gZGF0YS5tYXAoZD0+IHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFZhbHVlcyA9IHgudmFsdWUoZCk7XG4gICAgICAgICAgICBsZXQgeDAgPSB0aGlzLmNvbmZpZy5taWRkbGVWYWx1ZSAtIGQzLnN1bShvcmlnaW5hbFZhbHVlcy5tYXAoKHYsaSkgPT4gIGkgPCBwbG90Lm5ldXRyYWxJbmRleCA/IHYgOiAwICkpO1xuICAgICAgICAgICAgaWYgKHBsb3QuY2F0ZWdvcnlOYW1lcy5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHgwICs9IC0xICogb3JpZ2luYWxWYWx1ZXNbcGxvdC5uZXV0cmFsSW5kZXhdLzI7XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBvcmlnaW5hbFZhbHVlcy5tYXAoKHYsIGkpID0+IGk8cGxvdC5uZXV0cmFsSW5kZXggPyB0aGlzLmNvbmZpZy5taWRkbGVWYWx1ZSAtIHYgOiB0aGlzLmNvbmZpZy5taWRkbGVWYWx1ZSArIHYpO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gZDMuc3VtKG9yaWdpbmFsVmFsdWVzKTtcbiAgICAgICAgICAgIGxldCBjYXRlZ29yaWVzID0gcGxvdC5jYXRlZ29yeU5hbWVzO1xuICAgICAgICAgICAgaWYoZC5jYXRlZ29yaWVzKXtcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzID0gZC5jYXRlZ29yaWVzLm1hcCgoY2F0SW5kZXgsIGkpPT5wbG90LmNhdGVnb3J5TmFtZXNbY2F0SW5kZXhdKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsVmFsdWVzOiBvcmlnaW5hbFZhbHVlcyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICBtaW46IHgwLFxuICAgICAgICAgICAgICAgIG1heDogeDArdG90YWwsXG4gICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsLFxuICAgICAgICAgICAgICAgIGJveGVzOiB2YWx1ZXMubWFwKCh2LCBpKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY2F0ZWdvcmllc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwOiB4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiB4MCs9b3JpZ2luYWxWYWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBvcmlnaW5hbFZhbHVlc1tpXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGRvbWFpbjtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9tYWluID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSBkMy5leHRlbnQoW10uY29uY2F0KC4uLnBsb3Qucm93cy5tYXAoYj0+W2IubWluLCBiLm1heF0pKSk7XG4gICAgICAgICAgICBsZXQgbWFyZ2luID0gKChkb21haW5bMV0tZG9tYWluWzBdKSogY29uZi5kb21haW5NYXJnaW4pIHx8IGNvbmYuZG9tYWluTWFyZ2luKmRvbWFpblswXTtcblxuICAgICAgICAgICAgZG9tYWluWzBdLT1tYXJnaW47XG4gICAgICAgICAgICBkb21haW5bMV0rPW1hcmdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QueC5zY2FsZS5kb21haW4oZG9tYWluKTtcblxuICAgIH07XG5cblxuICAgIHNldHVwWSgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHkgPSBwbG90Lnk7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgeS52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZS5jYWxsKHRoaXMuY29uZmlnLCBkKTtcbiAgICAgICAgeS5zY2FsZSA9IGQzLnNjYWxlQmFuZCgpLnJhbmdlKFswLCBwbG90LmhlaWdodF0pLnBhZGRpbmcoLjMpO1xuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcbiAgICAgICAgaWYgKGNvbmYudGlja3MpIHtcbiAgICAgICAgICAgIHkuYXhpcy50aWNrcyhjb25mLnRpY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBpZihjb25mLmd1aWRlcyl7XG4gICAgICAgICAgICB5LmF4aXMudGlja1NpemUoLXBsb3Qud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0dXBZRG9tYWluKCk7XG4gICAgfTtcblxuICAgIHNldHVwWURvbWFpbigpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdmFyIGRvbWFpbiA9IGRhdGEubWFwKHBsb3QueS52YWx1ZSkgO1xuXG4gICAgICAgIHBsb3QueS5zY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICB9XG5cbiAgICBkcmF3QXhpc1goKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLng7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteCcpICsgXCIuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzJykgKyAoYXhpc0NvbmYuZ3VpZGVzID8gJycgOiAnLicgKyBzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpXG5cbiAgICAgICAgaWYoYXhpc0NvbmYub3JpZW50ID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgYXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnguYXhpcyk7XG5cbiAgICAgICAgdmFyIHRpdGxlWSA9IGF4aXNDb25mLm9yaWVudCA9PT0gJ2JvdHRvbScgPyBwbG90Lm1hcmdpbi5ib3R0b20gOiAwO1xuICAgICAgICB2YXIgdGl0bGVEWSA9IGF4aXNDb25mLm9yaWVudCA9PT0gJ2JvdHRvbScgPyBcIi0xZW1cIiA6IFwiLTEuNWVtXCI7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAocGxvdC53aWR0aC8yKSArXCIsXCIrICh0aXRsZVkpICtcIilcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgdGl0bGVEWSlcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIGRyYXdBeGlzWSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy15JykgKyBcIi5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSArIChheGlzQ29uZi5ndWlkZXMgPyAnJyA6ICcuJyArIHNlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSk7XG5cblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueS5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1wbG90Lm1hcmdpbi5sZWZ0ICsgXCIsXCIgKyAocGxvdC5oZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICBkcmF3QmFycygpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcGxvdCA9IHNlbGYucGxvdCxcbiAgICAgICAgICAgIGNvbmZpZyA9IHNlbGYuY29uZmlnO1xuXG4gICAgICAgIGxldCByb3dDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJyb3dcIik7XG4gICAgICAgIGxldCByb3dzID0gc2VsZi5zdmdHLnNlbGVjdEFsbChcIi5cIisgcm93Q2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnJvd3MpO1xuXG4gICAgICAgIGxldCByb3dFbnRlciA9IHJvd3MuZW50ZXIoKS5hcHBlbmRTZWxlY3RvcihcImcuXCIrcm93Q2xhc3MpO1xuXG4gICAgICAgIGxldCByb3dNZXJnZSA9IHJvd0VudGVyLm1lcmdlKHJvd3MpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LnkubWFwKGQuZGF0dW0pICsgXCIpXCIpO1xuXG4gICAgICAgIHJvd3MuZXhpdCgpLnJlbW92ZSgpO1xuXG5cbiAgICAgICAgbGV0IGJhckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImJhclwiKTtcblxuICAgICAgICBsZXQgYmFycyA9IHJvd01lcmdlLnNlbGVjdEFsbChcImcuXCIrIGJhckNsYXNzKVxuICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ib3hlczsgfSk7XG4gICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBiYXJzRW50ZXIgPSBiYXJzLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGJhckNsYXNzKTtcblxuICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKFwicmVjdFwiKTtcbiAgICAgICAgaWYoY29uZmlnLnNob3dCYXJWYWx1ZXMpe1xuICAgICAgICAgICAgYmFyc0VudGVyLmFwcGVuZChcInRleHRcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxldCBiYXJzTSA9ICBiYXJzRW50ZXIubWVyZ2UoYmFycyk7XG5cbiAgICAgICAgYmFyc00uc2VsZWN0KFwicmVjdFwiKS5hdHRyKFwiaGVpZ2h0XCIsIHBsb3QueS5zY2FsZS5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBkID0+cGxvdC54LnNjYWxlKGQueDApKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBkID0+IHBsb3QueC5zY2FsZShkLngxKSAtIHBsb3QueC5zY2FsZShkLngwKSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgKGQsIGkpID0+IHBsb3QuY29sb3IoZC5uYW1lLCBpKSk7XG5cblxuICAgICAgICBsZXQgdGV4dE0gPSBiYXJzTS5zZWxlY3QoXCJ0ZXh0XCIpO1xuICAgICAgICBpZihjb25maWcuc2hvd0JhclZhbHVlcyl7XG4gICAgICAgICAgICB0ZXh0TS5hdHRyKFwieFwiLCBkID0+IHBsb3QueC5zY2FsZShkLngwKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgcGxvdC55LnNjYWxlLmJhbmR3aWR0aCgpLzIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjAuNWVtXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBkPT4ocGxvdC54LnNjYWxlKGQueDEpLXBsb3QueC5zY2FsZShkLngwKSkvMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gZC5vcmlnaW5hbFZhbHVlICE9PSAwICYmIChkLngxLWQueDApPjAuMDQgPyBkLm9yaWdpbmFsVmFsdWUgOiBcIlwiKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0ZXh0TS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJsaW5lLlwiK3NlbGYucHJlZml4Q2xhc3MoXCJtaWRkbGUtbGluZVwiKSlcbiAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgcGxvdC54LnNjYWxlKHNlbGYuY29uZmlnLm1pZGRsZVZhbHVlKSlcbiAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgcGxvdC54LnNjYWxlKHNlbGYuY29uZmlnLm1pZGRsZVZhbHVlKSlcbiAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgcGxvdC5oZWlnaHQpO1xuXG4gICAgfVxuXG4gICAgdXBkYXRlKG5ld0RhdGEpe1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG4gICAgICAgIHRoaXMuZHJhd0F4aXNYKCk7XG4gICAgICAgIHRoaXMuZHJhd0F4aXNZKCk7XG4gICAgICAgIHRoaXMuZHJhd0JhcnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG4gICAgc2V0dXBDb2xvcigpIHtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBpZihjb25mLmQzQ29sb3JDYXRlZ29yeSl7XG4gICAgICAgICAgICB2YXIgY29sb3JTY2hlbWVDYXRlZ29yeSA9ICdzY2hlbWUnK1V0aWxzLmNhcGl0YWxpemVGaXJzdExldHRlcihjb25mLmQzQ29sb3JDYXRlZ29yeSk7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSA9IGQzLnNjYWxlT3JkaW5hbChkM1tjb2xvclNjaGVtZUNhdGVnb3J5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sb3JWYWx1ZSA9IGNvbmYuY29sb3I7XG4gICAgICAgIGlmIChjb2xvclZhbHVlICYmIHR5cGVvZiBjb2xvclZhbHVlID09PSAnc3RyaW5nJyB8fCBjb2xvclZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKXtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IGNvbG9yVmFsdWU7XG4gICAgICAgIH1lbHNlIGlmIChjb25mLmNvbG9yUmFuZ2Upe1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gVXRpbHMuY3JlYXRlU2NhbGUoXCJvcmRpbmFsXCIpLmRvbWFpbih0aGlzLnBsb3QuY2F0ZWdvcnlOYW1lcykucmFuZ2UoY29uZi5jb2xvclJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMucGxvdC5jb2xvckNhdGVnb3J5KXtcbiAgICAgICAgICAgIHNlbGYucGxvdC5jb2xvclZhbHVlPWNvbG9yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY29sb3IgPSB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlTGVnZW5kKCkge1xuXG4gICAgICAgIHZhciBzZWxmID10aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcblxuICAgICAgICB2YXIgc2NhbGUgPSBwbG90LmNvbG9yO1xuXG4gICAgICAgIGlmKCFzY2FsZS5kb21haW4oKSB8fCAhdGhpcy5jb25maWcuZm9yY2VMZWdlbmQgJiYgc2NhbGUuZG9tYWluKCkubGVuZ3RoPDIpe1xuICAgICAgICAgICAgcGxvdC5zaG93TGVnZW5kID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZighcGxvdC5zaG93TGVnZW5kKXtcbiAgICAgICAgICAgIGlmKHBsb3QubGVnZW5kICYmIHBsb3QubGVnZW5kLmNvbnRhaW5lcil7XG4gICAgICAgICAgICAgICAgcGxvdC5sZWdlbmQuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgbGVnZW5kWCA9IHRoaXMucGxvdC53aWR0aCArIHRoaXMuY29uZmlnLmxlZ2VuZC5tYXJnaW47XG4gICAgICAgIHZhciBsZWdlbmRZID0gdGhpcy5jb25maWcubGVnZW5kLm1hcmdpbjtcblxuICAgICAgICBwbG90LmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5zdmcsIHRoaXMuc3ZnRywgc2NhbGUsIGxlZ2VuZFgsIGxlZ2VuZFkpO1xuXG4gICAgICAgIHBsb3QubGVnZW5kQ29sb3IgPSBwbG90LmxlZ2VuZC5jb2xvcigpXG4gICAgICAgICAgICAuc2hhcGVXaWR0aCh0aGlzLmNvbmZpZy5sZWdlbmQuc2hhcGVXaWR0aClcbiAgICAgICAgICAgIC5vcmllbnQoJ3ZlcnRpY2FsJylcbiAgICAgICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgICAgIC5sYWJlbFdyYXAodGhpcy5jb25maWcubGVnZW5kLndpZHRoKVxuICAgICAgICAgICAgLy8gLmxhYmVscyhzY2FsZS5kb21haW4oKS5tYXAodj0+cGxvdC5ncm91cFRvTGFiZWxbdl0pKTtcblxuICAgICAgICBwbG90LmxlZ2VuZC5jb250YWluZXJcbiAgICAgICAgICAgIC5jYWxsKHBsb3QubGVnZW5kQ29sb3IpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtIZWF0bWFwLCBIZWF0bWFwQ29uZmlnfSBmcm9tIFwiLi9oZWF0bWFwXCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHtTdGF0aXN0aWNzVXRpbHN9IGZyb20gJy4vc3RhdGlzdGljcy11dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBIZWF0bWFwVGltZVNlcmllc0NvbmZpZyBleHRlbmRzIEhlYXRtYXBDb25maWcge1xuICAgIHggPSB7XG4gICAgICAgIGZpbGxNaXNzaW5nOiBmYWxzZSwgLy8gZmlsbCBtaXNzaW5nIHZhbHVlcyB1c2luZyBpbnRlcnZhbCBhbmQgaW50ZXJ2YWxTdGVwXG4gICAgICAgIGludGVydmFsOiB1bmRlZmluZWQsIC8vdXNlZCBpbiBmaWxsaW5nIG1pc3NpbmcgdGlja3NcbiAgICAgICAgaW50ZXJ2YWxTdGVwOiAxLFxuICAgICAgICBmb3JtYXQ6IHVuZGVmaW5lZCwgLy9pbnB1dCBkYXRhIGQzIHRpbWUgZm9ybWF0XG4gICAgICAgIGRpc3BsYXlGb3JtYXQ6IHVuZGVmaW5lZCwvL2QzIHRpbWUgZm9ybWF0IGZvciBkaXNwbGF5XG4gICAgICAgIGludGVydmFsVG9Gb3JtYXRzOiBbIC8vdXNlZCB0byBndWVzcyBpbnRlcnZhbCBhbmQgZm9ybWF0XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3llYXInLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcIiVZXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdtb250aCcsXG4gICAgICAgICAgICAgICAgZm9ybWF0czogW1wiJVktJW1cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2RheScsXG4gICAgICAgICAgICAgICAgZm9ybWF0czogW1wiJVktJW0tJWRcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2hvdXInLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFsnJUgnLCAnJVktJW0tJWQgJUgnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbWludXRlJyxcbiAgICAgICAgICAgICAgICBmb3JtYXRzOiBbJyVIOiVNJywgJyVZLSVtLSVkICVIOiVNJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NlY29uZCcsXG4gICAgICAgICAgICAgICAgZm9ybWF0czogWyclSDolTTolUycsICclWS0lbS0lZCAlSDolTTolUyddXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG5cbiAgICAgICAgc29ydENvbXBhcmF0b3I6IGZ1bmN0aW9uIHNvcnRDb21wYXJhdG9yKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5pc1N0cmluZyhhKSA/ICBhLmxvY2FsZUNvbXBhcmUoYikgOiAgYSAtIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB6ID0ge1xuICAgICAgICBmaWxsTWlzc2luZzogdHJ1ZSAvLyBmaWlsbCBtaXNzaW5nIHZhbHVlcyB3aXRoIG5lYXJlc3QgcHJldmlvdXMgdmFsdWVcbiAgICB9O1xuXG4gICAgbGVnZW5kID0ge1xuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh2IC8gMTAwMDAwMCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gXCIgTVwiO1xuICAgICAgICAgICAgICAgIHYgPSBOdW1iZXIodiAvIDEwMDAwMDApLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmYgPSBJbnRsLk51bWJlckZvcm1hdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5mLmZvcm1hdCh2KSArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBpZiAoY3VzdG9tKSB7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIZWF0bWFwVGltZVNlcmllcyBleHRlbmRzIEhlYXRtYXAge1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgSGVhdG1hcFRpbWVTZXJpZXNDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBIZWF0bWFwVGltZVNlcmllc0NvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cblxuICAgIHNldHVwVmFsdWVzQmVmb3JlR3JvdXBzU29ydCgpIHtcblxuICAgICAgICB0aGlzLnBsb3QueC50aW1lRm9ybWF0ID0gdGhpcy5jb25maWcueC5mb3JtYXQ7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnguZGlzcGxheUZvcm1hdCAmJiAhdGhpcy5wbG90LngudGltZUZvcm1hdCl7XG4gICAgICAgICAgICB0aGlzLmd1ZXNzVGltZUZvcm1hdCgpO1xuICAgICAgICB9XG5cblxuICAgICAgICBzdXBlci5zZXR1cFZhbHVlc0JlZm9yZUdyb3Vwc1NvcnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy54LmZpbGxNaXNzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5pbml0VGltZUZvcm1hdEFuZEludGVydmFsKCk7XG5cbiAgICAgICAgdGhpcy5wbG90LnguaW50ZXJ2YWxTdGVwID0gdGhpcy5jb25maWcueC5pbnRlcnZhbFN0ZXAgfHwgMTtcblxuICAgICAgICB0aGlzLnBsb3QueC50aW1lUGFyc2VyID0gdGhpcy5nZXRUaW1lUGFyc2VyKCk7XG5cblxuXG4gICAgICAgIHRoaXMucGxvdC54LnVuaXF1ZVZhbHVlcy5zb3J0KHRoaXMuY29uZmlnLnguc29ydENvbXBhcmF0b3IpO1xuXG4gICAgICAgIHZhciBwcmV2ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBsb3QueC51bmlxdWVWYWx1ZXMuZm9yRWFjaCgoeCwgaSk9PiB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMucGFyc2VUaW1lKHgpO1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gc2VsZi5uZXh0VGltZVRpY2tWYWx1ZShwcmV2KTtcbiAgICAgICAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICAgICAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxmLmNvbXBhcmVUaW1lVmFsdWVzKG5leHQsIGN1cnJlbnQpPD0wKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbiA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGQgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZVN0cmluZyA9IHNlbGYuZm9ybWF0VGltZShuZXh0KTtcbiAgICAgICAgICAgICAgICBkW3RoaXMuY29uZmlnLngua2V5XSA9IHRpbWVTdHJpbmc7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUdyb3VwcyhkLCB0aW1lU3RyaW5nLCBzZWxmLnBsb3QueC5ncm91cHMsIHNlbGYuY29uZmlnLnguZ3JvdXBzKTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHNlbGYubmV4dFRpbWVUaWNrVmFsdWUobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBwYXJzZVRpbWUoeCkge1xuICAgICAgICB2YXIgcGFyc2VyID0gdGhpcy5nZXRUaW1lUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBwYXJzZXIoeCk7XG4gICAgfVxuXG4gICAgZm9ybWF0VGltZShkYXRlKXtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZ2V0VGltZUZvcm1hdHRlcigpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKGRhdGUpO1xuICAgIH1cblxuICAgIGZvcm1hdFZhbHVlWCh2YWx1ZSkgeyAvL3VzZWQgb25seSBmb3IgZGlzcGxheVxuICAgICAgICBpZiAodGhpcy5jb25maWcueC5mb3JtYXR0ZXIpIHJldHVybiB0aGlzLmNvbmZpZy54LmZvcm1hdHRlci5jYWxsKHRoaXMuY29uZmlnLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYodGhpcy5jb25maWcueC5kaXNwbGF5Rm9ybWF0KXtcbiAgICAgICAgICAgIHZhciBkYXRlID0gdGhpcy5wYXJzZVRpbWUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGQzLnRpbWVGb3JtYXQodGhpcy5jb25maWcueC5kaXNwbGF5Rm9ybWF0KShkYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLnBsb3QueC50aW1lRm9ybWF0KSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgaWYoVXRpbHMuaXNEYXRlKHZhbHVlKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRUaW1lKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb21wYXJlVGltZVZhbHVlcyhhLCBiKXtcbiAgICAgICAgcmV0dXJuIGEtYjtcbiAgICB9XG5cbiAgICB0aW1lVmFsdWVzRXF1YWwoYSwgYikge1xuICAgICAgICB2YXIgcGFyc2VyID0gdGhpcy5wbG90LngudGltZVBhcnNlcjtcbiAgICAgICAgcmV0dXJuIHBhcnNlcihhKSA9PT0gcGFyc2VyKGIpO1xuICAgIH1cblxuICAgIG5leHRUaW1lVGlja1ZhbHVlKHQpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gJ3RpbWUnK1V0aWxzLmNhcGl0YWxpemVGaXJzdExldHRlcih0aGlzLnBsb3QueC5pbnRlcnZhbCk7XG5cbiAgICAgICAgcmV0dXJuIGQzW2ludGVydmFsXS5vZmZzZXQodCwgdGhpcy5wbG90LnguaW50ZXJ2YWxTdGVwKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpIHtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuei5maWxsTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hdHJpeC5mb3JFYWNoKChyb3csIHJvd0luZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZSb3dWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByb3cuZm9yRWFjaCgoY2VsbCwgY29sSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcmV2Um93VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC52YWx1ZSA9IHByZXZSb3dWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwubWlzc2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldlJvd1ZhbHVlID0gY2VsbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIHVwZGF0ZShuZXdEYXRhKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcblxuICAgIH07XG5cblxuICAgIGluaXRUaW1lRm9ybWF0QW5kSW50ZXJ2YWwoKSB7XG5cbiAgICAgICAgdGhpcy5wbG90LnguaW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy54LmludGVydmFsO1xuXG4gICAgICAgIGlmKCF0aGlzLnBsb3QueC50aW1lRm9ybWF0KXtcbiAgICAgICAgICAgIHRoaXMuZ3Vlc3NUaW1lRm9ybWF0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5wbG90LnguaW50ZXJ2YWwgJiYgdGhpcy5wbG90LngudGltZUZvcm1hdCl7XG4gICAgICAgICAgICB0aGlzLmd1ZXNzSW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGd1ZXNzVGltZUZvcm1hdCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmb3IobGV0IGk9MDsgaSA8IHNlbGYuY29uZmlnLnguaW50ZXJ2YWxUb0Zvcm1hdHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IGludGVydmFsRm9ybWF0ID0gc2VsZi5jb25maWcueC5pbnRlcnZhbFRvRm9ybWF0c1tpXTtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGZvcm1hdE1hdGNoID0gaW50ZXJ2YWxGb3JtYXQuZm9ybWF0cy5zb21lKGY9PntcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXIgPSBkMy50aW1lUGFyc2UoZik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGxvdC54LnVuaXF1ZVZhbHVlcy5ldmVyeSh4PT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXIoeCkgIT09IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYoZm9ybWF0TWF0Y2gpe1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC54LnRpbWVGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0d1ZXNzZWQgdGltZUZvcm1hdCcsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgaWYoIXNlbGYucGxvdC54LmludGVydmFsKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbG90LnguaW50ZXJ2YWwgPSBpbnRlcnZhbEZvcm1hdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnR3Vlc3NlZCBpbnRlcnZhbCcsIHNlbGYucGxvdC54LmludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ3Vlc3NJbnRlcnZhbCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmb3IobGV0IGk9MDsgaSA8IHNlbGYuY29uZmlnLnguaW50ZXJ2YWxUb0Zvcm1hdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbnRlcnZhbEZvcm1hdCA9IHNlbGYuY29uZmlnLnguaW50ZXJ2YWxUb0Zvcm1hdHNbaV07XG5cbiAgICAgICAgICAgIGlmKGludGVydmFsRm9ybWF0LmZvcm1hdHMuaW5kZXhPZihzZWxmLnBsb3QueC50aW1lRm9ybWF0KSA+PSAwKXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QueC5pbnRlcnZhbCA9IGludGVydmFsRm9ybWF0Lm5hbWU7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0d1ZXNzZWQgaW50ZXJ2YWwnLCBzZWxmLnBsb3QueC5pbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdldFRpbWVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIGlmKCF0aGlzLnBsb3QueC50aW1lRm9ybWF0dGVyKXtcbiAgICAgICAgICAgIHRoaXMucGxvdC54LnRpbWVGb3JtYXR0ZXIgPSBkMy50aW1lRm9ybWF0KHRoaXMucGxvdC54LnRpbWVGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3QueC50aW1lRm9ybWF0dGVyO1xuICAgIH1cbiAgICBnZXRUaW1lUGFyc2VyKCkge1xuICAgICAgICBpZighdGhpcy5wbG90LngudGltZVBhcnNlcil7XG4gICAgICAgICAgICB0aGlzLnBsb3QueC50aW1lUGFyc2VyID0gZDMudGltZVBhcnNlKHRoaXMucGxvdC54LnRpbWVGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3QueC50aW1lUGFyc2VyO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHtDaGFydCwgQ2hhcnRDb25maWd9IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHtMZWdlbmR9IGZyb20gJy4vbGVnZW5kJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIEhlYXRtYXBDb25maWcgZXh0ZW5kcyBDaGFydENvbmZpZyB7XG5cbiAgICBzdmdDbGFzcyA9ICdvZGMtaGVhdG1hcCc7XG4gICAgc2hvd1Rvb2x0aXAgPSB0cnVlOyAvL3Nob3cgdG9vbHRpcCBvbiBkb3QgaG92ZXJcbiAgICB0b29sdGlwID0ge1xuICAgICAgICBub0RhdGFUZXh0OiBcIk4vQVwiXG4gICAgfTtcbiAgICBzaG93TGVnZW5kID0gdHJ1ZTtcbiAgICBsZWdlbmQgPSB7XG4gICAgICAgIHdpZHRoOiAzMCxcbiAgICAgICAgcm90YXRlTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgZGVjaW1hbFBsYWNlczogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtYXR0ZXI6IHYgPT4gdGhpcy5sZWdlbmQuZGVjaW1hbFBsYWNlcyA9PT0gdW5kZWZpbmVkID8gdiA6IE51bWJlcih2KS50b0ZpeGVkKHRoaXMubGVnZW5kLmRlY2ltYWxQbGFjZXMpXG4gICAgfVxuICAgIGhpZ2hsaWdodExhYmVscyA9IHRydWU7XG4gICAgeCA9IHsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyB0aXRsZVxuICAgICAgICBrZXk6IDAsXG4gICAgICAgIHZhbHVlOiAoZCkgPT4gZFt0aGlzLngua2V5XSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICByb3RhdGVMYWJlbHM6IHRydWUsXG4gICAgICAgIHNvcnRMYWJlbHM6IGZhbHNlLFxuICAgICAgICBzb3J0Q29tcGFyYXRvcjogKGEsIGIpPT4gVXRpbHMuaXNOdW1iZXIoYSkgPyBhIC0gYiA6IGEubG9jYWxlQ29tcGFyZShiKSxcbiAgICAgICAgZ3JvdXBzOiB7XG4gICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgIGxhYmVsczogW10sXG4gICAgICAgICAgICB2YWx1ZTogKGQsIGtleSkgPT4gZFtrZXldLFxuICAgICAgICAgICAgb3ZlcmxhcDoge1xuICAgICAgICAgICAgICAgIHRvcDogMjAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAyMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCAvLyB2YWx1ZSBmb3JtYXR0ZXIgZnVuY3Rpb25cblxuICAgIH07XG4gICAgeSA9IHsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyB0aXRsZSxcbiAgICAgICAgcm90YXRlTGFiZWxzOiB0cnVlLFxuICAgICAgICBrZXk6IDEsXG4gICAgICAgIHZhbHVlOiAoZCkgPT4gZFt0aGlzLnkua2V5XSwgLy8geSB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzb3J0TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgc29ydENvbXBhcmF0b3I6IChhLCBiKT0+IFV0aWxzLmlzTnVtYmVyKGIpID8gYiAtIGEgOiBiLmxvY2FsZUNvbXBhcmUoYSksXG4gICAgICAgIGdyb3Vwczoge1xuICAgICAgICAgICAga2V5czogW10sXG4gICAgICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IGRba2V5XSxcbiAgICAgICAgICAgIG92ZXJsYXA6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAyMCxcbiAgICAgICAgICAgICAgICByaWdodDogMjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQvLyB2YWx1ZSBmb3JtYXR0ZXIgZnVuY3Rpb25cbiAgICB9O1xuICAgIHogPSB7XG4gICAgICAgIGtleTogMixcbiAgICAgICAgdmFsdWU6IChkKSA9PiBkW3RoaXMuei5rZXldLFxuICAgICAgICBub3RBdmFpbGFibGVWYWx1ZTogKHYpID0+IHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkLFxuXG4gICAgICAgIGRlY2ltYWxQbGFjZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybWF0dGVyOiB2ID0+IHRoaXMuei5kZWNpbWFsUGxhY2VzID09PSB1bmRlZmluZWQgPyB2IDogTnVtYmVyKHYpLnRvRml4ZWQodGhpcy56LmRlY2ltYWxQbGFjZXMpLy8gdmFsdWUgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cbiAgICB9O1xuICAgIGNvbG9yID0ge1xuICAgICAgICBub0RhdGFDb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgcmV2ZXJzZVNjYWxlOiBmYWxzZSxcbiAgICAgICAgcmFuZ2U6IFtcImRhcmtibHVlXCIsIFwibGlnaHRza3libHVlXCIsIFwib3JhbmdlXCIsIFwiY3JpbXNvblwiLCBcImRhcmtyZWRcIl1cbiAgICB9O1xuICAgIGNlbGwgPSB7XG4gICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICBzaXplTWluOiAxNSxcbiAgICAgICAgc2l6ZU1heDogMjUwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgICBtYXJnaW4gPSB7XG4gICAgICAgIGxlZnQ6IDYwLFxuICAgICAgICByaWdodDogNTAsXG4gICAgICAgIHRvcDogMzAsXG4gICAgICAgIGJvdHRvbTogODBcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChjdXN0b20pIHtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy9UT0RPIHJlZmFjdG9yXG5leHBvcnQgY2xhc3MgSGVhdG1hcCBleHRlbmRzIENoYXJ0IHtcblxuICAgIHN0YXRpYyBtYXhHcm91cEdhcFNpemUgPSAyNDtcbiAgICBzdGF0aWMgZ3JvdXBUaXRsZVJlY3RIZWlnaHQgPSA2O1xuXG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBIZWF0bWFwQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgSGVhdG1hcENvbmZpZyhjb25maWcpKTtcblxuICAgIH1cblxuICAgIGluaXRQbG90KCkge1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNvbmZpZy5tYXJnaW47XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdGhpcy5wbG90LnggPSB7fTtcbiAgICAgICAgdGhpcy5wbG90LnkgPSB7fTtcbiAgICAgICAgdGhpcy5wbG90LnogPSB7XG4gICAgICAgICAgICBtYXRyaXhlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VsbHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbG9yOiB7fSxcbiAgICAgICAgICAgIHNoYXBlOiB7fVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdGhpcy5zZXR1cFZhbHVlcygpO1xuICAgICAgICB0aGlzLmJ1aWxkQ2VsbHMoKTtcblxuICAgICAgICB2YXIgdGl0bGVSZWN0V2lkdGggPSA2O1xuICAgICAgICB0aGlzLnBsb3QueC5vdmVybGFwID0ge1xuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVgpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHNlbGYuY29uZmlnLnguZ3JvdXBzLmtleXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFsbFRpdGxlc1dpZHRoID0gZGVwdGggKiAodGl0bGVSZWN0V2lkdGgpO1xuXG4gICAgICAgICAgICB0aGlzLnBsb3QueC5vdmVybGFwLmJvdHRvbSA9IHNlbGYuY29uZmlnLnguZ3JvdXBzLm92ZXJsYXAuYm90dG9tO1xuICAgICAgICAgICAgdGhpcy5wbG90Lngub3ZlcmxhcC50b3AgPSBzZWxmLmNvbmZpZy54Lmdyb3Vwcy5vdmVybGFwLnRvcCArIGFsbFRpdGxlc1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi50b3AgPSB0aGlzLnBsb3QubWFyZ2luLnRvcCArIGNvbmYueC5ncm91cHMub3ZlcmxhcC50b3A7XG4gICAgICAgICAgICB0aGlzLnBsb3QubWFyZ2luLmJvdHRvbSA9IHRoaXMucGxvdC5tYXJnaW4uYm90dG9tICsgY29uZi54Lmdyb3Vwcy5vdmVybGFwLmJvdHRvbTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5wbG90Lnkub3ZlcmxhcCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICByaWdodDogMFxuICAgICAgICB9O1xuXG5cbiAgICAgICAgaWYgKHRoaXMucGxvdC5ncm91cEJ5WSkge1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gc2VsZi5jb25maWcueS5ncm91cHMua2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYWxsVGl0bGVzV2lkdGggPSBkZXB0aCAqICh0aXRsZVJlY3RXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLnBsb3QueS5vdmVybGFwLnJpZ2h0ID0gc2VsZi5jb25maWcueS5ncm91cHMub3ZlcmxhcC5sZWZ0ICsgYWxsVGl0bGVzV2lkdGg7XG4gICAgICAgICAgICB0aGlzLnBsb3QueS5vdmVybGFwLmxlZnQgPSBzZWxmLmNvbmZpZy55Lmdyb3Vwcy5vdmVybGFwLmxlZnQ7XG4gICAgICAgICAgICB0aGlzLnBsb3QubWFyZ2luLmxlZnQgPSB0aGlzLnBsb3QubWFyZ2luLmxlZnQgKyB0aGlzLnBsb3QueS5vdmVybGFwLmxlZnQ7XG4gICAgICAgICAgICB0aGlzLnBsb3QubWFyZ2luLnJpZ2h0ID0gdGhpcy5wbG90Lm1hcmdpbi5yaWdodCArIHRoaXMucGxvdC55Lm92ZXJsYXAucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbG90LnNob3dMZWdlbmQgPSBjb25mLnNob3dMZWdlbmQ7XG4gICAgICAgIGlmICh0aGlzLnBsb3Quc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5yaWdodCArPSBjb25mLmxlZ2VuZC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnNldHVwWlNjYWxlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuY29uZmlnO1xuICAgICAgICB2YXIgeCA9IHNlbGYucGxvdC54O1xuICAgICAgICB2YXIgeSA9IHNlbGYucGxvdC55O1xuICAgICAgICB2YXIgeiA9IHNlbGYucGxvdC56O1xuXG5cbiAgICAgICAgeC52YWx1ZSA9IGQgPT4gY29uZmlnLngudmFsdWUuY2FsbChjb25maWcsIGQpO1xuICAgICAgICB5LnZhbHVlID0gZCA9PiBjb25maWcueS52YWx1ZS5jYWxsKGNvbmZpZywgZCk7XG4gICAgICAgIHoudmFsdWUgPSBkID0+IGNvbmZpZy56LnZhbHVlLmNhbGwoY29uZmlnLCBkKTtcblxuICAgICAgICB4LnVuaXF1ZVZhbHVlcyA9IFtdO1xuICAgICAgICB5LnVuaXF1ZVZhbHVlcyA9IFtdO1xuXG5cbiAgICAgICAgc2VsZi5wbG90Lmdyb3VwQnlZID0gISFjb25maWcueS5ncm91cHMua2V5cy5sZW5ndGg7XG4gICAgICAgIHNlbGYucGxvdC5ncm91cEJ5WCA9ICEhY29uZmlnLnguZ3JvdXBzLmtleXMubGVuZ3RoO1xuXG4gICAgICAgIHkuZ3JvdXBzID0ge1xuICAgICAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgICAgY2hpbGRyZW46IG51bGwsXG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgbGFzdEluZGV4OiAwXG4gICAgICAgIH07XG4gICAgICAgIHguZ3JvdXBzID0ge1xuICAgICAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgICAgY2hpbGRyZW46IG51bGwsXG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgbGFzdEluZGV4OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHZhbHVlTWFwID0ge307XG4gICAgICAgIHZhciBtaW5aID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbWF4WiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goZD0+IHtcblxuICAgICAgICAgICAgdmFyIHhWYWwgPSB4LnZhbHVlKGQpO1xuICAgICAgICAgICAgdmFyIHlWYWwgPSB5LnZhbHVlKGQpO1xuICAgICAgICAgICAgdmFyIHpWYWxSYXcgPSB6LnZhbHVlKGQpO1xuICAgICAgICAgICAgdmFyIHpWYWwgPSBjb25maWcuei5ub3RBdmFpbGFibGVWYWx1ZSh6VmFsUmF3KSA/IHVuZGVmaW5lZCA6IHBhcnNlRmxvYXQoelZhbFJhdyk7XG5cblxuICAgICAgICAgICAgaWYgKHgudW5pcXVlVmFsdWVzLmluZGV4T2YoeFZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgeC51bmlxdWVWYWx1ZXMucHVzaCh4VmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHkudW5pcXVlVmFsdWVzLmluZGV4T2YoeVZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgeS51bmlxdWVWYWx1ZXMucHVzaCh5VmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyb3VwWSA9IHkuZ3JvdXBzO1xuICAgICAgICAgICAgaWYgKHNlbGYucGxvdC5ncm91cEJ5WSkge1xuICAgICAgICAgICAgICAgIGdyb3VwWSA9IHRoaXMudXBkYXRlR3JvdXBzKGQsIHlWYWwsIHkuZ3JvdXBzLCBjb25maWcueS5ncm91cHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyb3VwWCA9IHguZ3JvdXBzO1xuICAgICAgICAgICAgaWYgKHNlbGYucGxvdC5ncm91cEJ5WCkge1xuXG4gICAgICAgICAgICAgICAgZ3JvdXBYID0gdGhpcy51cGRhdGVHcm91cHMoZCwgeFZhbCwgeC5ncm91cHMsIGNvbmZpZy54Lmdyb3Vwcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdmFsdWVNYXBbZ3JvdXBZLmluZGV4XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTWFwW2dyb3VwWS5pbmRleF0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZU1hcFtncm91cFkuaW5kZXhdW2dyb3VwWC5pbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZU1hcFtncm91cFkuaW5kZXhdW2dyb3VwWC5pbmRleF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdW3lWYWxdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdW3lWYWxdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZU1hcFtncm91cFkuaW5kZXhdW2dyb3VwWC5pbmRleF1beVZhbF1beFZhbF0gPSB6VmFsO1xuXG5cbiAgICAgICAgICAgIGlmIChtaW5aID09PSB1bmRlZmluZWQgfHwgelZhbCA8IG1pblopIHtcbiAgICAgICAgICAgICAgICBtaW5aID0gelZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhaID09PSB1bmRlZmluZWQgfHwgelZhbCA+IG1heFopIHtcbiAgICAgICAgICAgICAgICBtYXhaID0gelZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYucGxvdC52YWx1ZU1hcCA9IHZhbHVlTWFwO1xuXG5cbiAgICAgICAgaWYgKCFzZWxmLnBsb3QuZ3JvdXBCeVgpIHtcbiAgICAgICAgICAgIHguZ3JvdXBzLnZhbHVlcyA9IHgudW5pcXVlVmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIHkuZ3JvdXBzLnZhbHVlcyA9IHkudW5pcXVlVmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXR1cFZhbHVlc0JlZm9yZUdyb3Vwc1NvcnQoKTtcblxuICAgICAgICB4LmdhcHMgPSBbXTtcbiAgICAgICAgeC50b3RhbFZhbHVlc0NvdW50ID0gMDtcbiAgICAgICAgeC5hbGxWYWx1ZXNMaXN0ID0gW107XG4gICAgICAgIHRoaXMuc29ydEdyb3Vwcyh4LCB4Lmdyb3VwcywgY29uZmlnLngpO1xuXG4gICAgICAgIHkuZ2FwcyA9IFtdO1xuICAgICAgICB5LnRvdGFsVmFsdWVzQ291bnQgPSAwO1xuICAgICAgICB5LmFsbFZhbHVlc0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5zb3J0R3JvdXBzKHksIHkuZ3JvdXBzLCBjb25maWcueSk7XG5cbiAgICAgICAgei5taW4gPSBtaW5aO1xuICAgICAgICB6Lm1heCA9IG1heFo7XG5cbiAgICB9XG5cbiAgICBzZXR1cFZhbHVlc0JlZm9yZUdyb3Vwc1NvcnQoKSB7XG4gICAgfVxuXG4gICAgYnVpbGRDZWxscygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IHNlbGYucGxvdC54O1xuICAgICAgICB2YXIgeSA9IHNlbGYucGxvdC55O1xuICAgICAgICB2YXIgeiA9IHNlbGYucGxvdC56O1xuICAgICAgICB2YXIgdmFsdWVNYXAgPSBzZWxmLnBsb3QudmFsdWVNYXA7XG5cbiAgICAgICAgdmFyIG1hdHJpeENlbGxzID0gc2VsZi5wbG90LmNlbGxzID0gW107XG4gICAgICAgIHZhciBtYXRyaXggPSBzZWxmLnBsb3QubWF0cml4ID0gW107XG5cbiAgICAgICAgeS5hbGxWYWx1ZXNMaXN0LmZvckVhY2goKHYxLCBpKT0+IHtcbiAgICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICAgIG1hdHJpeC5wdXNoKHJvdyk7XG5cbiAgICAgICAgICAgIHguYWxsVmFsdWVzTGlzdC5mb3JFYWNoKCh2MiwgaikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciB6VmFsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHpWYWwgPSB2YWx1ZU1hcFt2MS5ncm91cC5pbmRleF1bdjIuZ3JvdXAuaW5kZXhdW3YxLnZhbF1bdjIudmFsXVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcm93VmFyOiB2MSxcbiAgICAgICAgICAgICAgICAgICAgY29sVmFyOiB2MixcbiAgICAgICAgICAgICAgICAgICAgcm93OiBpLFxuICAgICAgICAgICAgICAgICAgICBjb2w6IGosXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB6VmFsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByb3cucHVzaChjZWxsKTtcblxuICAgICAgICAgICAgICAgIG1hdHJpeENlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICB1cGRhdGVHcm91cHMoZCwgYXhpc1ZhbCwgcm9vdEdyb3VwLCBheGlzR3JvdXBzQ29uZmlnKSB7XG5cbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICB2YXIgY3VycmVudEdyb3VwID0gcm9vdEdyb3VwO1xuICAgICAgICBheGlzR3JvdXBzQ29uZmlnLmtleXMuZm9yRWFjaCgoZ3JvdXBLZXksIGdyb3VwS2V5SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5rZXkgPSBncm91cEtleTtcblxuICAgICAgICAgICAgaWYgKCFjdXJyZW50R3JvdXAuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyb3VwaW5nVmFsdWUgPSBheGlzR3JvdXBzQ29uZmlnLnZhbHVlLmNhbGwoY29uZmlnLCBkLCBncm91cEtleSk7XG5cbiAgICAgICAgICAgIGlmICghY3VycmVudEdyb3VwLmNoaWxkcmVuLmhhc093blByb3BlcnR5KGdyb3VwaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcm9vdEdyb3VwLmxhc3RJbmRleCsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5jaGlsZHJlbltncm91cGluZ1ZhbHVlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwaW5nVmFsdWU6IGdyb3VwaW5nVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBjdXJyZW50R3JvdXAubGV2ZWwgKyAxLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogcm9vdEdyb3VwLmxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBncm91cEtleVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudEdyb3VwID0gY3VycmVudEdyb3VwLmNoaWxkcmVuW2dyb3VwaW5nVmFsdWVdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY3VycmVudEdyb3VwLnZhbHVlcy5pbmRleE9mKGF4aXNWYWwpID09PSAtMSkge1xuICAgICAgICAgICAgY3VycmVudEdyb3VwLnZhbHVlcy5wdXNoKGF4aXNWYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRHcm91cDtcbiAgICB9XG5cbiAgICBzb3J0R3JvdXBzKGF4aXMsIGdyb3VwLCBheGlzQ29uZmlnLCBnYXBzKSB7XG4gICAgICAgIGlmIChheGlzQ29uZmlnLmdyb3Vwcy5sYWJlbHMgJiYgYXhpc0NvbmZpZy5ncm91cHMubGFiZWxzLmxlbmd0aCA+IGdyb3VwLmxldmVsKSB7XG4gICAgICAgICAgICBncm91cC5sYWJlbCA9IGF4aXNDb25maWcuZ3JvdXBzLmxhYmVsc1tncm91cC5sZXZlbF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncm91cC5sYWJlbCA9IGdyb3VwLmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZ2Fwcykge1xuICAgICAgICAgICAgZ2FwcyA9IFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2Fwcy5sZW5ndGggPD0gZ3JvdXAubGV2ZWwpIHtcbiAgICAgICAgICAgIGdhcHMucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwLmFsbFZhbHVlc0NvdW50ID0gZ3JvdXAuYWxsVmFsdWVzQ291bnQgfHwgMDtcbiAgICAgICAgZ3JvdXAuYWxsVmFsdWVzQmVmb3JlQ291bnQgPSBncm91cC5hbGxWYWx1ZXNCZWZvcmVDb3VudCB8fCAwO1xuXG4gICAgICAgIGdyb3VwLmdhcHMgPSBnYXBzLnNsaWNlKCk7XG4gICAgICAgIGdyb3VwLmdhcHNCZWZvcmUgPSBnYXBzLnNsaWNlKCk7XG5cblxuICAgICAgICBncm91cC5nYXBzU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcHNTaXplKGdyb3VwLmdhcHMpO1xuICAgICAgICBncm91cC5nYXBzQmVmb3JlU2l6ZSA9IGdyb3VwLmdhcHNTaXplO1xuICAgICAgICBpZiAoZ3JvdXAudmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoYXhpc0NvbmZpZy5zb3J0TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAudmFsdWVzLnNvcnQoYXhpc0NvbmZpZy5zb3J0Q29tcGFyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cC52YWx1ZXMuZm9yRWFjaCh2PT5heGlzLmFsbFZhbHVlc0xpc3QucHVzaCh7dmFsOiB2LCBncm91cDogZ3JvdXB9KSk7XG4gICAgICAgICAgICBncm91cC5hbGxWYWx1ZXNCZWZvcmVDb3VudCA9IGF4aXMudG90YWxWYWx1ZXNDb3VudDtcbiAgICAgICAgICAgIGF4aXMudG90YWxWYWx1ZXNDb3VudCArPSBncm91cC52YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgZ3JvdXAuYWxsVmFsdWVzQ291bnQgKz0gZ3JvdXAudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwLmNoaWxkcmVuTGlzdCA9IFtdO1xuICAgICAgICBpZiAoZ3JvdXAuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbkNvdW50ID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgY2hpbGRQcm9wIGluIGdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLmNoaWxkcmVuLmhhc093blByb3BlcnR5KGNoaWxkUHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bY2hpbGRQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuY2hpbGRyZW5MaXN0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkNvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0R3JvdXBzKGF4aXMsIGNoaWxkLCBheGlzQ29uZmlnLCBnYXBzKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWxsVmFsdWVzQ291bnQgKz0gY2hpbGQuYWxsVmFsdWVzQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGdhcHNbZ3JvdXAubGV2ZWxdICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2FwcyAmJiBjaGlsZHJlbkNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIGdhcHNbZ3JvdXAubGV2ZWxdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmdhcHNJbnNpZGUgPSBbXTtcbiAgICAgICAgICAgIGdhcHMuZm9yRWFjaCgoZCwgaSk9PiB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZ2Fwc0luc2lkZS5wdXNoKGQgLSAoZ3JvdXAuZ2Fwc0JlZm9yZVtpXSB8fCAwKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3VwLmdhcHNJbnNpZGVTaXplID0gSGVhdG1hcC5jb21wdXRlR2Fwc1NpemUoZ3JvdXAuZ2Fwc0luc2lkZSk7XG5cbiAgICAgICAgICAgIGlmIChheGlzLmdhcHMubGVuZ3RoIDwgZ2Fwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBheGlzLmdhcHMgPSBnYXBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBjb21wdXRlWUF4aXNMYWJlbHNXaWR0aChvZmZzZXQpIHtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5wbG90Lm1hcmdpbi5sZWZ0O1xuICAgICAgICBpZiAodGhpcy5jb25maWcueS50aXRsZSkge1xuICAgICAgICAgICAgbWF4V2lkdGggLT0gMTU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAmJiBvZmZzZXQueCkge1xuICAgICAgICAgICAgbWF4V2lkdGggKz0gb2Zmc2V0Lng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb25maWcueS5yb3RhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIG1heFdpZHRoICo9IFV0aWxzLlNRUlRfMjtcbiAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IDExOyAvL3RvZG8gY2hlY2sgYWN0dWFsIGZvbnQgc2l6ZVxuICAgICAgICAgICAgbWF4V2lkdGggLT1mb250U2l6ZS8yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgIH1cblxuICAgIGNvbXB1dGVYQXhpc0xhYmVsc1dpZHRoKG9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLngucm90YXRlTGFiZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbG90LmNlbGxXaWR0aCAtIDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnBsb3QubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLngudGl0bGUpIHtcbiAgICAgICAgICAgIHNpemUgLT0gMTU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAmJiBvZmZzZXQueSkge1xuICAgICAgICAgICAgc2l6ZSAtPSBvZmZzZXQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemUgKj0gVXRpbHMuU1FSVF8yO1xuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IDExOyAvL3RvZG8gY2hlY2sgYWN0dWFsIGZvbnQgc2l6ZVxuICAgICAgICBzaXplIC09Zm9udFNpemUvMjtcblxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29tcHV0ZUdhcFNpemUoZ2FwTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIEhlYXRtYXAubWF4R3JvdXBHYXBTaXplIC8gKGdhcExldmVsICsgMSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbXB1dGVHYXBzU2l6ZShnYXBzKSB7XG4gICAgICAgIHZhciBnYXBzU2l6ZSA9IDA7XG4gICAgICAgIGdhcHMuZm9yRWFjaCgoZ2Fwc051bWJlciwgZ2Fwc0xldmVsKT0+IGdhcHNTaXplICs9IGdhcHNOdW1iZXIgKiBIZWF0bWFwLmNvbXB1dGVHYXBTaXplKGdhcHNMZXZlbCkpO1xuICAgICAgICByZXR1cm4gZ2Fwc1NpemU7XG4gICAgfVxuXG4gICAgY29tcHV0ZVBsb3RTaXplKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuICAgICAgICB2YXIgbWFyZ2luID0gcGxvdC5tYXJnaW47XG4gICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IFV0aWxzLmF2YWlsYWJsZVdpZHRoKHRoaXMuY29uZmlnLndpZHRoLCB0aGlzLmdldEJhc2VDb250YWluZXIoKSwgdGhpcy5wbG90Lm1hcmdpbik7XG4gICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSBVdGlscy5hdmFpbGFibGVIZWlnaHQodGhpcy5jb25maWcuaGVpZ2h0LCB0aGlzLmdldEJhc2VDb250YWluZXIoKSwgdGhpcy5wbG90Lm1hcmdpbik7XG4gICAgICAgIHZhciB3aWR0aCA9IGF2YWlsYWJsZVdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0O1xuXG4gICAgICAgIHZhciB4R2Fwc1NpemUgPSBIZWF0bWFwLmNvbXB1dGVHYXBzU2l6ZShwbG90LnguZ2Fwcyk7XG5cblxuICAgICAgICB2YXIgY29tcHV0ZWRDZWxsV2lkdGggPSBNYXRoLm1heChjb25mLmNlbGwuc2l6ZU1pbiwgTWF0aC5taW4oY29uZi5jZWxsLnNpemVNYXgsIChhdmFpbGFibGVXaWR0aCAtIHhHYXBzU2l6ZSkgLyB0aGlzLnBsb3QueC50b3RhbFZhbHVlc0NvdW50KSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy53aWR0aCkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNlbGwud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFdpZHRoID0gY29tcHV0ZWRDZWxsV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jZWxsV2lkdGggPSB0aGlzLmNvbmZpZy5jZWxsLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucGxvdC5jZWxsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFdpZHRoID0gY29tcHV0ZWRDZWxsV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IHRoaXMucGxvdC5jZWxsV2lkdGggKiB0aGlzLnBsb3QueC50b3RhbFZhbHVlc0NvdW50ICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQgKyB4R2Fwc1NpemU7XG5cbiAgICAgICAgdmFyIHlHYXBzU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcHNTaXplKHBsb3QueS5nYXBzKTtcbiAgICAgICAgdmFyIGNvbXB1dGVkQ2VsbEhlaWdodCA9IE1hdGgubWF4KGNvbmYuY2VsbC5zaXplTWluLCBNYXRoLm1pbihjb25mLmNlbGwuc2l6ZU1heCwgKGF2YWlsYWJsZUhlaWdodCAtIHlHYXBzU2l6ZSkgLyB0aGlzLnBsb3QueS50b3RhbFZhbHVlc0NvdW50KSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25maWcuY2VsbC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbEhlaWdodCA9IGNvbXB1dGVkQ2VsbEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jZWxsSGVpZ2h0ID0gdGhpcy5jb25maWcuY2VsbC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5wbG90LmNlbGxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbEhlaWdodCA9IGNvbXB1dGVkQ2VsbEhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5wbG90LmNlbGxIZWlnaHQgKiB0aGlzLnBsb3QueS50b3RhbFZhbHVlc0NvdW50ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20gKyB5R2Fwc1NpemU7XG5cblxuICAgICAgICB0aGlzLnBsb3Qud2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICB0aGlzLnBsb3QuaGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgfVxuXG5cbiAgICBzZXR1cFpTY2FsZSgpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb25maWcgPSBzZWxmLmNvbmZpZztcbiAgICAgICAgdmFyIHogPSBzZWxmLnBsb3QuejtcbiAgICAgICAgdmFyIHJhbmdlID0gY29uZmlnLmNvbG9yLnJhbmdlO1xuICAgICAgICB2YXIgZXh0ZW50ID0gei5tYXggLSB6Lm1pbjtcbiAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICB6LmRvbWFpbiA9IFtdO1xuICAgICAgICBpZiAoY29uZmlnLmNvbG9yLnNjYWxlID09IFwicG93XCIpIHtcbiAgICAgICAgICAgIHZhciBleHBvbmVudCA9IDEwO1xuICAgICAgICAgICAgcmFuZ2UuZm9yRWFjaCgoYywgaSk9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB6Lm1heCAtIChleHRlbnQgLyBNYXRoLnBvdygxMCwgaSkpO1xuICAgICAgICAgICAgICAgIHouZG9tYWluLnB1c2godilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2NhbGUgPSBkMy5zY2FsZVBvdygpLmV4cG9uZW50KGV4cG9uZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuY29sb3Iuc2NhbGUgPT0gXCJsb2dcIikge1xuXG4gICAgICAgICAgICByYW5nZS5mb3JFYWNoKChjLCBpKT0+IHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHoubWluICsgKGV4dGVudCAvIE1hdGgucG93KDEwLCBpKSk7XG4gICAgICAgICAgICAgICAgei5kb21haW4udW5zaGlmdCh2KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2NhbGUgPSBkMy5zY2FsZUxvZygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZS5mb3JFYWNoKChjLCBpKT0+IHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHoubWluICsgKGV4dGVudCAqIChpIC8gKHJhbmdlLmxlbmd0aCAtIDEpKSk7XG4gICAgICAgICAgICAgICAgei5kb21haW4ucHVzaCh2KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmZpZy5jb2xvci5zY2FsZSk7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgei5kb21haW5bMF0gPSB6Lm1pbjsgLy9yZW1vdmluZyB1bm5lY2Vzc2FyeSBmbG9hdGluZyBwb2ludHNcbiAgICAgICAgei5kb21haW5bei5kb21haW4ubGVuZ3RoIC0gMV0gPSB6Lm1heDsgLy9yZW1vdmluZyB1bm5lY2Vzc2FyeSBmbG9hdGluZyBwb2ludHNcbiAgICAgICAgLy8gY29uc29sZS5sb2coei5kb21haW4pO1xuXG4gICAgICAgIGlmIChjb25maWcuY29sb3IucmV2ZXJzZVNjYWxlKSB7XG4gICAgICAgICAgICB6LmRvbWFpbi5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhyYW5nZSk7XG5cbiAgICAgICAgcGxvdC56LmNvbG9yLnNjYWxlID0gc2NhbGUuZG9tYWluKHouZG9tYWluKS5yYW5nZShyYW5nZSk7XG4gICAgICAgIHZhciBzaGFwZSA9IHBsb3Quei5zaGFwZSA9IHt9O1xuXG4gICAgICAgIHZhciBjZWxsQ29uZiA9IHRoaXMuY29uZmlnLmNlbGw7XG4gICAgICAgIHNoYXBlLnR5cGUgPSBcInJlY3RcIjtcblxuICAgICAgICBwbG90Lnouc2hhcGUud2lkdGggPSBwbG90LmNlbGxXaWR0aCAtIGNlbGxDb25mLnBhZGRpbmcgKiAyO1xuICAgICAgICBwbG90Lnouc2hhcGUuaGVpZ2h0ID0gcGxvdC5jZWxsSGVpZ2h0IC0gY2VsbENvbmYucGFkZGluZyAqIDI7XG4gICAgfVxuXG5cbiAgICB1cGRhdGUobmV3RGF0YSkge1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0dyb3Vwc1kodGhpcy5wbG90LnkuZ3JvdXBzLCB0aGlzLnN2Z0cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVgpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0dyb3Vwc1godGhpcy5wbG90LnguZ3JvdXBzLCB0aGlzLnN2Z0cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVDZWxscygpO1xuXG4gICAgICAgIC8vIHRoaXMudXBkYXRlVmFyaWFibGVMYWJlbHMoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNYKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXhpc1koKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMZWdlbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlQXhpc1RpdGxlcygpO1xuICAgIH07XG5cbiAgICB1cGRhdGVBeGlzVGl0bGVzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuXG5cbiAgICB9XG5cblxuICAgIHVwZGF0ZUF4aXNYKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgbGFiZWxDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJsYWJlbFwiKTtcbiAgICAgICAgdmFyIGxhYmVsWENsYXNzID0gbGFiZWxDbGFzcyArIFwiLXhcIjtcbiAgICAgICAgdmFyIGxhYmVsWUNsYXNzID0gbGFiZWxDbGFzcyArIFwiLXlcIjtcbiAgICAgICAgcGxvdC5sYWJlbENsYXNzID0gbGFiZWxDbGFzcztcblxuICAgICAgICB2YXIgb2Zmc2V0WCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIGxldCBnYXBTaXplID0gSGVhdG1hcC5jb21wdXRlR2FwU2l6ZSgwKTtcbiAgICAgICAgaWYgKHBsb3QuZ3JvdXBCeVgpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGFwID0gc2VsZi5jb25maWcueC5ncm91cHMub3ZlcmxhcDtcblxuICAgICAgICAgICAgb2Zmc2V0WC54ID0gZ2FwU2l6ZSAvIDI7XG4gICAgICAgICAgICBvZmZzZXRYLnkgPSBvdmVybGFwLmJvdHRvbSArIGdhcFNpemUgLyAyICsgNjtcbiAgICAgICAgfSBlbHNlIGlmIChwbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICBvZmZzZXRYLnkgPSBnYXBTaXplO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgbGFiZWxzID0gc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyBsYWJlbFhDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHBsb3QueC5hbGxWYWx1ZXNMaXN0LCAoZCwgaSk9PmkpO1xuXG4gICAgICAgIHZhciBsYWJlbHNNZXJnZSA9IGxhYmVscy5lbnRlcigpLmFwcGVuZChcInRleHRcIikuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBsYWJlbENsYXNzICsgXCIgXCIgKyBsYWJlbFhDbGFzcyArIFwiIFwiICsgbGFiZWxYQ2xhc3MgKyBcIi1cIiArIGkpLm1lcmdlKGxhYmVscyk7XG5cbiAgICAgICAgbGFiZWxzTWVyZ2VcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4gKGkgKiBwbG90LmNlbGxXaWR0aCArIHBsb3QuY2VsbFdpZHRoIC8gMikgKyAoZC5ncm91cC5nYXBzU2l6ZSkgKyBvZmZzZXRYLngpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgcGxvdC5oZWlnaHQgKyBvZmZzZXRYLnkpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDEwKVxuXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChkPT5zZWxmLmZvcm1hdFZhbHVlWChkLnZhbCkpO1xuXG5cblxuICAgICAgICB2YXIgbWF4V2lkdGggPSBzZWxmLmNvbXB1dGVYQXhpc0xhYmVsc1dpZHRoKG9mZnNldFgpO1xuXG4gICAgICAgIGxhYmVsc01lcmdlLmVhY2goZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0ZXh0ID0gc2VsZi5mb3JtYXRWYWx1ZVgobGFiZWwudmFsKTtcbiAgICAgICAgICAgIFV0aWxzLnBsYWNlVGV4dFdpdGhFbGxpcHNpc0FuZFRvb2x0aXAoZWxlbSwgdGV4dCwgbWF4V2lkdGgsIHNlbGYuY29uZmlnLnNob3dUb29sdGlwID8gc2VsZi5wbG90LnRvb2x0aXAgOiBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy54LnJvdGF0ZUxhYmVscykge1xuICAgICAgICAgICAgbGFiZWxzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJyb3RhdGUoLTQ1LCBcIiArICgoaSAqIHBsb3QuY2VsbFdpZHRoICsgcGxvdC5jZWxsV2lkdGggLyAyKSArIGQuZ3JvdXAuZ2Fwc1NpemUgKyBvZmZzZXRYLnggKSArIFwiLCBcIiArICggcGxvdC5oZWlnaHQgKyBvZmZzZXRYLnkpICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAtMilcbiAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIDgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGFiZWxzLmV4aXQoKS5yZW1vdmUoKTtcblxuXG4gICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzLXgnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHBsb3Qud2lkdGggLyAyKSArIFwiLFwiICsgKHBsb3QuaGVpZ2h0ICsgcGxvdC5tYXJnaW4uYm90dG9tKSArIFwiKVwiKVxuICAgICAgICAgICAgLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG5cbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCItMC41ZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChzZWxmLmNvbmZpZy54LnRpdGxlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVBeGlzWSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGxhYmVsQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwibGFiZWxcIik7XG4gICAgICAgIHZhciBsYWJlbFlDbGFzcyA9IGxhYmVsQ2xhc3MgKyBcIi15XCI7XG4gICAgICAgIHBsb3QubGFiZWxDbGFzcyA9IGxhYmVsQ2xhc3M7XG5cblxuICAgICAgICB2YXIgbGFiZWxzID0gc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyBsYWJlbFlDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHBsb3QueS5hbGxWYWx1ZXNMaXN0KTtcblxuICAgICAgICB2YXIgbGFiZWxzRW50ZXIgPSBsYWJlbHMuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpO1xuICAgICAgICB2YXIgbGFiZWxzTWVyZ2UgPSBsYWJlbHNFbnRlci5tZXJnZShsYWJlbHMpO1xuXG4gICAgICAgIHZhciBvZmZzZXRZID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGFwID0gc2VsZi5jb25maWcueS5ncm91cHMub3ZlcmxhcDtcbiAgICAgICAgICAgIGxldCBnYXBTaXplID0gSGVhdG1hcC5jb21wdXRlR2FwU2l6ZSgwKTtcbiAgICAgICAgICAgIG9mZnNldFkueCA9IC1vdmVybGFwLmxlZnQ7XG5cbiAgICAgICAgICAgIG9mZnNldFkueSA9IGdhcFNpemUgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsc01lcmdlXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgb2Zmc2V0WS54KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIChkLCBpKSA9PiAoaSAqIHBsb3QuY2VsbEhlaWdodCArIHBsb3QuY2VsbEhlaWdodCAvIDIpICsgZC5ncm91cC5nYXBzU2l6ZSArIG9mZnNldFkueSlcbiAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgLTIpXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBsYWJlbENsYXNzICsgXCIgXCIgKyBsYWJlbFlDbGFzcyArIFwiIFwiICsgbGFiZWxZQ2xhc3MgKyBcIi1cIiArIGkpXG5cbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IHNlbGYuZm9ybWF0VmFsdWVZKGQudmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbWF4V2lkdGggPSBzZWxmLmNvbXB1dGVZQXhpc0xhYmVsc1dpZHRoKG9mZnNldFkpO1xuXG4gICAgICAgIGxhYmVsc01lcmdlLmVhY2goZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0ZXh0ID0gc2VsZi5mb3JtYXRWYWx1ZVkobGFiZWwudmFsKTtcbiAgICAgICAgICAgIFV0aWxzLnBsYWNlVGV4dFdpdGhFbGxpcHNpc0FuZFRvb2x0aXAoZWxlbSwgdGV4dCwgbWF4V2lkdGgsIHNlbGYuY29uZmlnLnNob3dUb29sdGlwID8gc2VsZi5wbG90LnRvb2x0aXAgOiBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy55LnJvdGF0ZUxhYmVscykge1xuICAgICAgICAgICAgbGFiZWxzTWVyZ2VcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJyb3RhdGUoLTQ1LCBcIiArIChvZmZzZXRZLnggICkgKyBcIiwgXCIgKyAoZC5ncm91cC5nYXBzU2l6ZSArIChpICogcGxvdC5jZWxsSGVpZ2h0ICsgcGxvdC5jZWxsSGVpZ2h0IC8gMikgKyBvZmZzZXRZLnkpICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKTtcbiAgICAgICAgICAgIC8vIC5hdHRyKFwiZHhcIiwgLTcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxzTWVyZ2UuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIH1cblxuXG4gICAgICAgIGxhYmVscy5leGl0KCkucmVtb3ZlKCk7XG5cblxuICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy15JykpXG4gICAgICAgICAgICAuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiICsgc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLXBsb3QubWFyZ2luLmxlZnQgKyBcIixcIiArIChwbG90LmhlaWdodCAvIDIpICsgXCIpcm90YXRlKC05MClcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChzZWxmLmNvbmZpZy55LnRpdGxlKTtcblxuICAgIH1cblxuXG4gICAgZHJhd0dyb3Vwc1kocGFyZW50R3JvdXAsIGNvbnRhaW5lciwgYXZhaWxhYmxlV2lkdGgpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuXG4gICAgICAgIHZhciBncm91cENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImdyb3VwXCIpO1xuICAgICAgICB2YXIgZ3JvdXBZQ2xhc3MgPSBncm91cENsYXNzICsgXCIteVwiO1xuICAgICAgICB2YXIgZ3JvdXBzID0gY29udGFpbmVyLnNlbGVjdEFsbChcImcuXCIgKyBncm91cENsYXNzICsgXCIuXCIgKyBncm91cFlDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHBhcmVudEdyb3VwLmNoaWxkcmVuTGlzdCk7XG5cbiAgICAgICAgdmFyIHZhbHVlc0JlZm9yZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIGdhcHNCZWZvcmVTaXplID0gMDtcblxuICAgICAgICB2YXIgZ3JvdXBzRW50ZXIgPSBncm91cHMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuICAgICAgICBncm91cHNFbnRlclxuICAgICAgICAgICAgLmNsYXNzZWQoZ3JvdXBDbGFzcywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKGdyb3VwWUNsYXNzLCB0cnVlKVxuICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIikuY2xhc3NlZChcImdyb3VwLXJlY3RcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIHRpdGxlR3JvdXBFbnRlciA9IGdyb3Vwc0VudGVyLmFwcGVuZFNlbGVjdG9yKFwiZy50aXRsZVwiKTtcbiAgICAgICAgdGl0bGVHcm91cEVudGVyLmFwcGVuZChcInJlY3RcIik7XG4gICAgICAgIHRpdGxlR3JvdXBFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xuXG4gICAgICAgIHZhciBnYXBTaXplID0gSGVhdG1hcC5jb21wdXRlR2FwU2l6ZShwYXJlbnRHcm91cC5sZXZlbCk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gZ2FwU2l6ZSAvIDQ7XG5cbiAgICAgICAgdmFyIHRpdGxlUmVjdFdpZHRoID0gSGVhdG1hcC5ncm91cFRpdGxlUmVjdEhlaWdodDtcbiAgICAgICAgdmFyIGRlcHRoID0gc2VsZi5jb25maWcueS5ncm91cHMua2V5cy5sZW5ndGggLSBwYXJlbnRHcm91cC5sZXZlbDtcbiAgICAgICAgdmFyIG92ZXJsYXAgPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWF2YWlsYWJsZVdpZHRoKSB7XG4gICAgICAgICAgICBvdmVybGFwLnJpZ2h0ID0gcGxvdC55Lm92ZXJsYXAubGVmdDtcbiAgICAgICAgICAgIG92ZXJsYXAubGVmdCA9IHBsb3QueS5vdmVybGFwLmxlZnQ7XG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHBsb3Qud2lkdGggKyBnYXBTaXplICsgb3ZlcmxhcC5sZWZ0ICsgb3ZlcmxhcC5yaWdodDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGdyb3Vwc01lcmdlID0gZ3JvdXBzRW50ZXIubWVyZ2UoZ3JvdXBzKTtcblxuICAgICAgICBncm91cHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoXCIgKyAocGFkZGluZyAtIG92ZXJsYXAubGVmdCkgKyBcIixcIiArICgocGxvdC5jZWxsSGVpZ2h0ICogdmFsdWVzQmVmb3JlQ291bnQpICsgaSAqIGdhcFNpemUgKyBnYXBzQmVmb3JlU2l6ZSArIHBhZGRpbmcpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgZ2Fwc0JlZm9yZVNpemUgKz0gKGQuZ2Fwc0luc2lkZVNpemUgfHwgMCk7XG4gICAgICAgICAgICAgICAgdmFsdWVzQmVmb3JlQ291bnQgKz0gZC5hbGxWYWx1ZXNDb3VudCB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgdmFyIGdyb3VwV2lkdGggPSBhdmFpbGFibGVXaWR0aCAtIHBhZGRpbmcgKiAyO1xuXG4gICAgICAgIHZhciB0aXRsZUdyb3VwcyA9IGdyb3Vwc01lcmdlLnNlbGVjdEFsbChcImcudGl0bGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInRyYW5zbGF0ZShcIiArIChncm91cFdpZHRoIC0gdGl0bGVSZWN0V2lkdGgpICsgXCIsIDApXCIpO1xuXG4gICAgICAgIHZhciB0aWxlUmVjdHMgPSB0aXRsZUdyb3Vwcy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHRpdGxlUmVjdFdpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZD0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGQuZ2Fwc0luc2lkZVNpemUgfHwgMCkgKyBwbG90LmNlbGxIZWlnaHQgKiBkLmFsbFZhbHVlc0NvdW50ICsgcGFkZGluZyAqIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJmaWxsXCIsIFwibGlnaHRncmV5XCIpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAwKTtcblxuICAgICAgICB0aGlzLnNldEdyb3VwTW91c2VDYWxsYmFja3MocGFyZW50R3JvdXAsIHRpbGVSZWN0cyk7XG5cblxuICAgICAgICBncm91cHNNZXJnZS5zZWxlY3RBbGwoXCJyZWN0Lmdyb3VwLXJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZD0+IFwiZ3JvdXAtcmVjdCBncm91cC1yZWN0LVwiICsgZC5pbmRleClcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZ3JvdXBXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQ9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkLmdhcHNJbnNpZGVTaXplIHx8IDApICsgcGxvdC5jZWxsSGVpZ2h0ICogZC5hbGxWYWx1ZXNDb3VudCArIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIndoaXRlXCIpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMC41KVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuXG5cbiAgICAgICAgZ3JvdXBzTWVyZ2UuZWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcblxuICAgICAgICAgICAgc2VsZi5kcmF3R3JvdXBzWS5jYWxsKHNlbGYsIGdyb3VwLCBkMy5zZWxlY3QodGhpcyksIGdyb3VwV2lkdGggLSB0aXRsZVJlY3RXaWR0aCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZHJhd0dyb3Vwc1gocGFyZW50R3JvdXAsIGNvbnRhaW5lciwgYXZhaWxhYmxlSGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcblxuICAgICAgICB2YXIgZ3JvdXBDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJncm91cFwiKTtcbiAgICAgICAgdmFyIGdyb3VwWENsYXNzID0gZ3JvdXBDbGFzcyArIFwiLXhcIjtcbiAgICAgICAgdmFyIGdyb3VwcyA9IGNvbnRhaW5lci5zZWxlY3RBbGwoXCJnLlwiICsgZ3JvdXBDbGFzcyArIFwiLlwiICsgZ3JvdXBYQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwYXJlbnRHcm91cC5jaGlsZHJlbkxpc3QpO1xuXG4gICAgICAgIHZhciB2YWx1ZXNCZWZvcmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBnYXBzQmVmb3JlU2l6ZSA9IDA7XG5cbiAgICAgICAgdmFyIGdyb3Vwc0VudGVyID0gZ3JvdXBzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgZ3JvdXBzRW50ZXJcbiAgICAgICAgICAgIC5jbGFzc2VkKGdyb3VwQ2xhc3MsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZChncm91cFhDbGFzcywgdHJ1ZSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpLmNsYXNzZWQoXCJncm91cC1yZWN0XCIsIHRydWUpO1xuXG4gICAgICAgIHZhciB0aXRsZUdyb3VwRW50ZXIgPSBncm91cHNFbnRlci5hcHBlbmRTZWxlY3RvcihcImcudGl0bGVcIik7XG4gICAgICAgIHRpdGxlR3JvdXBFbnRlci5hcHBlbmQoXCJyZWN0XCIpO1xuICAgICAgICB0aXRsZUdyb3VwRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuICAgICAgICB2YXIgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUocGFyZW50R3JvdXAubGV2ZWwpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IGdhcFNpemUgLyA0O1xuICAgICAgICB2YXIgdGl0bGVSZWN0SGVpZ2h0ID0gSGVhdG1hcC5ncm91cFRpdGxlUmVjdEhlaWdodDtcblxuICAgICAgICB2YXIgZGVwdGggPSBzZWxmLmNvbmZpZy54Lmdyb3Vwcy5rZXlzLmxlbmd0aCAtIHBhcmVudEdyb3VwLmxldmVsO1xuXG4gICAgICAgIHZhciBvdmVybGFwID0ge1xuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFhdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIG92ZXJsYXAuYm90dG9tID0gcGxvdC54Lm92ZXJsYXAuYm90dG9tO1xuICAgICAgICAgICAgb3ZlcmxhcC50b3AgPSBwbG90Lngub3ZlcmxhcC50b3A7XG4gICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBwbG90LmhlaWdodCArIGdhcFNpemUgKyBvdmVybGFwLnRvcCArIG92ZXJsYXAuYm90dG9tO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdmVybGFwLnRvcCA9IC10aXRsZVJlY3RIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcmVudEdyb3VwJyxwYXJlbnRHcm91cCwgJ2dhcFNpemUnLCBnYXBTaXplLCBwbG90Lngub3ZlcmxhcCk7XG5cbiAgICAgICAgdmFyIGdyb3Vwc01lcmdlID0gZ3JvdXBzRW50ZXIubWVyZ2UoZ3JvdXBzKTtcblxuICAgICAgICBncm91cHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoXCIgKyAoKHBsb3QuY2VsbFdpZHRoICogdmFsdWVzQmVmb3JlQ291bnQpICsgaSAqIGdhcFNpemUgKyBnYXBzQmVmb3JlU2l6ZSArIHBhZGRpbmcpICsgXCIsIFwiICsgKHBhZGRpbmcgLSBvdmVybGFwLnRvcCkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICBnYXBzQmVmb3JlU2l6ZSArPSAoZC5nYXBzSW5zaWRlU2l6ZSB8fCAwKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNCZWZvcmVDb3VudCArPSBkLmFsbFZhbHVlc0NvdW50IHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdyb3VwSGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0IC0gcGFkZGluZyAqIDI7XG5cbiAgICAgICAgdmFyIHRpdGxlR3JvdXBzID0gZ3JvdXBzTWVyZ2Uuc2VsZWN0QWxsKFwiZy50aXRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IFwidHJhbnNsYXRlKDAsIFwiICsgKDApICsgXCIpXCIpO1xuXG5cbiAgICAgICAgdmFyIHRpbGVSZWN0cyA9IHRpdGxlR3JvdXBzLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHRpdGxlUmVjdEhlaWdodClcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZD0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGQuZ2Fwc0luc2lkZVNpemUgfHwgMCkgKyBwbG90LmNlbGxXaWR0aCAqIGQuYWxsVmFsdWVzQ291bnQgKyBwYWRkaW5nICogMlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAgICAgICAvLyAuYXR0cihcImZpbGxcIiwgXCJsaWdodGdyZXlcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDApO1xuXG4gICAgICAgIHRoaXMuc2V0R3JvdXBNb3VzZUNhbGxiYWNrcyhwYXJlbnRHcm91cCwgdGlsZVJlY3RzKTtcblxuXG4gICAgICAgIGdyb3Vwc01lcmdlLnNlbGVjdEFsbChcInJlY3QuZ3JvdXAtcmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkPT4gXCJncm91cC1yZWN0IGdyb3VwLXJlY3QtXCIgKyBkLmluZGV4KVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZ3JvdXBIZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGQ9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkLmdhcHNJbnNpZGVTaXplIHx8IDApICsgcGxvdC5jZWxsV2lkdGggKiBkLmFsbFZhbHVlc0NvdW50ICsgcGFkZGluZyAqIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwid2hpdGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAwLjUpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpO1xuXG4gICAgICAgIGdyb3Vwc01lcmdlLmVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICBzZWxmLmRyYXdHcm91cHNYLmNhbGwoc2VsZiwgZ3JvdXAsIGQzLnNlbGVjdCh0aGlzKSwgZ3JvdXBIZWlnaHQgLSB0aXRsZVJlY3RIZWlnaHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgfVxuXG4gICAgc2V0R3JvdXBNb3VzZUNhbGxiYWNrcyhwYXJlbnRHcm91cCwgdGlsZVJlY3RzKSB7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBtb3VzZW92ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgbW91c2VvdmVyQ2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdoaWdobGlnaHRlZCcsIHRydWUpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZS5wYXJlbnROb2RlKS5zZWxlY3RBbGwoXCJyZWN0Lmdyb3VwLXJlY3QtXCIgKyBkLmluZGV4KS5jbGFzc2VkKCdoaWdobGlnaHRlZCcsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbW91c2VvdXRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgbW91c2VvdXRDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hpZ2hsaWdodGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZS5wYXJlbnROb2RlKS5zZWxlY3RBbGwoXCJyZWN0Lmdyb3VwLXJlY3QtXCIgKyBkLmluZGV4KS5jbGFzc2VkKCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwbG90LnRvb2x0aXApIHtcblxuICAgICAgICAgICAgbW91c2VvdmVyQ2FsbGJhY2tzLnB1c2goZD0+IHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IHBhcmVudEdyb3VwLmxhYmVsICsgXCI6IFwiICsgZC5ncm91cGluZ1ZhbHVlO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Rvb2x0aXAoaHRtbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbW91c2VvdXRDYWxsYmFja3MucHVzaChkPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfVxuICAgICAgICB0aWxlUmVjdHMub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZiwgZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGlsZVJlY3RzLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzZWxmLCBkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZUNlbGxzKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBjZWxsQ29udGFpbmVyQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiY2VsbHNcIik7XG4gICAgICAgIHZhciBnYXBTaXplID0gSGVhdG1hcC5jb21wdXRlR2FwU2l6ZSgwKTtcbiAgICAgICAgdmFyIHBhZGRpbmdYID0gcGxvdC54Lmdyb3Vwcy5jaGlsZHJlbkxpc3QubGVuZ3RoID8gZ2FwU2l6ZSAvIDIgOiAwO1xuICAgICAgICB2YXIgcGFkZGluZ1kgPSBwbG90LnkuZ3JvdXBzLmNoaWxkcmVuTGlzdC5sZW5ndGggPyBnYXBTaXplIC8gMiA6IDA7XG4gICAgICAgIHZhciBjZWxsQ29udGFpbmVyID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIGNlbGxDb250YWluZXJDbGFzcyk7XG4gICAgICAgIGNlbGxDb250YWluZXIuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBhZGRpbmdYICsgXCIsIFwiICsgcGFkZGluZ1kgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIGNlbGxDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJjZWxsXCIpO1xuICAgICAgICB2YXIgY2VsbFNoYXBlID0gcGxvdC56LnNoYXBlLnR5cGU7XG5cbiAgICAgICAgdmFyIGNlbGxzID0gY2VsbENvbnRhaW5lci5zZWxlY3RBbGwoXCJnLlwiICsgY2VsbENsYXNzKVxuICAgICAgICAgICAgLmRhdGEoc2VsZi5wbG90LmNlbGxzKTtcblxuICAgICAgICB2YXIgY2VsbEVudGVyID0gY2VsbHMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChjZWxsQ2xhc3MsIHRydWUpO1xuXG4gICAgICAgIHZhciBjZWxsc01lcmdlID0gY2VsbEVudGVyLm1lcmdlKGNlbGxzKTtcbiAgICAgICAgY2VsbHNNZXJnZS5hdHRyKFwidHJhbnNmb3JtXCIsIGM9PiBcInRyYW5zbGF0ZShcIiArICgocGxvdC5jZWxsV2lkdGggKiBjLmNvbCArIHBsb3QuY2VsbFdpZHRoIC8gMikgKyBjLmNvbFZhci5ncm91cC5nYXBzU2l6ZSkgKyBcIixcIiArICgocGxvdC5jZWxsSGVpZ2h0ICogYy5yb3cgKyBwbG90LmNlbGxIZWlnaHQgLyAyKSArIGMucm93VmFyLmdyb3VwLmdhcHNTaXplKSArIFwiKVwiKTtcblxuICAgICAgICB2YXIgc2hhcGVzID0gY2VsbHNNZXJnZS5zZWxlY3RPckFwcGVuZChjZWxsU2hhcGUgKyBcIi5jZWxsLXNoYXBlLVwiICsgY2VsbFNoYXBlKTtcblxuICAgICAgICBzaGFwZXNcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGxvdC56LnNoYXBlLndpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgcGxvdC56LnNoYXBlLmhlaWdodClcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAtcGxvdC5jZWxsV2lkdGggLyAyKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIC1wbG90LmNlbGxIZWlnaHQgLyAyKTtcblxuICAgICAgICBzaGFwZXMuc3R5bGUoXCJmaWxsXCIsIGM9PiBjLnZhbHVlID09PSB1bmRlZmluZWQgPyBzZWxmLmNvbmZpZy5jb2xvci5ub0RhdGFDb2xvciA6IHBsb3Quei5jb2xvci5zY2FsZShjLnZhbHVlKSk7XG4gICAgICAgIHNoYXBlcy5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIGQ9PiBkLnZhbHVlID09PSB1bmRlZmluZWQgPyAwIDogMSk7XG5cbiAgICAgICAgdmFyIG1vdXNlb3ZlckNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgbW91c2VvdXRDYWxsYmFja3MgPSBbXTtcblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG5cbiAgICAgICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5wdXNoKGM9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBjLnZhbHVlID09PSB1bmRlZmluZWQgPyBzZWxmLmNvbmZpZy50b29sdGlwLm5vRGF0YVRleHQgOiBzZWxmLmZvcm1hdFZhbHVlWihjLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbW91c2VvdXRDYWxsYmFja3MucHVzaChjPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLmhpZ2hsaWdodExhYmVscykge1xuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodENsYXNzID0gc2VsZi5jb25maWcuY3NzQ2xhc3NQcmVmaXggKyBcImhpZ2hsaWdodFwiO1xuICAgICAgICAgICAgdmFyIHhMYWJlbENsYXNzID0gYz0+cGxvdC5sYWJlbENsYXNzICsgXCIteC1cIiArIGMuY29sO1xuICAgICAgICAgICAgdmFyIHlMYWJlbENsYXNzID0gYz0+cGxvdC5sYWJlbENsYXNzICsgXCIteS1cIiArIGMucm93O1xuXG5cbiAgICAgICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5wdXNoKGM9PiB7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIHhMYWJlbENsYXNzKGMpKS5jbGFzc2VkKGhpZ2hsaWdodENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIHlMYWJlbENsYXNzKGMpKS5jbGFzc2VkKGhpZ2hsaWdodENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW91c2VvdXRDYWxsYmFja3MucHVzaChjPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgeExhYmVsQ2xhc3MoYykpLmNsYXNzZWQoaGlnaGxpZ2h0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIHlMYWJlbENsYXNzKGMpKS5jbGFzc2VkKGhpZ2hsaWdodENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY2VsbHNNZXJnZS5vbihcIm1vdXNlb3ZlclwiLCBjID0+IHtcbiAgICAgICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrPT5jYWxsYmFjayhjKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBjID0+IHtcbiAgICAgICAgICAgICAgICBtb3VzZW91dENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrPT5jYWxsYmFjayhjKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjZWxsc01lcmdlLm9uKFwiY2xpY2tcIiwgYz0+IHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihcImNlbGwtc2VsZWN0ZWRcIiwgYyk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgY2VsbHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGZvcm1hdFZhbHVlWCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnguZm9ybWF0dGVyKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnguZm9ybWF0dGVyLmNhbGwodGhpcy5jb25maWcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXRWYWx1ZVkodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy55LmZvcm1hdHRlcikgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy55LmZvcm1hdHRlci5jYWxsKHRoaXMuY29uZmlnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0VmFsdWVaKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuei5mb3JtYXR0ZXIpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuei5mb3JtYXR0ZXIuY2FsbCh0aGlzLmNvbmZpZywgdmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdExlZ2VuZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcubGVnZW5kLmZvcm1hdHRlcikgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sZWdlbmQuZm9ybWF0dGVyLmNhbGwodGhpcy5jb25maWcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVMZWdlbmQoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBsZWdlbmRYID0gdGhpcy5wbG90LndpZHRoICsgMTA7XG4gICAgICAgIHZhciBnYXBTaXplID0gSGVhdG1hcC5jb21wdXRlR2FwU2l6ZSgwKTtcbiAgICAgICAgaWYgKHRoaXMucGxvdC5ncm91cEJ5WSkge1xuICAgICAgICAgICAgbGVnZW5kWCArPSBnYXBTaXplIC8gMiArIHBsb3QueS5vdmVybGFwLnJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxvdC5ncm91cEJ5WCkge1xuICAgICAgICAgICAgbGVnZW5kWCArPSBnYXBTaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWdlbmRZID0gMDtcbiAgICAgICAgaWYgKHRoaXMucGxvdC5ncm91cEJ5WCB8fCB0aGlzLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIGxlZ2VuZFkgKz0gZ2FwU2l6ZSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFyV2lkdGggPSAxMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IHRoaXMucGxvdC5oZWlnaHQgLSAyO1xuICAgICAgICB2YXIgc2NhbGUgPSBwbG90LnouY29sb3Iuc2NhbGU7XG5cbiAgICAgICAgcGxvdC5sZWdlbmQgPSBuZXcgTGVnZW5kKHRoaXMuc3ZnLCB0aGlzLnN2Z0csIHNjYWxlLCBsZWdlbmRYLCBsZWdlbmRZLCB2ID0+IHNlbGYuZm9ybWF0TGVnZW5kVmFsdWUodikpLnNldFJvdGF0ZUxhYmVscyhzZWxmLmNvbmZpZy5sZWdlbmQucm90YXRlTGFiZWxzKS5saW5lYXJHcmFkaWVudEJhcihiYXJXaWR0aCwgYmFySGVpZ2h0KTtcbiAgICB9XG5cblxufVxuIiwiaW1wb3J0IHtDaGFydFdpdGhDb2xvckdyb3VwcywgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWd9IGZyb20gXCIuL2NoYXJ0LXdpdGgtY29sb3ItZ3JvdXBzXCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIEhpc3RvZ3JhbUNvbmZpZyBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlne1xuXG4gICAgc3ZnQ2xhc3M9IHRoaXMuY3NzQ2xhc3NQcmVmaXgrJ2hpc3RvZ3JhbSc7XG4gICAgc2hvd0xlZ2VuZD10cnVlO1xuICAgIHNob3dUb29sdGlwID10cnVlO1xuICAgIHg9ey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsXG4gICAgICAgIGtleTogMCxcbiAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IFV0aWxzLmlzTnVtYmVyKGQpID8gZCA6IHBhcnNlRmxvYXQoZFtrZXldKSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgb3JpZW50OiBcImJvdHRvbVwiLFxuICAgICAgICB0aWNrczogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgeT17Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgbGFiZWwsXG4gICAgICAgIG9yaWVudDogXCJsZWZ0XCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiXG4gICAgfTtcbiAgICBmcmVxdWVuY3k9dHJ1ZTtcbiAgICBncm91cHM9e1xuICAgICAgICBrZXk6IDFcbiAgICB9O1xuICAgIHRyYW5zaXRpb249IHRydWU7XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEhpc3RvZ3JhbSBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBze1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgSGlzdG9ncmFtQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBIaXN0b2dyYW1Db25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKXtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcblxuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54PXt9O1xuICAgICAgICB0aGlzLnBsb3QueT17fTtcbiAgICAgICAgdGhpcy5wbG90LmJhcj17XG4gICAgICAgICAgICBjb2xvcjogbnVsbC8vY29sb3Igc2NhbGUgbWFwcGluZyBmdW5jdGlvblxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0dXBYKCk7XG4gICAgICAgIHRoaXMuc2V0dXBIaXN0b2dyYW0oKTtcbiAgICAgICAgdGhpcy5zZXR1cEdyb3VwU3RhY2tzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBZKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWCgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy54O1xuXG4gICAgICAgIC8qICpcbiAgICAgICAgICogdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAgICAgICAqIHNjYWxlIC0gbWFwcyB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzIGEgcGl4ZWwgcG9zaXRpb24uXG4gICAgICAgICAqIG1hcCBmdW5jdGlvbiAtIG1hcHMgZnJvbSBkYXRhIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICogYXhpcyAtIHNldHMgdXAgYXhpc1xuICAgICAgICAgKiovXG4gICAgICAgIHgudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuICAgICAgICB4LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi5zY2FsZSkucmFuZ2UoWzAsIHBsb3Qud2lkdGhdKTtcbiAgICAgICAgeC5tYXAgPSBkID0+IHguc2NhbGUoeC52YWx1ZShkKSk7XG5cbiAgICAgICAgeC5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeC5zY2FsZSk7XG5cbiAgICAgICAgaWYoY29uZi50aWNrcyl7XG4gICAgICAgICAgICB4LmF4aXMudGlja3MoY29uZi50aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG4gICAgICAgIHBsb3QueC5zY2FsZS5kb21haW4oW2QzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueC52YWx1ZSkpLCBkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBwbG90LngudmFsdWUpKV0pO1xuICAgICAgICBcbiAgICB9O1xuXG4gICAgc2V0dXBZICgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB5LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi5zY2FsZSkucmFuZ2UoW3Bsb3QuaGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgeS5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeS5zY2FsZSk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIHZhciB5U3RhY2tNYXggPSBkMy5tYXgocGxvdC5zdGFja2VkSGlzdG9ncmFtcywgbGF5ZXIgPT4gZDMubWF4KGxheWVyLmhpc3RvZ3JhbUJpbnMsIGQgPT4gZC55MCArIGQueSkpO1xuICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKFswLCB5U3RhY2tNYXhdKTtcblxuICAgIH07XG5cblxuICAgIHNldHVwSGlzdG9ncmFtKCkge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciB5ID0gcGxvdC55O1xuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLmNvbmZpZy54LnRpY2tzID8geC5zY2FsZS50aWNrcyh0aGlzLmNvbmZpZy54LnRpY2tzKSA6IHguc2NhbGUudGlja3MoKTtcblxuICAgICAgICBwbG90Lmhpc3RvZ3JhbSA9IGQzLmhpc3RvZ3JhbSgpXG4gICAgICAgICAgICAuZG9tYWluKHguc2NhbGUuZG9tYWluKCkpXG4gICAgICAgICAgICAudmFsdWUoeC52YWx1ZSlcbiAgICAgICAgICAgIC50aHJlc2hvbGRzKHRpY2tzKTtcbiAgICB9XG5cbiAgICBzZXR1cEdyb3VwU3RhY2tzKCkge1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICB2YXIgeTBzID0gW107XG4gICAgICAgIHRoaXMucGxvdC5ncm91cGVkRGF0YS5mb3JFYWNoKGQ9PntcbiAgICAgICAgICAgIGQuaGlzdG9ncmFtQmlucyA9IHRoaXMucGxvdC5oaXN0b2dyYW0oZC52YWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgZC5oaXN0b2dyYW1CaW5zLmZvckVhY2goKGIsaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBiLnggPWIueDA7XG4gICAgICAgICAgICAgICAgICAgIGIuZHggPSBiLngxLWIueDA7XG4gICAgICAgICAgICAgICAgICAgIGIueSA9IGIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlkwID0geTBzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZighcHJldlkwKSBwcmV2WTAgPSAwO1xuICAgICAgICAgICAgICAgICAgICBiLnkwID0gcHJldlkwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmNvbmZpZy5mcmVxdWVuY3kpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYi55Lz10aGlzLnBsb3QuZGF0YUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkwc1tpXSA9IGIueStwcmV2WTA7XG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGEubWFwKGQ9PmQua2V5KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wbG90Lmdyb3VwZWREYXRhKTtcblxuICAgICAgICB0aGlzLnBsb3Quc3RhY2sgPSBkMy5zdGFjaygpLmtleXMoa2V5cykudmFsdWUoZD0+ZC5oaXN0b2dyYW1CaW5zKTtcbiAgICAgICAgdGhpcy5wbG90LnN0YWNrZWRIaXN0b2dyYW1zID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuICAgIH1cblxuICAgIGRyYXdBeGlzWCgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy54O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcy14JykrXCIuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpKyhzZWxmLmNvbmZpZy5ndWlkZXMgPyAnJyA6ICcuJytzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnguYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAocGxvdC53aWR0aC8yKSArXCIsXCIrIChwbG90Lm1hcmdpbi5ib3R0b20pICtcIilcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCItMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICBkcmF3QXhpc1koKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpK1wiLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSsoc2VsZi5jb25maWcuZ3VpZGVzID8gJycgOiAnLicrc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKTtcblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueS5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIitzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIC1wbG90Lm1hcmdpbi5sZWZ0ICtcIixcIisocGxvdC5oZWlnaHQvMikrXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuXG4gICAgZHJhd0hpc3RvZ3JhbSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgXG4gICAgICAgIHZhciBsYXllckNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcImxheWVyXCIpO1xuXG4gICAgICAgIHZhciBiYXJDbGFzcyA9IHRoaXMucHJlZml4Q2xhc3MoXCJiYXJcIik7XG4gICAgICAgIHZhciBsYXllciA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCIuXCIrbGF5ZXJDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHBsb3Quc3RhY2tlZEhpc3RvZ3JhbXMpO1xuXG4gICAgICAgIHZhciBsYXllck1lcmdlID0gbGF5ZXIuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGxheWVyQ2xhc3MpLm1lcmdlKGxheWVyKTtcblxuXG4gICAgICAgIHZhciBiYXIgPSBsYXllck1lcmdlLnNlbGVjdEFsbChcIi5cIitiYXJDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKGQgPT4gZC5oaXN0b2dyYW1CaW5zKTtcblxuICAgICAgICB2YXIgYmFyRW50ZXIgPSBiYXIuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuICAgICAgICBiYXJFbnRlclxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBiYXJDbGFzcylcbiAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMSk7XG5cbiAgICAgICAgdmFyIGJhck1lcmdlID0gYmFyRW50ZXIubWVyZ2UoYmFyKTtcbiAgICAgICAgdmFyIGJhclJlY3QgPSBiYXJNZXJnZS5zZWxlY3QoXCJyZWN0XCIpO1xuXG4gICAgICAgIHZhciBiYXJSZWN0VCA9IGJhclJlY3Q7XG4gICAgICAgIHZhciBiYXJUID0gYmFyTWVyZ2U7XG4gICAgICAgIHZhciBsYXllclQgPSBsYXllck1lcmdlO1xuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBiYXJSZWN0VCA9IGJhclJlY3QudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgYmFyVCA9IGJhck1lcmdlLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGxheWVyVD0gbGF5ZXJNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXJULmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBwbG90Lnguc2NhbGUoZC54KSArIFwiLFwiICsgKHBsb3QueS5zY2FsZShkLnkwICtkLnkpKSArIFwiKVwiOyB9KTtcbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHBsb3Quc3RhY2tlZEhpc3RvZ3JhbXMubGVuZ3RoID8gKHBsb3Quc3RhY2tlZEhpc3RvZ3JhbXNbMF0uaGlzdG9ncmFtQmlucy5sZW5ndGggPyAgcGxvdC54LnNjYWxlKHBsb3Quc3RhY2tlZEhpc3RvZ3JhbXNbMF0uaGlzdG9ncmFtQmluc1swXS54MSktcGxvdC54LnNjYWxlKHBsb3Quc3RhY2tlZEhpc3RvZ3JhbXNbMF0uaGlzdG9ncmFtQmluc1swXS54MCktMSA6IDApIDogMDtcblxuXG4gICAgICAgIGJhclJlY3RUXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsICBkPT4gIE1hdGgubWF4KDAsIHBsb3QueC5zY2FsZShkLngxKS1wbG90Lnguc2NhbGUoZC54MCktMSkgKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiAgIHBsb3QuaGVpZ2h0IC0gcGxvdC55LnNjYWxlKGQueSkpO1xuXG4gICAgICAgIGlmKHRoaXMucGxvdC5jb2xvcil7XG4gICAgICAgICAgICBsYXllclRcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgdGhpcy5wbG90LnNlcmllc0NvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwbG90LnRvb2x0aXApIHtcbiAgICAgICAgICAgIGJhck1lcmdlLm9uKFwibW91c2VvdmVyXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Rvb2x0aXAoZC55KTtcbiAgICAgICAgICAgIH0pLm9uKFwibW91c2VvdXRcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICBiYXIuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWCgpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWSgpO1xuXG4gICAgICAgIHRoaXMuZHJhd0hpc3RvZ3JhbSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuIiwiaW1wb3J0IHtEM0V4dGVuc2lvbnN9IGZyb20gJy4vZDMtZXh0ZW5zaW9ucydcbkQzRXh0ZW5zaW9ucy5leHRlbmQoKTtcblxuZXhwb3J0IHtTY2F0dGVyUGxvdCwgU2NhdHRlclBsb3RDb25maWd9IGZyb20gXCIuL3NjYXR0ZXJwbG90XCI7XG5leHBvcnQge1NjYXR0ZXJQbG90TWF0cml4LCBTY2F0dGVyUGxvdE1hdHJpeENvbmZpZ30gZnJvbSBcIi4vc2NhdHRlcnBsb3QtbWF0cml4XCI7XG5leHBvcnQge1JlZ3Jlc3Npb24sIFJlZ3Jlc3Npb25Db25maWd9IGZyb20gJy4vcmVncmVzc2lvbidcbmV4cG9ydCB7Q29ycmVsYXRpb25NYXRyaXgsIENvcnJlbGF0aW9uTWF0cml4Q29uZmlnfSBmcm9tICcuL2NvcnJlbGF0aW9uLW1hdHJpeCdcbmV4cG9ydCB7SGVhdG1hcCwgSGVhdG1hcENvbmZpZ30gZnJvbSAnLi9oZWF0bWFwJ1xuZXhwb3J0IHtIZWF0bWFwVGltZVNlcmllcywgSGVhdG1hcFRpbWVTZXJpZXNDb25maWd9IGZyb20gJy4vaGVhdG1hcC10aW1lc2VyaWVzJ1xuZXhwb3J0IHtIaXN0b2dyYW0sIEhpc3RvZ3JhbUNvbmZpZ30gZnJvbSAnLi9oaXN0b2dyYW0nXG5leHBvcnQge0JhckNoYXJ0LCBCYXJDaGFydENvbmZpZ30gZnJvbSAnLi9iYXItY2hhcnQnXG5leHBvcnQge0JveFBsb3RCYXNlLCBCb3hQbG90QmFzZUNvbmZpZ30gZnJvbSAnLi9ib3gtcGxvdC1iYXNlJ1xuZXhwb3J0IHtCb3hQbG90LCBCb3hQbG90Q29uZmlnfSBmcm9tICcuL2JveC1wbG90J1xuZXhwb3J0IHtEaXZlcmdpbmdTdGFja2VkQmFyQ2hhcnQsIERpdmVyZ2luZ1N0YWNrZWRCYXJDaGFydENvbmZpZ30gZnJvbSAnLi9kaXZlcmdpbmctc3RhY2tlZC1iYXItY2hhcnQnXG5leHBvcnQge0xpbmVDaGFydCwgTGluZUNoYXJ0Q29uZmlnfSBmcm9tICcuL2xpbmUtY2hhcnQnXG5leHBvcnQge1N0YXRpc3RpY3NVdGlsc30gZnJvbSAnLi9zdGF0aXN0aWNzLXV0aWxzJ1xuZXhwb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmV4cG9ydCB7TGVnZW5kfSBmcm9tICcuL2xlZ2VuZCdcblxuXG5cblxuXG4iLCJpbXBvcnQge1V0aWxzfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5pbXBvcnQge2xlZ2VuZENvbG9yLCBsZWdlbmRTaXplLCBsZWdlbmRTeW1ib2x9IGZyb20gJ2QzLXN2Zy1sZWdlbmQnXG5cblxuLyp2YXIgZDMgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2QzJyk7XG4qL1xuLy8gdmFyIGxlZ2VuZCA9IHJlcXVpcmUoJy4uL2Jvd2VyX2NvbXBvbmVudHMvZDMtbGVnZW5kL25vLWV4dGVuZCcpO1xuLy9cbi8vIG1vZHVsZS5leHBvcnRzLmxlZ2VuZCA9IGxlZ2VuZDtcblxuZXhwb3J0IGNsYXNzIExlZ2VuZCB7XG5cbiAgICBjc3NDbGFzc1ByZWZpeD1cIm9kYy1cIjtcbiAgICBsZWdlbmRDbGFzcz10aGlzLmNzc0NsYXNzUHJlZml4K1wibGVnZW5kXCI7XG4gICAgY29udGFpbmVyO1xuICAgIHNjYWxlO1xuICAgIGNvbG9yPSBsZWdlbmRDb2xvcjtcbiAgICBzaXplID0gbGVnZW5kU2l6ZTtcbiAgICBzeW1ib2w9IGxlZ2VuZFN5bWJvbDtcbiAgICBndWlkO1xuXG4gICAgbGFiZWxGb3JtYXQgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdHJ1Y3RvcihzdmcsIGxlZ2VuZFBhcmVudCwgc2NhbGUsIGxlZ2VuZFgsIGxlZ2VuZFksIGxhYmVsRm9ybWF0KXtcbiAgICAgICAgdGhpcy5zY2FsZT1zY2FsZTtcbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgICAgIHRoaXMuZ3VpZCA9IFV0aWxzLmd1aWQoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSAgVXRpbHMuc2VsZWN0T3JBcHBlbmQobGVnZW5kUGFyZW50LCBcImcuXCIrdGhpcy5sZWdlbmRDbGFzcywgXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIitsZWdlbmRYK1wiLFwiK2xlZ2VuZFkrXCIpXCIpXG4gICAgICAgICAgICAuY2xhc3NlZCh0aGlzLmxlZ2VuZENsYXNzLCB0cnVlKTtcblxuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0ID0gbGFiZWxGb3JtYXQ7XG4gICAgfVxuXG5cblxuICAgIGxpbmVhckdyYWRpZW50QmFyKGJhcldpZHRoLCBiYXJIZWlnaHQsIHRpdGxlKXtcbiAgICAgICAgdmFyIGdyYWRpZW50SWQgPSB0aGlzLmNzc0NsYXNzUHJlZml4K1wibGluZWFyLWdyYWRpZW50XCIrXCItXCIrdGhpcy5ndWlkO1xuICAgICAgICB2YXIgc2NhbGU9IHRoaXMuc2NhbGU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLmxpbmVhckdyYWRpZW50ID0gVXRpbHMubGluZWFyR3JhZGllbnQodGhpcy5zdmcsIGdyYWRpZW50SWQsIHRoaXMuc2NhbGUucmFuZ2UoKSwgMCwgMTAwLCAwLCAwKTtcblxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zZWxlY3RPckFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgYmFyV2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBiYXJIZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcInVybCgjXCIrZ3JhZGllbnRJZCtcIilcIik7XG5cblxuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLmNvbnRhaW5lci5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuZGF0YSggc2NhbGUuZG9tYWluKCkgKTtcbiAgICAgICAgdmFyIHRpY2tzTnVtYmVyID1zY2FsZS5kb21haW4oKS5sZW5ndGgtMTtcbiAgICAgICAgdmFyIHRpY2tzTWVyZ2UgPSB0aWNrcy5lbnRlcigpLmFwcGVuZChcInRleHRcIikubWVyZ2UodGlja3MpO1xuXG4gICAgICAgIHRpY2tzTWVyZ2UuYXR0cihcInhcIiwgYmFyV2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgIChkLCBpKSA9PiAgYmFySGVpZ2h0IC0oaSpiYXJIZWlnaHQvdGlja3NOdW1iZXIpKVxuICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAzKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJkeVwiLCAxKVxuICAgICAgICAgICAgLmF0dHIoXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGQ9PiBzZWxmLmxhYmVsRm9ybWF0ID8gc2VsZi5sYWJlbEZvcm1hdChkKSA6IGQpO1xuICAgICAgICB0aWNrc01lcmdlLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKVxuICAgICAgICBpZih0aGlzLnJvdGF0ZUxhYmVscyl7XG4gICAgICAgICAgICB0aWNrc01lcmdlXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IFwicm90YXRlKC00NSwgXCIgKyBiYXJXaWR0aCArIFwiLCBcIiArIChiYXJIZWlnaHQgLShpKmJhckhlaWdodC90aWNrc051bWJlcikpICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCA1KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgNSk7XG5cbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRpY2tzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRSb3RhdGVMYWJlbHMocm90YXRlTGFiZWxzKSB7XG4gICAgICAgIHRoaXMucm90YXRlTGFiZWxzID0gcm90YXRlTGFiZWxzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBcbn0iLCJpbXBvcnQge0NoYXJ0V2l0aENvbG9yR3JvdXBzLCBDaGFydFdpdGhDb2xvckdyb3Vwc0NvbmZpZ30gZnJvbSBcIi4vY2hhcnQtd2l0aC1jb2xvci1ncm91cHNcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgTGluZUNoYXJ0Q29uZmlnIGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWd7XG5cbiAgICBzdmdDbGFzcz0gdGhpcy5jc3NDbGFzc1ByZWZpeCsnbGluZS1jaGFydCc7XG4gICAgZ3VpZGVzPSBmYWxzZTsgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgc2hvd1Rvb2x0aXA9IHRydWU7IC8vc2hvdyB0b29sdGlwIG9uIGRvdCBob3ZlclxuXG4gICAgeD17Ly8gWCBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgbGFiZWxcbiAgICAgICAga2V5OiAwLFxuICAgICAgICB2YWx1ZTogKGQsIGtleSkgPT4gZFtrZXldLCAvLyB4IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIG9yaWVudDogXCJib3R0b21cIixcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4wNVxuICAgIH07XG4gICAgeT17Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgbGFiZWwsXG4gICAgICAgIGtleTogMSxcbiAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IGRba2V5XSwgLy8geSB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBvcmllbnQ6IFwibGVmdFwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgZG9tYWluTWFyZ2luOiAwLjA1XG4gICAgfTtcbiAgICBncm91cHM9e1xuICAgICAgICBrZXk6IDJcbiAgICB9O1xuXG4gICAgZG90UmFkaXVzID0gMjtcbiAgICBkb3RJZCA9IChkLCBpKT0+IHVuZGVmaW5lZDtcbiAgICB0cmFuc2l0aW9uPSB0cnVlO1xuICAgIG9uRG90SG92ZXIgPSAoZCwgaSkgPT4ge307XG4gICAgb25Eb3RIb3Zlck91dCA9IChkLCBpKSA9PiB7fTtcbiAgICBsaW5lSWQgPSAoZCwgaSk9PiB1bmRlZmluZWQ7XG4gICAgdHJhbnNpdGlvbj0gdHJ1ZTtcbiAgICBvbkxpbmVIb3ZlciA9IChkLCBpKSA9PiB7fTtcbiAgICBvbkxpbmVIb3Zlck91dCA9IChkLCBpKSA9PiB7fTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG5cblxuXG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIExpbmVDaGFydCBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBze1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgTGluZUNoYXJ0Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBMaW5lQ2hhcnRDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKXtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcblxuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54PXt9O1xuICAgICAgICB0aGlzLnBsb3QueT17fTtcblxuICAgICAgICB0aGlzLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnNldHVwWCgpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWCgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy54O1xuXG4gICAgICAgIC8qICpcbiAgICAgICAgICogdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAgICAgICAqIHNjYWxlIC0gbWFwcyB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzIGEgcGl4ZWwgcG9zaXRpb24uXG4gICAgICAgICAqIG1hcCBmdW5jdGlvbiAtIG1hcHMgZnJvbSBkYXRhIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICogYXhpcyAtIHNldHMgdXAgYXhpc1xuICAgICAgICAgKiovXG4gICAgICAgIHgudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuICAgICAgICBcbiAgICAgICAgeC5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFswLCBwbG90LndpZHRoXSk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuICAgICAgICBcbiAgICAgICAgeC5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeC5zY2FsZSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG5cbiAgICAgICAgdmFyIGRvbWFpbiA9IFtwYXJzZUZsb2F0KGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueC52YWx1ZSkpKSwgcGFyc2VGbG9hdChkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBwbG90LngudmFsdWUpKSldO1xuICAgICAgICB2YXIgZXh0ZW50ID0gKGRvbWFpblsxXS1kb21haW5bMF0pIHx8IDE7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoZXh0ZW50KSogY29uZi5kb21haW5NYXJnaW47XG4gICAgICAgIGRvbWFpblswXS09bWFyZ2luO1xuICAgICAgICBkb21haW5bMV0rPW1hcmdpbjtcbiAgICAgICAgcGxvdC54LnNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgICAgICBpZih0aGlzLmNvbmZpZy5ndWlkZXMpIHtcbiAgICAgICAgICAgIHguYXhpcy50aWNrU2l6ZSgtcGxvdC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZICgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy55O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIHkudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuXG4gICAgICAgIHkuc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnNjYWxlKS5yYW5nZShbcGxvdC5oZWlnaHQsIDBdKTtcblxuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcblxuICAgICAgICBpZih0aGlzLmNvbmZpZy5ndWlkZXMpe1xuICAgICAgICAgICAgeS5heGlzLnRpY2tTaXplKC1wbG90LndpZHRoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG5cbiAgICAgICAgdmFyIGRvbWFpbiA9IFtwYXJzZUZsb2F0KGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueS52YWx1ZSkpKSwgcGFyc2VGbG9hdChkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBwbG90LnkudmFsdWUpKSldO1xuICAgICAgICB2YXIgZXh0ZW50ID0gKGRvbWFpblsxXS1kb21haW5bMF0pIHx8IDE7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoZXh0ZW50KSogY29uZi5kb21haW5NYXJnaW47XG5cbiAgICAgICAgZG9tYWluWzBdLT1tYXJnaW47XG4gICAgICAgIGRvbWFpblsxXSs9bWFyZ2luO1xuICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIHBsb3QueS5zY2FsZS5kb21haW4oW2QzLm1pbihkYXRhLCBwbG90LnkudmFsdWUpLTEsIGQzLm1heChkYXRhLCBwbG90LnkudmFsdWUpKzFdKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNYKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLng7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzLXgnKStcIi5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzJykrKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nK3NlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnguYXhpcyk7XG4gICAgICAgIFxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIitzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIChwbG90LndpZHRoLzIpICtcIixcIisgKHBsb3QubWFyZ2luLmJvdHRvbSkgK1wiKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi0xZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIGRyYXdBeGlzWSgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcy15JykrXCIuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpKyhzZWxmLmNvbmZpZy5ndWlkZXMgPyAnJyA6ICcuJytzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnkuYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAtcGxvdC5tYXJnaW4ubGVmdCArXCIsXCIrKHBsb3QuaGVpZ2h0LzIpK1wiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1goKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1koKTtcbiAgICAgICAgdGhpcy51cGRhdGVMaW5lcygpO1xuICAgIH07XG5cbiAgICB1cGRhdGVMaW5lcygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGRhdGEgPSBwbG90LmRhdGE7XG4gICAgICAgIHZhciBsYXllckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnbGF5ZXInKTtcbiAgICAgICAgdmFyIGxpbmVDbGFzcyA9IHRoaXMubGluZUNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnbGluZScpO1xuICAgICAgICBzZWxmLmxpbmVzQ29udGFpbmVyQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKCdsaW5lcy1jb250YWluZXInKTtcblxuICAgICAgICB2YXIgbGluZXNDb250YWluZXIgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5saW5lc0NvbnRhaW5lckNsYXNzKTtcblxuICAgICAgICB2YXIgbGF5ZXIgPSBsaW5lc0NvbnRhaW5lci5zZWxlY3RBbGwoXCJnLlwiK2xheWVyQ2xhc3MpLmRhdGEocGxvdC5ncm91cGVkRGF0YSk7XG5cbiAgICAgICAgdmFyIGxheWVyRW50ZXIgPSBsYXllci5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKFwiZy5cIitsYXllckNsYXNzKTtcbiAgICAgICAgdmFyIGxpbmVQYXRoRW50ZXIgPSBsYXllckVudGVyLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgbGluZUNsYXNzKTtcblxuICAgICAgICB2YXIgbGF5ZXJNZXJnZSA9IGxheWVyRW50ZXIubWVyZ2UobGF5ZXIpO1xuXG4gICAgICAgIHZhciBsaW5lUGF0aCA9IGxheWVyTWVyZ2Uuc2VsZWN0KCcuJyArIGxpbmVDbGFzcylcbiAgICAgICAgICAgIC5kYXR1bShkPT5kLnZhbHVlcyk7XG5cbiAgICAgICAgdmFyIGxpbmVQYXRoTWVyZ2UgPSBsaW5lUGF0aEVudGVyLm1lcmdlKGxpbmVQYXRoKTtcblxuICAgICAgICB2YXIgbGluZVBhdGhUID0gbGluZVBhdGhNZXJnZTtcbiAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgbGluZVBhdGhUID0gbGluZVBhdGhNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZSA9IGQzLmxpbmUoKVxuICAgICAgICAgICAgLngocGxvdC54Lm1hcClcbiAgICAgICAgICAgIC55KHBsb3QueS5tYXApO1xuXG4gICAgICAgIGxpbmVQYXRoVFxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJzdHJva2VcIiwgXCJzdGVlbGJsdWVcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLWxpbmVqb2luXCIsIFwicm91bmRcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCB0aGlzLmNvbmZpZy5saW5lSWQpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZSk7XG5cblxuICAgICAgICAvL1RPRE8gYWRkIHRvb2x0aXBcblxuICAgICAgICBsaW5lUGF0aE1lcmdlLm9uKFwibW91c2VvdmVyLm9uTGluZUhvdmVyXCIsIHRoaXMuY29uZmlnLm9uTGluZUhvdmVyKTtcbiAgICAgICAgbGluZVBhdGhNZXJnZS5vbihcIm1vdXNlb3V0Lm9uTGluZUhvdmVyT3V0XCIsIHRoaXMuY29uZmlnLm9uTGluZUhvdmVyT3V0KTtcblxuICAgICAgICBpZiAocGxvdC5zZXJpZXNDb2xvcikge1xuICAgICAgICAgICAgbGF5ZXJNZXJnZS5zdHlsZShcInN0cm9rZVwiLCBwbG90LnNlcmllc0NvbG9yKVxuICAgICAgICB9ZWxzZSBpZihwbG90LmNvbG9yKXtcbiAgICAgICAgICAgIGxpbmVQYXRoTWVyZ2Uuc3R5bGUoXCJzdHJva2VcIiwgcGxvdC5jb2xvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVQYXRoLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgdmFyIGRvdENsYXNzID0gdGhpcy5kb3RDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2RvdCcpO1xuXG4gICAgICAgIHZhciBkb3RzID0gbGF5ZXJNZXJnZS5zZWxlY3RBbGwoJy4nICsgZG90Q2xhc3MpXG4gICAgICAgICAgICAuZGF0YShkPT5kLnZhbHVlcyk7XG5cbiAgICAgICAgdmFyIGRvdHNFbnRlciA9IGRvdHMuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZG90Q2xhc3MpO1xuXG4gICAgICAgIHZhciBkb3RzTWVyZ2UgPSBkb3RzRW50ZXIubWVyZ2UoZG90cyk7XG5cbiAgICAgICAgdmFyIGRvdHNUID0gZG90c01lcmdlO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBkb3RzVCA9IGRvdHNNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3RzVC5hdHRyKFwiclwiLCBzZWxmLmNvbmZpZy5kb3RSYWRpdXMpXG4gICAgICAgICAgICAuYXR0cihcImN4XCIsIHBsb3QueC5tYXApXG4gICAgICAgICAgICAuYXR0cihcImN5XCIsIHBsb3QueS5tYXApXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIHRoaXMuY29uZmlnLmRvdElkKTtcblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICBkb3RzTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBcIihcIiArIHBsb3QueC52YWx1ZShkKSArIFwiLCBcIiArIHBsb3QueS52YWx1ZShkKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHNlbGYuY29uZmlnLmdyb3VwcyA/ICBzZWxmLmNvbmZpZy5ncm91cHMudmFsdWUuY2FsbChzZWxmLmNvbmZpZyxkKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwIHx8IGdyb3VwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcGxvdC5ncm91cFRvTGFiZWxbZ3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IFwiPGJyLz5cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gc2VsZi5jb25maWcuZ3JvdXBzLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gbGFiZWwgKyBcIjogXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBncm91cFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZG90c01lcmdlLm9uKFwibW91c2VvdmVyLm9uRG90SG92ZXJcIiwgdGhpcy5jb25maWcub25Eb3RIb3Zlcik7XG4gICAgICAgIGRvdHNNZXJnZS5vbihcIm1vdXNlb3V0Lm9uRG90SG92ZXJPdXRcIiwgdGhpcy5jb25maWcub25Eb3RIb3Zlck91dCk7XG5cbiAgICAgICAgaWYgKHBsb3Quc2VyaWVzQ29sb3IpIHtcbiAgICAgICAgICAgIGxheWVyTWVyZ2Uuc3R5bGUoXCJmaWxsXCIsIHBsb3Quc2VyaWVzQ29sb3IpXG4gICAgICAgIH1lbHNlIGlmKHBsb3QuY29sb3Ipe1xuICAgICAgICAgICAgZG90c01lcmdlLnN0eWxlKFwiZmlsbFwiLCBwbG90LmNvbG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgZG90cy5leGl0KCkucmVtb3ZlKCk7XG5cblxuXG4gICAgICAgIGxheWVyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7U2NhdHRlclBsb3QsIFNjYXR0ZXJQbG90Q29uZmlnfSBmcm9tIFwiLi9zY2F0dGVycGxvdFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7U3RhdGlzdGljc1V0aWxzfSBmcm9tICcuL3N0YXRpc3RpY3MtdXRpbHMnXG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgUmVncmVzc2lvbkNvbmZpZyBleHRlbmRzIFNjYXR0ZXJQbG90Q29uZmlne1xuXG4gICAgbWFpblJlZ3Jlc3Npb24gPSB0cnVlO1xuICAgIGdyb3VwUmVncmVzc2lvbiA9IHRydWU7XG4gICAgY29uZmlkZW5jZT17XG4gICAgICAgIGxldmVsOiAwLjk1LFxuICAgICAgICBjcml0aWNhbFZhbHVlOiAoZGVncmVlc09mRnJlZWRvbSwgY3JpdGljYWxQcm9iYWJpbGl0eSkgPT4gU3RhdGlzdGljc1V0aWxzLnRWYWx1ZShkZWdyZWVzT2ZGcmVlZG9tLCBjcml0aWNhbFByb2JhYmlsaXR5KSxcbiAgICAgICAgbWFyZ2luT2ZFcnJvcjogdW5kZWZpbmVkLCAvL2N1c3RvbSAgbWFyZ2luIE9mIEVycm9yIGZ1bmN0aW9uICh4LCBwb2ludHMpXG4gICAgICAgIGFyZWFDdXJ2ZTogZDMuY3VydmVOYXR1cmFsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVncmVzc2lvbiBleHRlbmRzIFNjYXR0ZXJQbG90e1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgUmVncmVzc2lvbkNvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKXtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgUmVncmVzc2lvbkNvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpe1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB0aGlzLmluaXRSZWdyZXNzaW9uTGluZXMoKTtcbiAgICB9XG5cbiAgICBpbml0UmVncmVzc2lvbkxpbmVzKCl7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JvdXBzQXZhaWxhYmxlID0gc2VsZi5wbG90Lmdyb3VwaW5nRW5hYmxlZDtcblxuICAgICAgICBzZWxmLnBsb3QucmVncmVzc2lvbnM9IFtdO1xuXG5cbiAgICAgICAgaWYoZ3JvdXBzQXZhaWxhYmxlICYmIHNlbGYuY29uZmlnLm1haW5SZWdyZXNzaW9uKXtcbiAgICAgICAgICAgIHZhciByZWdyZXNzaW9uID0gdGhpcy5pbml0UmVncmVzc2lvbih0aGlzLnBsb3QuZGF0YSwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5wbG90LnJlZ3Jlc3Npb25zLnB1c2gocmVncmVzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihzZWxmLmNvbmZpZy5ncm91cFJlZ3Jlc3Npb24pe1xuICAgICAgICAgICAgdGhpcy5pbml0R3JvdXBSZWdyZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGluaXRHcm91cFJlZ3Jlc3Npb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEuZm9yRWFjaChncm91cD0+e1xuICAgICAgICAgICAgaWYoZ3JvdXAudmFsdWVzLmxlbmd0aDwyKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdyZXNzaW9uID0gdGhpcy5pbml0UmVncmVzc2lvbihncm91cC52YWx1ZXMsIGdyb3VwLmtleSk7XG4gICAgICAgICAgICBzZWxmLnBsb3QucmVncmVzc2lvbnMucHVzaChyZWdyZXNzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5pdFJlZ3Jlc3Npb24odmFsdWVzLCBncm91cFZhbCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgcG9pbnRzID0gdmFsdWVzLm1hcChkPT57XG4gICAgICAgICAgICByZXR1cm4gW3BhcnNlRmxvYXQoc2VsZi5wbG90LngudmFsdWUoZCkpLCBwYXJzZUZsb2F0KHNlbGYucGxvdC55LnZhbHVlKGQpKV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBvaW50cy5zb3J0KChhLGIpID0+IGFbMF0tYlswXSk7XG5cbiAgICAgICAgdmFyIGxpbmVhclJlZ3Jlc3Npb24gPSAgU3RhdGlzdGljc1V0aWxzLmxpbmVhclJlZ3Jlc3Npb24ocG9pbnRzKTtcbiAgICAgICAgdmFyIGxpbmVhclJlZ3Jlc3Npb25MaW5lID0gU3RhdGlzdGljc1V0aWxzLmxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24pO1xuXG5cbiAgICAgICAgdmFyIGV4dGVudFggPSBkMy5leHRlbnQocG9pbnRzLCBkPT5kWzBdKTtcblxuXG4gICAgICAgIHZhciBsaW5lUG9pbnRzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6IGV4dGVudFhbMF0sXG4gICAgICAgICAgICAgICAgeTogbGluZWFyUmVncmVzc2lvbkxpbmUoZXh0ZW50WFswXSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeDogZXh0ZW50WFsxXSxcbiAgICAgICAgICAgICAgICB5OiBsaW5lYXJSZWdyZXNzaW9uTGluZShleHRlbnRYWzFdKVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIHZhciBsaW5lID0gZDMubGluZSgpXG4gICAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcylcbiAgICAgICAgICAgIC54KGQgPT4gc2VsZi5wbG90Lnguc2NhbGUoZC54KSlcbiAgICAgICAgICAgIC55KGQgPT4gc2VsZi5wbG90Lnkuc2NhbGUoZC55KSk7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gc2VsZi5wbG90LmNvbG9yO1xuXG4gICAgICAgIHZhciBkZWZhdWx0Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICAgIGlmKFV0aWxzLmlzRnVuY3Rpb24oY29sb3IpKXtcbiAgICAgICAgICAgIGlmKHZhbHVlcy5sZW5ndGggJiYgZ3JvdXBWYWwhPT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgaWYoc2VsZi5jb25maWcuc2VyaWVzKXtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPXNlbGYucGxvdC5jb2xvckNhdGVnb3J5KGdyb3VwVmFsKTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcih2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIGlmKCFjb2xvciAmJiBncm91cFZhbD09PWZhbHNlKXtcbiAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdENvbG9yO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgY29uZmlkZW5jZSA9IHRoaXMuY29tcHV0ZUNvbmZpZGVuY2UocG9pbnRzLCBleHRlbnRYLCAgbGluZWFyUmVncmVzc2lvbixsaW5lYXJSZWdyZXNzaW9uTGluZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cDogZ3JvdXBWYWwgfHwgZmFsc2UsXG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgbGluZVBvaW50czogbGluZVBvaW50cyxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IGNvbmZpZGVuY2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wdXRlQ29uZmlkZW5jZShwb2ludHMsIGV4dGVudFgsIGxpbmVhclJlZ3Jlc3Npb24sbGluZWFyUmVncmVzc2lvbkxpbmUpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzbG9wZSA9IGxpbmVhclJlZ3Jlc3Npb24ubTtcbiAgICAgICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVncmVlc09mRnJlZWRvbSA9IE1hdGgubWF4KDAsIG4tMik7XG5cbiAgICAgICAgdmFyIGFscGhhID0gMSAtIHNlbGYuY29uZmlnLmNvbmZpZGVuY2UubGV2ZWw7XG4gICAgICAgIHZhciBjcml0aWNhbFByb2JhYmlsaXR5ICA9IDEgLSBhbHBoYS8yO1xuICAgICAgICB2YXIgY3JpdGljYWxWYWx1ZSA9IHNlbGYuY29uZmlnLmNvbmZpZGVuY2UuY3JpdGljYWxWYWx1ZShkZWdyZWVzT2ZGcmVlZG9tLGNyaXRpY2FsUHJvYmFiaWxpdHkpO1xuXG4gICAgICAgIHZhciB4VmFsdWVzID0gcG9pbnRzLm1hcChkPT5kWzBdKTtcbiAgICAgICAgdmFyIG1lYW5YID0gU3RhdGlzdGljc1V0aWxzLm1lYW4oeFZhbHVlcyk7XG4gICAgICAgIHZhciB4TXlTdW09MDtcbiAgICAgICAgdmFyIHhTdW09MDtcbiAgICAgICAgdmFyIHhQb3dTdW09MDtcbiAgICAgICAgdmFyIHlTdW09MDtcbiAgICAgICAgdmFyIHlQb3dTdW09MDtcbiAgICAgICAgcG9pbnRzLmZvckVhY2gocD0+e1xuICAgICAgICAgICAgdmFyIHggPSBwWzBdO1xuICAgICAgICAgICAgdmFyIHkgPSBwWzFdO1xuXG4gICAgICAgICAgICB4TXlTdW0gKz0geCp5O1xuICAgICAgICAgICAgeFN1bSs9eDtcbiAgICAgICAgICAgIHlTdW0rPXk7XG4gICAgICAgICAgICB4UG93U3VtKz0geCp4O1xuICAgICAgICAgICAgeVBvd1N1bSs9IHkqeTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhID0gbGluZWFyUmVncmVzc2lvbi5tO1xuICAgICAgICB2YXIgYiA9IGxpbmVhclJlZ3Jlc3Npb24uYjtcblxuICAgICAgICB2YXIgU2EyID0gbi8obisyKSAqICgoeVBvd1N1bS1hKnhNeVN1bS1iKnlTdW0pLyhuKnhQb3dTdW0tKHhTdW0qeFN1bSkpKTsgLy9XYXJpYW5jamEgd3Nww7PFgmN6eW5uaWthIGtpZXJ1bmtvd2VnbyByZWdyZXNqaSBsaW5pb3dlaiBhXG4gICAgICAgIHZhciBTeTIgPSAoeVBvd1N1bSAtIGEqeE15U3VtLWIqeVN1bSkvKG4qKG4tMikpOyAvL1NhMiAvL01lYW4geSB2YWx1ZSB2YXJpYW5jZVxuXG4gICAgICAgIHZhciBlcnJvckZuID0geD0+IE1hdGguc3FydChTeTIgKyBNYXRoLnBvdyh4LW1lYW5YLDIpKlNhMik7IC8vcGllcndpYXN0ZWsga3dhZHJhdG93eSB6IHdhcmlhbmNqaSBkb3dvbG5lZ28gcHVua3R1IHByb3N0ZWpcbiAgICAgICAgdmFyIG1hcmdpbk9mRXJyb3IgPSAgeD0+IGNyaXRpY2FsVmFsdWUqIGVycm9yRm4oeCk7XG5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbicsIG4sICdkZWdyZWVzT2ZGcmVlZG9tJywgZGVncmVlc09mRnJlZWRvbSwgJ2NyaXRpY2FsUHJvYmFiaWxpdHknLGNyaXRpY2FsUHJvYmFiaWxpdHkpO1xuICAgICAgICAvLyB2YXIgY29uZmlkZW5jZURvd24gPSB4ID0+IGxpbmVhclJlZ3Jlc3Npb25MaW5lKHgpIC0gIG1hcmdpbk9mRXJyb3IoeCk7XG4gICAgICAgIC8vIHZhciBjb25maWRlbmNlVXAgPSB4ID0+IGxpbmVhclJlZ3Jlc3Npb25MaW5lKHgpICsgIG1hcmdpbk9mRXJyb3IoeCk7XG5cblxuICAgICAgICB2YXIgY29tcHV0ZUNvbmZpZGVuY2VBcmVhUG9pbnQgPSB4PT57XG4gICAgICAgICAgICB2YXIgbGluZWFyUmVncmVzc2lvbiA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKHgpO1xuICAgICAgICAgICAgdmFyIG1vZSA9IG1hcmdpbk9mRXJyb3IoeCk7XG4gICAgICAgICAgICB2YXIgY29uZkRvd24gPSBsaW5lYXJSZWdyZXNzaW9uIC0gbW9lO1xuICAgICAgICAgICAgdmFyIGNvbmZVcCA9IGxpbmVhclJlZ3Jlc3Npb24gKyBtb2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTA6IGNvbmZEb3duLFxuICAgICAgICAgICAgICAgIHkxOiBjb25mVXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjZW50ZXJYID0gKGV4dGVudFhbMV0rZXh0ZW50WFswXSkvMjtcblxuICAgICAgICAvLyB2YXIgY29uZmlkZW5jZUFyZWFQb2ludHMgPSBbZXh0ZW50WFswXSwgY2VudGVyWCwgIGV4dGVudFhbMV1dLm1hcChjb21wdXRlQ29uZmlkZW5jZUFyZWFQb2ludCk7XG4gICAgICAgIHZhciBjb25maWRlbmNlQXJlYVBvaW50cyA9IFtleHRlbnRYWzBdLCBjZW50ZXJYLCAgZXh0ZW50WFsxXV0ubWFwKGNvbXB1dGVDb25maWRlbmNlQXJlYVBvaW50KTtcblxuICAgICAgICB2YXIgZml0SW5QbG90ID0geSA9PiB5O1xuXG4gICAgICAgIHZhciBjb25maWRlbmNlQXJlYSA9ICBkMy5hcmVhKClcbiAgICAgICAgLmN1cnZlKHNlbGYuY29uZmlnLmNvbmZpZGVuY2UuYXJlYUN1cnZlKVxuICAgICAgICAgICAgLngoZCA9PiBzZWxmLnBsb3QueC5zY2FsZShkLngpKVxuICAgICAgICAgICAgLnkwKGQgPT4gZml0SW5QbG90KHNlbGYucGxvdC55LnNjYWxlKGQueTApKSlcbiAgICAgICAgICAgIC55MShkID0+IGZpdEluUGxvdChzZWxmLnBsb3QueS5zY2FsZShkLnkxKSkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcmVhOmNvbmZpZGVuY2VBcmVhLFxuICAgICAgICAgICAgcG9pbnRzOmNvbmZpZGVuY2VBcmVhUG9pbnRzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdXBkYXRlKG5ld0RhdGEpe1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlUmVncmVzc2lvbkxpbmVzKCk7XG5cbiAgICB9O1xuXG4gICAgdXBkYXRlUmVncmVzc2lvbkxpbmVzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByZWdyZXNzaW9uQ29udGFpbmVyQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKFwicmVncmVzc2lvbi1jb250YWluZXJcIik7XG4gICAgICAgIHZhciByZWdyZXNzaW9uQ29udGFpbmVyU2VsZWN0b3IgPSBcImcuXCIrcmVncmVzc2lvbkNvbnRhaW5lckNsYXNzO1xuXG4gICAgICAgIHZhciBjbGlwUGF0aElkID0gc2VsZi5wcmVmaXhDbGFzcyhcImNsaXBcIik7XG5cbiAgICAgICAgdmFyIHJlZ3Jlc3Npb25Db250YWluZXIgPSBzZWxmLnN2Z0cuc2VsZWN0T3JJbnNlcnQocmVncmVzc2lvbkNvbnRhaW5lclNlbGVjdG9yLCBcIi5cIitzZWxmLmRvdHNDb250YWluZXJDbGFzcyk7XG4gICAgICAgIHZhciByZWdyZXNzaW9uQ29udGFpbmVyQ2xpcCA9IHJlZ3Jlc3Npb25Db250YWluZXIuc2VsZWN0T3JBcHBlbmQoXCJjbGlwUGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBjbGlwUGF0aElkKTtcblxuXG4gICAgICAgIHJlZ3Jlc3Npb25Db250YWluZXJDbGlwLnNlbGVjdE9yQXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHNlbGYucGxvdC53aWR0aClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBzZWxmLnBsb3QuaGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKTtcblxuICAgICAgICByZWdyZXNzaW9uQ29udGFpbmVyLmF0dHIoXCJjbGlwLXBhdGhcIiwgKGQsaSkgPT4gXCJ1cmwoI1wiK2NsaXBQYXRoSWQrXCIpXCIpO1xuXG4gICAgICAgIHZhciByZWdyZXNzaW9uQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKFwicmVncmVzc2lvblwiKTtcbiAgICAgICAgdmFyIGNvbmZpZGVuY2VBcmVhQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiY29uZmlkZW5jZVwiKTtcbiAgICAgICAgdmFyIHJlZ3Jlc3Npb25TZWxlY3RvciA9IFwiZy5cIityZWdyZXNzaW9uQ2xhc3M7XG4gICAgICAgIHZhciByZWdyZXNzaW9uID0gcmVncmVzc2lvbkNvbnRhaW5lci5zZWxlY3RBbGwocmVncmVzc2lvblNlbGVjdG9yKVxuICAgICAgICAgICAgLmRhdGEoc2VsZi5wbG90LnJlZ3Jlc3Npb25zLCAoZCxpKT0+IGQuZ3JvdXApO1xuXG5cbiAgICAgICAgdmFyIHJlZ3Jlc3Npb25FbnRlciA9IHJlZ3Jlc3Npb24uZW50ZXIoKS5hcHBlbmRTZWxlY3RvcihyZWdyZXNzaW9uU2VsZWN0b3IpO1xuICAgICAgICB2YXIgcmVncmVzc2lvbk1lcmdlID0gcmVncmVzc2lvbkVudGVyLm1lcmdlKHJlZ3Jlc3Npb24pO1xuICAgICAgICB2YXIgbGluZUNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImxpbmVcIik7XG4gICAgICAgIHJlZ3Jlc3Npb25FbnRlclxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgbGluZUNsYXNzKVxuICAgICAgICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIiwgXCJvcHRpbWl6ZVF1YWxpdHlcIik7XG5cbiAgICAgICAgdmFyIGxpbmUgPSByZWdyZXNzaW9uTWVyZ2Uuc2VsZWN0KFwicGF0aC5cIitsaW5lQ2xhc3MpXG4gICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgciA9PiByLmNvbG9yKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsaW5lVCA9IGxpbmU7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGxpbmVUID0gbGluZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lVC5hdHRyKFwiZFwiLCByID0+IHIubGluZShyLmxpbmVQb2ludHMpKVxuXG5cbiAgICAgICAgcmVncmVzc2lvbkVudGVyXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBjb25maWRlbmNlQXJlYUNsYXNzKVxuICAgICAgICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIiwgXCJvcHRpbWl6ZVF1YWxpdHlcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwLjRcIik7XG5cblxuXG4gICAgICAgIHZhciBhcmVhID0gcmVncmVzc2lvbk1lcmdlLnNlbGVjdChcInBhdGguXCIrY29uZmlkZW5jZUFyZWFDbGFzcyk7XG5cbiAgICAgICAgdmFyIGFyZWFUID0gYXJlYTtcbiAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgYXJlYVQgPSBhcmVhLnRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBhcmVhVC5hdHRyKFwiZFwiLCByID0+IHIuY29uZmlkZW5jZS5hcmVhKHIuY29uZmlkZW5jZS5wb2ludHMpKTtcbiAgICAgICAgYXJlYVQuc3R5bGUoXCJmaWxsXCIsIHIgPT4gci5jb2xvcilcbiAgICAgICAgcmVncmVzc2lvbi5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICB9XG5cblxuXG59XG5cbiIsImltcG9ydCB7Q2hhcnRXaXRoQ29sb3JHcm91cHN9IGZyb20gXCIuL2NoYXJ0LXdpdGgtY29sb3ItZ3JvdXBzXCI7XG5pbXBvcnQge1NjYXR0ZXJQbG90Q29uZmlnfSBmcm9tIFwiLi9zY2F0dGVycGxvdFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7TGVnZW5kfSBmcm9tIFwiLi9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBTY2F0dGVyUGxvdE1hdHJpeENvbmZpZyBleHRlbmRzIFNjYXR0ZXJQbG90Q29uZmlne1xuXG4gICAgc3ZnQ2xhc3M9IHRoaXMuY3NzQ2xhc3NQcmVmaXgrJ3NjYXR0ZXJwbG90LW1hdHJpeCc7XG4gICAgc2l6ZT0gdW5kZWZpbmVkOyAvL3NjYXR0ZXIgcGxvdCBjZWxsIHNpemVcbiAgICBtaW5DZWxsU2l6ZSA9IDUwO1xuICAgIG1heENlbGxTaXplID0gMTAwMDtcbiAgICBwYWRkaW5nPSAyMDsgLy9zY2F0dGVyIHBsb3QgY2VsbCBwYWRkaW5nXG4gICAgYnJ1c2g9IHRydWU7XG4gICAgZ3VpZGVzPSB0cnVlOyAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICBzaG93VG9vbHRpcD0gdHJ1ZTsgLy9zaG93IHRvb2x0aXAgb24gZG90IGhvdmVyXG4gICAgdGlja3M9IHVuZGVmaW5lZDsgLy90aWNrcyBudW1iZXIsIChkZWZhdWx0OiBjb21wdXRlZCB1c2luZyBjZWxsIHNpemUpXG4gICAgeD17Ly8gWCBheGlzIGNvbmZpZ1xuICAgICAgICBvcmllbnQ6IFwiYm90dG9tXCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiXG4gICAgfTtcbiAgICB5PXsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIG9yaWVudDogXCJsZWZ0XCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiXG4gICAgfTtcbiAgICBncm91cHM9e1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCwgLy9vYmplY3QgcHJvcGVydHkgbmFtZSBvciBhcnJheSBpbmRleCB3aXRoIGdyb3VwaW5nIHZhcmlhYmxlXG4gICAgICAgIGluY2x1ZGVJblBsb3Q6IGZhbHNlLCAvL2luY2x1ZGUgZ3JvdXAgYXMgdmFyaWFibGUgaW4gcGxvdCwgYm9vbGVhbiAoZGVmYXVsdDogZmFsc2UpXG4gICAgfTtcbiAgICB2YXJpYWJsZXM9IHtcbiAgICAgICAgbGFiZWxzOiBbXSwgLy9vcHRpb25hbCBhcnJheSBvZiB2YXJpYWJsZSBsYWJlbHMgKGZvciB0aGUgZGlhZ29uYWwgb2YgdGhlIHBsb3QpLlxuICAgICAgICBrZXlzOiBbXSwgLy9vcHRpb25hbCBhcnJheSBvZiB2YXJpYWJsZSBrZXlzXG4gICAgICAgIHZhbHVlOiAoZCwgdmFyaWFibGVLZXkpID0+IGRbdmFyaWFibGVLZXldIC8vIHZhcmlhYmxlIHZhbHVlIGFjY2Vzc29yXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICB9XG5cblxufVxuXG5leHBvcnQgY2xhc3MgU2NhdHRlclBsb3RNYXRyaXggZXh0ZW5kcyBDaGFydFdpdGhDb2xvckdyb3VwcyB7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBTY2F0dGVyUGxvdE1hdHJpeENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IFNjYXR0ZXJQbG90TWF0cml4Q29uZmlnKGNvbmZpZykpO1xuXG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbWFyZ2luID0gdGhpcy5wbG90Lm1hcmdpbjtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdGhpcy5wbG90Lng9e307XG4gICAgICAgIHRoaXMucGxvdC55PXt9O1xuICAgICAgICB0aGlzLnBsb3QuZG90PXtcbiAgICAgICAgICAgIGNvbG9yOiBudWxsLy9jb2xvciBzY2FsZSBtYXBwaW5nIGZ1bmN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldHVwVmFyaWFibGVzKCk7XG5cbiAgICAgICAgdGhpcy5wbG90LnNpemUgPSBjb25mLnNpemU7XG5cblxuICAgICAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoO1xuICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBVdGlscy5hdmFpbGFibGVXaWR0aCh0aGlzLmNvbmZpZy53aWR0aCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIG1hcmdpbik7XG4gICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSBVdGlscy5hdmFpbGFibGVIZWlnaHQodGhpcy5jb25maWcuaGVpZ2h0LCB0aGlzLmdldEJhc2VDb250YWluZXIoKSwgbWFyZ2luKTtcbiAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgICAgaWYoIXRoaXMucGxvdC5zaXplKXtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3Quc2l6ZSA9ICBNYXRoLm1pbihjb25mLm1heENlbGxTaXplLCBNYXRoLm1heChjb25mLm1pbkNlbGxTaXplLCBhdmFpbGFibGVXaWR0aC90aGlzLnBsb3QudmFyaWFibGVzLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2lkdGggPSBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCArIHRoaXMucGxvdC52YXJpYWJsZXMubGVuZ3RoKnRoaXMucGxvdC5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmKCF0aGlzLnBsb3Quc2l6ZSl7XG4gICAgICAgICAgICB0aGlzLnBsb3Quc2l6ZSA9ICh3aWR0aCAtIChtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkpIC8gdGhpcy5wbG90LnZhcmlhYmxlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsb3Qud2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICB0aGlzLnBsb3QuaGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cblxuICAgICAgICB0aGlzLnBsb3QudGlja3MgPSBjb25mLnRpY2tzO1xuXG4gICAgICAgIGlmKHRoaXMucGxvdC50aWNrcz09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLnBsb3QudGlja3MgPSB0aGlzLnBsb3Quc2l6ZSAvIDQwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXR1cFgoKTtcbiAgICAgICAgdGhpcy5zZXR1cFkoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBzZXR1cFZhcmlhYmxlcygpIHtcbiAgICAgICAgdmFyIHZhcmlhYmxlc0NvbmYgPSB0aGlzLmNvbmZpZy52YXJpYWJsZXM7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICBwbG90LmRvbWFpbkJ5VmFyaWFibGUgPSB7fTtcbiAgICAgICAgcGxvdC52YXJpYWJsZXMgPSB2YXJpYWJsZXNDb25mLmtleXM7XG4gICAgICAgIGlmKCFwbG90LnZhcmlhYmxlcyB8fCAhcGxvdC52YXJpYWJsZXMubGVuZ3RoKXtcblxuICAgICAgICAgICAgcGxvdC52YXJpYWJsZXMgPSBkYXRhLmxlbmd0aCA/IFV0aWxzLmluZmVyVmFyaWFibGVzKGRhdGFbMF0udmFsdWVzLCB0aGlzLmNvbmZpZy5ncm91cHMua2V5LCB0aGlzLmNvbmZpZy5pbmNsdWRlSW5QbG90KSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC5sYWJlbHMgPSBbXTtcbiAgICAgICAgcGxvdC5sYWJlbEJ5VmFyaWFibGUgPSB7fTtcbiAgICAgICAgcGxvdC52YXJpYWJsZXMuZm9yRWFjaCgodmFyaWFibGVLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB2YXIgbWluID0gZDMubWluKGRhdGEsIHM9PmQzLm1pbihzLnZhbHVlcywgZD0+dmFyaWFibGVzQ29uZi52YWx1ZShkLCB2YXJpYWJsZUtleSkpKTtcbiAgICAgICAgICAgIHZhciBtYXggPSBkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBkPT52YXJpYWJsZXNDb25mLnZhbHVlKGQsIHZhcmlhYmxlS2V5KSkpO1xuICAgICAgICAgICAgcGxvdC5kb21haW5CeVZhcmlhYmxlW3ZhcmlhYmxlS2V5XSA9IFttaW4sbWF4XTtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHZhcmlhYmxlS2V5O1xuICAgICAgICAgICAgaWYodmFyaWFibGVzQ29uZi5sYWJlbHMgJiYgdmFyaWFibGVzQ29uZi5sYWJlbHMubGVuZ3RoPmluZGV4KXtcblxuICAgICAgICAgICAgICAgIGxhYmVsID0gdmFyaWFibGVzQ29uZi5sYWJlbHNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGxvdC5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICBwbG90LmxhYmVsQnlWYXJpYWJsZVt2YXJpYWJsZUtleV0gPSBsYWJlbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGxvdC5zdWJwbG90cyA9IFtdO1xuICAgIH07XG5cbiAgICBzZXR1cFgoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIFxuICAgICAgICB4LnZhbHVlID0gY29uZi52YXJpYWJsZXMudmFsdWU7XG4gICAgICAgIHguc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnguc2NhbGUpLnJhbmdlKFtjb25mLnBhZGRpbmcgLyAyLCBwbG90LnNpemUgLSBjb25mLnBhZGRpbmcgLyAyXSk7XG4gICAgICAgIHgubWFwID0gKGQsIHZhcmlhYmxlKSA9PiB4LnNjYWxlKHgudmFsdWUoZCwgdmFyaWFibGUpKTtcblxuICAgICAgICB4LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYueC5vcmllbnQsIHguc2NhbGUpLnRpY2tzKHBsb3QudGlja3MpO1xuICAgICAgICB4LmF4aXMudGlja1NpemUocGxvdC5zaXplICogcGxvdC52YXJpYWJsZXMubGVuZ3RoKTtcblxuICAgIH07XG5cbiAgICBzZXR1cFkoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB5ID0gcGxvdC55O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHkudmFsdWUgPSBjb25mLnZhcmlhYmxlcy52YWx1ZTtcbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYueS5zY2FsZSkucmFuZ2UoWyBwbG90LnNpemUgLSBjb25mLnBhZGRpbmcgLyAyLCBjb25mLnBhZGRpbmcgLyAyXSk7XG5cbiAgICAgICAgeS5tYXAgPSAoZCwgdmFyaWFibGUpID0+IHkuc2NhbGUoeS52YWx1ZShkLCB2YXJpYWJsZSkpO1xuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYueS5vcmllbnQsIHkuc2NhbGUpLnRpY2tzKHBsb3QudGlja3MpO1xuICAgICAgICB5LmF4aXMudGlja1NpemUoLXBsb3Quc2l6ZSAqIHBsb3QudmFyaWFibGVzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIHVwZGF0ZSggbmV3RGF0YSkge1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG5cbiAgICAgICAgdmFyIHNlbGYgPXRoaXM7XG4gICAgICAgIHZhciBuID0gc2VsZi5wbG90LnZhcmlhYmxlcy5sZW5ndGg7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdmFyIGF4aXNDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJheGlzXCIpO1xuICAgICAgICB2YXIgYXhpc1hDbGFzcyA9IGF4aXNDbGFzcytcIi14XCI7XG4gICAgICAgIHZhciBheGlzWUNsYXNzID0gYXhpc0NsYXNzK1wiLXlcIjtcblxuICAgICAgICB2YXIgeEF4aXNTZWxlY3RvciA9IFwiZy5cIitheGlzWENsYXNzK1wiLlwiK2F4aXNDbGFzcztcbiAgICAgICAgdmFyIHlBeGlzU2VsZWN0b3IgPSBcImcuXCIrYXhpc1lDbGFzcytcIi5cIitheGlzQ2xhc3M7XG5cbiAgICAgICAgdmFyIG5vR3VpZGVzQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwibm8tZ3VpZGVzXCIpO1xuICAgICAgICB2YXIgeEF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKHhBeGlzU2VsZWN0b3IpXG4gICAgICAgICAgICAuZGF0YShzZWxmLnBsb3QudmFyaWFibGVzKTtcblxuICAgICAgICB2YXIgeEF4aXNNZXJnZSA9IHhBeGlzLmVudGVyKCkuYXBwZW5kU2VsZWN0b3IoeEF4aXNTZWxlY3RvcilcbiAgICAgICAgICAgIC5jbGFzc2VkKG5vR3VpZGVzQ2xhc3MsICFjb25mLmd1aWRlcykubWVyZ2UoeEF4aXMpO1xuXG5cbiAgICAgICAgeEF4aXNNZXJnZS5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInRyYW5zbGF0ZShcIiArIChuIC0gaSAtIDEpICogc2VsZi5wbG90LnNpemUgKyBcIiwwKVwiKVxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC54LnNjYWxlLmRvbWFpbihzZWxmLnBsb3QuZG9tYWluQnlWYXJpYWJsZVtkXSk7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBheGlzID0gYXhpcy50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF4aXMuY2FsbChzZWxmLnBsb3QueC5heGlzKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgeEF4aXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIHZhciB5QXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoeUF4aXNTZWxlY3RvcilcbiAgICAgICAgICAgIC5kYXRhKHNlbGYucGxvdC52YXJpYWJsZXMpO1xuICAgICAgICB2YXIgeUF4aXNNZXJnZSA9IHlBeGlzLmVudGVyKCkuYXBwZW5kU2VsZWN0b3IoeUF4aXNTZWxlY3RvcikubWVyZ2UoeUF4aXMpO1xuICAgICAgICB5QXhpc01lcmdlLmNsYXNzZWQobm9HdWlkZXNDbGFzcywgIWNvbmYuZ3VpZGVzKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IFwidHJhbnNsYXRlKDAsXCIgKyBpICogc2VsZi5wbG90LnNpemUgKyBcIilcIik7XG4gICAgICAgIHlBeGlzTWVyZ2UuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBzZWxmLnBsb3QueS5zY2FsZS5kb21haW4oc2VsZi5wbG90LmRvbWFpbkJ5VmFyaWFibGVbZF0pO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXhpcyA9IGF4aXMudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXhpcy5jYWxsKHNlbGYucGxvdC55LmF4aXMpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHlBeGlzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgY2VsbENsYXNzID0gIHNlbGYucHJlZml4Q2xhc3MoXCJjZWxsXCIpO1xuICAgICAgICB2YXIgY2VsbCA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCIuXCIrY2VsbENsYXNzKVxuICAgICAgICAgICAgLmRhdGEoc2VsZi51dGlscy5jcm9zcyhzZWxmLnBsb3QudmFyaWFibGVzLCBzZWxmLnBsb3QudmFyaWFibGVzKSk7XG5cbiAgICAgICAgdmFyIGNlbGxFbnRlciA9ICBjZWxsLmVudGVyKCkuYXBwZW5kU2VsZWN0b3IoXCJnLlwiK2NlbGxDbGFzcyk7XG4gICAgICAgIGNlbGxFbnRlci5maWx0ZXIoZCA9PiBkLmkgPT09IGQuaikuYXBwZW5kKFwidGV4dFwiKTtcblxuICAgICAgICB2YXIgY2VsbE1lcmdlID0gY2VsbEVudGVyLm1lcmdlKGNlbGwpO1xuICAgICAgICBjZWxsTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgKG4gLSBkLmkgLSAxKSAqIHNlbGYucGxvdC5zaXplICsgXCIsXCIgKyBkLmogKiBzZWxmLnBsb3Quc2l6ZSArIFwiKVwiKTtcblxuICAgICAgICBpZihjb25mLmJydXNoKXtcbiAgICAgICAgICAgIHRoaXMuZHJhd0JydXNoKGNlbGxNZXJnZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNlbGxNZXJnZS5lYWNoKHBsb3RTdWJwbG90KTtcblxuICAgICAgICAvL0xhYmVsc1xuICAgICAgICBjZWxsTWVyZ2Uuc2VsZWN0KFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGNvbmYucGFkZGluZylcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBjb25mLnBhZGRpbmcpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLjcxZW1cIilcbiAgICAgICAgICAgIC50ZXh0KCBkID0+IHNlbGYucGxvdC5sYWJlbEJ5VmFyaWFibGVbZC54XSk7XG5cbiAgICAgICAgY2VsbC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gcGxvdFN1YnBsb3QocCkge1xuICAgICAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgICAgICBwbG90LnN1YnBsb3RzLnB1c2gocCk7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgICAgICAgICAgcGxvdC54LnNjYWxlLmRvbWFpbihwbG90LmRvbWFpbkJ5VmFyaWFibGVbcC54XSk7XG4gICAgICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKHBsb3QuZG9tYWluQnlWYXJpYWJsZVtwLnldKTtcblxuICAgICAgICAgICAgdmFyIGZyYW1lQ2xhc3MgPSAgc2VsZi5wcmVmaXhDbGFzcyhcImZyYW1lXCIpO1xuICAgICAgICAgICAgY2VsbC5zZWxlY3RPckFwcGVuZChcInJlY3QuXCIrZnJhbWVDbGFzcylcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGZyYW1lQ2xhc3MpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGNvbmYucGFkZGluZyAvIDIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGNvbmYucGFkZGluZyAvIDIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwbG90LnNpemUgLSBjb25mLnBhZGRpbmcpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgcGxvdC5zaXplIC0gY29uZi5wYWRkaW5nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcC51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdWJwbG90ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2xheWVyJyk7XG5cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGNlbGwuc2VsZWN0QWxsKFwiZy5cIitsYXllckNsYXNzKS5kYXRhKHNlbGYucGxvdC5ncm91cGVkRGF0YSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJNZXJnZSA9IGxheWVyLmVudGVyKCkuYXBwZW5kU2VsZWN0b3IoXCJnLlwiK2xheWVyQ2xhc3MpLm1lcmdlKGxheWVyKTtcblxuICAgICAgICAgICAgICAgIHZhciBkb3RzID0gbGF5ZXJNZXJnZS5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoZD0+ZC52YWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRvdHNNZXJnZSA9IGRvdHMuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikubWVyZ2UoZG90cyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZG90c1QgPSBkb3RzTWVyZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkb3RzVCA9IGRvdHNNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG90c1QuYXR0cihcImN4XCIsIChkKSA9PiBwbG90LngubWFwKGQsIHN1YnBsb3QueCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgKGQpID0+IHBsb3QueS5tYXAoZCwgc3VicGxvdC55KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIHNlbGYuY29uZmlnLmRvdFJhZGl1cyk7XG5cblxuICAgICAgICAgICAgICAgIGlmIChwbG90LnNlcmllc0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyTWVyZ2Uuc3R5bGUoXCJmaWxsXCIsIHBsb3Quc2VyaWVzQ29sb3IpXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYocGxvdC5jb2xvcil7XG4gICAgICAgICAgICAgICAgICAgIGRvdHNNZXJnZS5zdHlsZShcImZpbGxcIiwgcGxvdC5jb2xvcilcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGlmIChwbG90LnRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgZG90c01lcmdlLm9uKFwibW91c2VvdmVyXCIsIChkKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gXCIoXCIgKyBwbG90LngudmFsdWUoZCwgc3VicGxvdC54KSArIFwiLCBcIiArIHBsb3QueS52YWx1ZShkLCBzdWJwbG90LnkpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBzZWxmLmNvbmZpZy5ncm91cHMgPyBzZWxmLmNvbmZpZy5ncm91cHMudmFsdWUuY2FsbChzZWxmLmNvbmZpZywgZCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwIHx8IGdyb3VwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBwbG90Lmdyb3VwVG9MYWJlbFtncm91cF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBcIjxici8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gc2VsZi5jb25maWcuZ3JvdXBzLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGxhYmVsICsgXCI6IFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQpPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvdHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGxheWVyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwLnVwZGF0ZSgpO1xuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZHJhd0JydXNoKGNlbGwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgaGlkZGVuQ2xhc3MgPSBzZWxmLnBsb3QuaGlkZGVuQ2xhc3MgPSAgc2VsZi5wcmVmaXhDbGFzcyhcImhpZGRlblwiKTtcbiAgICAgICAgdmFyIGJydXNoID0gZDMuYnJ1c2goKVxuICAgICAgICAgICAgLy8gLngoc2VsZi5wbG90Lnguc2NhbGUpXG4gICAgICAgICAgICAvLyAueShzZWxmLnBsb3QueS5zY2FsZSlcbiAgICAgICAgICAgIC5vbihcInN0YXJ0XCIsIGJydXNoc3RhcnQpXG4gICAgICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaG1vdmUpXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgYnJ1c2hlbmQpO1xuXG4gICAgICAgIGJydXNoLmV4dGVudChbWzAsIDBdLCBbc2VsZi5wbG90LnNpemUsIHNlbGYucGxvdC5zaXplXV0pO1xuICAgICAgICBjZWxsLnNlbGVjdE9yQXBwZW5kKFwiZy5icnVzaC1jb250YWluZXJcIikuY2FsbChicnVzaCk7XG5cbiAgICAgICAgc2VsZi5jbGVhckJydXNoKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHByZXZpb3VzbHktYWN0aXZlIGJydXNoLCBpZiBhbnkuXG4gICAgICAgIGZ1bmN0aW9uIGJydXNoc3RhcnQocCkge1xuICAgICAgICAgICAgaWYgKHNlbGYucGxvdC5icnVzaENlbGwgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFyQnJ1c2goKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QueC5zY2FsZS5kb21haW4oc2VsZi5wbG90LmRvbWFpbkJ5VmFyaWFibGVbcC54XSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lnkuc2NhbGUuZG9tYWluKHNlbGYucGxvdC5kb21haW5CeVZhcmlhYmxlW3AueV0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5icnVzaENlbGwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5icnVzaCA9IGJydXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSBzZWxlY3RlZCBjaXJjbGVzLlxuICAgICAgICBmdW5jdGlvbiBicnVzaG1vdmUocCkge1xuICAgICAgICAgICAgdmFyIHMgPSBkMy5ldmVudC5zZWxlY3Rpb247XG4gICAgICAgICAgICBpZighcylyZXR1cm47XG4gICAgICAgICAgICB2YXIgZSA9IHMubWFwKF89PiBbc2VsZi5wbG90Lnguc2NhbGUuaW52ZXJ0KF9bMF0pLCBzZWxmLnBsb3QueS5zY2FsZS5pbnZlcnQoX1sxXSldKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGUpO1xuXG4gICAgICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiY2lyY2xlXCIpLmNsYXNzZWQoaGlkZGVuQ2xhc3MsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KGRbcC54XSksXG4gICAgICAgICAgICAgICAgICAgIHkgPSBwYXJzZUZsb2F0KGRbcC55XSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZVswXVswXSA+IHggfHwgeCA+IGVbMV1bMF1cbiAgICAgICAgICAgICAgICAgICAgfHwgZVsxXVsxXSA+IHkgfHwgeSA+IGVbMF1bMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgYnJ1c2ggaXMgZW1wdHksIHNlbGVjdCBhbGwgY2lyY2xlcy5cbiAgICAgICAgZnVuY3Rpb24gYnJ1c2hlbmQoKSB7XG4gICAgICAgICAgICBpZiAoIWQzLmV2ZW50LnNlbGVjdGlvbikgc2VsZi5zdmdHLnNlbGVjdEFsbChcIi5cIitoaWRkZW5DbGFzcykuY2xhc3NlZChoaWRkZW5DbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNsZWFyQnJ1c2goKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZighc2VsZi5wbG90LmJydXNoQ2VsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNlbGYucGxvdC5icnVzaC5tb3ZlKGQzLnNlbGVjdChzZWxmLnBsb3QuYnJ1c2hDZWxsKSwgbnVsbCk7XG4gICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCIuXCIrc2VsZi5wbG90LmhpZGRlbkNsYXNzKS5jbGFzc2VkKHNlbGYucGxvdC5oaWRkZW5DbGFzcywgZmFsc2UpO1xuICAgICAgICBzZWxmLnBsb3QuYnJ1c2hDZWxsPW51bGw7XG5cbiAgICB9XG59IiwiaW1wb3J0IHtDaGFydFdpdGhDb2xvckdyb3VwcywgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWd9IGZyb20gXCIuL2NoYXJ0LXdpdGgtY29sb3ItZ3JvdXBzXCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIFNjYXR0ZXJQbG90Q29uZmlnIGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWd7XG5cbiAgICBzdmdDbGFzcz0gdGhpcy5jc3NDbGFzc1ByZWZpeCsnc2NhdHRlcnBsb3QnO1xuICAgIGd1aWRlcz0gZmFsc2U7IC8vc2hvdyBheGlzIGd1aWRlc1xuICAgIHNob3dUb29sdGlwPSB0cnVlOyAvL3Nob3cgdG9vbHRpcCBvbiBkb3QgaG92ZXJcblxuICAgIHg9ey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsXG4gICAgICAgIGtleTogMCxcbiAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IGRba2V5XSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBvcmllbnQ6IFwiYm90dG9tXCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBkb21haW5NYXJnaW46IDAuMDVcbiAgICB9O1xuICAgIHk9ey8vIFkgYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsLFxuICAgICAgICBrZXk6IDEsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBkW2tleV0sIC8vIHkgdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgb3JpZW50OiBcImxlZnRcIixcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4wNVxuICAgIH07XG4gICAgZ3JvdXBzPXtcbiAgICAgICAga2V5OiAyXG4gICAgfTtcbiAgICBkb3RSYWRpdXMgPSAyO1xuICAgIGRvdElkID0gKGQsIGkpPT4gdW5kZWZpbmVkO1xuICAgIHRyYW5zaXRpb249IHRydWU7XG4gICAgb25Eb3RIb3ZlciA9IChkLCBpKSA9PiB7fTtcbiAgICBvbkRvdEhvdmVyT3V0ID0gKGQsIGkpID0+IHt9O1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcblxuXG5cbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2NhdHRlclBsb3QgZXh0ZW5kcyBDaGFydFdpdGhDb2xvckdyb3Vwc3tcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IFNjYXR0ZXJQbG90Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBTY2F0dGVyUGxvdENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpe1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuXG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdGhpcy5wbG90Lng9e307XG4gICAgICAgIHRoaXMucGxvdC55PXt9O1xuXG4gICAgICAgIHRoaXMuY29tcHV0ZVBsb3RTaXplKCk7XG4gICAgICAgIHRoaXMuc2V0dXBYKCk7XG4gICAgICAgIHRoaXMuc2V0dXBZKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBYKCl7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLng7XG5cbiAgICAgICAgLyogKlxuICAgICAgICAgKiB2YWx1ZSBhY2Nlc3NvciAtIHJldHVybnMgdGhlIHZhbHVlIHRvIGVuY29kZSBmb3IgYSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICAgICAgICogc2NhbGUgLSBtYXBzIHZhbHVlIHRvIGEgdmlzdWFsIGRpc3BsYXkgZW5jb2RpbmcsIHN1Y2ggYXMgYSBwaXhlbCBwb3NpdGlvbi5cbiAgICAgICAgICogbWFwIGZ1bmN0aW9uIC0gbWFwcyBmcm9tIGRhdGEgdmFsdWUgdG8gZGlzcGxheSB2YWx1ZVxuICAgICAgICAgKiBheGlzIC0gc2V0cyB1cCBheGlzXG4gICAgICAgICAqKi9cbiAgICAgICAgeC52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZShkLCBjb25mLmtleSk7XG4gICAgICAgIFxuICAgICAgICB4LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi5zY2FsZSkucmFuZ2UoWzAsIHBsb3Qud2lkdGhdKTtcbiAgICAgICAgeC5tYXAgPSBkID0+IHguc2NhbGUoeC52YWx1ZShkKSk7XG4gICAgICAgIFxuICAgICAgICB4LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB4LnNjYWxlKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5ncm91cGVkRGF0YTtcblxuICAgICAgICB2YXIgZG9tYWluID0gW3BhcnNlRmxvYXQoZDMubWluKGRhdGEsIHM9PmQzLm1pbihzLnZhbHVlcywgcGxvdC54LnZhbHVlKSkpLCBwYXJzZUZsb2F0KGQzLm1heChkYXRhLCBzPT5kMy5tYXgocy52YWx1ZXMsIHBsb3QueC52YWx1ZSkpKV07XG4gICAgICAgIHZhciBleHRlbnQgPSAoZG9tYWluWzFdLWRvbWFpblswXSkgfHwgMTtcbiAgICAgICAgdmFyIG1hcmdpbiA9IChleHRlbnQpKiBjb25mLmRvbWFpbk1hcmdpbjtcbiAgICAgICAgZG9tYWluWzBdLT1tYXJnaW47XG4gICAgICAgIGRvbWFpblsxXSs9bWFyZ2luO1xuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLmd1aWRlcykge1xuICAgICAgICAgICAgeC5heGlzLnRpY2tTaXplKC1wbG90LmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBzZXR1cFkgKCl7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB5ID0gcGxvdC55O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLnk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAgICAgICAqIHNjYWxlIC0gbWFwcyB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzIGEgcGl4ZWwgcG9zaXRpb24uXG4gICAgICAgICAqIG1hcCBmdW5jdGlvbiAtIG1hcHMgZnJvbSBkYXRhIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICogYXhpcyAtIHNldHMgdXAgYXhpc1xuICAgICAgICAgKi9cbiAgICAgICAgeS52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZShkLCBjb25mLmtleSk7XG5cbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFtwbG90LmhlaWdodCwgMF0pO1xuXG4gICAgICAgIHkubWFwID0gZCA9PiB5LnNjYWxlKHkudmFsdWUoZCkpO1xuXG4gICAgICAgIHkuYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHkuc2NhbGUpO1xuXG4gICAgICAgIGlmKHRoaXMuY29uZmlnLmd1aWRlcyl7XG4gICAgICAgICAgICB5LmF4aXMudGlja1NpemUoLXBsb3Qud2lkdGgpO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5ncm91cGVkRGF0YTtcblxuICAgICAgICB2YXIgZG9tYWluID0gW3BhcnNlRmxvYXQoZDMubWluKGRhdGEsIHM9PmQzLm1pbihzLnZhbHVlcywgcGxvdC55LnZhbHVlKSkpLCBwYXJzZUZsb2F0KGQzLm1heChkYXRhLCBzPT5kMy5tYXgocy52YWx1ZXMsIHBsb3QueS52YWx1ZSkpKV07XG4gICAgICAgIHZhciBleHRlbnQgPSAoZG9tYWluWzFdLWRvbWFpblswXSkgfHwgMTtcbiAgICAgICAgdmFyIG1hcmdpbiA9IChleHRlbnQpKiBjb25mLmRvbWFpbk1hcmdpbjtcblxuICAgICAgICBkb21haW5bMF0tPW1hcmdpbjtcbiAgICAgICAgZG9tYWluWzFdKz1tYXJnaW47XG4gICAgICAgIHBsb3QueS5zY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gcGxvdC55LnNjYWxlLmRvbWFpbihbZDMubWluKGRhdGEsIHBsb3QueS52YWx1ZSktMSwgZDMubWF4KGRhdGEsIHBsb3QueS52YWx1ZSkrMV0pO1xuICAgIH07XG5cbiAgICBkcmF3QXhpc1goKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueDtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMteCcpK1wiLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSsoc2VsZi5jb25maWcuZ3VpZGVzID8gJycgOiAnLicrc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIHBsb3QuaGVpZ2h0ICsgXCIpXCIpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueC5heGlzKTtcbiAgICAgICAgXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiK3NlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgKHBsb3Qud2lkdGgvMikgK1wiLFwiKyAocGxvdC5tYXJnaW4uYm90dG9tKSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNZKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzLXknKStcIi5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzJykrKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nK3NlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSk7XG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueS5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIitzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIC1wbG90Lm1hcmdpbi5sZWZ0ICtcIixcIisocGxvdC5oZWlnaHQvMikrXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWCgpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRG90cygpO1xuICAgIH07XG5cbiAgICB1cGRhdGVEb3RzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgZGF0YSA9IHBsb3QuZGF0YTtcbiAgICAgICAgdmFyIGxheWVyQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKCdsYXllcicpO1xuICAgICAgICB2YXIgZG90Q2xhc3MgPSB0aGlzLmRvdENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnZG90Jyk7XG4gICAgICAgIHNlbGYuZG90c0NvbnRhaW5lckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnZG90cy1jb250YWluZXInKTtcblxuICAgICAgICB2YXIgZG90c0NvbnRhaW5lciA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLmRvdHNDb250YWluZXJDbGFzcyk7XG5cbiAgICAgICAgdmFyIGxheWVyID0gZG90c0NvbnRhaW5lci5zZWxlY3RBbGwoXCJnLlwiK2xheWVyQ2xhc3MpLmRhdGEocGxvdC5ncm91cGVkRGF0YSk7XG5cbiAgICAgICAgdmFyIGxheWVyRW50ZXIgPSBsYXllci5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKFwiZy5cIitsYXllckNsYXNzKTtcblxuICAgICAgICB2YXIgbGF5ZXJNZXJnZSA9IGxheWVyRW50ZXIubWVyZ2UobGF5ZXIpO1xuXG4gICAgICAgIHZhciBkb3RzID0gbGF5ZXJNZXJnZS5zZWxlY3RBbGwoJy4nICsgZG90Q2xhc3MpXG4gICAgICAgICAgICAuZGF0YShkPT5kLnZhbHVlcylcblxuICAgICAgICB2YXIgZG90c0VudGVyID0gZG90cy5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkb3RDbGFzcyk7XG5cbiAgICAgICAgdmFyIGRvdHNNZXJnZSA9IGRvdHNFbnRlci5tZXJnZShkb3RzKTtcblxuICAgICAgICB2YXIgZG90c1QgPSBkb3RzTWVyZ2U7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGRvdHNUID0gZG90c01lcmdlLnRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvdHNULmF0dHIoXCJyXCIsIHNlbGYuY29uZmlnLmRvdFJhZGl1cylcbiAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgcGxvdC54Lm1hcClcbiAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgcGxvdC55Lm1hcClcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgdGhpcy5jb25maWcuZG90SWQpO1xuXG4gICAgICAgIGlmIChwbG90LnRvb2x0aXApIHtcbiAgICAgICAgICAgIGRvdHNNZXJnZS5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IFwiKFwiICsgcGxvdC54LnZhbHVlKGQpICsgXCIsIFwiICsgcGxvdC55LnZhbHVlKGQpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gc2VsZi5jb25maWcuZ3JvdXBzID8gIHNlbGYuY29uZmlnLmdyb3Vwcy52YWx1ZS5jYWxsKHNlbGYuY29uZmlnLGQpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgfHwgZ3JvdXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBwbG90Lmdyb3VwVG9MYWJlbFtncm91cF07XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gXCI8YnIvPlwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBzZWxmLmNvbmZpZy5ncm91cHMubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBsYWJlbCArIFwiOiBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBodG1sICs9IGdyb3VwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Rvb2x0aXAoaHRtbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3RzTWVyZ2Uub24oXCJtb3VzZW92ZXIub25Eb3RIb3ZlclwiLCB0aGlzLmNvbmZpZy5vbkRvdEhvdmVyKTtcbiAgICAgICAgZG90c01lcmdlLm9uKFwibW91c2VvdXQub25Eb3RIb3Zlck91dFwiLCB0aGlzLmNvbmZpZy5vbkRvdEhvdmVyT3V0KTtcblxuICAgICAgICBpZiAocGxvdC5zZXJpZXNDb2xvcikge1xuICAgICAgICAgICAgbGF5ZXJNZXJnZS5zdHlsZShcImZpbGxcIiwgcGxvdC5zZXJpZXNDb2xvcilcbiAgICAgICAgfWVsc2UgaWYocGxvdC5jb2xvcil7XG4gICAgICAgICAgICBkb3RzTWVyZ2Uuc3R5bGUoXCJmaWxsXCIsIHBsb3QuY29sb3IpXG4gICAgICAgIH1cblxuICAgICAgICBkb3RzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgbGF5ZXIuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZW5yYXNtdXNlbi8xMjYxOTc3XG4gKiBOQU1FXG4gKiBcbiAqIHN0YXRpc3RpY3MtZGlzdHJpYnV0aW9ucy5qcyAtIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgY2FsY3VsYXRpbmdcbiAqICAgY3JpdGljYWwgdmFsdWVzIGFuZCB1cHBlciBwcm9iYWJpbGl0aWVzIG9mIGNvbW1vbiBzdGF0aXN0aWNhbFxuICogICBkaXN0cmlidXRpb25zXG4gKiBcbiAqIFNZTk9QU0lTXG4gKiBcbiAqIFxuICogICAvLyBDaGktc3F1YXJlZC1jcml0ICgyIGRlZ3JlZXMgb2YgZnJlZWRvbSwgOTV0aCBwZXJjZW50aWxlID0gMC4wNSBsZXZlbFxuICogICBjaGlzcXJkaXN0cigyLCAuMDUpXG4gKiAgIFxuICogICAvLyB1LWNyaXQgKDk1dGggcGVyY2VudGlsZSA9IDAuMDUgbGV2ZWwpXG4gKiAgIHVkaXN0ciguMDUpO1xuICogICBcbiAqICAgLy8gdC1jcml0ICgxIGRlZ3JlZSBvZiBmcmVlZG9tLCA5OS41dGggcGVyY2VudGlsZSA9IDAuMDA1IGxldmVsKSBcbiAqICAgdGRpc3RyKDEsLjAwNSk7XG4gKiAgIFxuICogICAvLyBGLWNyaXQgKDEgZGVncmVlIG9mIGZyZWVkb20gaW4gbnVtZXJhdG9yLCAzIGRlZ3JlZXMgb2YgZnJlZWRvbSBcbiAqICAgLy8gICAgICAgICBpbiBkZW5vbWluYXRvciwgOTl0aCBwZXJjZW50aWxlID0gMC4wMSBsZXZlbClcbiAqICAgZmRpc3RyKDEsMywuMDEpO1xuICogICBcbiAqICAgLy8gdXBwZXIgcHJvYmFiaWxpdHkgb2YgdGhlIHUgZGlzdHJpYnV0aW9uICh1ID0gLTAuODUpOiBRKHUpID0gMS1HKHUpXG4gKiAgIHVwcm9iKC0wLjg1KTtcbiAqICAgXG4gKiAgIC8vIHVwcGVyIHByb2JhYmlsaXR5IG9mIHRoZSBjaGktc3F1YXJlIGRpc3RyaWJ1dGlvblxuICogICAvLyAoMyBkZWdyZWVzIG9mIGZyZWVkb20sIGNoaS1zcXVhcmVkID0gNi4yNSk6IFEgPSAxLUdcbiAqICAgY2hpc3FycHJvYigzLDYuMjUpO1xuICogICBcbiAqICAgLy8gdXBwZXIgcHJvYmFiaWxpdHkgb2YgdGhlIHQgZGlzdHJpYnV0aW9uXG4gKiAgIC8vICgzIGRlZ3JlZXMgb2YgZnJlZWRvbSwgdCA9IDYuMjUxKTogUSA9IDEtR1xuICogICB0cHJvYigzLDYuMjUxKTtcbiAqICAgXG4gKiAgIC8vIHVwcGVyIHByb2JhYmlsaXR5IG9mIHRoZSBGIGRpc3RyaWJ1dGlvblxuICogICAvLyAoMyBkZWdyZWVzIG9mIGZyZWVkb20gaW4gbnVtZXJhdG9yLCA1IGRlZ3JlZXMgb2YgZnJlZWRvbSBpblxuICogICAvLyAgZGVub21pbmF0b3IsIEYgPSA2LjI1KTogUSA9IDEtR1xuICogICBmcHJvYigzLDUsLjYyNSk7XG4gKiBcbiAqIFxuICogIERFU0NSSVBUSU9OXG4gKiBcbiAqIFRoaXMgbGlicmFyeSBjYWxjdWxhdGVzIHBlcmNlbnRhZ2UgcG9pbnRzICg1IHNpZ25pZmljYW50IGRpZ2l0cykgb2YgdGhlIHVcbiAqIChzdGFuZGFyZCBub3JtYWwpIGRpc3RyaWJ1dGlvbiwgdGhlIHN0dWRlbnQncyB0IGRpc3RyaWJ1dGlvbiwgdGhlXG4gKiBjaGktc3F1YXJlIGRpc3RyaWJ1dGlvbiBhbmQgdGhlIEYgZGlzdHJpYnV0aW9uLiBJdCBjYW4gYWxzbyBjYWxjdWxhdGUgdGhlXG4gKiB1cHBlciBwcm9iYWJpbGl0eSAoNSBzaWduaWZpY2FudCBkaWdpdHMpIG9mIHRoZSB1IChzdGFuZGFyZCBub3JtYWwpLCB0aGVcbiAqIGNoaS1zcXVhcmUsIHRoZSB0IGFuZCB0aGUgRiBkaXN0cmlidXRpb24uXG4gKiBcbiAqIFRoZXNlIGNyaXRpY2FsIHZhbHVlcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gc3RhdGlzdGljYWwgdGVzdHMsIGxpa2UgdGhlIHVcbiAqIHRlc3QsIHRoZSB0IHRlc3QsIHRoZSBGIHRlc3QgYW5kIHRoZSBjaGktc3F1YXJlZCB0ZXN0LCBhbmQgdG8gY2FsY3VsYXRlXG4gKiBjb25maWRlbmNlIGludGVydmFscy5cbiAqIFxuICogSWYgeW91IGFyZSBpbnRlcmVzdGVkIGluIG1vcmUgcHJlY2lzZSBhbGdvcml0aG1zIHlvdSBjb3VsZCBsb29rIGF0OlxuICogICBTdGF0TGliOiBodHRwOi8vbGliLnN0YXQuY211LmVkdS9hcHN0YXQvIDsgXG4gKiAgIEFwcGxpZWQgU3RhdGlzdGljcyBBbGdvcml0aG1zIGJ5IEdyaWZmaXRocywgUC4gYW5kIEhpbGwsIEkuRC5cbiAqICAgLCBFbGxpcyBIb3J3b29kOiBDaGljaGVzdGVyICgxOTg1KVxuICogXG4gKiBCVUdTIFxuICogXG4gKiBUaGlzIHBvcnQgd2FzIHByb2R1Y2VkIGZyb20gdGhlIFBlcmwgbW9kdWxlIFN0YXRpc3RpY3M6OkRpc3RyaWJ1dGlvbnNcbiAqIHRoYXQgaGFzIGhhZCBubyBidWcgcmVwb3J0cyBpbiBzZXZlcmFsIHllYXJzLiAgSWYgeW91IGZpbmQgYSBidWcgdGhlblxuICogcGxlYXNlIGRvdWJsZS1jaGVjayB0aGF0IEphdmFTY3JpcHQgZG9lcyBub3QgdGhpbmcgdGhlIG51bWJlcnMgeW91IGFyZVxuICogcGFzc2luZyBpbiBhcmUgc3RyaW5ncy4gIChZb3UgY2FuIHN1YnRyYWN0IDAgZnJvbSB0aGVtIGFzIHlvdSBwYXNzIHRoZW1cbiAqIGluIHNvIHRoYXQgXCI1XCIgaXMgcHJvcGVybHkgdW5kZXJzdG9vZCB0byBiZSA1LikgIElmIHlvdSBoYXZlIHBhc3NlZCBpbiBhXG4gKiBudW1iZXIgdGhlbiBwbGVhc2UgY29udGFjdCB0aGUgYXV0aG9yXG4gKiBcbiAqIEFVVEhPUlxuICogXG4gKiBCZW4gVGlsbHkgPGJ0aWxseUBnbWFpbC5jb20+XG4gKiBcbiAqIE9yaWdpbmwgUGVybCB2ZXJzaW9uIGJ5IE1pY2hhZWwgS29zcGFjaCA8bWlrZS5wZXJsQGdteC5hdD5cbiAqIFxuICogTmljZSBmb3JtYXRpbmcsIHNpbXBsaWZpY2F0aW9uIGFuZCBidWcgcmVwYWlyIGJ5IE1hdHRoaWFzIFRyYXV0bmVyIEtyb21hbm5cbiAqIDxtdGtAaWQuY2JzLmRrPlxuICogXG4gKiBDT1BZUklHSFQgXG4gKiBcbiAqIENvcHlyaWdodCAyMDA4IEJlbiBUaWxseS5cbiAqIFxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSBzYW1lIHRlcm1zIGFzIFBlcmwgaXRzZWxmLiAgVGhpcyBtZWFucyB1bmRlciBlaXRoZXIgdGhlIFBlcmxcbiAqIEFydGlzdGljIExpY2Vuc2Ugb3IgdGhlIEdQTCB2MSBvciBsYXRlci5cbiAqL1xuXG52YXIgU0lHTklGSUNBTlQgPSA1OyAvLyBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHRvIGJlIHJldHVybmVkXG5cbmZ1bmN0aW9uIGNoaXNxcmRpc3RyICgkbiwgJHApIHtcblx0aWYgKCRuIDw9IDAgfHwgTWF0aC5hYnMoJG4pIC0gTWF0aC5hYnMoaW50ZWdlcigkbikpICE9IDApIHtcblx0XHR0aHJvdyhcIkludmFsaWQgbjogJG5cXG5cIik7IC8qIGRlZ3JlZSBvZiBmcmVlZG9tICovXG5cdH1cblx0aWYgKCRwIDw9IDAgfHwgJHAgPiAxKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIHA6ICRwXFxuXCIpOyBcblx0fVxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3ViY2hpc3FyKCRuLTAsICRwLTApKTtcbn1cblxuZnVuY3Rpb24gdWRpc3RyICgkcCkge1xuXHRpZiAoJHAgPiAxIHx8ICRwIDw9IDApIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YnUoJHAtMCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGRpc3RyICgkbiwgJHApIHtcblx0aWYgKCRuIDw9IDAgfHwgTWF0aC5hYnMoJG4pIC0gTWF0aC5hYnMoaW50ZWdlcigkbikpICE9IDApIHtcblx0XHR0aHJvdyhcIkludmFsaWQgbjogJG5cXG5cIik7XG5cdH1cblx0aWYgKCRwIDw9IDAgfHwgJHAgPj0gMSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBwOiAkcFxcblwiKTtcblx0fVxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3VidCgkbi0wLCAkcC0wKSk7XG59XG5cbmZ1bmN0aW9uIGZkaXN0ciAoJG4sICRtLCAkcCkge1xuXHRpZiAoKCRuPD0wKSB8fCAoKE1hdGguYWJzKCRuKS0oTWF0aC5hYnMoaW50ZWdlcigkbikpKSkhPTApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpOyAvKiBmaXJzdCBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdGlmICgoJG08PTApIHx8ICgoTWF0aC5hYnMoJG0pLShNYXRoLmFicyhpbnRlZ2VyKCRtKSkpKSE9MCkpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgbTogJG1cXG5cIik7IC8qIHNlY29uZCBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdGlmICgoJHA8PTApIHx8ICgkcD4xKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBwOiAkcFxcblwiKTtcblx0fVxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3ViZigkbi0wLCAkbS0wLCAkcC0wKSk7XG59XG5cbmZ1bmN0aW9uIHVwcm9iICgkeCkge1xuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3VidXByb2IoJHgtMCkpO1xufVxuXG5mdW5jdGlvbiBjaGlzcXJwcm9iICgkbiwkeCkge1xuXHRpZiAoKCRuIDw9IDApIHx8ICgoTWF0aC5hYnMoJG4pIC0gKE1hdGguYWJzKGludGVnZXIoJG4pKSkpICE9IDApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpOyAvKiBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdHJldHVybiBwcmVjaXNpb25fc3RyaW5nKF9zdWJjaGlzcXJwcm9iKCRuLTAsICR4LTApKTtcbn1cblxuZnVuY3Rpb24gdHByb2IgKCRuLCAkeCkge1xuXHRpZiAoKCRuIDw9IDApIHx8ICgoTWF0aC5hYnMoJG4pIC0gTWF0aC5hYnMoaW50ZWdlcigkbikpKSAhPTApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpOyAvKiBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdHJldHVybiBwcmVjaXNpb25fc3RyaW5nKF9zdWJ0cHJvYigkbi0wLCAkeC0wKSk7XG59XG5cbmZ1bmN0aW9uIGZwcm9iICgkbiwgJG0sICR4KSB7XG5cdGlmICgoJG48PTApIHx8ICgoTWF0aC5hYnMoJG4pLShNYXRoLmFicyhpbnRlZ2VyKCRuKSkpKSE9MCkpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgbjogJG5cXG5cIik7IC8qIGZpcnN0IGRlZ3JlZSBvZiBmcmVlZG9tICovXG5cdH1cblx0aWYgKCgkbTw9MCkgfHwgKChNYXRoLmFicygkbSktKE1hdGguYWJzKGludGVnZXIoJG0pKSkpIT0wKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBtOiAkbVxcblwiKTsgLyogc2Vjb25kIGRlZ3JlZSBvZiBmcmVlZG9tICovXG5cdH0gXG5cdHJldHVybiBwcmVjaXNpb25fc3RyaW5nKF9zdWJmcHJvYigkbi0wLCAkbS0wLCAkeC0wKSk7XG59XG5cblxuZnVuY3Rpb24gX3N1YmZwcm9iICgkbiwgJG0sICR4KSB7XG5cdHZhciAkcDtcblxuXHRpZiAoJHg8PTApIHtcblx0XHQkcD0xO1xuXHR9IGVsc2UgaWYgKCRtICUgMiA9PSAwKSB7XG5cdFx0dmFyICR6ID0gJG0gLyAoJG0gKyAkbiAqICR4KTtcblx0XHR2YXIgJGEgPSAxO1xuXHRcdGZvciAodmFyICRpID0gJG0gLSAyOyAkaSA+PSAyOyAkaSAtPSAyKSB7XG5cdFx0XHQkYSA9IDEgKyAoJG4gKyAkaSAtIDIpIC8gJGkgKiAkeiAqICRhO1xuXHRcdH1cblx0XHQkcCA9IDEgLSBNYXRoLnBvdygoMSAtICR6KSwgKCRuIC8gMikgKiAkYSk7XG5cdH0gZWxzZSBpZiAoJG4gJSAyID09IDApIHtcblx0XHR2YXIgJHogPSAkbiAqICR4IC8gKCRtICsgJG4gKiAkeCk7XG5cdFx0dmFyICRhID0gMTtcblx0XHRmb3IgKHZhciAkaSA9ICRuIC0gMjsgJGkgPj0gMjsgJGkgLT0gMikge1xuXHRcdFx0JGEgPSAxICsgKCRtICsgJGkgLSAyKSAvICRpICogJHogKiAkYTtcblx0XHR9XG5cdFx0JHAgPSBNYXRoLnBvdygoMSAtICR6KSwgKCRtIC8gMikpICogJGE7XG5cdH0gZWxzZSB7XG5cdFx0dmFyICR5ID0gTWF0aC5hdGFuMihNYXRoLnNxcnQoJG4gKiAkeCAvICRtKSwgMSk7XG5cdFx0dmFyICR6ID0gTWF0aC5wb3coTWF0aC5zaW4oJHkpLCAyKTtcblx0XHR2YXIgJGEgPSAoJG4gPT0gMSkgPyAwIDogMTtcblx0XHRmb3IgKHZhciAkaSA9ICRuIC0gMjsgJGkgPj0gMzsgJGkgLT0gMikge1xuXHRcdFx0JGEgPSAxICsgKCRtICsgJGkgLSAyKSAvICRpICogJHogKiAkYTtcblx0XHR9IFxuXHRcdHZhciAkYiA9IE1hdGguUEk7XG5cdFx0Zm9yICh2YXIgJGkgPSAyOyAkaSA8PSAkbSAtIDE7ICRpICs9IDIpIHtcblx0XHRcdCRiICo9ICgkaSAtIDEpIC8gJGk7XG5cdFx0fVxuXHRcdHZhciAkcDEgPSAyIC8gJGIgKiBNYXRoLnNpbigkeSkgKiBNYXRoLnBvdyhNYXRoLmNvcygkeSksICRtKSAqICRhO1xuXG5cdFx0JHogPSBNYXRoLnBvdyhNYXRoLmNvcygkeSksIDIpO1xuXHRcdCRhID0gKCRtID09IDEpID8gMCA6IDE7XG5cdFx0Zm9yICh2YXIgJGkgPSAkbS0yOyAkaSA+PSAzOyAkaSAtPSAyKSB7XG5cdFx0XHQkYSA9IDEgKyAoJGkgLSAxKSAvICRpICogJHogKiAkYTtcblx0XHR9XG5cdFx0JHAgPSBtYXgoMCwgJHAxICsgMSAtIDIgKiAkeSAvIE1hdGguUElcblx0XHRcdC0gMiAvIE1hdGguUEkgKiBNYXRoLnNpbigkeSkgKiBNYXRoLmNvcygkeSkgKiAkYSk7XG5cdH1cblx0cmV0dXJuICRwO1xufVxuXG5cbmZ1bmN0aW9uIF9zdWJjaGlzcXJwcm9iICgkbiwkeCkge1xuXHR2YXIgJHA7XG5cblx0aWYgKCR4IDw9IDApIHtcblx0XHQkcCA9IDE7XG5cdH0gZWxzZSBpZiAoJG4gPiAxMDApIHtcblx0XHQkcCA9IF9zdWJ1cHJvYigoTWF0aC5wb3coKCR4IC8gJG4pLCAxLzMpXG5cdFx0XHRcdC0gKDEgLSAyLzkvJG4pKSAvIE1hdGguc3FydCgyLzkvJG4pKTtcblx0fSBlbHNlIGlmICgkeCA+IDQwMCkge1xuXHRcdCRwID0gMDtcblx0fSBlbHNlIHsgICBcblx0XHR2YXIgJGE7XG4gICAgICAgICAgICAgICAgdmFyICRpO1xuICAgICAgICAgICAgICAgIHZhciAkaTE7XG5cdFx0aWYgKCgkbiAlIDIpICE9IDApIHtcblx0XHRcdCRwID0gMiAqIF9zdWJ1cHJvYihNYXRoLnNxcnQoJHgpKTtcblx0XHRcdCRhID0gTWF0aC5zcXJ0KDIvTWF0aC5QSSkgKiBNYXRoLmV4cCgtJHgvMikgLyBNYXRoLnNxcnQoJHgpO1xuXHRcdFx0JGkxID0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JHAgPSAkYSA9IE1hdGguZXhwKC0keC8yKTtcblx0XHRcdCRpMSA9IDI7XG5cdFx0fVxuXG5cdFx0Zm9yICgkaSA9ICRpMTsgJGkgPD0gKCRuLTIpOyAkaSArPSAyKSB7XG5cdFx0XHQkYSAqPSAkeCAvICRpO1xuXHRcdFx0JHAgKz0gJGE7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAkcDtcbn1cblxuZnVuY3Rpb24gX3N1YnUgKCRwKSB7XG5cdHZhciAkeSA9IC1NYXRoLmxvZyg0ICogJHAgKiAoMSAtICRwKSk7XG5cdHZhciAkeCA9IE1hdGguc3FydChcblx0XHQkeSAqICgxLjU3MDc5NjI4OFxuXHRcdCAgKyAkeSAqICguMDM3MDY5ODc5MDZcblx0XHQgIFx0KyAkeSAqICgtLjgzNjQzNTM1ODlFLTNcblx0XHRcdCAgKyAkeSAqKC0uMjI1MDk0NzE3NkUtM1xuXHRcdFx0ICBcdCsgJHkgKiAoLjY4NDEyMTgyOTlFLTVcblx0XHRcdFx0ICArICR5ICogKDAuNTgyNDIzODUxNUUtNVxuXHRcdFx0XHRcdCsgJHkgKiAoLS4xMDQ1Mjc0OTdFLTVcblx0XHRcdFx0XHQgICsgJHkgKiAoLjgzNjA5MzcwMTdFLTdcblx0XHRcdFx0XHRcdCsgJHkgKiAoLS4zMjMxMDgxMjc3RS04XG5cdFx0XHRcdFx0XHQgICsgJHkgKiAoLjM2NTc3NjMwMzZFLTEwXG5cdFx0XHRcdFx0XHRcdCsgJHkgKi42OTM2MjMzOTgyRS0xMikpKSkpKSkpKSkpO1xuXHRpZiAoJHA+LjUpXG4gICAgICAgICAgICAgICAgJHggPSAtJHg7XG5cdHJldHVybiAkeDtcbn1cblxuZnVuY3Rpb24gX3N1YnVwcm9iICgkeCkge1xuXHR2YXIgJHAgPSAwOyAvKiBpZiAoJGFic3ggPiAxMDApICovXG5cdHZhciAkYWJzeCA9IE1hdGguYWJzKCR4KTtcblxuXHRpZiAoJGFic3ggPCAxLjkpIHtcblx0XHQkcCA9IE1hdGgucG93KCgxICtcblx0XHRcdCRhYnN4ICogKC4wNDk4NjczNDdcblx0XHRcdCAgKyAkYWJzeCAqICguMDIxMTQxMDA2MVxuXHRcdFx0ICBcdCsgJGFic3ggKiAoLjAwMzI3NzYyNjNcblx0XHRcdFx0ICArICRhYnN4ICogKC4wMDAwMzgwMDM2XG5cdFx0XHRcdFx0KyAkYWJzeCAqICguMDAwMDQ4ODkwNlxuXHRcdFx0XHRcdCAgKyAkYWJzeCAqIC4wMDAwMDUzODMpKSkpKSksIC0xNikvMjtcblx0fSBlbHNlIGlmICgkYWJzeCA8PSAxMDApIHtcblx0XHRmb3IgKHZhciAkaSA9IDE4OyAkaSA+PSAxOyAkaS0tKSB7XG5cdFx0XHQkcCA9ICRpIC8gKCRhYnN4ICsgJHApO1xuXHRcdH1cblx0XHQkcCA9IE1hdGguZXhwKC0uNSAqICRhYnN4ICogJGFic3gpIFxuXHRcdFx0LyBNYXRoLnNxcnQoMiAqIE1hdGguUEkpIC8gKCRhYnN4ICsgJHApO1xuXHR9XG5cblx0aWYgKCR4PDApXG4gICAgICAgIFx0JHAgPSAxIC0gJHA7XG5cdHJldHVybiAkcDtcbn1cblxuICAgXG5mdW5jdGlvbiBfc3VidCAoJG4sICRwKSB7XG5cblx0aWYgKCRwID49IDEgfHwgJHAgPD0gMCkge1xuXHRcdHRocm93KFwiSW52YWxpZCBwOiAkcFxcblwiKTtcblx0fVxuXG5cdGlmICgkcCA9PSAwLjUpIHtcblx0XHRyZXR1cm4gMDtcblx0fSBlbHNlIGlmICgkcCA8IDAuNSkge1xuXHRcdHJldHVybiAtIF9zdWJ0KCRuLCAxIC0gJHApO1xuXHR9XG5cblx0dmFyICR1ID0gX3N1YnUoJHApO1xuXHR2YXIgJHUyID0gTWF0aC5wb3coJHUsIDIpO1xuXG5cdHZhciAkYSA9ICgkdTIgKyAxKSAvIDQ7XG5cdHZhciAkYiA9ICgoNSAqICR1MiArIDE2KSAqICR1MiArIDMpIC8gOTY7XG5cdHZhciAkYyA9ICgoKDMgKiAkdTIgKyAxOSkgKiAkdTIgKyAxNykgKiAkdTIgLSAxNSkgLyAzODQ7XG5cdHZhciAkZCA9ICgoKCg3OSAqICR1MiArIDc3NikgKiAkdTIgKyAxNDgyKSAqICR1MiAtIDE5MjApICogJHUyIC0gOTQ1KSBcblx0XHRcdFx0LyA5MjE2MDtcblx0dmFyICRlID0gKCgoKCgyNyAqICR1MiArIDMzOSkgKiAkdTIgKyA5MzApICogJHUyIC0gMTc4MikgKiAkdTIgLSA3NjUpICogJHUyXG5cdFx0XHQrIDE3OTU1KSAvIDM2ODY0MDtcblxuXHR2YXIgJHggPSAkdSAqICgxICsgKCRhICsgKCRiICsgKCRjICsgKCRkICsgJGUgLyAkbikgLyAkbikgLyAkbikgLyAkbikgLyAkbik7XG5cblx0aWYgKCRuIDw9IE1hdGgucG93KGxvZzEwKCRwKSwgMikgKyAzKSB7XG5cdFx0dmFyICRyb3VuZDtcblx0XHRkbyB7IFxuXHRcdFx0dmFyICRwMSA9IF9zdWJ0cHJvYigkbiwgJHgpO1xuXHRcdFx0dmFyICRuMSA9ICRuICsgMTtcblx0XHRcdHZhciAkZGVsdGEgPSAoJHAxIC0gJHApIFxuXHRcdFx0XHQvIE1hdGguZXhwKCgkbjEgKiBNYXRoLmxvZygkbjEgLyAoJG4gKyAkeCAqICR4KSkgXG5cdFx0XHRcdFx0KyBNYXRoLmxvZygkbi8kbjEvMi9NYXRoLlBJKSAtIDEgXG5cdFx0XHRcdFx0KyAoMS8kbjEgLSAxLyRuKSAvIDYpIC8gMik7XG5cdFx0XHQkeCArPSAkZGVsdGE7XG5cdFx0XHQkcm91bmQgPSByb3VuZF90b19wcmVjaXNpb24oJGRlbHRhLCBNYXRoLmFicyhpbnRlZ2VyKGxvZzEwKE1hdGguYWJzKCR4KSktNCkpKTtcblx0XHR9IHdoaWxlICgoJHgpICYmICgkcm91bmQgIT0gMCkpO1xuXHR9XG5cdHJldHVybiAkeDtcbn1cblxuZnVuY3Rpb24gX3N1YnRwcm9iICgkbiwgJHgpIHtcblxuXHR2YXIgJGE7XG4gICAgICAgIHZhciAkYjtcblx0dmFyICR3ID0gTWF0aC5hdGFuMigkeCAvIE1hdGguc3FydCgkbiksIDEpO1xuXHR2YXIgJHogPSBNYXRoLnBvdyhNYXRoLmNvcygkdyksIDIpO1xuXHR2YXIgJHkgPSAxO1xuXG5cdGZvciAodmFyICRpID0gJG4tMjsgJGkgPj0gMjsgJGkgLT0gMikge1xuXHRcdCR5ID0gMSArICgkaS0xKSAvICRpICogJHogKiAkeTtcblx0fSBcblxuXHRpZiAoJG4gJSAyID09IDApIHtcblx0XHQkYSA9IE1hdGguc2luKCR3KS8yO1xuXHRcdCRiID0gLjU7XG5cdH0gZWxzZSB7XG5cdFx0JGEgPSAoJG4gPT0gMSkgPyAwIDogTWF0aC5zaW4oJHcpKk1hdGguY29zKCR3KS9NYXRoLlBJO1xuXHRcdCRiPSAuNSArICR3L01hdGguUEk7XG5cdH1cblx0cmV0dXJuIG1heCgwLCAxIC0gJGIgLSAkYSAqICR5KTtcbn1cblxuZnVuY3Rpb24gX3N1YmYgKCRuLCAkbSwgJHApIHtcblx0dmFyICR4O1xuXG5cdGlmICgkcCA+PSAxIHx8ICRwIDw9IDApIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblxuXHRpZiAoJHAgPT0gMSkge1xuXHRcdCR4ID0gMDtcblx0fSBlbHNlIGlmICgkbSA9PSAxKSB7XG5cdFx0JHggPSAxIC8gTWF0aC5wb3coX3N1YnQoJG4sIDAuNSAtICRwIC8gMiksIDIpO1xuXHR9IGVsc2UgaWYgKCRuID09IDEpIHtcblx0XHQkeCA9IE1hdGgucG93KF9zdWJ0KCRtLCAkcC8yKSwgMik7XG5cdH0gZWxzZSBpZiAoJG0gPT0gMikge1xuXHRcdHZhciAkdSA9IF9zdWJjaGlzcXIoJG0sIDEgLSAkcCk7XG5cdFx0dmFyICRhID0gJG0gLSAyO1xuXHRcdCR4ID0gMSAvICgkdSAvICRtICogKDEgK1xuXHRcdFx0KCgkdSAtICRhKSAvIDIgK1xuXHRcdFx0XHQoKCg0ICogJHUgLSAxMSAqICRhKSAqICR1ICsgJGEgKiAoNyAqICRtIC0gMTApKSAvIDI0ICtcblx0XHRcdFx0XHQoKCgyICogJHUgLSAxMCAqICRhKSAqICR1ICsgJGEgKiAoMTcgKiAkbSAtIDI2KSkgKiAkdVxuXHRcdFx0XHRcdFx0LSAkYSAqICRhICogKDkgKiAkbSAtIDYpXG5cdFx0XHRcdFx0KS80OC8kblxuXHRcdFx0XHQpLyRuXG5cdFx0XHQpLyRuKSk7XG5cdH0gZWxzZSBpZiAoJG4gPiAkbSkge1xuXHRcdCR4ID0gMSAvIF9zdWJmMigkbSwgJG4sIDEgLSAkcClcblx0fSBlbHNlIHtcblx0XHQkeCA9IF9zdWJmMigkbiwgJG0sICRwKVxuXHR9XG5cdHJldHVybiAkeDtcbn1cblxuZnVuY3Rpb24gX3N1YmYyICgkbiwgJG0sICRwKSB7XG5cdHZhciAkdSA9IF9zdWJjaGlzcXIoJG4sICRwKTtcblx0dmFyICRuMiA9ICRuIC0gMjtcblx0dmFyICR4ID0gJHUgLyAkbiAqIFxuXHRcdCgxICsgXG5cdFx0XHQoKCR1IC0gJG4yKSAvIDIgKyBcblx0XHRcdFx0KCgoNCAqICR1IC0gMTEgKiAkbjIpICogJHUgKyAkbjIgKiAoNyAqICRuIC0gMTApKSAvIDI0ICsgXG5cdFx0XHRcdFx0KCgoMiAqICR1IC0gMTAgKiAkbjIpICogJHUgKyAkbjIgKiAoMTcgKiAkbiAtIDI2KSkgKiAkdSBcblx0XHRcdFx0XHRcdC0gJG4yICogJG4yICogKDkgKiAkbiAtIDYpKSAvIDQ4IC8gJG0pIC8gJG0pIC8gJG0pO1xuXHR2YXIgJGRlbHRhO1xuXHRkbyB7XG5cdFx0dmFyICR6ID0gTWF0aC5leHAoXG5cdFx0XHQoKCRuKyRtKSAqIE1hdGgubG9nKCgkbiskbSkgLyAoJG4gKiAkeCArICRtKSkgXG5cdFx0XHRcdCsgKCRuIC0gMikgKiBNYXRoLmxvZygkeClcblx0XHRcdFx0KyBNYXRoLmxvZygkbiAqICRtIC8gKCRuKyRtKSlcblx0XHRcdFx0LSBNYXRoLmxvZyg0ICogTWF0aC5QSSlcblx0XHRcdFx0LSAoMS8kbiAgKyAxLyRtIC0gMS8oJG4rJG0pKS82XG5cdFx0XHQpLzIpO1xuXHRcdCRkZWx0YSA9IChfc3ViZnByb2IoJG4sICRtLCAkeCkgLSAkcCkgLyAkejtcblx0XHQkeCArPSAkZGVsdGE7XG5cdH0gd2hpbGUgKE1hdGguYWJzKCRkZWx0YSk+M2UtNCk7XG5cdHJldHVybiAkeDtcbn1cblxuZnVuY3Rpb24gX3N1YmNoaXNxciAoJG4sICRwKSB7XG5cdHZhciAkeDtcblxuXHRpZiAoKCRwID4gMSkgfHwgKCRwIDw9IDApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIHA6ICRwXFxuXCIpO1xuXHR9IGVsc2UgaWYgKCRwID09IDEpe1xuXHRcdCR4ID0gMDtcblx0fSBlbHNlIGlmICgkbiA9PSAxKSB7XG5cdFx0JHggPSBNYXRoLnBvdyhfc3VidSgkcCAvIDIpLCAyKTtcblx0fSBlbHNlIGlmICgkbiA9PSAyKSB7XG5cdFx0JHggPSAtMiAqIE1hdGgubG9nKCRwKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgJHUgPSBfc3VidSgkcCk7XG5cdFx0dmFyICR1MiA9ICR1ICogJHU7XG5cblx0XHQkeCA9IG1heCgwLCAkbiArIE1hdGguc3FydCgyICogJG4pICogJHUgXG5cdFx0XHQrIDIvMyAqICgkdTIgLSAxKVxuXHRcdFx0KyAkdSAqICgkdTIgLSA3KSAvIDkgLyBNYXRoLnNxcnQoMiAqICRuKVxuXHRcdFx0LSAyLzQwNSAvICRuICogKCR1MiAqICgzICokdTIgKyA3KSAtIDE2KSk7XG5cblx0XHRpZiAoJG4gPD0gMTAwKSB7XG5cdFx0XHR2YXIgJHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkejtcblx0XHRcdGRvIHtcblx0XHRcdFx0JHgwID0gJHg7XG5cdFx0XHRcdGlmICgkeCA8IDApIHtcblx0XHRcdFx0XHQkcDEgPSAxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCRuPjEwMCkge1xuXHRcdFx0XHRcdCRwMSA9IF9zdWJ1cHJvYigoTWF0aC5wb3coKCR4IC8gJG4pLCAoMS8zKSkgLSAoMSAtIDIvOS8kbikpXG5cdFx0XHRcdFx0XHQvIE1hdGguc3FydCgyLzkvJG4pKTtcblx0XHRcdFx0fSBlbHNlIGlmICgkeD40MDApIHtcblx0XHRcdFx0XHQkcDEgPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciAkaTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGE7XG5cdFx0XHRcdFx0aWYgKCgkbiAlIDIpICE9IDApIHtcblx0XHRcdFx0XHRcdCRwMSA9IDIgKiBfc3VidXByb2IoTWF0aC5zcXJ0KCR4KSk7XG5cdFx0XHRcdFx0XHQkYSA9IE1hdGguc3FydCgyL01hdGguUEkpICogTWF0aC5leHAoLSR4LzIpIC8gTWF0aC5zcXJ0KCR4KTtcblx0XHRcdFx0XHRcdCRpMCA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdCRwMSA9ICRhID0gTWF0aC5leHAoLSR4LzIpO1xuXHRcdFx0XHRcdFx0JGkwID0gMjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKHZhciAkaSA9ICRpMDsgJGkgPD0gJG4tMjsgJGkgKz0gMikge1xuXHRcdFx0XHRcdFx0JGEgKj0gJHggLyAkaTtcblx0XHRcdFx0XHRcdCRwMSArPSAkYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0JHogPSBNYXRoLmV4cCgoKCRuLTEpICogTWF0aC5sb2coJHgvJG4pIC0gTWF0aC5sb2coNCpNYXRoLlBJKiR4KSBcblx0XHRcdFx0XHQrICRuIC0gJHggLSAxLyRuLzYpIC8gMik7XG5cdFx0XHRcdCR4ICs9ICgkcDEgLSAkcCkgLyAkejtcblx0XHRcdFx0JHggPSByb3VuZF90b19wcmVjaXNpb24oJHgsIDUpO1xuXHRcdFx0fSB3aGlsZSAoKCRuIDwgMzEpICYmIChNYXRoLmFicygkeDAgLSAkeCkgPiAxZS00KSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAkeDtcbn1cblxuZnVuY3Rpb24gbG9nMTAgKCRuKSB7XG5cdHJldHVybiBNYXRoLmxvZygkbikgLyBNYXRoLmxvZygxMCk7XG59XG4gXG5mdW5jdGlvbiBtYXggKCkge1xuXHR2YXIgJG1heCA9IGFyZ3VtZW50c1swXTtcblx0Zm9yICh2YXIgJGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRtYXggPCBhcmd1bWVudHNbJGldKVxuICAgICAgICAgICAgICAgICAgICAgICAgJG1heCA9IGFyZ3VtZW50c1skaV07XG5cdH1cdFxuXHRyZXR1cm4gJG1heDtcbn1cblxuZnVuY3Rpb24gbWluICgpIHtcblx0dmFyICRtaW4gPSBhcmd1bWVudHNbMF07XG5cdGZvciAodmFyICRpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgkbWluID4gYXJndW1lbnRzWyRpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICRtaW4gPSBhcmd1bWVudHNbJGldO1xuXHR9XG5cdHJldHVybiAkbWluO1xufVxuXG5mdW5jdGlvbiBwcmVjaXNpb24gKCR4KSB7XG5cdHJldHVybiBNYXRoLmFicyhpbnRlZ2VyKGxvZzEwKE1hdGguYWJzKCR4KSkgLSBTSUdOSUZJQ0FOVCkpO1xufVxuXG5mdW5jdGlvbiBwcmVjaXNpb25fc3RyaW5nICgkeCkge1xuXHRpZiAoJHgpIHtcblx0XHRyZXR1cm4gcm91bmRfdG9fcHJlY2lzaW9uKCR4LCBwcmVjaXNpb24oJHgpKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gXCIwXCI7XG5cdH1cbn1cblxuZnVuY3Rpb24gcm91bmRfdG9fcHJlY2lzaW9uICgkeCwgJHApIHtcbiAgICAgICAgJHggPSAkeCAqIE1hdGgucG93KDEwLCAkcCk7XG4gICAgICAgICR4ID0gTWF0aC5yb3VuZCgkeCk7XG4gICAgICAgIHJldHVybiAkeCAvIE1hdGgucG93KDEwLCAkcCk7XG59XG5cbmZ1bmN0aW9uIGludGVnZXIgKCRpKSB7XG4gICAgICAgIGlmICgkaSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoJGkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgkaSk7XG59IiwiaW1wb3J0IHt0ZGlzdHJ9IGZyb20gXCIuL3N0YXRpc3RpY3MtZGlzdHJpYnV0aW9uc1wiXG5cbnZhciBzdSA9IG1vZHVsZS5leHBvcnRzLlN0YXRpc3RpY3NVdGlscyA9e307XG5zdS5zYW1wbGVDb3JyZWxhdGlvbiA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zYW1wbGVfY29ycmVsYXRpb24nKTtcbnN1LmxpbmVhclJlZ3Jlc3Npb24gPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvbGluZWFyX3JlZ3Jlc3Npb24nKTtcbnN1LmxpbmVhclJlZ3Jlc3Npb25MaW5lID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2xpbmVhcl9yZWdyZXNzaW9uX2xpbmUnKTtcbnN1LmVycm9yRnVuY3Rpb24gPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvZXJyb3JfZnVuY3Rpb24nKTtcbnN1LnN0YW5kYXJkRGV2aWF0aW9uID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3N0YW5kYXJkX2RldmlhdGlvbicpO1xuc3Uuc2FtcGxlU3RhbmRhcmREZXZpYXRpb24gPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvc2FtcGxlX3N0YW5kYXJkX2RldmlhdGlvbicpO1xuc3UudmFyaWFuY2UgPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvdmFyaWFuY2UnKTtcbnN1Lm1lYW4gPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvbWVhbicpO1xuc3UuelNjb3JlID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3pfc2NvcmUnKTtcbnN1LnN0YW5kYXJkRXJyb3I9IGFyciA9PiBNYXRoLnNxcnQoc3UudmFyaWFuY2UoYXJyKS8oYXJyLmxlbmd0aC0xKSk7XG5zdS5xdWFudGlsZSA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9xdWFudGlsZScpO1xuXG5zdS50VmFsdWU9IChkZWdyZWVzT2ZGcmVlZG9tLCBjcml0aWNhbFByb2JhYmlsaXR5KSA9PiB7IC8vYXMgaW4gaHR0cDovL3N0YXR0cmVrLmNvbS9vbmxpbmUtY2FsY3VsYXRvci90LWRpc3RyaWJ1dGlvbi5hc3B4XG4gICAgcmV0dXJuIHRkaXN0cihkZWdyZWVzT2ZGcmVlZG9tLCBjcml0aWNhbFByb2JhYmlsaXR5KTtcbn07IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIFV0aWxzIHtcbiAgICBzdGF0aWMgU1FSVF8yID0gMS40MTQyMTM1NjIzNztcbiAgICAvLyB1c2FnZSBleGFtcGxlIGRlZXBFeHRlbmQoe30sIG9iakEsIG9iakIpOyA9PiBzaG91bGQgd29yayBzaW1pbGFyIHRvICQuZXh0ZW5kKHRydWUsIHt9LCBvYmpBLCBvYmpCKTtcbiAgICBzdGF0aWMgZGVlcEV4dGVuZChvdXQpIHtcblxuICAgICAgICB2YXIgdXRpbHMgPSB0aGlzO1xuICAgICAgICB2YXIgZW1wdHlPdXQgPSB7fTtcblxuXG4gICAgICAgIGlmICghb3V0ICYmIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkob3V0W2tleV0pO1xuICAgICAgICAgICAgICAgIHZhciBpc09iamVjdCA9IHV0aWxzLmlzT2JqZWN0KG91dFtrZXldKTtcbiAgICAgICAgICAgICAgICB2YXIgc3JjT2JqID0gdXRpbHMuaXNPYmplY3Qoc291cmNlW2tleV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0ICYmICFpc0FycmF5ICYmIHNyY09iaikge1xuICAgICAgICAgICAgICAgICAgICB1dGlscy5kZWVwRXh0ZW5kKG91dFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBzdGF0aWMgbWVyZ2VEZWVwKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQpO1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3ROb3RBcnJheSh0YXJnZXQpICYmIFV0aWxzLmlzT2JqZWN0Tm90QXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0Tm90QXJyYXkoc291cmNlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiB0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHtba2V5XTogc291cmNlW2tleV19KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBVdGlscy5tZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwge1trZXldOiBzb3VyY2Vba2V5XX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyb3NzKGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSBbXSwgbiA9IGEubGVuZ3RoLCBtID0gYi5sZW5ndGgsIGksIGo7XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuOykgZm9yIChqID0gLTE7ICsraiA8IG07KSBjLnB1c2goe3g6IGFbaV0sIGk6IGksIHk6IGJbal0sIGo6IGp9KTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfTtcblxuICAgIHN0YXRpYyBpbmZlclZhcmlhYmxlcyhkYXRhLCBncm91cEtleSwgaW5jbHVkZUdyb3VwKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgaWYoIWRhdGEpe1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGQgPSBkYXRhWzBdO1xuICAgICAgICAgICAgaWYgKGQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IGQubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWQuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBLZXkgIT09IG51bGwgJiYgZ3JvdXBLZXkgIT09IHVuZGVmaW5lZCAmJiAhaW5jbHVkZUdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByZXMuaW5kZXhPZihncm91cEtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHJlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzT2JqZWN0Tm90QXJyYXkoaXRlbSkge1xuICAgICAgICByZXR1cm4gKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGl0ZW0pICYmIGl0ZW0gIT09IG51bGwpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaXNBcnJheShpdGVtKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW0pO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaXNPYmplY3QoYSkge1xuICAgICAgICByZXR1cm4gYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCc7XG4gICAgfTtcblxuICAgIHN0YXRpYyBpc051bWJlcihhKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oYSkgJiYgdHlwZW9mIGEgPT09ICdudW1iZXInO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaXNGdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzRGF0ZShhKXtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG4gICAgfVxuXG4gICAgc3RhdGljIGlzU3RyaW5nKGEpe1xuICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IGEgaW5zdGFuY2VvZiBTdHJpbmdcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBvcGVyYXRpb24sIGJlZm9yZSkge1xuXG4gICAgICAgIHZhciBzZWxlY3RvclBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoLyhbXFwuXFwjXSkvKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBwYXJlbnRbb3BlcmF0aW9uXShzZWxlY3RvclBhcnRzLnNoaWZ0KCksIGJlZm9yZSk7Ly9cIjpmaXJzdC1jaGlsZFwiXG4gICAgICAgIFxuICAgICAgICB3aGlsZSAoc2VsZWN0b3JQYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JNb2RpZmllciA9IHNlbGVjdG9yUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rvckl0ZW0gPSBzZWxlY3RvclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JNb2RpZmllciA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5jbGFzc2VkKHNlbGVjdG9ySXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yTW9kaWZpZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuYXR0cignaWQnLCBzZWxlY3Rvckl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnNlcnRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBiZWZvcmUpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmluc2VydE9yQXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgXCJpbnNlcnRcIiwgYmVmb3JlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gVXRpbHMuaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBcImFwcGVuZFwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0T3JBcHBlbmQocGFyZW50LCBzZWxlY3RvciwgZWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gcGFyZW50LnNlbGVjdChzZWxlY3Rvcik7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uZW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVdGlscy5hcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yKTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfTtcblxuICAgIHN0YXRpYyBzZWxlY3RPckluc2VydChwYXJlbnQsIHNlbGVjdG9yLCBiZWZvcmUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHBhcmVudC5zZWxlY3Qoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5pbnNlcnRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBiZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfTtcblxuICAgIHN0YXRpYyBsaW5lYXJHcmFkaWVudChzdmcsIGdyYWRpZW50SWQsIHJhbmdlLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgZGVmcyA9IFV0aWxzLnNlbGVjdE9yQXBwZW5kKHN2ZywgXCJkZWZzXCIpO1xuICAgICAgICB2YXIgbGluZWFyR3JhZGllbnQgPSBkZWZzLmFwcGVuZChcImxpbmVhckdyYWRpZW50XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGdyYWRpZW50SWQpO1xuXG4gICAgICAgIGxpbmVhckdyYWRpZW50XG4gICAgICAgICAgICAuYXR0cihcIngxXCIsIHgxICsgXCIlXCIpXG4gICAgICAgICAgICAuYXR0cihcInkxXCIsIHkxICsgXCIlXCIpXG4gICAgICAgICAgICAuYXR0cihcIngyXCIsIHgyICsgXCIlXCIpXG4gICAgICAgICAgICAuYXR0cihcInkyXCIsIHkyICsgXCIlXCIpO1xuXG4gICAgICAgIC8vQXBwZW5kIG11bHRpcGxlIGNvbG9yIHN0b3BzIGJ5IHVzaW5nIEQzJ3MgZGF0YS9lbnRlciBzdGVwXG4gICAgICAgIHZhciBzdG9wcyA9IGxpbmVhckdyYWRpZW50LnNlbGVjdEFsbChcInN0b3BcIilcbiAgICAgICAgICAgIC5kYXRhKHJhbmdlKTtcblxuICAgICAgICB2YXIgc3RvcHNNZXJnZSA9IHN0b3BzLmVudGVyKCkuYXBwZW5kKFwic3RvcFwiKS5tZXJnZShzdG9wcyk7XG5cbiAgICAgICAgc3RvcHNNZXJnZS5hdHRyKFwib2Zmc2V0XCIsIChkLCBpKSA9PiBpIC8gKHJhbmdlLmxlbmd0aCAtIDEpKVxuICAgICAgICAgICAgLmF0dHIoXCJzdG9wLWNvbG9yXCIsIGQgPT4gZCk7XG5cbiAgICAgICAgc3RvcHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzYW5pdGl6ZUhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpLCAxMCkgfHwgNDAwKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIHNhbml0aXplV2lkdGggPSBmdW5jdGlvbiAod2lkdGgsIGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gKHdpZHRoIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSwgMTApIHx8IDk2MCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBhdmFpbGFibGVIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgVXRpbHMuc2FuaXRpemVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIpIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH07XG5cbiAgICBzdGF0aWMgYXZhaWxhYmxlV2lkdGggPSBmdW5jdGlvbiAod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBVdGlscy5zYW5pdGl6ZVdpZHRoKHdpZHRoLCBjb250YWluZXIpIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ3VpZCgpIHtcbiAgICAgICAgZnVuY3Rpb24gczQoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICtcbiAgICAgICAgICAgIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgfVxuXG4gICAgLy9wbGFjZXMgdGV4dFN0cmluZyBpbiB0ZXh0T2JqLCBhZGRzIGFuIGVsbGlwc2lzIGlmIHRleHQgY2FuJ3QgZml0IGluIHdpZHRoXG4gICAgc3RhdGljIHBsYWNlVGV4dFdpdGhFbGxpcHNpcyh0ZXh0RDNPYmosIHRleHRTdHJpbmcsIHdpZHRoKXtcbiAgICAgICAgdmFyIHRleHRPYmogPSB0ZXh0RDNPYmoubm9kZSgpO1xuICAgICAgICB0ZXh0T2JqLnRleHRDb250ZW50PXRleHRTdHJpbmc7XG5cbiAgICAgICAgdmFyIG1hcmdpbiA9IDA7XG4gICAgICAgIHZhciBlbGxpcHNpc0xlbmd0aCA9IDk7XG4gICAgICAgIC8vZWxsaXBzaXMgaXMgbmVlZGVkXG4gICAgICAgIGlmICh0ZXh0T2JqLmdldENvbXB1dGVkVGV4dExlbmd0aCgpPndpZHRoK21hcmdpbil7XG4gICAgICAgICAgICBmb3IgKHZhciB4PXRleHRTdHJpbmcubGVuZ3RoLTM7eD4wO3gtPTEpe1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0T2JqLmdldFN1YlN0cmluZ0xlbmd0aCgwLHgpK2VsbGlwc2lzTGVuZ3RoPD13aWR0aCttYXJnaW4pe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T2JqLnRleHRDb250ZW50PXRleHRTdHJpbmcuc3Vic3RyaW5nKDAseCkrXCIuLi5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudD1cIi4uLlwiOyAvL2Nhbid0IHBsYWNlIGF0IGFsbFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBwbGFjZVRleHRXaXRoRWxsaXBzaXNBbmRUb29sdGlwKHRleHREM09iaiwgdGV4dFN0cmluZywgd2lkdGgsIHRvb2x0aXApe1xuICAgICAgICB2YXIgZWxsaXBzaXNQbGFjZWQgPSBVdGlscy5wbGFjZVRleHRXaXRoRWxsaXBzaXModGV4dEQzT2JqLCB0ZXh0U3RyaW5nLCB3aWR0aCk7XG4gICAgICAgIGlmKGVsbGlwc2lzUGxhY2VkICYmIHRvb2x0aXApe1xuICAgICAgICAgICAgdGV4dEQzT2JqLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAuOSk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5odG1sKHRleHRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgKGQzLmV2ZW50LnBhZ2VYICsgNSkgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAoZDMuZXZlbnQucGFnZVkgLSAyOCkgKyBcInB4XCIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRleHREM09iai5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Rm9udFNpemUoZWxlbWVudCl7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC1zaXplXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNjYWxlKHNjYWxlTmFtZSkge1xuICAgICAgICB2YXIgc2NhbGVGdW5jdGlvbk5hbWUgPSAnc2NhbGUnK1V0aWxzLmNhcGl0YWxpemVGaXJzdExldHRlcihzY2FsZU5hbWUpO1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICByZXR1cm4gZDNbc2NhbGVGdW5jdGlvbk5hbWVdKCk7XG4gICAgICAgIH1jYXRjaCAoZSl7XG4gICAgICAgICAgICB0aHJvdyAnT0RDLUQzIC0gc2NhbGUgbm90IHN1cHBvcnRlZDogJytzY2FsZU5hbWUrICcgKCcrc2NhbGVGdW5jdGlvbk5hbWUrJyknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUF4aXMob3JpZW50LCBzY2FsZSl7XG4gICAgICAgIHZhciBheGlzRm5OYW1lID0gJ2F4aXMnK1V0aWxzLmNhcGl0YWxpemVGaXJzdExldHRlcihvcmllbnQpO1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICByZXR1cm4gZDNbYXhpc0ZuTmFtZV0oc2NhbGUpXG4gICAgICAgIH1jYXRjaCAoZSl7XG4gICAgICAgICAgICB0aHJvdyAnT0RDLUQzIC0gYXhpcyBvcmllbnQgbm90IHN1cHBvcnRlZDogJytvcmllbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=
