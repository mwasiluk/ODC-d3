(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ODCD3 = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function cross(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number(x) {
  return x === null ? NaN : +x;
}

function variance(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

function constant(x) {
  return function() {
    return x;
  };
}

function identity(x) {
  return x;
}

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function quantile(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function median(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
}

function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}

function scan(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],2:[function(require,module,exports){
// https://d3js.org/d3-axis/ v1.0.12 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var slice = Array.prototype.slice;

function identity(x) {
  return x;
}

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){
// https://d3js.org/d3-brush/ v1.0.6 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-transition')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-transition'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Selection,d3Dispatch,d3Drag,d3Interpolate,d3Transition) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function BrushEvent(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

function brush() {
  return brush$1(XY);
}

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = d3Dispatch.dispatch(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          d3Selection.select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = d3Interpolate.interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            d3Transition.interrupt(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = d3Selection.select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (d3Selection.event.touches) { if (d3Selection.event.changedTouches.length < d3Selection.event.touches.length) return noevent(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = d3Selection.event.target.__data__.type,
        mode = (d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && d3Selection.event.shiftKey,
        lockX,
        lockY,
        point0 = d3Selection.mouse(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = d3Selection.select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (d3Selection.event.touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = d3Selection.select(d3Selection.event.view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      d3Drag.dragDisable(d3Selection.event.view);
    }

    nopropagation();
    d3Transition.interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = d3Selection.mouse(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (d3Selection.event.touches) {
        if (d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        d3Drag.dragEnable(d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }

    function keyupped() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (d3Selection.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

exports.brush = brush;
exports.brushX = brushX;
exports.brushY = brushY;
exports.brushSelection = brushSelection;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":6,"d3-drag":7,"d3-interpolate":11,"d3-selection":14,"d3-transition":25}],4:[function(require,module,exports){
// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],5:[function(require,module,exports){
// https://d3js.org/d3-color/ v1.2.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://beta.observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.lch = lch;
exports.gray = gray;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],6:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ v1.0.5 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

exports.dispatch = dispatch;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],7:[function(require,module,exports){
// https://d3js.org/d3-drag/ v1.2.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Selection,d3Dispatch) { 'use strict';

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

function nodrag(view) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant(x) {
  return function() {
    return x;
  };
}

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = d3Dispatch.dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
    if (!gesture) return;
    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(d3Selection.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = d3Selection.event.clientX;
    mousedowny = d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(d3Selection.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

exports.drag = drag;
exports.dragDisable = nodrag;
exports.dragEnable = yesdrag;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":6,"d3-selection":14}],8:[function(require,module,exports){
// https://d3js.org/d3-ease/ v1.0.5 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function linear(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

exports.easeLinear = linear;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadOut = quadOut;
exports.easeQuadInOut = quadInOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicOut = cubicOut;
exports.easeCubicInOut = cubicInOut;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyOut = polyOut;
exports.easePolyInOut = polyInOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinOut = sinOut;
exports.easeSinInOut = sinInOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpOut = expOut;
exports.easeExpInOut = expInOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleOut = circleOut;
exports.easeCircleInOut = circleInOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceOut = bounceOut;
exports.easeBounceInOut = bounceInOut;
exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackOut = backOut;
exports.easeBackInOut = backInOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticOut = elasticOut;
exports.easeElasticInOut = elasticInOut;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],9:[function(require,module,exports){
// https://d3js.org/d3-format/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],10:[function(require,module,exports){
// https://d3js.org/d3-hierarchy/ v1.1.8 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

function cluster() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose(circles) {
  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function siblings(circles) {
  packEnclose(circles);
  return circles;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant(x) {
  return function() {
    return x;
  };
}

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function index() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
function tree() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function index$1() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };

  return treemap;
}

function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}

var resquarify = (function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi);

exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index;
exports.packSiblings = siblings;
exports.packEnclose = enclose;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$1;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;
exports.treemapResquarify = resquarify;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],11:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = d3Color.rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function array(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function number(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
      : b instanceof d3Color.color ? rgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function round(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$1 = hsl(hue);
var hslLong = hsl(nogamma);

function lab(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$1 = hcl(hue);
var hclLong = hcl(nogamma);

function cubehelix(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

var cubehelix$1 = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHue = hue$1;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$1;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab;
exports.interpolateHcl = hcl$1;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$1;
exports.interpolateCubehelixLong = cubehelixLong;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":5}],12:[function(require,module,exports){
// https://d3js.org/d3-path/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

exports.path = path;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],13:[function(require,module,exports){
// https://d3js.org/d3-scale/ Version 1.0.7. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-collection'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format'), require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat,d3Color) { 'use strict';

var array = Array.prototype;

var map$1 = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal(range$$1) {
  var index = d3Collection.map(),
      domain = [],
      unknown = implicit;

  range$$1 = range$$1 == null ? [] : slice.call(range$$1);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range$$1[(i - 1) % range$$1.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), scale) : range$$1.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range$$1)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range$$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range$$1[1] < range$$1[0],
        start = range$$1[reverse - 0],
        stop = range$$1[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range$$1)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

var constant = function(x) {
  return function() {
    return x;
  };
};

var number = function(x) {
  return +x;
};

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range$$1, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range$$1, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range$$1.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range$$1 = range$$1.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range$$1 = unit,
      interpolate$$1 = d3Interpolate.interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = slice.call(_), interpolate$$1 = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
  };

  return rescale();
}

var tickFormat = function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = d3Array.tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
};

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber);

  scale.copy = function() {
    return copy(scale, linear());
  };

  return linearish(scale);
}

function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return linearish(scale);
}

var nice = function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
};

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log().base(base));
  };

  return scale;
}

function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

function quantile$1() {
  var domain = [],
      range$$1 = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range$$1.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range$$1[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile$1()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range$$1 = [0, 1];

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range$$1 = slice.call(_)).length - 1, rescale()) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range$$1);
  };

  return linearish(scale);
}

function threshold() {
  var domain = [0.5],
      range$$1 = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format$$1) {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format$$1(".%L"),
      formatSecond = format$$1(":%S"),
      formatMinute = format$$1("%I:%M"),
      formatHour = format$$1("%I %p"),
      formatDay = format$$1("%a %d"),
      formatWeek = format$$1("%b %d"),
      formatMonth = format$$1("%B"),
      formatYear = format$$1("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format$$1(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format$$1));
  };

  return scale;
}

var time = function() {
  return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
};

var utcTime = function() {
  return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
};

var colors = function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
};

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var rainbow = d3Color.cubehelix();

var rainbow$1 = function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
};

function ramp(range$$1) {
  var n = range$$1.length;
  return function(t) {
    return range$$1[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile$1;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.schemeCategory10 = category10;
exports.schemeCategory20b = category20b;
exports.schemeCategory20c = category20c;
exports.schemeCategory20 = category20;
exports.interpolateCubehelixDefault = cubehelix$1;
exports.interpolateRainbow = rainbow$1;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;
exports.scaleSequential = sequential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":1,"d3-collection":4,"d3-color":5,"d3-format":9,"d3-interpolate":11,"d3-time":23,"d3-time-format":22}],14:[function(require,module,exports){
// https://d3js.org/d3-selection/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

function selection_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_merge(selection$$1) {

  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

exports.create = create;
exports.creator = creator;
exports.local = local;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.clientPoint = point;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],15:[function(require,module,exports){
// https://d3js.org/d3-shape/ v1.2.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-path')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Path) { 'use strict';

function constant(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi) {
          var oc = da0 > epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line() {
  var x$$1 = x,
      y$$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity(d) {
  return d;
}

function pie() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x,
      y$$1 = y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = d3Path.path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), link) : x$$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), link) : y$$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = d3Path.path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop() {}

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function none(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$1(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
}

function ascending(series) {
  var sums = series.map(sum);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$1(series) {
  return ascending(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$1(series).reverse();
}

exports.arc = arc;
exports.area = area;
exports.line = line;
exports.pie = pie;
exports.areaRadial = areaRadial;
exports.radialArea = areaRadial;
exports.lineRadial = lineRadial$1;
exports.radialLine = lineRadial$1;
exports.pointRadial = pointRadial;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle;
exports.symbolCross = cross;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetNone = none;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAscending = ascending;
exports.stackOrderDescending = descending$1;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$1;
exports.stackOrderReverse = reverse;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-path":12}],16:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-format'), require('d3-dispatch'), require('d3-scale'), require('d3-array')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-format', 'd3-dispatch', 'd3-scale', 'd3-array'], factory) :
	(factory((global.indexRollup = global.indexRollup || {}),global.d3Selection,global.d3Format,global.d3Dispatch,global.d3Scale,global.d3Array));
}(this, (function (exports,d3Selection,d3Format,d3Dispatch,d3Scale,d3Array) { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var d3_identity = function d3_identity(d) {
  return d;
};

var d3_reverse = function d3_reverse(arr) {
  var mirror = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    mirror[i] = arr[l - i - 1];
  }
  return mirror;
};

//Text wrapping code adapted from Mike Bostock
var d3_textWrapping = function d3_textWrapping(text, width) {
  text.each(function () {
    var text = d3Selection.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.2,
        //ems
    y = text.attr("y"),
        dy = parseFloat(text.attr("dy")) || 0,
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", dy + "em");

    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width && line.length > 1) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + dy + "em").text(word);
      }
    }
  });
};

var d3_mergeLabels = function d3_mergeLabels() {
  var gen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var labels = arguments[1];
  var domain = arguments[2];
  var range = arguments[3];
  var labelDelimiter = arguments[4];

  if ((typeof labels === "undefined" ? "undefined" : _typeof(labels)) === "object") {
    if (labels.length === 0) return gen;

    var i = labels.length;
    for (; i < gen.length; i++) {
      labels.push(gen[i]);
    }
    return labels;
  } else if (typeof labels === "function") {
    var customLabels = [];
    var genLength = gen.length;
    for (var _i = 0; _i < genLength; _i++) {
      customLabels.push(labels({
        i: _i,
        genLength: genLength,
        generatedLabels: gen,
        domain: domain,
        range: range,
        labelDelimiter: labelDelimiter
      }));
    }
    return customLabels;
  }

  return gen;
};

var d3_linearLegend = function d3_linearLegend(scale, cells, labelFormat) {
  var data = [];

  if (cells.length > 1) {
    data = cells;
  } else {
    var domain = scale.domain(),
        increment = (domain[domain.length - 1] - domain[0]) / (cells - 1);
    var i = 0;

    for (; i < cells; i++) {
      data.push(domain[0] + i * increment);
    }
  }

  var labels = data.map(labelFormat);
  return {
    data: data,
    labels: labels,
    feature: function feature(d) {
      return scale(d);
    }
  };
};

var d3_quantLegend = function d3_quantLegend(scale, labelFormat, labelDelimiter) {
  var labels = scale.range().map(function (d) {
    var invert = scale.invertExtent(d);
    return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
  });

  return {
    data: scale.range(),
    labels: labels,
    feature: d3_identity
  };
};

var d3_ordinalLegend = function d3_ordinalLegend(scale) {
  return {
    data: scale.domain(),
    labels: scale.domain(),
    feature: function feature(d) {
      return scale(d);
    }
  };
};

var d3_cellOver = function d3_cellOver(cellDispatcher, d, obj) {
  cellDispatcher.call("cellover", obj, d);
};

var d3_cellOut = function d3_cellOut(cellDispatcher, d, obj) {
  cellDispatcher.call("cellout", obj, d);
};

var d3_cellClick = function d3_cellClick(cellDispatcher, d, obj) {
  cellDispatcher.call("cellclick", obj, d);
};

var helper = {
  d3_drawShapes: function d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
    if (shape === "rect") {
      shapes.attr("height", shapeHeight).attr("width", shapeWidth);
    } else if (shape === "circle") {
      shapes.attr("r", shapeRadius);
    } else if (shape === "line") {
      shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);
    } else if (shape === "path") {
      shapes.attr("d", path);
    }
  },

  d3_addText: function d3_addText(svg, enter, labels, classPrefix, labelWidth) {
    enter.append("text").attr("class", classPrefix + "label");
    var text = svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").data(labels).text(d3_identity);

    if (labelWidth) {
      svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").call(d3_textWrapping, labelWidth);
    }

    return text;
  },

  d3_calcType: function d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter) {
    var type = scale.invertExtent ? d3_quantLegend(scale, labelFormat, labelDelimiter) : scale.ticks ? d3_linearLegend(scale, cells, labelFormat) : d3_ordinalLegend(scale);

    //for d3.scaleSequential that doesn't have a range function
    var range = scale.range && scale.range() || scale.domain();
    type.labels = d3_mergeLabels(type.labels, labels, scale.domain(), range, labelDelimiter);

    if (ascending) {
      type.labels = d3_reverse(type.labels);
      type.data = d3_reverse(type.data);
    }

    return type;
  },

  d3_filterCells: function d3_filterCells(type, cellFilter) {
    var filterCells = type.data.map(function (d, i) {
      return { data: d, label: type.labels[i] };
    }).filter(cellFilter);
    var dataValues = filterCells.map(function (d) {
      return d.data;
    });
    var labelValues = filterCells.map(function (d) {
      return d.label;
    });
    type.data = type.data.filter(function (d) {
      return dataValues.indexOf(d) !== -1;
    });
    type.labels = type.labels.filter(function (d) {
      return labelValues.indexOf(d) !== -1;
    });
    return type;
  },

  d3_placement: function d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign) {
    cell.attr("transform", cellTrans);
    text.attr("transform", textTrans);
    if (orient === "horizontal") {
      text.style("text-anchor", labelAlign);
    }
  },

  d3_addEvents: function d3_addEvents(cells, dispatcher) {
    cells.on("mouseover.legend", function (d) {
      d3_cellOver(dispatcher, d, this);
    }).on("mouseout.legend", function (d) {
      d3_cellOut(dispatcher, d, this);
    }).on("click.legend", function (d) {
      d3_cellClick(dispatcher, d, this);
    });
  },

  d3_title: function d3_title(svg, title, classPrefix, titleWidth) {
    if (title !== "") {
      var titleText = svg.selectAll("text." + classPrefix + "legendTitle");

      titleText.data([title]).enter().append("text").attr("class", classPrefix + "legendTitle");

      svg.selectAll("text." + classPrefix + "legendTitle").text(title);

      if (titleWidth) {
        svg.selectAll("text." + classPrefix + "legendTitle").call(d3_textWrapping, titleWidth);
      }

      var cellsSvg = svg.select("." + classPrefix + "legendCells");
      var yOffset = svg.select("." + classPrefix + "legendTitle").nodes().map(function (d) {
        return d.getBBox().height;
      })[0],
          xOffset = -cellsSvg.nodes().map(function (d) {
        return d.getBBox().x;
      })[0];
      cellsSvg.attr("transform", "translate(" + xOffset + "," + yOffset + ")");
    }
  },

  d3_defaultLocale: {
    format: d3Format.format,
    formatPrefix: d3Format.formatPrefix
  },

  d3_defaultFormatSpecifier: ".01f",

  d3_defaultDelimiter: "to"
};

function color() {
  var scale = d3Scale.scaleLinear(),
      shape = "rect",
      shapeWidth = 15,
      shapeHeight = 15,
      shapeRadius = 10,
      shapePadding = 2,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      useClass = false,
      title = "",
      locale = helper.d3_defaultLocale,
      specifier = helper.d3_defaultFormatSpecifier,
      labelOffset = 10,
      labelAlign = "middle",
      labelDelimiter = helper.d3_defaultDelimiter,
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      path = void 0,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {
    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
        legendG = svg.selectAll("g").data([scale]);

    legendG.enter().append("g").attr("class", classPrefix + "legendCells");

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);

    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch").data(type.data);

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    cell.exit().transition().style("opacity", 0).remove();
    shapes.exit().transition().style("opacity", 0).remove();

    shapes = shapes.merge(shapes);

    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);
    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    // sets placement
    var textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d) {
      return d.getBBox();
    });
    //sets scale
    //everything is fill except for line which is stroke,
    if (!useClass) {
      if (shape == "line") {
        shapes.style("stroke", type.feature);
      } else {
        shapes.style("fill", type.feature);
      }
    } else {
      shapes.attr("class", function (d) {
        return classPrefix + "swatch " + type.feature(d);
      });
    }

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(d.height, shapeSize[i].height);
        });

        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));
          return "translate(0, " + (height + i * shapePadding) + ")";
        };

        textTrans = function textTrans(d, i) {
          return "translate( " + (shapeSize[i].width + shapeSize[i].x + labelOffset) + ", " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans(d, i) {
        return "translate(" + i * (shapeSize[i].width + shapePadding) + ",0)";
      };
      textTrans = function textTrans(d, i) {
        return "translate(" + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n          " + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ")";
      };
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);

    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shape = function (_, d) {
    if (!arguments.length) return shape;
    if (_ == "rect" || _ == "circle" || _ == "line" || _ == "path" && typeof d === "string") {
      shape = _;
      path = d;
    }
    return legend;
  };

  legend.shapeWidth = function (_) {
    if (!arguments.length) return shapeWidth;
    shapeWidth = +_;
    return legend;
  };

  legend.shapeHeight = function (_) {
    if (!arguments.length) return shapeHeight;
    shapeHeight = +_;
    return legend;
  };

  legend.shapeRadius = function (_) {
    if (!arguments.length) return shapeRadius;
    shapeRadius = +_;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.locale = function (_) {
    if (!arguments.length) return locale;
    locale = d3Format.formatLocale(_);
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return legend.locale().format(specifier);
    specifier = d3Format.formatSpecifier(_);
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.useClass = function (_) {
    if (!arguments.length) return useClass;
    if (_ === true || _ === false) {
      useClass = _;
    }
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

function size() {
  var scale = d3Scale.scaleLinear(),
      shape = "rect",
      shapeWidth = 15,
      shapePadding = 2,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      title = "",
      locale = helper.d3_defaultLocale,
      specifier = helper.d3_defaultFormatSpecifier,
      labelOffset = 10,
      labelAlign = "middle",
      labelDelimiter = helper.d3_defaultDelimiter,
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      path = void 0,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {
    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
        legendG = svg.selectAll("g").data([scale]);

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    legendG.enter().append("g").attr("class", classPrefix + "legendCells");

    var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);
    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch");

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    cell.exit().transition().style("opacity", 0).remove();

    shapes.exit().transition().style("opacity", 0).remove();
    shapes = shapes.merge(shapes);

    //creates shape
    if (shape === "line") {
      helper.d3_drawShapes(shape, shapes, 0, shapeWidth);
      shapes.attr("stroke-width", type.feature);
    } else {
      helper.d3_drawShapes(shape, shapes, type.feature, type.feature, type.feature, path);
    }

    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    //sets placement

    var textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d, i) {
      var bbox = d.getBBox();
      var stroke = scale(type.data[i]);

      if (shape === "line" && orient === "horizontal") {
        bbox.height = bbox.height + stroke;
      } else if (shape === "line" && orient === "vertical") {
        bbox.width = bbox.width;
      }
      return bbox;
    });

    var maxH = d3Array.max(shapeSize, function (d) {
      return d.height + d.y;
    }),
        maxW = d3Array.max(shapeSize, function (d) {
      return d.width + d.x;
    });

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(d.height, shapeSize[i].height);
        });
        var y = shape == "circle" || shape == "line" ? shapeSize[0].height / 2 : 0;
        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));

          return "translate(0, " + (y + height + i * shapePadding) + ")";
        };

        textTrans = function textTrans(d, i) {
          return "translate( " + (maxW + labelOffset) + ",\n          " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
        };
      })();
    } else if (orient === "horizontal") {
      (function () {
        cellTrans = function cellTrans(d, i) {
          var width = d3Array.sum(shapeSize.slice(0, i), function (d) {
            return d.width;
          });
          var y = shape == "circle" || shape == "line" ? maxH / 2 : 0;
          return "translate(" + (width + i * shapePadding) + ", " + y + ")";
        };

        var offset = shape == "line" ? maxH / 2 : maxH;
        textTrans = function textTrans(d, i) {
          return "translate( " + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n              " + (offset + labelOffset) + ")";
        };
      })();
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);

    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shape = function (_, d) {
    if (!arguments.length) return shape;
    if (_ == "rect" || _ == "circle" || _ == "line") {
      shape = _;
      path = d;
    }
    return legend;
  };

  legend.shapeWidth = function (_) {
    if (!arguments.length) return shapeWidth;
    shapeWidth = +_;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.locale = function (_) {
    if (!arguments.length) return locale;
    locale = d3Format.formatLocale(_);
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return legend.locale().format(specifier);
    specifier = d3Format.formatSpecifier(_);
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

function symbol() {
  var scale = d3Scale.scaleLinear(),
      shape = "path",
      shapeWidth = 15,
      shapeHeight = 15,
      shapeRadius = 10,
      shapePadding = 5,
      cells = [5],
      cellFilter = void 0,
      labels = [],
      classPrefix = "",
      title = "",
      locale = helper.d3_defaultLocale,
      specifier = helper.d3_defaultFormatSpecifier,
      labelAlign = "middle",
      labelOffset = 10,
      labelDelimiter = helper.d3_defaultDelimiter,
      labelWrap = void 0,
      orient = "vertical",
      ascending = false,
      titleWidth = void 0,
      legendDispatcher = d3Dispatch.dispatch("cellover", "cellout", "cellclick");

  function legend(svg) {
    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
        legendG = svg.selectAll("g").data([scale]);

    if (cellFilter) {
      helper.d3_filterCells(type, cellFilter);
    }

    legendG.enter().append("g").attr("class", classPrefix + "legendCells");

    var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);
    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");

    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch");

    //add event handlers
    helper.d3_addEvents(cellEnter, legendDispatcher);

    //remove old shapes
    cell.exit().transition().style("opacity", 0).remove();
    shapes.exit().transition().style("opacity", 0).remove();
    shapes = shapes.merge(shapes);

    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, type.feature);
    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
    cell = cellEnter.merge(cell);

    // sets placement
    var textSize = text.nodes().map(function (d) {
      return d.getBBox();
    }),
        shapeSize = shapes.nodes().map(function (d) {
      return d.getBBox();
    });

    var maxH = d3Array.max(shapeSize, function (d) {
      return d.height;
    }),
        maxW = d3Array.max(shapeSize, function (d) {
      return d.width;
    });

    var cellTrans = void 0,
        textTrans = void 0,
        textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

    //positions cells and text
    if (orient === "vertical") {
      (function () {
        var cellSize = textSize.map(function (d, i) {
          return Math.max(maxH, d.height);
        });

        cellTrans = function cellTrans(d, i) {
          var height = d3Array.sum(cellSize.slice(0, i));
          return "translate(0, " + (height + i * shapePadding) + " )";
        };
        textTrans = function textTrans(d, i) {
          return "translate( " + (maxW + labelOffset) + ",\n              " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans(d, i) {
        return "translate( " + i * (maxW + shapePadding) + ",0)";
      };
      textTrans = function textTrans(d, i) {
        return "translate( " + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n              " + (maxH + labelOffset) + ")";
      };
    }

    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);
    cell.transition().style("opacity", 1);
  }

  legend.scale = function (_) {
    if (!arguments.length) return scale;
    scale = _;
    return legend;
  };

  legend.cells = function (_) {
    if (!arguments.length) return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };

  legend.cellFilter = function (_) {
    if (!arguments.length) return cellFilter;
    cellFilter = _;
    return legend;
  };

  legend.shapePadding = function (_) {
    if (!arguments.length) return shapePadding;
    shapePadding = +_;
    return legend;
  };

  legend.labels = function (_) {
    if (!arguments.length) return labels;
    labels = _;
    return legend;
  };

  legend.labelAlign = function (_) {
    if (!arguments.length) return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };

  legend.locale = function (_) {
    if (!arguments.length) return locale;
    locale = d3Format.formatLocale(_);
    return legend;
  };

  legend.labelFormat = function (_) {
    if (!arguments.length) return legend.locale().format(specifier);
    specifier = d3Format.formatSpecifier(_);
    return legend;
  };

  legend.labelOffset = function (_) {
    if (!arguments.length) return labelOffset;
    labelOffset = +_;
    return legend;
  };

  legend.labelDelimiter = function (_) {
    if (!arguments.length) return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };

  legend.labelWrap = function (_) {
    if (!arguments.length) return labelWrap;
    labelWrap = _;
    return legend;
  };

  legend.orient = function (_) {
    if (!arguments.length) return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };

  legend.ascending = function (_) {
    if (!arguments.length) return ascending;
    ascending = !!_;
    return legend;
  };

  legend.classPrefix = function (_) {
    if (!arguments.length) return classPrefix;
    classPrefix = _;
    return legend;
  };

  legend.title = function (_) {
    if (!arguments.length) return title;
    title = _;
    return legend;
  };

  legend.titleWidth = function (_) {
    if (!arguments.length) return titleWidth;
    titleWidth = _;
    return legend;
  };

  legend.on = function () {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };

  return legend;
}

var thresholdLabels = function thresholdLabels(_ref) {
  var i = _ref.i,
      genLength = _ref.genLength,
      generatedLabels = _ref.generatedLabels,
      labelDelimiter = _ref.labelDelimiter;

  if (i === 0) {
    var values = generatedLabels[i].split(" " + labelDelimiter + " ");
    return "Less than " + values[1];
  } else if (i === genLength - 1) {
    var _values = generatedLabels[i].split(" " + labelDelimiter + " ");
    return _values[0] + " or more";
  }
  return generatedLabels[i];
};

var legendHelpers = {
  thresholdLabels: thresholdLabels
};

var index = {
  legendColor: color,
  legendSize: size,
  legendSymbol: symbol,
  legendHelpers: legendHelpers
};

exports.legendColor = color;
exports.legendSize = size;
exports.legendSymbol = symbol;
exports.legendHelpers = legendHelpers;
exports['default'] = index;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{"d3-array":17,"d3-dispatch":18,"d3-format":19,"d3-scale":20,"d3-selection":21}],17:[function(require,module,exports){
// https://d3js.org/d3-array/ Version 1.0.1. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  function descending(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  function number(x) {
    return x === null ? NaN : +x;
  }

  function variance(array, f) {
    var n = array.length,
        m = 0,
        a,
        d,
        s = 0,
        i = -1,
        j = 0;

    if (f == null) {
      while (++i < n) {
        if (!isNaN(a = number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    else {
      while (++i < n) {
        if (!isNaN(a = number(f(array[i], i, array)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    if (j > 1) return s / (j - 1);
  }

  function deviation(array, f) {
    var v = variance(array, f);
    return v ? Math.sqrt(v) : v;
  }

  function extent(array, f) {
    var i = -1,
        n = array.length,
        a,
        b,
        c;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    return [a, c];
  }

  var array = Array.prototype;

  var slice = array.slice;
  var map = array.map;

  function constant(x) {
    return function() {
      return x;
    };
  }

  function identity(x) {
    return x;
  }

  function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function ticks(start, stop, count) {
    var step = tickStep(start, stop, count);
    return range(
      Math.ceil(start / step) * step,
      Math.floor(stop / step) * step + step / 2, // inclusive
      step
    );
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function sturges(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
  }

  function histogram() {
    var value = identity,
        domain = extent,
        threshold = sturges;

    function histogram(data) {
      var i,
          n = data.length,
          x,
          values = new Array(n);

      for (i = 0; i < n; ++i) {
        values[i] = value(data[i], i, data);
      }

      var xz = domain(values),
          x0 = xz[0],
          x1 = xz[1],
          tz = threshold(values, x0, x1);

      // Convert number of thresholds into uniform thresholds.
      if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);

      // Remove any thresholds outside the domain.
      var m = tz.length;
      while (tz[0] <= x0) tz.shift(), --m;
      while (tz[m - 1] >= x1) tz.pop(), --m;

      var bins = new Array(m + 1),
          bin;

      // Initialize bins.
      for (i = 0; i <= m; ++i) {
        bin = bins[i] = [];
        bin.x0 = i > 0 ? tz[i - 1] : x0;
        bin.x1 = i < m ? tz[i] : x1;
      }

      // Assign data to bins by value, ignoring any outside the domain.
      for (i = 0; i < n; ++i) {
        x = values[i];
        if (x0 <= x && x <= x1) {
          bins[bisectRight(tz, x, 0, m)].push(data[i]);
        }
      }

      return bins;
    }

    histogram.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
    };

    histogram.domain = function(_) {
      return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
    };

    histogram.thresholds = function(_) {
      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
    };

    return histogram;
  }

  function quantile(array, p, f) {
    if (f == null) f = number;
    if (!(n = array.length)) return;
    if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
    if (p >= 1) return +f(array[n - 1], n - 1, array);
    var n,
        h = (n - 1) * p,
        i = Math.floor(h),
        a = +f(array[i], i, array),
        b = +f(array[i + 1], i + 1, array);
    return a + (b - a) * (h - i);
  }

  function freedmanDiaconis(values, min, max) {
    values = map.call(values, number).sort(ascending);
    return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
  }

  function scott(values, min, max) {
    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
  }

  function max(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
    }

    return a;
  }

  function mean(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1,
        j = n;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number(array[i]))) s += a; else --j;
    }

    else {
      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a; else --j;
    }

    if (j) return s / j;
  }

  function median(array, f) {
    var numbers = [],
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);
    }

    else {
      while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);
    }

    return quantile(numbers.sort(ascending), 0.5);
  }

  function merge(arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) j += arrays[i].length;
    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  }

  function min(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
    }

    return a;
  }

  function pairs(array) {
    var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [p, p = array[++i]];
    return pairs;
  }

  function permute(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  }

  function scan(array, compare) {
    if (!(n = array.length)) return;
    var i = 0,
        n,
        j = 0,
        xi,
        xj = array[j];

    if (!compare) compare = ascending;

    while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;

    if (compare(xj, xj) === 0) return j;
  }

  function shuffle(array, i0, i1) {
    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }

    return array;
  }

  function sum(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
    }

    else {
      while (++i < n) if (a = +f(array[i], i, array)) s += a;
    }

    return s;
  }

  function transpose(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  }

  function length(d) {
    return d.length;
  }

  function zip() {
    return transpose(arguments);
  }

  exports.bisect = bisectRight;
  exports.bisectRight = bisectRight;
  exports.bisectLeft = bisectLeft;
  exports.ascending = ascending;
  exports.bisector = bisector;
  exports.descending = descending;
  exports.deviation = deviation;
  exports.extent = extent;
  exports.histogram = histogram;
  exports.thresholdFreedmanDiaconis = freedmanDiaconis;
  exports.thresholdScott = scott;
  exports.thresholdSturges = sturges;
  exports.max = max;
  exports.mean = mean;
  exports.median = median;
  exports.merge = merge;
  exports.min = min;
  exports.pairs = pairs;
  exports.permute = permute;
  exports.quantile = quantile;
  exports.range = range;
  exports.scan = scan;
  exports.shuffle = shuffle;
  exports.sum = sum;
  exports.ticks = ticks;
  exports.tickStep = tickStep;
  exports.transpose = transpose;
  exports.variance = variance;
  exports.zip = zip;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],18:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ Version 1.0.1. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  var noop = {value: function() {}};

  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch(_);
  }

  function Dispatch(_) {
    this._ = _;
  }

  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return {type: t, name: name};
    });
  }

  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._,
          T = parseTypenames(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
      }

      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _) copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };

  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({name: name, value: callback});
    return type;
  }

  exports.dispatch = dispatch;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],19:[function(require,module,exports){
// https://d3js.org/d3-format/ Version 1.0.2. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatDefault(x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        case "e": break out;
        default: if (i0 > 0) i0 = 0; break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "": formatDefault,
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + this.type;
  };

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function identity(x) {
    return x;
  }

  function formatLocale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
        currency = locale.currency,
        decimal = locale.decimal;

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? (type ? 6 : 12)
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Convert negative to positive, and compute the prefix.
          // Note that -0 is not less than 0, but 1 / -0 is!
          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

          // Perform the initial formatting.
          value = formatType(value, precision);

          // If the original value was negative, it may be rounded to zero during
          // formatting; treat this as (positive) zero.
          if (valueNegative) {
            i = -1, n = value.length;
            valueNegative = false;
            while (++i < n) {
              if (c = value.charCodeAt(i), (48 < c && c < 58)
                  || (type === "x" && 96 < c && c < 103)
                  || (type === "X" && 64 < c && c < 71)) {
                valueNegative = true;
                break;
              }
            }
          }

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": return valuePrefix + value + valueSuffix + padding;
          case "=": return valuePrefix + padding + value + valueSuffix;
          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
        }
        return padding + valuePrefix + value + valueSuffix;
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    exports.format = locale.format;
    exports.formatPrefix = locale.formatPrefix;
    return locale;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  }

  exports.formatDefaultLocale = defaultLocale;
  exports.formatLocale = formatLocale;
  exports.formatSpecifier = formatSpecifier;
  exports.precisionFixed = precisionFixed;
  exports.precisionPrefix = precisionPrefix;
  exports.precisionRound = precisionRound;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],20:[function(require,module,exports){
// https://d3js.org/d3-scale/ Version 1.0.3. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-collection'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format'), require('d3-color')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format', 'd3-color'], factory) :
  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat,d3Color) { 'use strict';

  var array = Array.prototype;

  var map$1 = array.map;
  var slice = array.slice;

  var implicit = {name: "implicit"};

  function ordinal(range) {
    var index = d3Collection.map(),
        domain = [],
        unknown = implicit;

    range = range == null ? [] : slice.call(range);

    function scale(d) {
      var key = d + "", i = index.get(key);
      if (!i) {
        if (unknown !== implicit) return unknown;
        index.set(key, i = domain.push(d));
      }
      return range[(i - 1) % range.length];
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = d3Collection.map();
      var i = -1, n = _.length, d, key;
      while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
      return scale;
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), scale) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return ordinal()
          .domain(domain)
          .range(range)
          .unknown(unknown);
    };

    return scale;
  }

  function band() {
    var scale = ordinal().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range,
        range = [0, 1],
        step,
        bandwidth,
        round = false,
        paddingInner = 0,
        paddingOuter = 0,
        align = 0.5;

    delete scale.unknown;

    function rescale() {
      var n = domain().length,
          reverse = range[1] < range[0],
          start = range[reverse - 0],
          stop = range[1 - reverse];
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = d3Array.range(n).map(function(i) { return start + step * i; });
      return ordinalRange(reverse ? values.reverse() : values);
    }

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.range = function(_) {
      return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = [+_[0], +_[1]], round = true, rescale();
    };

    scale.bandwidth = function() {
      return bandwidth;
    };

    scale.step = function() {
      return step;
    };

    scale.round = function(_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };

    scale.padding = function(_) {
      return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
    };

    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };

    scale.copy = function() {
      return band()
          .domain(domain())
          .range(range)
          .round(round)
          .paddingInner(paddingInner)
          .paddingOuter(paddingOuter)
          .align(align);
    };

    return rescale();
  }

  function pointish(scale) {
    var copy = scale.copy;

    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;

    scale.copy = function() {
      return pointish(copy());
    };

    return scale;
  }

  function point() {
    return pointish(band().paddingInner(1));
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  function number(x) {
    return +x;
  }

  var unit = [0, 1];

  function deinterpolate(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant(b);
  }

  function deinterpolateClamp(deinterpolate) {
    return function(a, b) {
      var d = deinterpolate(a = +a, b = +b);
      return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
    };
  }

  function reinterpolateClamp(reinterpolate) {
    return function(a, b) {
      var r = reinterpolate(a = +a, b = +b);
      return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
    };
  }

  function bimap(domain, range, deinterpolate, reinterpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
    else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, deinterpolate, reinterpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = deinterpolate(domain[i], domain[i + 1]);
      r[i] = reinterpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = d3Array.bisect(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp());
  }

  // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
  function continuous(deinterpolate$$, reinterpolate) {
    var domain = unit,
        range = unit,
        interpolate = d3Interpolate.interpolate,
        clamp = false,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate$$) : deinterpolate$$, interpolate)))(+x);
    }

    scale.invert = function(y) {
      return (input || (input = piecewise(range, domain, deinterpolate, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, rescale()) : clamp;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    return rescale();
  }

  function tickFormat(domain, count, specifier) {
    var start = domain[0],
        stop = domain[domain.length - 1],
        step = d3Array.tickStep(start, stop, count == null ? 10 : count),
        precision;
    specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
        return d3Format.formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return d3Format.format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      return tickFormat(domain(), count, specifier);
    };

    scale.nice = function(count) {
      var d = domain(),
          i = d.length - 1,
          n = count == null ? 10 : count,
          start = d[0],
          stop = d[i],
          step = d3Array.tickStep(start, stop, n);

      if (step) {
        step = d3Array.tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
        d[0] = Math.floor(start / step) * step;
        d[i] = Math.ceil(stop / step) * step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear() {
    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber);

    scale.copy = function() {
      return copy(scale, linear());
    };

    return linearish(scale);
  }

  function identity() {
    var domain = [0, 1];

    function scale(x) {
      return +x;
    }

    scale.invert = scale;

    scale.domain = scale.range = function(_) {
      return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
    };

    scale.copy = function() {
      return identity().domain(domain);
    };

    return linearish(scale);
  }

  function nice(domain, interval) {
    domain = domain.slice();

    var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;

    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }

    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  function deinterpolate$1(a, b) {
    return (b = Math.log(b / a))
        ? function(x) { return Math.log(x / a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    return a < 0
        ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
        : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
  }

  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }

  function powp(base) {
    return base === 10 ? pow10
        : base === Math.E ? Math.exp
        : function(x) { return Math.pow(base, x); };
  }

  function logp(base) {
    return base === Math.E ? Math.log
        : base === 10 && Math.log10
        || base === 2 && Math.log2
        || (base = Math.log(base), function(x) { return Math.log(x) / base; });
  }

  function reflect(f) {
    return function(x) {
      return -f(-x);
    };
  }

  function log() {
    var scale = continuous(deinterpolate$1, reinterpolate).domain([1, 10]),
        domain = scale.domain,
        base = 10,
        logs = logp(10),
        pows = powp(10);

    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
      return scale;
    }

    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.ticks = function(count) {
      var d = domain(),
          u = d[0],
          v = d[d.length - 1],
          r;

      if (r = v < u) i = u, u = v, v = i;

      var i = logs(u),
          j = logs(v),
          p,
          k,
          t,
          n = count == null ? 10 : +count,
          z = [];

      if (!(base % 1) && j - i < n) {
        i = Math.round(i) - 1, j = Math.round(j) + 1;
        if (u > 0) for (; i < j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        } else for (; i < j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
      } else {
        z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
      }

      return r ? z.reverse() : z;
    };

    scale.tickFormat = function(count, specifier) {
      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
      if (typeof specifier !== "function") specifier = d3Format.format(specifier);
      if (count === Infinity) return specifier;
      if (count == null) count = 10;
      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
      return function(d) {
        var i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };

    scale.nice = function() {
      return domain(nice(domain(), {
        floor: function(x) { return pows(Math.floor(logs(x))); },
        ceil: function(x) { return pows(Math.ceil(logs(x))); }
      }));
    };

    scale.copy = function() {
      return copy(scale, log().base(base));
    };

    return scale;
  }

  function raise(x, exponent) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  }

  function pow() {
    var exponent = 1,
        scale = continuous(deinterpolate, reinterpolate),
        domain = scale.domain;

    function deinterpolate(a, b) {
      return (b = raise(b, exponent) - (a = raise(a, exponent)))
          ? function(x) { return (raise(x, exponent) - a) / b; }
          : constant(b);
    }

    function reinterpolate(a, b) {
      b = raise(b, exponent) - (a = raise(a, exponent));
      return function(t) { return raise(a + b * t, 1 / exponent); };
    }

    scale.exponent = function(_) {
      return arguments.length ? (exponent = +_, domain(domain())) : exponent;
    };

    scale.copy = function() {
      return copy(scale, pow().exponent(exponent));
    };

    return linearish(scale);
  }

  function sqrt() {
    return pow().exponent(0.5);
  }

  function quantile$1() {
    var domain = [],
        range = [],
        thresholds = [];

    function rescale() {
      var i = 0, n = Math.max(1, range.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
      return scale;
    }

    function scale(x) {
      if (!isNaN(x = +x)) return range[d3Array.bisect(thresholds, x)];
    }

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(d3Array.ascending);
      return rescale();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
    };

    scale.quantiles = function() {
      return thresholds.slice();
    };

    scale.copy = function() {
      return quantile$1()
          .domain(domain)
          .range(range);
    };

    return scale;
  }

  function quantize() {
    var x0 = 0,
        x1 = 1,
        n = 1,
        domain = [0.5],
        range = [0, 1];

    function scale(x) {
      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
    }

    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }

    scale.domain = function(_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
    };

    scale.range = function(_) {
      return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN]
          : i < 1 ? [x0, domain[0]]
          : i >= n ? [domain[n - 1], x1]
          : [domain[i - 1], domain[i]];
    };

    scale.copy = function() {
      return quantize()
          .domain([x0, x1])
          .range(range);
    };

    return linearish(scale);
  }

  function threshold() {
    var domain = [0.5],
        range = [0, 1],
        n = 1;

    function scale(x) {
      if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
    }

    scale.domain = function(_) {
      return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return [domain[i - 1], domain[i]];
    };

    scale.copy = function() {
      return threshold()
          .domain(domain)
          .range(range);
    };

    return scale;
  }

  var durationSecond = 1000;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;
  function date(t) {
    return new Date(t);
  }

  function number$1(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }

  function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
    var scale = continuous(deinterpolate, d3Interpolate.interpolateNumber),
        invert = scale.invert,
        domain = scale.domain;

    var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");

    var tickIntervals = [
      [second,  1,      durationSecond],
      [second,  5,  5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute,  1,      durationMinute],
      [minute,  5,  5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [  hour,  1,      durationHour  ],
      [  hour,  3,  3 * durationHour  ],
      [  hour,  6,  6 * durationHour  ],
      [  hour, 12, 12 * durationHour  ],
      [   day,  1,      durationDay   ],
      [   day,  2,  2 * durationDay   ],
      [  week,  1,      durationWeek  ],
      [ month,  1,      durationMonth ],
      [ month,  3,  3 * durationMonth ],
      [  year,  1,      durationYear  ]
    ];

    function tickFormat(date) {
      return (second(date) < date ? formatMillisecond
          : minute(date) < date ? formatSecond
          : hour(date) < date ? formatMinute
          : day(date) < date ? formatHour
          : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
          : year(date) < date ? formatMonth
          : formatYear)(date);
    }

    function tickInterval(interval, start, stop, step) {
      if (interval == null) interval = 10;

      // If a desired tick count is specified, pick a reasonable tick interval
      // based on the extent of the domain and a rough estimate of tick size.
      // Otherwise, assume interval is already a time interval and use it.
      if (typeof interval === "number") {
        var target = Math.abs(stop - start) / interval,
            i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
        if (i === tickIntervals.length) {
          step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
          interval = year;
        } else if (i) {
          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
          step = i[1];
          interval = i[0];
        } else {
          step = d3Array.tickStep(start, stop, interval);
          interval = millisecond;
        }
      }

      return step == null ? interval : interval.every(step);
    }

    scale.invert = function(y) {
      return new Date(invert(y));
    };

    scale.domain = function(_) {
      return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
    };

    scale.ticks = function(interval, step) {
      var d = domain(),
          t0 = d[0],
          t1 = d[d.length - 1],
          r = t1 < t0,
          t;
      if (r) t = t0, t0 = t1, t1 = t;
      t = tickInterval(interval, t0, t1, step);
      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
      return r ? t.reverse() : t;
    };

    scale.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat : format(specifier);
    };

    scale.nice = function(interval, step) {
      var d = domain();
      return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
          ? domain(nice(d, interval))
          : scale;
    };

    scale.copy = function() {
      return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
    };

    return scale;
  }

  function time() {
    return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
  }

  function utcTime() {
    return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
  }

  function colors(s) {
    return s.match(/.{6}/g).map(function(x) {
      return "#" + x;
    });
  }

  var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

  var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

  var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

  var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

  var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

  var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

  var rainbow = d3Color.cubehelix();

  function rainbow$1(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    rainbow.h = 360 * t - 100;
    rainbow.s = 1.5 - 1.5 * ts;
    rainbow.l = 0.8 - 0.9 * ts;
    return rainbow + "";
  }

  function ramp(range) {
    var n = range.length;
    return function(t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

  var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

  var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

  var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  function sequential(interpolator) {
    var x0 = 0,
        x1 = 1,
        clamp = false;

    function scale(x) {
      var t = (x - x0) / (x1 - x0);
      return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
    }

    scale.domain = function(_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.copy = function() {
      return sequential(interpolator).domain([x0, x1]).clamp(clamp);
    };

    return linearish(scale);
  }

  exports.scaleBand = band;
  exports.scalePoint = point;
  exports.scaleIdentity = identity;
  exports.scaleLinear = linear;
  exports.scaleLog = log;
  exports.scaleOrdinal = ordinal;
  exports.scaleImplicit = implicit;
  exports.scalePow = pow;
  exports.scaleSqrt = sqrt;
  exports.scaleQuantile = quantile$1;
  exports.scaleQuantize = quantize;
  exports.scaleThreshold = threshold;
  exports.scaleTime = time;
  exports.scaleUtc = utcTime;
  exports.schemeCategory10 = category10;
  exports.schemeCategory20b = category20b;
  exports.schemeCategory20c = category20c;
  exports.schemeCategory20 = category20;
  exports.interpolateCubehelixDefault = cubehelix$1;
  exports.interpolateRainbow = rainbow$1;
  exports.interpolateWarm = warm;
  exports.interpolateCool = cool;
  exports.interpolateViridis = viridis;
  exports.interpolateMagma = magma;
  exports.interpolateInferno = inferno;
  exports.interpolatePlasma = plasma;
  exports.scaleSequential = sequential;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{"d3-array":17,"d3-collection":4,"d3-color":5,"d3-format":19,"d3-interpolate":11,"d3-time":23,"d3-time-format":22}],21:[function(require,module,exports){
// https://d3js.org/d3-selection/ Version 1.0.2. Copyright 2016 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  var nextId = 0;

  function local() {
    return new Local;
  }

  function Local() {
    this._ = "@" + (++nextId).toString(36);
  }

  Local.prototype = local.prototype = {
    constructor: Local,
    get: function(node) {
      var id = this._;
      while (!(id in node)) if (!(node = node.parentNode)) return;
      return node[id];
    },
    set: function(node, value) {
      return node[this._] = value;
    },
    remove: function(node) {
      return this._ in node && delete node[this._];
    },
    toString: function() {
      return this._;
    }
  };

  var matcher = function(selector) {
    return function() {
      return this.matches(selector);
    };
  };

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!element.matches) {
      var vendorMatches = element.webkitMatchesSelector
          || element.msMatchesSelector
          || element.mozMatchesSelector
          || element.oMatchesSelector;
      matcher = function(selector) {
        return function() {
          return vendorMatches.call(this, selector);
        };
      };
    }
  }

  var matcher$1 = matcher;

  var filterEvents = {};

  exports.event = null;

  if (typeof document !== "undefined") {
    var element$1 = document.documentElement;
    if (!("onmouseenter" in element$1)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      var event0 = exports.event; // Events can be reentrant (e.g., focus).
      exports.event = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        exports.event = event0;
      }
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function customEvent(event1, listener, that, args) {
    var event0 = exports.event;
    event1.sourceEvent = exports.event;
    exports.event = event1;
    try {
      return listener.apply(that, args);
    } finally {
      exports.event = event0;
    }
  }

  function sourceEvent() {
    var current = exports.event, source;
    while (source = current.sourceEvent) current = source;
    return current;
  }

  function point(node, event) {
    var svg = node.ownerSVGElement || node;

    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }

    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
  }

  function mouse(node) {
    var event = sourceEvent();
    if (event.changedTouches) event = event.changedTouches[0];
    return point(node, event);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher$1(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    var node;
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : defaultView(node = this.node())
            .getComputedStyle(node, null)
            .getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (event) {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function selectAll(selector) {
    return typeof selector === "string"
        ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
        : new Selection([selector == null ? [] : selector], root);
  }

  function touch(node, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

    for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return point(node, touch);
      }
    }

    return null;
  }

  function touches(node, touches) {
    if (touches == null) touches = sourceEvent().touches;

    for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
      points[i] = point(node, touches[i]);
    }

    return points;
  }

  exports.creator = creator;
  exports.local = local;
  exports.matcher = matcher$1;
  exports.mouse = mouse;
  exports.namespace = namespace;
  exports.namespaces = namespaces;
  exports.select = select;
  exports.selectAll = selectAll;
  exports.selection = selection;
  exports.selector = selector;
  exports.selectorAll = selectorAll;
  exports.touch = touch;
  exports.touches = touches;
  exports.window = defaultView;
  exports.customEvent = customEvent;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],22:[function(require,module,exports){
// https://d3js.org/d3-time-format/ v2.1.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":23}],23:[function(require,module,exports){
// https://d3js.org/d3-time/ v1.0.10 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],24:[function(require,module,exports){
// https://d3js.org/d3-timer/ v1.0.9 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

function interval$1(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
exports.timeout = timeout$1;
exports.interval = interval$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],25:[function(require,module,exports){
// https://d3js.org/d3-transition/ v1.1.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-timer'), require('d3-color'), require('d3-interpolate'), require('d3-selection'), require('d3-ease')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-timer', 'd3-color', 'd3-interpolate', 'd3-selection', 'd3-ease'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Dispatch,d3Timer,d3Color,d3Interpolate,d3Selection,d3Ease) { 'use strict';

var emptyOn = d3Dispatch.dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = d3Timer.timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return d3Timer.timeout(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    d3Timer.timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule$$1,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;
    schedule$$1.state = ENDED;
    schedule$$1.timer.stop();
    if (active) schedule$$1.on.call("interrupt", node, node.__data__, schedule$$1.index, schedule$$1.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule$$1 = set(this, id),
        tween = schedule$$1.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule$$1.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule$$1 = set(this, id),
        tween = schedule$$1.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule$$1.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule$$1 = set(this, id);
    (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? d3Interpolate.interpolateNumber
      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
      : d3Interpolate.interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function transition_attr(name, value) {
  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
}

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = d3Selection.namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function transition_filter(match) {
  if (typeof match !== "function") match = d3Selection.matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition$$1) {
  if (transition$$1._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule$$1 = sit(this, id),
        on = schedule$$1.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule$$1.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = d3Selection.selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleRemove(name, interpolate$$1) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name),
        value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
  return value == null ? this
          .styleTween(name, styleRemove(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction(name, i, tweenValue(this, "style." + name, value))
          : styleConstant(name, i, value + ""), priority);
}

function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return d3Selection.selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3Selection.selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease
};

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = d3Timer.now(), defaultTiming;
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

d3Selection.selection.prototype.interrupt = selection_interrupt;
d3Selection.selection.prototype.transition = selection_transition;

var root = [null];

function active(node, name) {
  var schedules = node.__transition,
      schedule$$1,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule$$1 = schedules[i]).state > SCHEDULED && schedule$$1.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}

exports.transition = transition;
exports.active = active;
exports.interrupt = interrupt;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":5,"d3-dispatch":6,"d3-ease":8,"d3-interpolate":11,"d3-selection":14,"d3-timer":24}],26:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x/*: number */)/*: number */ {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau = t * Math.exp(-Math.pow(x, 2) -
        1.26551223 +
        1.00002368 * t +
        0.37409196 * Math.pow(t, 2) +
        0.09678418 * Math.pow(t, 3) -
        0.18628806 * Math.pow(t, 4) +
        0.27886807 * Math.pow(t, 5) -
        1.13520398 * Math.pow(t, 6) +
        1.48851587 * Math.pow(t, 7) -
        0.82215223 * Math.pow(t, 8) +
        0.17087277 * Math.pow(t, 9));
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

module.exports = errorFunction;

},{}],27:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data/*: Array<Array<number>> */)/*: { m: number, b: number } */ {

    var m, b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0, sumY = 0,
            sumXX = 0, sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point, x, y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m = ((dataLength * sumXY) - (sumX * sumY)) /
            ((dataLength * sumXX) - (sumX * sumX));

        // `b` is the y-intercept of the line.
        b = (sumY / dataLength) - ((m * sumX) / dataLength);
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}


module.exports = linearRegression;

},{}],28:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb/*: { b: number, m: number }*/)/*: Function */ {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function(x) {
        return mb.b + (mb.m * x);
    };
}

module.exports = linearRegressionLine;

},{}],29:[function(require,module,exports){
'use strict';
/* @flow */

var sum = require('./sum');

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs on `O(n)`, linear time in respect to the array
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x /*: Array<number> */)/*:number*/ {
    // The mean of no numbers is null
    if (x.length === 0) {
        throw new Error('mean requires at least one data point');
    }

    return sum(x) / x.length;
}

module.exports = mean;

},{"./sum":38}],30:[function(require,module,exports){
'use strict';
/* @flow */

var quantileSorted = require('./quantile_sorted');
var quickselect = require('./quickselect');

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x /*: Array<number> */, p /*: Array<number> | number */) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) continue;

        var m = Math.floor((l + r) / 2);
        quantileSelect(arr, indices[m], indices[l], indices[r]);

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len /*: number */, p /*: number */)/*:number*/ {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

module.exports = quantile;

},{"./quantile_sorted":31,"./quickselect":32}],31:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x /*: Array<number> */, p /*: number */)/*:number*/ {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error('quantile requires at least one data point.');
    } else if (p < 0 || p > 1) {
        throw new Error('quantiles must be between 0 and 1');
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

module.exports = quantileSorted;

},{}],32:[function(require,module,exports){
'use strict';
/* @flow */

module.exports = quickselect;

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @private
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} left left index
 * @param {number} right right index
 * @returns {undefined}
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr /*: Array<number> */, k /*: number */, left /*: number */, right /*: number */) {
    left = left || 0;
    right = right || (arr.length - 1);

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);
            if (m - n / 2 < 0) sd *= -1;
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) i++;
            while (arr[j] > t) j--;
        }

        if (arr[left] === t) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

},{}],33:[function(require,module,exports){
'use strict';
/* @flow */

var sampleCovariance = require('./sample_covariance');
var sampleStandardDeviation = require('./sample_standard_deviation');

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x/*: Array<number> */, y/*: Array<number> */)/*:number*/ {
    var cov = sampleCovariance(x, y),
        xstd = sampleStandardDeviation(x),
        ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

module.exports = sampleCorrelation;

},{"./sample_covariance":34,"./sample_standard_deviation":35}],34:[function(require,module,exports){
'use strict';
/* @flow */

var mean = require('./mean');

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x /*:Array<number>*/, y /*:Array<number>*/)/*:number*/ {

    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error('sampleCovariance requires samples with equal lengths');
    }

    if (x.length < 2) {
        throw new Error('sampleCovariance requires at least two data points in each sample');
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x),
        ymean = mean(y),
        sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

module.exports = sampleCovariance;

},{"./mean":29}],35:[function(require,module,exports){
'use strict';
/* @flow */

var sampleVariance = require('./sample_variance');

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x/*:Array<number>*/)/*:number*/ {
    // The standard deviation of no numbers is null
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

module.exports = sampleStandardDeviation;

},{"./sample_variance":36}],36:[function(require,module,exports){
'use strict';
/* @flow */

var sumNthPowerDeviations = require('./sum_nth_power_deviations');

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x /*: Array<number> */)/*:number*/ {
    // The variance of no numbers is null
    if (x.length < 2) {
        throw new Error('sampleVariance requires at least two data points');
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

module.exports = sampleVariance;

},{"./sum_nth_power_deviations":39}],37:[function(require,module,exports){
'use strict';
/* @flow */

var variance = require('./variance');

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x /*: Array<number> */)/*:number*/ {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

module.exports = standardDeviation;

},{"./variance":40}],38:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x/*: Array<number> */)/*: number */ {

    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    for (var i = 1; i < x.length; i++) {
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += ((sum - transition) + x[i]);
        }
        else {
            correction += ((x[i] - transition) + sum);
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

module.exports = sum;

},{}],39:[function(require,module,exports){
'use strict';
/* @flow */

var mean = require('./mean');

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * var variance = sumNthPowerDeviations(input) / input.length;
 */
function sumNthPowerDeviations(x/*: Array<number> */, n/*: number */)/*:number*/ {
    var meanValue = mean(x),
        sum = 0,
        tempValue,
        i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

module.exports = sumNthPowerDeviations;

},{"./mean":29}],40:[function(require,module,exports){
'use strict';
/* @flow */

var sumNthPowerDeviations = require('./sum_nth_power_deviations');

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x/*: Array<number> */)/*:number*/ {
    // The variance of no numbers is null
    if (x.length === 0) {
        throw new Error('variance requires at least one data point');
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

module.exports = variance;

},{"./sum_nth_power_deviations":39}],41:[function(require,module,exports){
'use strict';
/* @flow */

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x/*:number*/, mean/*:number*/, standardDeviation/*:number*/)/*:number*/ {
    return (x - mean) / standardDeviation;
}

module.exports = zScore;

},{}],42:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BarChart = exports.BarChartConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var BarChartConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(BarChartConfig, _ChartWithColorGroups);

  function BarChartConfig(custom) {
    var _this;

    _classCallCheck(this, BarChartConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BarChartConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'bar-chart';
    _this.showLegend = true;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return _utils.Utils.isNumber(d) ? d : d[key];
      },
      // x value accessor
      scale: "ordinal",
      orient: "bottom",
      ticks: undefined
    };
    _this.y = {
      // Y axis config
      key: 1,
      value: function value(d, key) {
        return _utils.Utils.isNumber(d) ? d : d[key];
      },
      // x value accessor
      title: '',
      // axis label,
      orient: "left",
      scale: "linear"
    };
    _this.transition = true;

    var config = _assertThisInitialized(_assertThisInitialized(_this));

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return BarChartConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.BarChartConfig = BarChartConfig;

var BarChart =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(BarChart, _ChartWithColorGroups2);

  function BarChart(placeholderSelector, data, config) {
    _classCallCheck(this, BarChart);

    return _possibleConstructorReturn(this, _getPrototypeOf(BarChart).call(this, placeholderSelector, data, new BarChartConfig(config)));
  }

  _createClass(BarChart, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(BarChart.prototype), "setConfig", this).call(this, new BarChartConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(BarChart.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.computePlotSize();
      this.setupY();
      this.setupX();
      this.setupGroupStacks();
      this.setupYDomain();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = d3.scaleBand().range([0, plot.width]).paddingInner(.08);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.ticks) {
        x.axis.ticks(conf.ticks);
      }

      var data = this.plot.data;
      var domain;

      if (!data || !data.length) {
        domain = [];
      } else if (!this.config.series) {
        domain = d3.map(data, x.value).keys();
      } else {
        domain = d3.map(data[0].values, x.value).keys();
      }

      plot.x.scale.domain(domain);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;

      y.value = function (d) {
        return conf.value(d, conf.key);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
    }
  }, {
    key: "setupYDomain",
    value: function setupYDomain() {
      var plot = this.plot;
      var data = this.plot.data;
      var domain;
      var yStackMax = d3.max(plot.layers, function (layer) {
        return d3.max(layer.points, function (d) {
          return d.y0 + d.y;
        });
      }); // var min = d3.min(data, s=>d3.min(s.values, plot.y.value));

      var max = yStackMax;
      domain = [0, max];
      plot.y.scale.domain(domain); // console.log(' plot.y.scale.domain', plot.y.scale.domain());
    }
  }, {
    key: "setupGroupStacks",
    value: function setupGroupStacks() {
      var self = this;
      this.groupData();
      var y0s = [];
      this.plot.groupedData.forEach(function (s) {
        s.points = s.values.map(function (v) {
          return self.mapToPoint(v);
        });
        s.points.forEach(function (p, i) {
          var prevY0 = y0s[i];
          if (!prevY0) prevY0 = 0;
          p.y0 = prevY0;
          y0s[i] = p.y + prevY0;
        });
      });
      this.plot.layers = this.plot.groupedData;
    }
  }, {
    key: "mapToPoint",
    value: function mapToPoint(value) {
      var plot = this.plot;
      return {
        x: plot.x.value(value),
        y: parseFloat(plot.y.value(value))
      };
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawBars",
    value: function drawBars() {
      var self = this;
      var plot = self.plot; // console.log('layers', plot.layers);

      var layerClass = this.prefixClass("layer");
      var barClass = this.prefixClass("bar");
      var layer = self.svgG.selectAll("." + layerClass).data(plot.layers);
      var layerMerge = layer.enter().append("g").attr("class", layerClass).merge(layer);
      var bar = layerMerge.selectAll("." + barClass).data(function (d) {
        return d.points;
      });
      var barEnter = bar.enter().append("g").attr("class", barClass);
      var barRectEnter = barEnter.append("rect").attr("x", 1);
      var barMerge = barEnter.merge(bar);
      var barRect = barMerge.select("rect");
      var barRectT = barRect;
      var barT = barMerge;
      var layerT = layerMerge;

      if (this.transitionEnabled()) {
        barRectT = barRect.transition();
        barT = barMerge.transition();
        layerT = layerMerge.transition();
      }

      barEnter.attr("transform", function (d) {
        return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0) + ")";
      });
      var yDomain = plot.y.scale.domain();
      barT.attr("transform", function (d) {
        return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0 + d.y) + ")";
      });
      barRectEnter.attr("width", plot.x.scale.bandwidth()).attr("height", 0);
      barRectT.attr("width", plot.x.scale.bandwidth()).attr("height", function (d) {
        return plot.y.scale(d.y0) - plot.y.scale(d.y0 + d.y - yDomain[0]);
      });

      if (this.plot.seriesColor) {
        layerT.attr("fill", this.plot.seriesColor);
      }

      if (plot.tooltip) {
        barMerge.on("mouseover", function (d) {
          self.showTooltip(d.y);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      layer.exit().remove();
      bar.exit().remove();
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(BarChart.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawBars();
      return this;
    }
  }]);

  return BarChart;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.BarChart = BarChart;

},{"./chart-with-color-groups":45,"./d3":49,"./legend":55,"./utils":62}],43:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoxPlotBase = exports.BoxPlotBaseConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var BoxPlotBaseConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(BoxPlotBaseConfig, _ChartConfig); // string or function returning color's value for color scale


  function BoxPlotBaseConfig(custom) {
    var _this;

    _classCallCheck(this, BoxPlotBaseConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BoxPlotBaseConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'box-plot';
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      value: function value(s) {
        return s.key;
      },
      // x value accessor
      guides: false,
      //show axis guides
      orient: 'bottom'
    };
    _this.y = {
      // Y axis config
      title: '',
      value: function value(d) {
        return d;
      },
      // y value accessor
      scale: "linear",
      orient: 'left',
      domainMargin: 0.1,
      guides: true //show axis guides

    };

    _this.Q1 = function (d) {
      return d.values.Q1;
    };

    _this.Q2 = function (d) {
      return d.values.Q2;
    };

    _this.Q3 = function (d) {
      return d.values.Q3;
    };

    _this.Wl = function (d) {
      return d.values.whiskerLow;
    };

    _this.Wh = function (d) {
      return d.values.whiskerHigh;
    };

    _this.outliers = function (d) {
      return d.values.outliers;
    };

    _this.outlierValue = function (d, i) {
      return d;
    };

    _this.outlierLabel = function (d, i) {
      return d;
    };

    _this.minBoxWidth = 35;
    _this.maxBoxWidth = 100;
    _this.transition = true;
    _this.color = undefined;
    _this.d3ColorCategory = 'category10';

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return BoxPlotBaseConfig;
}(_chart.ChartConfig);

exports.BoxPlotBaseConfig = BoxPlotBaseConfig;

var BoxPlotBase =
/*#__PURE__*/
function (_Chart) {
  _inherits(BoxPlotBase, _Chart);

  function BoxPlotBase(placeholderSelector, data, config) {
    _classCallCheck(this, BoxPlotBase);

    return _possibleConstructorReturn(this, _getPrototypeOf(BoxPlotBase).call(this, placeholderSelector, data, new BoxPlotBaseConfig(config)));
  }

  _createClass(BoxPlotBase, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(BoxPlotBase.prototype), "setConfig", this).call(this, new BoxPlotBaseConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(BoxPlotBase.prototype), "initPlot", this).call(this);

      _get(_getPrototypeOf(BoxPlotBase.prototype), "computePlotSize", this).call(this);

      this.plot.x = {};
      this.plot.y = {};
      this.plot.data = this.getDataToPlot();
      this.setupY();
      this.setupX();
      this.setupColor();
    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      return this.data;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      x.value = conf.value;
      x.scale = d3.scaleBand().range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.guides) {
        x.axis.tickSize(-plot.height);
      }

      var data = this.plot.data;
      var domain;

      if (!data || !data.length) {
        domain = [];
      } else {
        domain = data.map(x.value);
      }

      plot.x.scale.domain(domain);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var _this2 = this;

      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;

      y.value = function (d) {
        return conf.value.call(_this2.config, d);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (conf.ticks) {
        y.axis.ticks(conf.ticks);
      }

      if (conf.guides) {
        y.axis.tickSize(-plot.width);
      }

      this.setupYDomain();
    }
  }, {
    key: "setupYDomain",
    value: function setupYDomain() {
      var plot = this.plot;
      var data = this.plot.data;
      var c = this.config;
      var values = [],
          yMin,
          yMax;
      data.forEach(function (d, i) {
        var q1 = c.Q1(d),
            q3 = c.Q3(d),
            wl = c.Wl(d),
            wh = c.Wh(d),
            outliers = c.outliers(d);

        if (outliers) {
          outliers.forEach(function (o, i) {
            values.push(c.outlierValue(o, i));
          });
        }

        if (wl) {
          values.push(wl);
        }

        if (q1) {
          values.push(q1);
        }

        if (q3) {
          values.push(q3);
        }

        if (wh) {
          values.push(wh);
        }
      });
      yMin = d3.min(values);
      yMax = d3.max(values);
      var margin = (yMax - yMin) * this.config.y.domainMargin;
      yMin -= margin;
      yMax += margin;
      var domain = [yMin, yMax];
      plot.y.scale.domain(domain);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.label);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawBoxPlots",
    value: function drawBoxPlots() {
      var self = this,
          plot = self.plot,
          config = self.config,
          boxplotClass = self.prefixClass("boxplot-item");
      var boxplots = self.svgG.selectAll('.' + boxplotClass).data(plot.data);
      var boxplotEnter = boxplots.enter().append('g').attr('class', boxplotClass).style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);
      var boxplotsMerge = boxplotEnter.merge(boxplots);
      var duration = 1000;
      var boxplotsT = boxplotsMerge;

      if (self.transitionEnabled()) {
        boxplotsT = boxplotsMerge.transition();
        boxplotsT.delay(function (d, i) {
          return i * duration / plot.data.length;
        });
      }

      boxplotsT.style('fill', plot.color).style('stroke-opacity', 1).style('fill-opacity', 0.75).attr('transform', function (d, i) {
        return 'translate(' + (plot.x.map(d, i) + plot.x.scale.bandwidth() * 0.05) + ', 0)';
      });
      boxplots.exit().remove();
      var boxWidth = !config.maxBoxWidth ? plot.x.scale.bandwidth() * 0.9 : Math.min(config.maxBoxWidth, Math.max(config.minBoxWidth, plot.x.scale.bandwidth() * 0.9));
      var boxLeft = plot.x.scale.bandwidth() * 0.45 - boxWidth / 2;
      var boxRight = plot.x.scale.bandwidth() * 0.45 + boxWidth / 2;
      var boxClass = self.prefixClass("box");
      boxplotEnter.append('rect').attr('class', boxClass) // tooltip events
      .on('mouseover', function (d, i) {
        d3.select(this).classed('hover', true);
        var html = 'Q3: ' + config.Q3(d, i) + '<br/>Q2: ' + config.Q2(d, i) + '<br/>Q1: ' + config.Q1(d, i);
        self.showTooltip(html);
      }).on('mouseout', function (d, i) {
        d3.select(this).classed('hover', false);
        self.hideTooltip();
      });
      var boxRects = boxplotsMerge.select('rect.' + boxClass);
      var boxRectsT = boxRects;

      if (self.config.transition) {
        boxRectsT = boxRects.transition();
      }

      boxRectsT.attr('y', function (d, i) {
        return plot.y.scale(config.Q3(d));
      }).attr('width', boxWidth).attr('x', boxLeft).attr('height', function (d, i) {
        return Math.abs(plot.y.scale(config.Q3(d)) - plot.y.scale(config.Q1(d))) || 1;
      }).style('stroke', plot.color); // median line

      var medianClass = self.prefixClass('median');
      boxplotEnter.append('line').attr('class', medianClass);
      var medianLine = boxplotsMerge.select('line.' + medianClass);

      if (self.config.transition) {
        medianLine = medianLine.transition();
      }

      medianLine.attr('x1', boxLeft).attr('y1', function (d, i) {
        return plot.y.scale(config.Q2(d));
      }).attr('x2', boxRight).attr('y2', function (d, i) {
        return plot.y.scale(config.Q2(d));
      }); //whiskers

      var whiskerClass = self.prefixClass("whisker"),
          tickClass = self.prefixClass("boxplot-tick");
      var whiskers = [{
        key: 'low',
        value: config.Wl
      }, {
        key: 'high',
        value: config.Wh
      }];
      boxplotEnter.each(function (d, i) {
        var box = d3.select(this);
        whiskers.forEach(function (f) {
          if (f.value(d)) {
            box.append('line').style('stroke', plot.color(d, i)).attr('class', whiskerClass + ' ' + boxplotClass + '-' + f.key);
            box.append('line').style('stroke', plot.color(d, i)).attr('class', tickClass + ' ' + boxplotClass + '-' + f.key);
          }
        });
      });
      whiskers.forEach(function (f) {
        var endpoint = f.key === 'low' ? config.Q1 : config.Q3;
        var whisker = boxplotsMerge.select('.' + whiskerClass + '.' + boxplotClass + '-' + f.key);
        var tick = boxplotsMerge.select('.' + tickClass + '.' + boxplotClass + '-' + f.key);

        if (self.config.transition) {
          whisker = whisker.transition();
          tick = tick.transition();
        }

        whisker.attr('x1', plot.x.scale.bandwidth() * 0.45).attr('y1', function (d, i) {
          return plot.y.scale(f.value(d));
        }).attr('x2', plot.x.scale.bandwidth() * 0.45).attr('y2', function (d, i) {
          return plot.y.scale(endpoint(d));
        });
        tick.attr('x1', boxLeft).attr('y1', function (d, i) {
          return plot.y.scale(f.value(d));
        }).attr('x2', boxRight).attr('y2', function (d, i) {
          return plot.y.scale(f.value(d));
        });
        boxplotEnter.selectAll('.' + boxplotClass + '-' + f.key).on('mouseover', function (d, i, j) {
          d3.select(this).classed('hover', true);
          self.showTooltip(f.value(d));
        }).on('mouseout', function (d, i, j) {
          d3.select(this).classed('hover', false);
          self.hideTooltip();
        });
      }); // outliers

      var outlierClass = self.prefixClass("outlier");
      var outliers = boxplotsMerge.selectAll('.' + outlierClass).data(function (d, i) {
        return config.outliers(d, i) || [];
      });
      var outlierEnterCircle = outliers.enter().append('circle').attr('class', outlierClass).style('z-index', 9000);
      outlierEnterCircle.on('mouseover', function (d, i, j) {
        d3.select(this).classed('hover', true);
        self.showTooltip(config.outlierLabel(d, i));
      }).on('mouseout', function (d, i, j) {
        d3.select(this).classed('hover', false);
        self.hideTooltip();
      });
      var outliersMerge = outlierEnterCircle.merge(outliers);
      var outliersT = outliersMerge;

      if (self.config.transition) {
        outliersT = outliersMerge.transition();
      }

      outliersT.attr('cx', plot.x.scale.bandwidth() * 0.45).attr('cy', function (d, i) {
        return plot.y.scale(config.outlierValue(d, i));
      }).attr('r', '3');
      outliers.exit().remove();
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(BoxPlotBase.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawBoxPlots();
      return this;
    }
  }, {
    key: "setupColor",
    value: function setupColor() {
      var _this3 = this;

      var self = this;
      var conf = this.config;

      if (conf.d3ColorCategory) {
        var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);

        this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
      }

      var colorValue = conf.color;

      if (colorValue && typeof colorValue === 'string' || colorValue instanceof String) {
        this.plot.color = colorValue;
      } else if (this.plot.colorCategory) {
        self.plot.colorValue = colorValue;

        this.plot.color = function (d) {
          return self.plot.colorCategory(_this3.plot.x.value(d));
        };
      }
    }
  }]);

  return BoxPlotBase;
}(_chart.Chart);

exports.BoxPlotBase = BoxPlotBase;

},{"./chart":46,"./d3":49,"./utils":62}],44:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoxPlot = exports.BoxPlotConfig = void 0;

var _boxPlotBase = require("./box-plot-base");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var BoxPlotConfig =
/*#__PURE__*/
function (_BoxPlotBaseConfig) {
  _inherits(BoxPlotConfig, _BoxPlotBaseConfig);

  function BoxPlotConfig(custom) {
    var _this;

    _classCallCheck(this, BoxPlotConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BoxPlotConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'box-plot';
    _this.showLegend = true;
    _this.showTooltip = true;
    _this.y = {
      // Y axis config
      key: undefined,
      value: function value(d) {
        return this.y.key === undefined ? d : d[this.y.key];
      },
      // y value accessor
      scale: "linear",
      orient: 'left',
      domainMargin: 0.1,
      guides: true //show axis guides

    };
    _this.series = false;
    _this.groups = {
      key: undefined,
      value: function value(d) {
        return this.groups.key === undefined ? '' : d[this.groups.key];
      },
      // grouping value accessor,
      label: "",
      displayValue: undefined // optional function returning display value (series label) for given group value, or object/array mapping value to display value

    };
    _this.tukey = false;

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return BoxPlotConfig;
}(_boxPlotBase.BoxPlotBaseConfig);

exports.BoxPlotConfig = BoxPlotConfig;

var BoxPlot =
/*#__PURE__*/
function (_BoxPlotBase) {
  _inherits(BoxPlot, _BoxPlotBase);

  function BoxPlot(placeholderSelector, data, config) {
    _classCallCheck(this, BoxPlot);

    return _possibleConstructorReturn(this, _getPrototypeOf(BoxPlot).call(this, placeholderSelector, data, new BoxPlotConfig(config)));
  }

  _createClass(BoxPlot, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(BoxPlot.prototype), "setConfig", this).call(this, new BoxPlotConfig(config));
    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      var self = this;
      var conf = self.config;
      self.plot.groupingEnabled = this.isGroupingEnabled();
      var data = this.data;

      if (!self.plot.groupingEnabled) {
        self.plot.groupedData = [{
          key: '',
          values: data
        }];
        self.plot.dataLength = data.length;
      } else {
        if (self.config.series) {
          self.plot.groupedData = data.map(function (s) {
            return {
              key: s.label || s.key || '',
              values: s.values
            };
          });
        } else {
          self.plot.groupValue = function (d) {
            return conf.groups.value.call(conf, d);
          };

          self.plot.groupedData = d3.nest().key(this.plot.groupValue).entries(data);

          var getDisplayValue = function getDisplayValue(k) {
            return k;
          };

          if (self.config.groups.displayValue) {
            if (_utils.Utils.isFunction(self.config.groups.displayValue)) {
              getDisplayValue = function getDisplayValue(k) {
                return self.config.groups.displayValue(k) || k;
              };
            } else if (_utils.Utils.isObject(self.config.groups.displayValue)) {
              getDisplayValue = function getDisplayValue(k) {
                return self.config.groups.displayValue[k] || k;
              };
            }
          }

          self.plot.groupedData.forEach(function (g) {
            g.key = getDisplayValue(g.key);
          });
        }

        self.plot.dataLength = d3.sum(this.plot.groupedData, function (s) {
          return s.values.length;
        });
      }

      self.plot.groupedData.forEach(function (s) {
        if (!Array.isArray(s.values)) {
          return;
        }

        var values = s.values.map(function (d) {
          return parseFloat(self.config.y.value.call(self.config, d));
        });
        s.values.Q1 = _statisticsUtils.StatisticsUtils.quantile(values, 0.25);
        s.values.Q2 = _statisticsUtils.StatisticsUtils.quantile(values, 0.5);
        s.values.Q3 = _statisticsUtils.StatisticsUtils.quantile(values, 0.75);
        var IQR = s.values.Q3 - s.values.Q1;

        if (!self.config.tukey) {
          s.values.whiskerLow = d3.min(values);
          s.values.whiskerHigh = d3.max(values);
        } else {
          s.values.whiskerLow = s.values.Q1 - 1.5 * IQR;
          s.values.whiskerHigh = s.values.Q3 + 1.5 * IQR;
          s.values.outliers = values.filter(function (d) {
            return d < s.values.whiskerLow || d > s.values.whiskerHigh;
          });
        }
      });
      return self.plot.groupedData;
    }
  }, {
    key: "isGroupingEnabled",
    value: function isGroupingEnabled() {
      return this.config.series || !!(this.config.groups && this.config.groups.value);
    }
  }]);

  return BoxPlot;
}(_boxPlotBase.BoxPlotBase);

exports.BoxPlot = BoxPlot;

},{"./box-plot-base":43,"./d3":49,"./statistics-utils":61,"./utils":62}],45:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChartWithColorGroups = exports.ChartWithColorGroupsConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var ChartWithColorGroupsConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(ChartWithColorGroupsConfig, _ChartConfig); // string or function returning color's value for color scale


  function ChartWithColorGroupsConfig(custom) {
    var _this;

    _classCallCheck(this, ChartWithColorGroupsConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ChartWithColorGroupsConfig).call(this));
    _this.showLegend = true;
    _this.forceLegend = false;
    _this.legend = {
      width: 80,
      margin: 10,
      shapeWidth: 20
    };
    _this.groups = {
      key: 2,
      value: function value(d) {
        return d[this.groups.key];
      },
      // grouping value accessor,
      label: "",
      displayValue: undefined // optional function returning display value (series label) for given group value, or object/array mapping value to display value

    };
    _this.series = false;
    _this.color = undefined;
    _this.d3ColorCategory = 'category10';

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return ChartWithColorGroupsConfig;
}(_chart.ChartConfig);

exports.ChartWithColorGroupsConfig = ChartWithColorGroupsConfig;

var ChartWithColorGroups =
/*#__PURE__*/
function (_Chart) {
  _inherits(ChartWithColorGroups, _Chart);

  function ChartWithColorGroups(placeholderSelector, data, config) {
    _classCallCheck(this, ChartWithColorGroups);

    return _possibleConstructorReturn(this, _getPrototypeOf(ChartWithColorGroups).call(this, placeholderSelector, data, new ChartWithColorGroupsConfig(config)));
  }

  _createClass(ChartWithColorGroups, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(ChartWithColorGroups.prototype), "setConfig", this).call(this, new ChartWithColorGroupsConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(ChartWithColorGroups.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.showLegend = conf.showLegend;
      this.setupGroups();
      this.plot.data = this.getDataToPlot();
      this.groupData();

      if (this.plot.showLegend) {
        var scale = this.plot.colorCategory;

        if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
          this.plot.showLegend = false;
        } else {
          this.plot.margin.right = conf.margin.right + conf.legend.width + conf.legend.margin * 2;
        }
      }

      return this;
    }
  }, {
    key: "isGroupingEnabled",
    value: function isGroupingEnabled() {
      return this.config.series || !!(this.config.groups && this.config.groups.value);
    }
  }, {
    key: "computeGroupColorDomain",
    value: function computeGroupColorDomain() {
      var _this2 = this;

      var map = d3.set(this.data, function (d) {
        return _this2.plot.groupValue(d);
      });
      return Object.getOwnPropertyNames(map).map(function (d) {
        return map[d];
      });
    }
  }, {
    key: "setupGroups",
    value: function setupGroups() {
      var _this3 = this;

      var self = this;
      var conf = this.config;
      this.plot.groupingEnabled = this.isGroupingEnabled();
      var domain = [];

      if (this.plot.groupingEnabled) {
        self.plot.groupToLabel = {};

        if (this.config.series) {
          this.plot.groupValue = function (s) {
            return s.key;
          };

          domain = this.computeGroupColorDomain();
          this.data.forEach(function (s) {
            self.plot.groupToLabel[s.key] = s.label || s.key;
          });
        } else {
          this.plot.groupValue = function (d) {
            return conf.groups.value.call(conf, d);
          };

          domain = this.computeGroupColorDomain();

          var getLabel = function getLabel(k) {
            return k;
          };

          if (self.config.groups.displayValue) {
            if (_utils.Utils.isFunction(self.config.groups.displayValue)) {
              getLabel = function getLabel(k) {
                return self.config.groups.displayValue(k) || k;
              };
            } else if (_utils.Utils.isObject(self.config.groups.displayValue)) {
              getLabel = function getLabel(k) {
                return self.config.groups.displayValue[k] || k;
              };
            }
          }

          domain.forEach(function (k) {
            self.plot.groupToLabel[k] = getLabel(k);
          });
        }
      } else {
        this.plot.groupValue = function (d) {
          return null;
        };
      }

      this.plot.groupColorDomain = domain;

      if (conf.d3ColorCategory) {
        var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);

        this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
      }

      var colorValue = conf.color;

      if (colorValue) {
        if (typeof colorValue === 'string' || colorValue instanceof String) {
          this.plot.color = colorValue;
          this.plot.seriesColor = this.plot.color;
        } else {
          this.plot.color = colorValue;
          this.plot.seriesColor = this.plot.color;
          var range = domain.map(function (v) {
            return _this3.plot.seriesColor({
              key: v
            });
          });
          this.plot.colorCategory = d3.scaleOrdinal(range);
          this.plot.colorCategory.domain(domain);
        }
      } else if (this.plot.colorCategory) {
        self.plot.colorValue = colorValue;
        self.plot.colorCategory.domain(domain);

        this.plot.seriesColor = function (s) {
          return self.plot.colorCategory(s.key);
        };

        this.plot.color = function (d) {
          return self.plot.colorCategory(_this3.plot.groupValue(d));
        };
      } else {
        this.plot.color = this.plot.seriesColor = function (s) {
          return 'black';
        };
      }
    }
  }, {
    key: "groupData",
    value: function groupData() {
      var self = this;
      var data = this.plot.data;

      if (!self.plot.groupingEnabled) {
        self.plot.groupedData = [{
          key: null,
          label: '',
          values: data
        }];
        self.plot.dataLength = data.length;
      } else {
        if (self.config.series) {
          self.plot.groupedData = data.map(function (s) {
            return {
              key: s.key,
              label: s.label,
              values: s.values
            };
          });
        } else {
          self.plot.groupedData = d3.nest().key(this.plot.groupValue).entries(data);
          self.plot.groupedData.forEach(function (g) {
            g.label = self.plot.groupToLabel[g.key];
          });
        }

        self.plot.dataLength = d3.sum(this.plot.groupedData, function (s) {
          return s.values.length;
        });
      } // this.plot.seriesColor

    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      var _this4 = this;

      if (!this.plot.groupingEnabled || !this.enabledGroups) {
        return this.data;
      }

      return this.data.filter(function (d) {
        return _this4.enabledGroups.indexOf(_this4.plot.groupValue(d)) > -1;
      });
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(ChartWithColorGroups.prototype), "update", this).call(this, newData);

      this.updateLegend();
      return this;
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var self = this;
      var plot = this.plot;
      var scale = plot.colorCategory;

      if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
        plot.showLegend = false;
      }

      if (!plot.showLegend) {
        if (plot.legend && plot.legend.container) {
          plot.legend.container.remove();
        }

        return;
      }

      var legendX = this.plot.width + this.config.legend.margin;
      var legendY = this.config.legend.margin;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY);
      plot.legendColor = plot.legend.color().shapeWidth(this.config.legend.shapeWidth).orient('vertical').scale(scale).labelWrap(this.config.legend.width).labels(scale.domain().map(function (v) {
        return plot.groupToLabel[v];
      }));
      plot.legendColor.on('cellclick', function (c) {
        return self.onLegendCellClick(c);
      });
      plot.legend.container.call(plot.legendColor);
      this.updateLegendCellStatuses();
    }
  }, {
    key: "onLegendCellClick",
    value: function onLegendCellClick(cellValue) {
      this.updateEnabledGroups(cellValue);
      this.init();
    }
  }, {
    key: "updateLegendCellStatuses",
    value: function updateLegendCellStatuses() {
      var self = this;
      this.plot.legend.container.selectAll("g.cell").each(function (cell) {
        var isDisabled = self.enabledGroups && self.enabledGroups.indexOf(cell) < 0;
        d3.select(this).classed("odc-disabled", isDisabled);
      });
    }
  }, {
    key: "updateEnabledGroups",
    value: function updateEnabledGroups(cellValue) {
      if (!this.enabledGroups) {
        this.enabledGroups = this.plot.colorCategory.domain().slice();
      }

      var index = this.enabledGroups.indexOf(cellValue);

      if (index < 0) {
        this.enabledGroups.push(cellValue);
      } else {
        this.enabledGroups.splice(index, 1);
      }

      if (!this.enabledGroups.length) {
        this.enabledGroups = this.plot.colorCategory.domain().slice();
      }
    }
  }, {
    key: "setData",
    value: function setData(data) {
      _get(_getPrototypeOf(ChartWithColorGroups.prototype), "setData", this).call(this, data);

      this.enabledGroups = null;
      return this;
    }
  }]);

  return ChartWithColorGroups;
}(_chart.Chart);

exports.ChartWithColorGroups = ChartWithColorGroups;

},{"./chart":46,"./d3":49,"./legend":55,"./utils":62}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chart = exports.ChartConfig = void 0;

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ChartConfig = function ChartConfig(custom) {
  _classCallCheck(this, ChartConfig);

  this.cssClassPrefix = "odc-";
  this.svgClass = this.cssClassPrefix + 'mw-d3-chart';
  this.width = undefined;
  this.height = undefined;
  this.margin = {
    left: 50,
    right: 30,
    top: 30,
    bottom: 50
  };
  this.showTooltip = false;
  this.transition = true;
  this.title = undefined;
  this.titleSize = 20;
  this.titleMargin = {
    left: 0,
    right: 0,
    top: 15,
    bottom: 20
  };
  this.subtitle = undefined;
  this.subtitleSize = 14;
  this.subtitleMargin = {
    left: 0,
    right: 0,
    top: 10,
    bottom: 20
  };

  if (custom) {
    _utils.Utils.deepExtend(this, custom);
  }
};

exports.ChartConfig = ChartConfig;

var Chart =
/*#__PURE__*/
function () {
  function Chart(base, data, config) {
    _classCallCheck(this, Chart);

    this.utils = _utils.Utils;
    this.plot = {
      margin: {}
    };
    this._attached = {};
    this._layers = {};
    this._events = {};
    this._isInitialized = false;
    this._id = _utils.Utils.guid();
    this._isAttached = base instanceof Chart;
    this.baseContainer = base;
    this.setConfig(config);

    if (data) {
      this.setData(data);
    }

    this.init();
    this.postInit();
  }

  _createClass(Chart, [{
    key: "setConfig",
    value: function setConfig(config) {
      if (!config) {
        this.config = new ChartConfig();
      } else {
        this.config = config;
      }

      this.initConfigAccessors();
      return this;
    }
  }, {
    key: "setData",
    value: function setData(data) {
      this.data = data;
      return this;
    }
  }, {
    key: "init",
    value: function init() {
      var self = this;
      self.initPlot();
      self.initSvg();

      if (!this._isInitialized) {
        self.initTooltip();
      }

      self.draw();
      this._isInitialized = true;
      return this;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      this.initConfigAccessors(true);
      return this.init();
    }
  }, {
    key: "postInit",
    value: function postInit() {}
  }, {
    key: "initSvg",
    value: function initSvg() {
      var self = this;
      var config = this.config;
      var margin = self.plot.margin;
      var width = self.svgWidth = self.plot.width + margin.left + margin.right;
      var height = self.svgHeight = self.plot.height + margin.top + margin.bottom;
      var aspect = width / height;

      if (!self._isAttached) {
        if (!this._isInitialized) {
          d3.select(self.baseContainer).select("svg").remove();
        }

        self.svg = d3.select(self.baseContainer).selectOrAppend("svg").classed(config.svgClass, true);
        self.svg.attr("width", width).attr("height", height).attr("viewBox", "0 0 " + " " + width + " " + height).attr("preserveAspectRatio", "xMidYMid meet");
        self.svgG = self.svg.selectOrAppend("g.main-group");
      } else {
        // console.log(self.baseContainer);
        self.svg = self.baseContainer.svg;
        self.svgG = self.svg.selectOrAppend("g.main-group." + config.svgClass);
      }

      self.svgG.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      if (!config.width || config.height) {
        d3.select(window).on("resize." + self._id, function () {
          var transition = self.config.transition;
          self.config.transition = false;
          self.init();
          self.config.transition = transition;
        });
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      d3.select(this.baseContainer).selectAll("*").remove();
      d3.select(window).on("resize." + this._id, null);
    }
  }, {
    key: "initTooltip",
    value: function initTooltip() {
      var self = this;

      if (self.config.showTooltip) {
        if (!self._isAttached) {
          self.plot.tooltip = d3.select("body").selectOrAppend('div.' + self.config.cssClassPrefix + 'tooltip').style("opacity", 0);
        } else {
          self.plot.tooltip = self.baseContainer.plot.tooltip;
        }
      } else {
        self.plot.tooltip = null;
      }
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      var margin = this.config.margin;
      this.plot = this.plot || {};
      this.plot.margin = {
        top: margin.top,
        bottom: margin.bottom,
        left: margin.left,
        right: margin.right
      };
      var titleMarginSize = 0;

      if (this.config.title) {
        titleMarginSize = this.config.titleSize + this.config.titleMargin.top;

        if (!this.config.subtitle) {
          titleMarginSize += this.config.titleMargin.bottom;
        }

        this.plot.margin.top = Math.max(this.plot.margin.top, titleMarginSize);
      }

      if (this.config.subtitle) {
        this.plot.margin.top = Math.max(this.plot.margin.top, titleMarginSize + this.config.subtitleMargin.top + this.config.subtitleSize + this.config.subtitleMargin.bottom);
      }
    }
  }, {
    key: "update",
    value: function update(data) {
      if (data) {
        this.setData(data);
      }

      this.updateTitle();
      this.updateSubtitle();
      var layerName, attachmentData;

      for (var attachmentName in this._attached) {
        attachmentData = data;

        this._attached[attachmentName].update(attachmentData);
      }

      return this;
    }
  }, {
    key: "updateTitle",
    value: function updateTitle() {
      var titleClass = this.prefixClass('plot-title');

      if (!this.config.title) {
        this.svg.select("text." + titleClass).remove();
        return;
      }

      this.svg.selectOrAppend("text." + titleClass).attr("transform", "translate(" + this.svgWidth / 2 + "," + this.config.titleMargin.top + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "0.5em").style("text-anchor", "middle").style("dominant-baseline", "central").style("font-size", this.config.titleSize + "px").text(this.config.title);
    }
  }, {
    key: "updateSubtitle",
    value: function updateSubtitle() {
      var subtitleClass = this.prefixClass('plot-subtitle');

      if (!this.config.subtitle) {
        this.svg.select("text." + subtitleClass).remove();
        return;
      }

      var y = this.config.subtitleMargin.top;

      if (this.config.title) {
        y += this.config.titleMargin.top + this.config.titleSize;
      }

      this.svg.selectOrAppend("text." + subtitleClass).attr("transform", "translate(" + this.svgWidth / 2 + "," + y + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "0.5em").style("text-anchor", "middle").style("dominant-baseline", "central").style("font-size", this.config.subtitleSize + "px").text(this.config.subtitle);
    }
  }, {
    key: "draw",
    value: function draw(data) {
      this.update(data);
      return this;
    } //Borrowed from d3.chart

    /**
     * Register or retrieve an "attachment" Chart. The "attachment" chart's `draw`
     * method will be invoked whenever the containing chart's `draw` method is
     * invoked.
     *
     * @externalExample chart-attach
     *
     * @param {String} attachmentName Name of the attachment
     * @param {Chart} [chart] Chart to register as a mix in of this chart. When
     *        unspecified, this method will return the attachment previously
     *        registered with the specified `attachmentName` (if any).
     *
     * @returns {Chart} Reference to this chart (chainable).
     */

  }, {
    key: "attach",
    value: function attach(attachmentName, chart) {
      if (arguments.length === 1) {
        return this._attached[attachmentName];
      }

      this._attached[attachmentName] = chart;
      return chart;
    }
  }, {
    key: "on",
    //Borrowed from d3.chart

    /**
     * Subscribe a callback function to an event triggered on the chart. See {@link
        * Chart#once} to subscribe a callback function to an event for one occurence.
     *
     * @externalExample {runnable} chart-on
     *
     * @param {String} name Name of the event
     * @param {ChartEventHandler} callback Function to be invoked when the event
     *        occurs
     * @param {Object} [context] Value to set as `this` when invoking the
     *        `callback`. Defaults to the chart instance.
     *
     * @returns {Chart} A reference to this chart (chainable).
     */
    value: function on(name, callback, context) {
      var events = this._events[name] || (this._events[name] = []);
      events.push({
        callback: callback,
        context: context || this,
        _chart: this
      });
      return this;
    } //Borrowed from d3.chart

    /**
     *
     * Subscribe a callback function to an event triggered on the chart. This
     * function will be invoked at the next occurance of the event and immediately
     * unsubscribed. See {@link Chart#on} to subscribe a callback function to an
     * event indefinitely.
     *
     * @externalExample {runnable} chart-once
     *
     * @param {String} name Name of the event
     * @param {ChartEventHandler} callback Function to be invoked when the event
     *        occurs
     * @param {Object} [context] Value to set as `this` when invoking the
     *        `callback`. Defaults to the chart instance
     *
     * @returns {Chart} A reference to this chart (chainable)
     */

  }, {
    key: "once",
    value: function once(name, callback, context) {
      var self = this;

      var once = function once() {
        self.off(name, once);
        callback.apply(this, arguments);
      };

      return this.on(name, once, context);
    } //Borrowed from d3.chart

    /**
     * Unsubscribe one or more callback functions from an event triggered on the
     * chart. When no arguments are specified, *all* handlers will be unsubscribed.
     * When only a `name` is specified, all handlers subscribed to that event will
     * be unsubscribed. When a `name` and `callback` are specified, only that
     * function will be unsubscribed from that event. When a `name` and `context`
     * are specified (but `callback` is omitted), all events bound to the given
     * event with the given context will be unsubscribed.
     *
     * @externalExample {runnable} chart-off
     *
     * @param {String} [name] Name of the event to be unsubscribed
     * @param {ChartEventHandler} [callback] Function to be unsubscribed
     * @param {Object} [context] Contexts to be unsubscribe
     *
     * @returns {Chart} A reference to this chart (chainable).
     */

  }, {
    key: "off",
    value: function off(name, callback, context) {
      var names, n, events, event, i, j; // remove all events

      if (arguments.length === 0) {
        for (name in this._events) {
          this._events[name].length = 0;
        }

        return this;
      } // remove all events for a specific name


      if (arguments.length === 1) {
        events = this._events[name];

        if (events) {
          events.length = 0;
        }

        return this;
      } // remove all events that match whatever combination of name, context
      // and callback.


      names = name ? [name] : Object.keys(this._events);

      for (i = 0; i < names.length; i++) {
        n = names[i];
        events = this._events[n];
        j = events.length;

        while (j--) {
          event = events[j];

          if (callback && callback === event.callback || context && context === event.context) {
            events.splice(j, 1);
          }
        }
      }

      return this;
    }
  }, {
    key: "trigger",
    //Borrowed from d3.chart

    /**
     * Publish an event on this chart with the given `name`.
     *
     * @externalExample {runnable} chart-trigger
     *
     * @param {String} name Name of the event to publish
     * @param {...*} arguments Values with which to invoke the registered
     *        callbacks.
     *
     * @returns {Chart} A reference to this chart (chainable).
     */
    value: function trigger(name) {
      var args = Array.prototype.slice.call(arguments, 1);
      var events = this._events[name];
      var i, ev;

      if (events !== undefined) {
        for (i = 0; i < events.length; i++) {
          ev = events[i];
          ev.callback.apply(ev.context, args);
        }
      }

      return this;
    }
  }, {
    key: "getBaseContainer",
    value: function getBaseContainer() {
      if (this._isAttached) {
        return this.baseContainer.svg;
      }

      return d3.select(this.baseContainer);
    }
  }, {
    key: "getBaseContainerNode",
    value: function getBaseContainerNode() {
      return this.getBaseContainer().node();
    }
  }, {
    key: "prefixClass",
    value: function prefixClass(clazz, addDot) {
      return addDot ? '.' : '' + this.config.cssClassPrefix + clazz;
    }
  }, {
    key: "computePlotSize",
    value: function computePlotSize() {
      this.plot.width = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), this.plot.margin);
      this.plot.height = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), this.plot.margin);
    }
  }, {
    key: "transitionEnabled",
    value: function transitionEnabled() {
      return this._isInitialized && this.config.transition;
    }
  }, {
    key: "showTooltip",
    value: function showTooltip(html) {
      if (!this.plot.tooltip) {
        return;
      }

      this.plot.tooltip.transition().duration(200).style("opacity", .9);
      this.plot.tooltip.html(html).style("left", d3.event.pageX + 5 + "px").style("top", d3.event.pageY - 28 + "px");
    }
  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      if (!this.plot.tooltip) {
        return;
      }

      this.plot.tooltip.transition().duration(500).style("opacity", 0);
    }
  }, {
    key: "initConfigAccessors",
    value: function initConfigAccessors(clean) {
      if (clean) {
        this.removePropertyAccessors(this, this, this.config, "$");
      }

      this.initPropertyAccessors(this, this, this.config, "$", true);
    }
  }, {
    key: "removePropertyAccessors",
    value: function removePropertyAccessors(bindTo, returnObj, source, prefix) {
      var self = this;

      for (var i in source) {
        if (!source.hasOwnProperty(i)) {
          continue;
        }

        delete bindTo[prefix + i];
      }
    }
  }, {
    key: "initPropertyAccessors",
    value: function initPropertyAccessors(bindTo, returnObj, source, prefix, recursive) {
      var self = this;

      for (var i in source) {
        if (!source.hasOwnProperty(i)) {
          continue;
        }

        var accessor = self.initPropertyAccessor(bindTo, returnObj, source, i, prefix);

        if (recursive && _utils.Utils.isObjectNotArray(source[i])) {
          self.initPropertyAccessors(accessor, bindTo, source[i], prefix, recursive);
        }
      }
    }
  }, {
    key: "initPropertyAccessor",
    value: function initPropertyAccessor(bindTo, returnObj, source, propertyKey, prefix) {
      return bindTo[prefix + propertyKey] = function (_) {
        if (!arguments.length) {
          return source[propertyKey];
        }

        source[propertyKey] = _;
        return returnObj;
      };
    }
  }]);

  return Chart;
}();

exports.Chart = Chart;

},{"./d3":49,"./utils":62}],47:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CorrelationMatrix = exports.CorrelationMatrixConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var _legend = require("./legend");

var _scatterplot = require("./scatterplot");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var CorrelationMatrixConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(CorrelationMatrixConfig, _ChartConfig); //show axis guides
  //show tooltip on dot hover


  function CorrelationMatrixConfig(custom) {
    var _this;

    _classCallCheck(this, CorrelationMatrixConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CorrelationMatrixConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'correlation-matrix';
    _this.guides = false;
    _this.showTooltip = true;
    _this.showLegend = true;
    _this.highlightLabels = true;
    _this.rotateLabelsX = true;
    _this.rotateLabelsY = true;
    _this.variables = {
      labels: undefined,
      keys: [],
      //optional array of variable keys
      value: function value(d, variableKey) {
        return parseFloat(d[variableKey]);
      },
      // variable value accessor
      scale: "ordinal"
    };
    _this.correlation = {
      scale: "linear",
      domain: [-1, -0.75, -0.5, 0, 0.5, 0.75, 1],
      range: ["darkblue", "blue", "lightskyblue", "white", "orangered", "crimson", "darkred"],
      value: function value(xValues, yValues) {
        return _statisticsUtils.StatisticsUtils.sampleCorrelation(xValues, yValues);
      }
    };
    _this.cell = {
      shape: "ellipse",
      //possible values: rect, circle, ellipse
      size: undefined,
      sizeMin: 15,
      sizeMax: 250,
      padding: 1
    };
    _this.margin = {
      left: 60,
      right: 50,
      top: 30,
      bottom: 60
    };
    _this.groups = {
      key: null
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return CorrelationMatrixConfig;
}(_chart.ChartConfig);

exports.CorrelationMatrixConfig = CorrelationMatrixConfig;

var CorrelationMatrix =
/*#__PURE__*/
function (_Chart) {
  _inherits(CorrelationMatrix, _Chart);

  function CorrelationMatrix(placeholderSelector, data, config) {
    _classCallCheck(this, CorrelationMatrix);

    return _possibleConstructorReturn(this, _getPrototypeOf(CorrelationMatrix).call(this, placeholderSelector, data, new CorrelationMatrixConfig(config)));
  }

  _createClass(CorrelationMatrix, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(CorrelationMatrix.prototype), "setConfig", this).call(this, new CorrelationMatrixConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(CorrelationMatrix.prototype), "initPlot", this).call(this);

      var self = this;
      var margin = this.config.margin;
      var conf = this.config;
      this.plot.x = {};
      this.plot.correlation = {
        matrix: undefined,
        cells: undefined,
        color: {},
        shape: {}
      };
      this.setupVariables();
      var width = conf.width;
      var placeholderNode = this.getBaseContainerNode();
      this.plot.placeholderNode = placeholderNode;
      var parentWidth = placeholderNode.getBoundingClientRect().width;

      if (width) {
        if (!this.plot.cellSize) {
          this.plot.cellSize = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (width - margin.left - margin.right) / this.plot.variables.length));
        }
      } else {
        this.plot.cellSize = this.config.cell.size;

        if (!this.plot.cellSize) {
          this.plot.cellSize = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (parentWidth - margin.left - margin.right) / this.plot.variables.length));
        }

        width = this.plot.cellSize * this.plot.variables.length + margin.left + margin.right;
      }

      var height = width;

      if (!height) {
        height = placeholderNode.getBoundingClientRect().height;
      }

      this.plot.width = width - margin.left - margin.right;
      this.plot.height = this.plot.width;
      this.setupVariablesScales();
      this.setupCorrelationScales();
      this.setupCorrelationMatrix();
      return this;
    }
  }, {
    key: "setupVariablesScales",
    value: function setupVariablesScales() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.variables;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = conf.value;
      x.scale = d3.scaleBand().range([plot.width, 0]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };
    }
  }, {
    key: "setupCorrelationScales",
    value: function setupCorrelationScales() {
      var plot = this.plot;
      var corrConf = this.config.correlation;
      plot.correlation.color.scale = _utils.Utils.createScale(corrConf.scale).domain(corrConf.domain).range(corrConf.range);
      var shape = plot.correlation.shape = {};
      var cellConf = this.config.cell;
      shape.type = cellConf.shape;
      var shapeSize = plot.cellSize - cellConf.padding * 2;

      if (shape.type == 'circle') {
        var radiusMax = shapeSize / 2;
        shape.radiusScale = d3.scaleLinear().domain([0, 1]).range([2, radiusMax]);

        shape.radius = function (c) {
          return shape.radiusScale(Math.abs(c.value));
        };
      } else if (shape.type == 'ellipse') {
        var radiusMax = shapeSize / 2;
        shape.radiusScale = d3.scaleLinear().domain([0, 1]).range([radiusMax, 2]);

        shape.radiusX = function (c) {
          return shape.radiusScale(Math.abs(c.value));
        };

        shape.radiusY = radiusMax;

        shape.rotateVal = function (v) {
          if (v == 0) return "0";
          if (v < 0) return "-45";
          return "45";
        };
      } else if (shape.type == 'rect') {
        shape.size = shapeSize;
      }
    }
  }, {
    key: "setupVariables",
    value: function setupVariables() {
      var variablesConf = this.config.variables;
      var data = this.data;
      var plot = this.plot;
      plot.domainByVariable = {};
      plot.variables = variablesConf.keys;

      if (!plot.variables || !plot.variables.length) {
        plot.variables = _utils.Utils.inferVariables(data, this.config.groups.key, this.config.includeInPlot);
      }

      plot.labels = [];
      plot.labelByVariable = {};
      plot.variables.forEach(function (variableKey, index) {
        plot.domainByVariable[variableKey] = d3.extent(data, function (d) {
          return variablesConf.value(d, variableKey);
        });
        var label = variableKey;

        if (variablesConf.labels && variablesConf.labels.length > index) {
          label = variablesConf.labels[index];
        }

        plot.labels.push(label);
        plot.labelByVariable[variableKey] = label;
      }); // console.log(plot.labelByVariable);
    }
  }, {
    key: "setupCorrelationMatrix",
    value: function setupCorrelationMatrix() {
      var self = this;
      var data = this.data;
      var matrix = this.plot.correlation.matrix = [];
      var matrixCells = this.plot.correlation.matrix.cells = [];
      var plot = this.plot;
      var variableToValues = {};
      plot.variables.forEach(function (v, i) {
        variableToValues[v] = data.map(function (d) {
          return plot.x.value(d, v);
        });
      });
      plot.variables.forEach(function (v1, i) {
        var row = [];
        matrix.push(row);
        plot.variables.forEach(function (v2, j) {
          var corr = 1;

          if (v1 != v2) {
            corr = self.config.correlation.value(variableToValues[v1], variableToValues[v2]);
          }

          var cell = {
            rowVar: v1,
            colVar: v2,
            row: i,
            col: j,
            value: corr
          };
          row.push(cell);
          matrixCells.push(cell);
        });
      });
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(CorrelationMatrix.prototype), "update", this).call(this, newData); // this.update


      this.updateCells();
      this.updateVariableLabels();

      if (this.config.showLegend) {
        this.updateLegend();
      }
    }
  }, {
    key: "updateVariableLabels",
    value: function updateVariableLabels() {
      this.plot.labelClass = this.prefixClass("label");
      this.updateAxisX();
      this.updateAxisY();
    }
  }, {
    key: "updateAxisX",
    value: function updateAxisX() {
      var self = this;
      var plot = self.plot;
      var labelClass = plot.labelClass;
      var labelXClass = labelClass + "-x";
      var labels = self.svgG.selectAll("text." + labelXClass).data(plot.variables, function (d, i) {
        return i;
      });
      var labelsMerge = labels.enter().append("text").attr("class", function (d, i) {
        return labelClass + " " + labelXClass + " " + labelXClass + "-" + i;
      }).merge(labels);
      labelsMerge.attr("x", function (d, i) {
        return i * plot.cellSize + plot.cellSize / 2;
      }).attr("y", plot.height).attr("dx", -2).attr("dy", 5).attr("text-anchor", "end") // .attr("dominant-baseline", "hanging")
      .text(function (v) {
        return plot.labelByVariable[v];
      });

      if (this.config.rotateLabelsX) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + (i * plot.cellSize + plot.cellSize / 2) + ", " + plot.height + ")";
        });
      }

      var maxWidth = self.computeXAxisLabelsWidth();
      labelsMerge.each(function (label) {
        _utils.Utils.placeTextWithEllipsisAndTooltip(d3.select(this), label, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });
      labels.exit().remove();
    }
  }, {
    key: "updateAxisY",
    value: function updateAxisY() {
      var self = this;
      var plot = self.plot;
      var labelClass = plot.labelClass;
      var labelYClass = plot.labelClass + "-y";
      var labels = self.svgG.selectAll("text." + labelYClass).data(plot.variables);
      var labelsMerge = labels.enter().append("text").merge(labels);
      labelsMerge.attr("x", 0).attr("y", function (d, i) {
        return i * plot.cellSize + plot.cellSize / 2;
      }).attr("dx", -2).attr("text-anchor", "end").attr("class", function (d, i) {
        return labelClass + " " + labelYClass + " " + labelYClass + "-" + i;
      }) // .attr("dominant-baseline", "hanging")
      .text(function (v) {
        return plot.labelByVariable[v];
      });

      if (this.config.rotateLabelsY) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + 0 + ", " + (i * plot.cellSize + plot.cellSize / 2) + ")";
        }).attr("text-anchor", "end");
      }

      var maxWidth = self.computeYAxisLabelsWidth();
      labelsMerge.each(function (label) {
        _utils.Utils.placeTextWithEllipsisAndTooltip(d3.select(this), label, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });
      labels.exit().remove();
    }
  }, {
    key: "computeYAxisLabelsWidth",
    value: function computeYAxisLabelsWidth() {
      var maxWidth = this.plot.margin.left;

      if (!this.config.rotateLabelsY) {
        return maxWidth;
      }

      maxWidth *= _utils.Utils.SQRT_2;
      var fontSize = 11; //todo check actual font size

      maxWidth -= fontSize / 2;
      return maxWidth;
    }
  }, {
    key: "computeXAxisLabelsWidth",
    value: function computeXAxisLabelsWidth(offset) {
      if (!this.config.rotateLabelsX) {
        return this.plot.cellSize - 2;
      }

      var size = this.plot.margin.bottom;
      size *= _utils.Utils.SQRT_2;
      var fontSize = 11; //todo check actual font size

      size -= fontSize / 2;
      return size;
    }
  }, {
    key: "updateCells",
    value: function updateCells() {
      var self = this;
      var plot = self.plot;
      var cellClass = self.prefixClass("cell");
      var cellShape = plot.correlation.shape.type;
      var cells = self.svgG.selectAll("g." + cellClass).data(plot.correlation.matrix.cells);
      var cellsEnter = cells.enter().append("g").classed(cellClass, true);
      var cellsMerge = cellsEnter.merge(cells);
      cellsMerge.attr("transform", function (c) {
        return "translate(" + (plot.cellSize * c.col + plot.cellSize / 2) + "," + (plot.cellSize * c.row + plot.cellSize / 2) + ")";
      });
      cellsMerge.classed(self.config.cssClassPrefix + "selectable", !!self.scatterPlot);
      var selector = "*:not(.cell-shape-" + cellShape + ")";
      var wrongShapes = cells.selectAll(selector);
      wrongShapes.remove();
      var shapes = cellsMerge.selectOrAppend(cellShape + ".cell-shape-" + cellShape);

      if (plot.correlation.shape.type == 'circle') {
        shapes.attr("r", plot.correlation.shape.radius).attr("cx", 0).attr("cy", 0);
      }

      if (plot.correlation.shape.type == 'ellipse') {
        // cells.attr("transform", c=> "translate(300,150) rotate("+plot.correlation.shape.rotateVal(c.value)+")");
        shapes.attr("rx", plot.correlation.shape.radiusX).attr("ry", plot.correlation.shape.radiusY).attr("cx", 0).attr("cy", 0).attr("transform", function (c) {
          return "rotate(" + plot.correlation.shape.rotateVal(c.value) + ")";
        });
      }

      if (plot.correlation.shape.type == 'rect') {
        shapes.attr("width", plot.correlation.shape.size).attr("height", plot.correlation.shape.size).attr("x", -plot.cellSize / 2).attr("y", -plot.cellSize / 2);
      }

      shapes.style("fill", function (c) {
        return plot.correlation.color.scale(c.value);
      });
      var mouseoverCallbacks = [];
      var mouseoutCallbacks = [];

      if (plot.tooltip) {
        mouseoverCallbacks.push(function (c) {
          var html = c.value;
          self.showTooltip(html);
        });
        mouseoutCallbacks.push(function (c) {
          self.hideTooltip();
        });
      }

      if (self.config.highlightLabels) {
        var highlightClass = self.config.cssClassPrefix + "highlight";

        var xLabelClass = function xLabelClass(c) {
          return plot.labelClass + "-x-" + c.col;
        };

        var yLabelClass = function yLabelClass(c) {
          return plot.labelClass + "-y-" + c.row;
        };

        mouseoverCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, true);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, true);
        });
        mouseoutCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, false);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, false);
        });
      }

      cellsMerge.on("mouseover", function (c) {
        mouseoverCallbacks.forEach(function (callback) {
          return callback(c);
        });
      }).on("mouseout", function (c) {
        mouseoutCallbacks.forEach(function (callback) {
          return callback(c);
        });
      });
      cellsMerge.on("click", function (c) {
        self.trigger("cell-selected", c);
      });
      cells.exit().remove();
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var plot = this.plot;
      var legendX = this.plot.width + 10;
      var legendY = 0;
      var barWidth = 10;
      var barHeight = this.plot.height - 2;
      var scale = plot.correlation.color.scale;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY).linearGradientBar(barWidth, barHeight);
    }
  }, {
    key: "attachScatterPlot",
    value: function attachScatterPlot(containerSelector, config) {
      var _this2 = this;

      var self = this;
      config = config || {};
      var scatterPlotConfig = {
        height: self.plot.height + self.config.margin.top + self.config.margin.bottom,
        width: self.plot.height + self.config.margin.top + self.config.margin.bottom,
        groups: {
          key: self.config.groups.key,
          label: self.config.groups.label
        },
        guides: true,
        showLegend: false
      };
      self.scatterPlot = true;
      scatterPlotConfig = _utils.Utils.deepExtend(scatterPlotConfig, config);
      this.update();
      this.on("cell-selected", function (c) {
        scatterPlotConfig.x = {
          key: c.rowVar,
          label: self.plot.labelByVariable[c.rowVar]
        };
        scatterPlotConfig.y = {
          key: c.colVar,
          label: self.plot.labelByVariable[c.colVar]
        };

        if (self.scatterPlot && self.scatterPlot !== true) {
          self.scatterPlot.setConfig(scatterPlotConfig).init();
        } else {
          self.scatterPlot = new _scatterplot.ScatterPlot(containerSelector, self.data, scatterPlotConfig);

          _this2.attach("ScatterPlot", self.scatterPlot);
        }
      });
    }
  }]);

  return CorrelationMatrix;
}(_chart.Chart);

exports.CorrelationMatrix = CorrelationMatrix;

},{"./chart":46,"./d3":49,"./legend":55,"./scatterplot":59,"./statistics-utils":61,"./utils":62}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.D3Extensions = void 0;

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var D3Extensions =
/*#__PURE__*/
function () {
  function D3Extensions() {
    _classCallCheck(this, D3Extensions);
  }

  _createClass(D3Extensions, null, [{
    key: "extend",
    value: function extend() {
      d3.selection.prototype.enter.prototype.insertSelector = d3.selection.prototype.insertSelector = function (selector, before) {
        return D3Extensions.insertSelector(this, selector, before);
      };

      d3.selection.prototype.enter.prototype.appendSelector = d3.selection.prototype.appendSelector = function (selector) {
        return D3Extensions.appendSelector(this, selector);
      };

      d3.selection.prototype.enter.prototype.selectOrAppend = d3.selection.prototype.selectOrAppend = function (selector) {
        return D3Extensions.selectOrAppend(this, selector);
      };

      d3.selection.prototype.enter.prototype.selectOrInsert = d3.selection.prototype.selectOrInsert = function (selector, before) {
        return D3Extensions.selectOrInsert(this, selector, before);
      };
    }
  }, {
    key: "insertOrAppendSelector",
    value: function insertOrAppendSelector(parent, selector, operation, before) {
      var selectorParts = selector.split(/([\.\#])/);
      var element = parent[operation](selectorParts.shift(), before); //":first-child"

      while (selectorParts.length > 1) {
        var selectorModifier = selectorParts.shift();
        var selectorItem = selectorParts.shift();

        if (selectorModifier === ".") {
          element = element.classed(selectorItem, true);
        } else if (selectorModifier === "#") {
          element = element.attr('id', selectorItem);
        }
      }

      return element;
    }
  }, {
    key: "insertSelector",
    value: function insertSelector(parent, selector, before) {
      return D3Extensions.insertOrAppendSelector(parent, selector, "insert", before);
    }
  }, {
    key: "appendSelector",
    value: function appendSelector(parent, selector) {
      return D3Extensions.insertOrAppendSelector(parent, selector, "append");
    }
  }, {
    key: "selectOrAppend",
    value: function selectOrAppend(parent, selector, element) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        if (element) {
          return parent.append(element);
        }

        return D3Extensions.appendSelector(parent, selector);
      }

      return selection;
    }
  }, {
    key: "selectOrInsert",
    value: function selectOrInsert(parent, selector, before) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        return D3Extensions.insertSelector(parent, selector, before);
      }

      return selection;
    }
  }]);

  return D3Extensions;
}();

exports.D3Extensions = D3Extensions;

},{"./d3":49}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3Dispatch = require("d3-dispatch");

Object.keys(_d3Dispatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Dispatch[key];
    }
  });
});

var _d3Scale = require("d3-scale");

Object.keys(_d3Scale).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Scale[key];
    }
  });
});

var _d3Selection = require("d3-selection");

Object.keys(_d3Selection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Selection[key];
    }
  });
});

var _d3Shape = require("d3-shape");

Object.keys(_d3Shape).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Shape[key];
    }
  });
});

var _d3Drag = require("d3-drag");

Object.keys(_d3Drag).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Drag[key];
    }
  });
});

var _d3Brush = require("d3-brush");

Object.keys(_d3Brush).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Brush[key];
    }
  });
});

var _d3Array = require("d3-array");

Object.keys(_d3Array).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Array[key];
    }
  });
});

var _d3Hierarchy = require("d3-hierarchy");

Object.keys(_d3Hierarchy).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Hierarchy[key];
    }
  });
});

var _d3TimeFormat = require("d3-time-format");

Object.keys(_d3TimeFormat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3TimeFormat[key];
    }
  });
});

var _d3Collection = require("d3-collection");

Object.keys(_d3Collection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Collection[key];
    }
  });
});

var _d3Ease = require("d3-ease");

Object.keys(_d3Ease).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Ease[key];
    }
  });
});

var _d3Axis = require("d3-axis");

Object.keys(_d3Axis).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _d3Axis[key];
    }
  });
});

},{"d3-array":1,"d3-axis":2,"d3-brush":3,"d3-collection":4,"d3-dispatch":6,"d3-drag":7,"d3-ease":8,"d3-hierarchy":10,"d3-scale":13,"d3-selection":14,"d3-shape":15,"d3-time-format":22}],50:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DivergingStackedBarChart = exports.DivergingStackedBarChartConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var DivergingStackedBarChartConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(DivergingStackedBarChartConfig, _ChartConfig); // string or function returning color's value for color scale


  function DivergingStackedBarChartConfig(custom) {
    var _this;

    _classCallCheck(this, DivergingStackedBarChartConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DivergingStackedBarChartConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'diverging-stacked-bar-chart';
    _this.showTooltip = true;
    _this.showLegend = true;
    _this.forceLegend = false;
    _this.legend = {
      width: 80,
      margin: 10,
      shapeWidth: 20
    };
    _this.x = {
      // X axis config
      title: '',
      // axis label
      value: function value(d) {
        return d.values;
      },
      // x value accessor
      guides: true,
      //show axis guides
      orient: 'top',
      scale: "linear",
      domainMargin: 0.02
    };
    _this.y = {
      // Y axis config
      title: '',
      value: function value(d) {
        return d.key;
      },
      // y value accessor
      scale: "ordinal",
      orient: 'left',
      guides: true //show axis guides

    };
    _this.transition = true;
    _this.color = undefined;
    _this.d3ColorCategory = 'category10';
    _this.showBarValues = true;
    _this.colorRange = undefined;
    _this.categoryNames = undefined;
    _this.middleValue = 0;

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return DivergingStackedBarChartConfig;
}(_chart.ChartConfig);

exports.DivergingStackedBarChartConfig = DivergingStackedBarChartConfig;

var DivergingStackedBarChart =
/*#__PURE__*/
function (_Chart) {
  _inherits(DivergingStackedBarChart, _Chart);

  function DivergingStackedBarChart(placeholderSelector, data, config) {
    _classCallCheck(this, DivergingStackedBarChart);

    return _possibleConstructorReturn(this, _getPrototypeOf(DivergingStackedBarChart).call(this, placeholderSelector, data, new DivergingStackedBarChartConfig(config)));
  }

  _createClass(DivergingStackedBarChart, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "setConfig", this).call(this, new DivergingStackedBarChartConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "initPlot", this).call(this);

      this.plot.showLegend = this.config.showLegend;

      if (this.plot.showLegend) {
        this.plot.margin.right = this.config.margin.right + this.config.legend.width + this.config.legend.margin * 2;
      }

      _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "computePlotSize", this).call(this);

      this.plot.x = {};
      this.plot.y = {};
      this.plot.data = this.getDataToPlot();
      this.setupY();
      this.setupX();
      this.setupColor();
    }
  }, {
    key: "getDataToPlot",
    value: function getDataToPlot() {
      return this.data;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var _this2 = this;

      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;

      x.value = function (d) {
        return conf.value.call(_this2.config, d);
      };

      x.scale = _utils.Utils.createScale(conf.scale).rangeRound([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.guides) {
        x.axis.tickSize(-plot.height);
      }

      var data = this.plot.data;
      plot.categoryNames = this.config.categoryNames;
      plot.neutralIndex = Math.floor(plot.categoryNames.length / 2);
      plot.rows = data.map(function (d) {
        var originalValues = x.value(d);
        var x0 = _this2.config.middleValue - d3.sum(originalValues.map(function (v, i) {
          return i < plot.neutralIndex ? v : 0;
        }));
        if (plot.categoryNames.length & 1) x0 += -1 * originalValues[plot.neutralIndex] / 2;
        var values = originalValues.map(function (v, i) {
          return i < plot.neutralIndex ? _this2.config.middleValue - v : _this2.config.middleValue + v;
        });
        var total = d3.sum(originalValues);
        var categories = plot.categoryNames;

        if (d.categories) {
          categories = d.categories.map(function (catIndex, i) {
            return plot.categoryNames[catIndex];
          });
        }

        return {
          datum: d,
          originalValues: originalValues,
          values: values,
          categories: [],
          min: x0,
          max: x0 + total,
          total: total,
          boxes: values.map(function (v, i) {
            return {
              name: categories[i],
              x0: x0,
              x1: x0 += originalValues[i],
              originalValue: originalValues[i]
            };
          })
        };
      });
      var domain;

      if (!data || !data.length) {
        domain = [];
      } else {
        var _ref;

        domain = d3.extent((_ref = []).concat.apply(_ref, _toConsumableArray(plot.rows.map(function (b) {
          return [b.min, b.max];
        }))));
        var margin = (domain[1] - domain[0]) * conf.domainMargin || conf.domainMargin * domain[0];
        domain[0] -= margin;
        domain[1] += margin;
      }

      plot.x.scale.domain(domain);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var _this3 = this;

      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;

      y.value = function (d) {
        return conf.value.call(_this3.config, d);
      };

      y.scale = d3.scaleBand().range([0, plot.height]).padding(.3);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (conf.ticks) {
        y.axis.ticks(conf.ticks);
      }

      if (conf.guides) {
        y.axis.tickSize(-plot.width);
      }

      this.setupYDomain();
    }
  }, {
    key: "setupYDomain",
    value: function setupYDomain() {
      var plot = this.plot;
      var data = this.plot.data;
      var c = this.config;
      var domain = data.map(plot.y.value);
      plot.y.scale.domain(domain);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));

      if (axisConf.orient === 'bottom') {
        axis.attr("transform", "translate(0," + plot.height + ")");
      }

      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      var titleY = axisConf.orient === 'bottom' ? plot.margin.bottom : 0;
      var titleDY = axisConf.orient === 'bottom' ? "-1em" : "-1.5em";
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + titleY + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", titleDY).style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (axisConf.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawBars",
    value: function drawBars() {
      var self = this,
          plot = self.plot,
          config = self.config;
      var rowClass = self.prefixClass("row");
      var rows = self.svgG.selectAll("." + rowClass).data(plot.rows);
      var rowEnter = rows.enter().appendSelector("g." + rowClass);
      var rowMerge = rowEnter.merge(rows).attr("transform", function (d) {
        return "translate(0," + plot.y.map(d.datum) + ")";
      });
      rows.exit().remove();
      var barClass = self.prefixClass("bar");
      var bars = rowMerge.selectAll("g." + barClass).data(function (d) {
        return d.boxes;
      });
      bars.exit().remove();
      var barsEnter = bars.enter().append("g").attr("class", barClass);
      barsEnter.append("rect");

      if (config.showBarValues) {
        barsEnter.append("text");
      }

      var barsM = barsEnter.merge(bars);
      barsM.select("rect").attr("height", plot.y.scale.bandwidth()).attr("x", function (d) {
        return plot.x.scale(d.x0);
      }).attr("width", function (d) {
        return plot.x.scale(d.x1) - plot.x.scale(d.x0);
      }).style("fill", function (d, i) {
        return plot.color(d.name, i);
      });
      var textM = barsM.select("text");

      if (config.showBarValues) {
        textM.attr("x", function (d) {
          return plot.x.scale(d.x0);
        }).attr("y", plot.y.scale.bandwidth() / 2).attr("dy", "0.5em").attr("dx", function (d) {
          return (plot.x.scale(d.x1) - plot.x.scale(d.x0)) / 2;
        }).style("text-anchor", "middle").text(function (d) {
          return d.originalValue !== 0 && d.x1 - d.x0 > 0.04 ? d.originalValue : "";
        });
      } else {
        textM.remove();
      }

      self.svgG.selectOrAppend("line." + self.prefixClass("middle-line")).attr("x1", plot.x.scale(self.config.middleValue)).attr("y1", 0).attr("x2", plot.x.scale(self.config.middleValue)).attr("y2", plot.height);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(DivergingStackedBarChart.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawBars();
      this.updateLegend();
      return this;
    }
  }, {
    key: "setupColor",
    value: function setupColor() {
      var self = this;
      var conf = this.config;

      if (conf.d3ColorCategory) {
        var colorSchemeCategory = 'scheme' + _utils.Utils.capitalizeFirstLetter(conf.d3ColorCategory);

        this.plot.colorCategory = d3.scaleOrdinal(d3[colorSchemeCategory]);
      }

      var colorValue = conf.color;

      if (colorValue && typeof colorValue === 'string' || colorValue instanceof String) {
        this.plot.color = colorValue;
      } else if (conf.colorRange) {
        this.plot.color = _utils.Utils.createScale("ordinal").domain(this.plot.categoryNames).range(conf.colorRange);
      } else if (this.plot.colorCategory) {
        self.plot.colorValue = colorValue;
        this.plot.color = this.plot.colorCategory;
      }
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var self = this;
      var plot = this.plot;
      var scale = plot.color;

      if (!scale.domain() || !this.config.forceLegend && scale.domain().length < 2) {
        plot.showLegend = false;
      }

      if (!plot.showLegend) {
        if (plot.legend && plot.legend.container) {
          plot.legend.container.remove();
        }

        return;
      }

      var legendX = this.plot.width + this.config.legend.margin;
      var legendY = this.config.legend.margin;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY);
      plot.legendColor = plot.legend.color().shapeWidth(this.config.legend.shapeWidth).orient('vertical').scale(scale).labelWrap(this.config.legend.width); // .labels(scale.domain().map(v=>plot.groupToLabel[v]));

      plot.legend.container.call(plot.legendColor);
    }
  }]);

  return DivergingStackedBarChart;
}(_chart.Chart);

exports.DivergingStackedBarChart = DivergingStackedBarChart;

},{"./chart":46,"./d3":49,"./legend":55,"./utils":62}],51:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HeatmapTimeSeries = exports.HeatmapTimeSeriesConfig = void 0;

var _chart = require("./chart");

var _heatmap = require("./heatmap");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var HeatmapTimeSeriesConfig =
/*#__PURE__*/
function (_HeatmapConfig) {
  _inherits(HeatmapTimeSeriesConfig, _HeatmapConfig);

  function HeatmapTimeSeriesConfig(custom) {
    var _this;

    _classCallCheck(this, HeatmapTimeSeriesConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HeatmapTimeSeriesConfig).call(this));
    _this.x = {
      fillMissing: false,
      // fill missing values using interval and intervalStep
      interval: undefined,
      //used in filling missing ticks
      intervalStep: 1,
      format: undefined,
      //input data d3 time format
      displayFormat: undefined,
      //d3 time format for display
      intervalToFormats: [//used to guess interval and format
      {
        name: 'year',
        formats: ["%Y"]
      }, {
        name: 'month',
        formats: ["%Y-%m"]
      }, {
        name: 'day',
        formats: ["%Y-%m-%d"]
      }, {
        name: 'hour',
        formats: ['%H', '%Y-%m-%d %H']
      }, {
        name: 'minute',
        formats: ['%H:%M', '%Y-%m-%d %H:%M']
      }, {
        name: 'second',
        formats: ['%H:%M:%S', '%Y-%m-%d %H:%M:%S']
      }],
      sortComparator: function sortComparator(a, b) {
        return _utils.Utils.isString(a) ? a.localeCompare(b) : a - b;
      },
      formatter: undefined
    };
    _this.z = {
      fillMissing: true // fiill missing values with nearest previous value

    };
    _this.legend = {
      formatter: function formatter(v) {
        var suffix = "";

        if (v / 1000000 >= 1) {
          suffix = " M";
          v = Number(v / 1000000).toFixed(3);
        }

        var nf = Intl.NumberFormat();
        return nf.format(v) + suffix;
      }
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return HeatmapTimeSeriesConfig;
}(_heatmap.HeatmapConfig);

exports.HeatmapTimeSeriesConfig = HeatmapTimeSeriesConfig;

var HeatmapTimeSeries =
/*#__PURE__*/
function (_Heatmap) {
  _inherits(HeatmapTimeSeries, _Heatmap);

  function HeatmapTimeSeries(placeholderSelector, data, config) {
    _classCallCheck(this, HeatmapTimeSeries);

    return _possibleConstructorReturn(this, _getPrototypeOf(HeatmapTimeSeries).call(this, placeholderSelector, data, new HeatmapTimeSeriesConfig(config)));
  }

  _createClass(HeatmapTimeSeries, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "setConfig", this).call(this, new HeatmapTimeSeriesConfig(config));
    }
  }, {
    key: "setupValuesBeforeGroupsSort",
    value: function setupValuesBeforeGroupsSort() {
      var _this2 = this;

      this.plot.x.timeFormat = this.config.x.format;

      if (this.config.x.displayFormat && !this.plot.x.timeFormat) {
        this.guessTimeFormat();
      }

      _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "setupValuesBeforeGroupsSort", this).call(this);

      if (!this.config.x.fillMissing) {
        return;
      }

      var self = this;
      this.initTimeFormatAndInterval();
      this.plot.x.intervalStep = this.config.x.intervalStep || 1;
      this.plot.x.timeParser = this.getTimeParser();
      this.plot.x.uniqueValues.sort(this.config.x.sortComparator);
      var prev = null;
      this.plot.x.uniqueValues.forEach(function (x, i) {
        var current = _this2.parseTime(x);

        if (prev === null) {
          prev = current;
          return;
        }

        var next = self.nextTimeTickValue(prev);
        var missing = [];
        var iteration = 0;

        while (self.compareTimeValues(next, current) <= 0) {
          iteration++;

          if (iteration > 100) {
            break;
          }

          var d = {};
          var timeString = self.formatTime(next);
          d[_this2.config.x.key] = timeString;
          self.updateGroups(d, timeString, self.plot.x.groups, self.config.x.groups);
          missing.push(next);
          next = self.nextTimeTickValue(next);
        }

        prev = current;
      });
    }
  }, {
    key: "parseTime",
    value: function parseTime(x) {
      var parser = this.getTimeParser();
      return parser(x);
    }
  }, {
    key: "formatTime",
    value: function formatTime(date) {
      var formatter = this.getTimeFormatter();
      return formatter(date);
    }
  }, {
    key: "formatValueX",
    value: function formatValueX(value) {
      //used only for display
      if (this.config.x.formatter) return this.config.x.formatter.call(this.config, value);

      if (this.config.x.displayFormat) {
        var date = this.parseTime(value);
        return d3.timeFormat(this.config.x.displayFormat)(date);
      }

      if (!this.plot.x.timeFormat) return value;

      if (_utils.Utils.isDate(value)) {
        return this.formatTime(value);
      }

      return value;
    }
  }, {
    key: "compareTimeValues",
    value: function compareTimeValues(a, b) {
      return a - b;
    }
  }, {
    key: "timeValuesEqual",
    value: function timeValuesEqual(a, b) {
      var parser = this.plot.x.timeParser;
      return parser(a) === parser(b);
    }
  }, {
    key: "nextTimeTickValue",
    value: function nextTimeTickValue(t) {
      var interval = 'time' + _utils.Utils.capitalizeFirstLetter(this.plot.x.interval);

      return d3[interval].offset(t, this.plot.x.intervalStep);
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "initPlot", this).call(this);

      if (this.config.z.fillMissing) {
        this.plot.matrix.forEach(function (row, rowIndex) {
          var prevRowValue = undefined;
          row.forEach(function (cell, colIndex) {
            if (cell.value === undefined && prevRowValue !== undefined) {
              cell.value = prevRowValue;
              cell.missing = true;
            }

            prevRowValue = cell.value;
          });
        });
      }
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(HeatmapTimeSeries.prototype), "update", this).call(this, newData);
    }
  }, {
    key: "initTimeFormatAndInterval",
    value: function initTimeFormatAndInterval() {
      this.plot.x.interval = this.config.x.interval;

      if (!this.plot.x.timeFormat) {
        this.guessTimeFormat();
      }

      if (!this.plot.x.interval && this.plot.x.timeFormat) {
        this.guessInterval();
      }
    }
  }, {
    key: "guessTimeFormat",
    value: function guessTimeFormat() {
      var self = this;

      for (var i = 0; i < self.config.x.intervalToFormats.length; i++) {
        var intervalFormat = self.config.x.intervalToFormats[i];
        var format = null;
        var formatMatch = intervalFormat.formats.some(function (f) {
          format = f;
          var parser = d3.timeParse(f);
          return self.plot.x.uniqueValues.every(function (x) {
            return parser(x) !== null;
          });
        });

        if (formatMatch) {
          self.plot.x.timeFormat = format; // console.log('Guessed timeFormat', format);

          if (!self.plot.x.interval) {
            self.plot.x.interval = intervalFormat.name; // console.log('Guessed interval', self.plot.x.interval);
          }

          return;
        }
      }
    }
  }, {
    key: "guessInterval",
    value: function guessInterval() {
      var self = this;

      for (var i = 0; i < self.config.x.intervalToFormats.length; i++) {
        var intervalFormat = self.config.x.intervalToFormats[i];

        if (intervalFormat.formats.indexOf(self.plot.x.timeFormat) >= 0) {
          self.plot.x.interval = intervalFormat.name; // console.log('Guessed interval', self.plot.x.interval);

          return;
        }
      }
    }
  }, {
    key: "getTimeFormatter",
    value: function getTimeFormatter() {
      if (!this.plot.x.timeFormatter) {
        this.plot.x.timeFormatter = d3.timeFormat(this.plot.x.timeFormat);
      }

      return this.plot.x.timeFormatter;
    }
  }, {
    key: "getTimeParser",
    value: function getTimeParser() {
      if (!this.plot.x.timeParser) {
        this.plot.x.timeParser = d3.timeParse(this.plot.x.timeFormat);
      }

      return this.plot.x.timeParser;
    }
  }]);

  return HeatmapTimeSeries;
}(_heatmap.Heatmap);

exports.HeatmapTimeSeries = HeatmapTimeSeries;

},{"./chart":46,"./d3":49,"./heatmap":52,"./statistics-utils":61,"./utils":62}],52:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Heatmap = exports.HeatmapConfig = void 0;

var _chart = require("./chart");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var HeatmapConfig =
/*#__PURE__*/
function (_ChartConfig) {
  _inherits(HeatmapConfig, _ChartConfig); //show tooltip on dot hover


  function HeatmapConfig(custom) {
    var _this;

    _classCallCheck(this, HeatmapConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HeatmapConfig).call(this));
    _this.svgClass = 'odc-heatmap';
    _this.showTooltip = true;
    _this.tooltip = {
      noDataText: "N/A"
    };
    _this.showLegend = true;
    _this.legend = {
      width: 30,
      rotateLabels: false,
      decimalPlaces: undefined,
      formatter: function formatter(v) {
        return _this.legend.decimalPlaces === undefined ? v : Number(v).toFixed(_this.legend.decimalPlaces);
      }
    };
    _this.highlightLabels = true;
    _this.x = {
      // X axis config
      title: '',
      // axis title
      key: 0,
      value: function value(d) {
        return d[_this.x.key];
      },
      // x value accessor
      rotateLabels: true,
      sortLabels: false,
      sortComparator: function sortComparator(a, b) {
        return _utils.Utils.isNumber(a) ? a - b : a.localeCompare(b);
      },
      groups: {
        keys: [],
        labels: [],
        value: function value(d, key) {
          return d[key];
        },
        overlap: {
          top: 20,
          bottom: 20
        }
      },
      formatter: undefined // value formatter function

    };
    _this.y = {
      // Y axis config
      title: '',
      // axis title,
      rotateLabels: true,
      key: 1,
      value: function value(d) {
        return d[_this.y.key];
      },
      // y value accessor
      sortLabels: false,
      sortComparator: function sortComparator(a, b) {
        return _utils.Utils.isNumber(b) ? b - a : b.localeCompare(a);
      },
      groups: {
        keys: [],
        labels: [],
        value: function value(d, key) {
          return d[key];
        },
        overlap: {
          left: 20,
          right: 20
        }
      },
      formatter: undefined // value formatter function

    };
    _this.z = {
      key: 2,
      value: function value(d) {
        return d[_this.z.key];
      },
      notAvailableValue: function notAvailableValue(v) {
        return v === null || v === undefined;
      },
      decimalPlaces: undefined,
      formatter: function formatter(v) {
        return _this.z.decimalPlaces === undefined ? v : Number(v).toFixed(_this.z.decimalPlaces);
      } // value formatter function

    };
    _this.color = {
      noDataColor: "white",
      scale: "linear",
      reverseScale: false,
      range: ["darkblue", "lightskyblue", "orange", "crimson", "darkred"]
    };
    _this.cell = {
      width: undefined,
      height: undefined,
      sizeMin: 15,
      sizeMax: 250,
      padding: 0
    };
    _this.margin = {
      left: 60,
      right: 50,
      top: 30,
      bottom: 80
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return HeatmapConfig;
}(_chart.ChartConfig); //TODO refactor


exports.HeatmapConfig = HeatmapConfig;

var Heatmap =
/*#__PURE__*/
function (_Chart) {
  _inherits(Heatmap, _Chart);

  function Heatmap(placeholderSelector, data, config) {
    _classCallCheck(this, Heatmap);

    return _possibleConstructorReturn(this, _getPrototypeOf(Heatmap).call(this, placeholderSelector, data, new HeatmapConfig(config)));
  }

  _createClass(Heatmap, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(Heatmap.prototype), "setConfig", this).call(this, new HeatmapConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(Heatmap.prototype), "initPlot", this).call(this);

      var self = this;
      var margin = this.config.margin;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.plot.z = {
        matrixes: undefined,
        cells: undefined,
        color: {},
        shape: {}
      };
      this.setupValues();
      this.buildCells();
      var titleRectWidth = 6;
      this.plot.x.overlap = {
        top: 0,
        bottom: 0
      };

      if (this.plot.groupByX) {
        var depth = self.config.x.groups.keys.length;
        var allTitlesWidth = depth * titleRectWidth;
        this.plot.x.overlap.bottom = self.config.x.groups.overlap.bottom;
        this.plot.x.overlap.top = self.config.x.groups.overlap.top + allTitlesWidth;
        this.plot.margin.top = this.plot.margin.top + conf.x.groups.overlap.top;
        this.plot.margin.bottom = this.plot.margin.bottom + conf.x.groups.overlap.bottom;
      }

      this.plot.y.overlap = {
        left: 0,
        right: 0
      };

      if (this.plot.groupByY) {
        var _depth = self.config.y.groups.keys.length;

        var _allTitlesWidth = _depth * titleRectWidth;

        this.plot.y.overlap.right = self.config.y.groups.overlap.left + _allTitlesWidth;
        this.plot.y.overlap.left = self.config.y.groups.overlap.left;
        this.plot.margin.left = this.plot.margin.left + this.plot.y.overlap.left;
        this.plot.margin.right = this.plot.margin.right + this.plot.y.overlap.right;
      }

      this.plot.showLegend = conf.showLegend;

      if (this.plot.showLegend) {
        this.plot.margin.right += conf.legend.width;
      }

      this.computePlotSize();
      this.setupZScale();
      return this;
    }
  }, {
    key: "setupValues",
    value: function setupValues() {
      var _this2 = this;

      var self = this;
      var config = self.config;
      var x = self.plot.x;
      var y = self.plot.y;
      var z = self.plot.z;

      x.value = function (d) {
        return config.x.value.call(config, d);
      };

      y.value = function (d) {
        return config.y.value.call(config, d);
      };

      z.value = function (d) {
        return config.z.value.call(config, d);
      };

      x.uniqueValues = [];
      y.uniqueValues = [];
      self.plot.groupByY = !!config.y.groups.keys.length;
      self.plot.groupByX = !!config.x.groups.keys.length;
      y.groups = {
        key: undefined,
        label: '',
        values: [],
        children: null,
        level: 0,
        index: 0,
        lastIndex: 0
      };
      x.groups = {
        key: undefined,
        label: '',
        values: [],
        children: null,
        level: 0,
        index: 0,
        lastIndex: 0
      };
      var valueMap = {};
      var minZ = undefined;
      var maxZ = undefined;
      this.data.forEach(function (d) {
        var xVal = x.value(d);
        var yVal = y.value(d);
        var zValRaw = z.value(d);
        var zVal = config.z.notAvailableValue(zValRaw) ? undefined : parseFloat(zValRaw);

        if (x.uniqueValues.indexOf(xVal) === -1) {
          x.uniqueValues.push(xVal);
        }

        if (y.uniqueValues.indexOf(yVal) === -1) {
          y.uniqueValues.push(yVal);
        }

        var groupY = y.groups;

        if (self.plot.groupByY) {
          groupY = _this2.updateGroups(d, yVal, y.groups, config.y.groups);
        }

        var groupX = x.groups;

        if (self.plot.groupByX) {
          groupX = _this2.updateGroups(d, xVal, x.groups, config.x.groups);
        }

        if (!valueMap[groupY.index]) {
          valueMap[groupY.index] = {};
        }

        if (!valueMap[groupY.index][groupX.index]) {
          valueMap[groupY.index][groupX.index] = {};
        }

        if (!valueMap[groupY.index][groupX.index][yVal]) {
          valueMap[groupY.index][groupX.index][yVal] = {};
        }

        valueMap[groupY.index][groupX.index][yVal][xVal] = zVal;

        if (minZ === undefined || zVal < minZ) {
          minZ = zVal;
        }

        if (maxZ === undefined || zVal > maxZ) {
          maxZ = zVal;
        }
      });
      self.plot.valueMap = valueMap;

      if (!self.plot.groupByX) {
        x.groups.values = x.uniqueValues;
      }

      if (!self.plot.groupByY) {
        y.groups.values = y.uniqueValues;
      }

      this.setupValuesBeforeGroupsSort();
      x.gaps = [];
      x.totalValuesCount = 0;
      x.allValuesList = [];
      this.sortGroups(x, x.groups, config.x);
      y.gaps = [];
      y.totalValuesCount = 0;
      y.allValuesList = [];
      this.sortGroups(y, y.groups, config.y);
      z.min = minZ;
      z.max = maxZ;
    }
  }, {
    key: "setupValuesBeforeGroupsSort",
    value: function setupValuesBeforeGroupsSort() {}
  }, {
    key: "buildCells",
    value: function buildCells() {
      var self = this;
      var x = self.plot.x;
      var y = self.plot.y;
      var z = self.plot.z;
      var valueMap = self.plot.valueMap;
      var matrixCells = self.plot.cells = [];
      var matrix = self.plot.matrix = [];
      y.allValuesList.forEach(function (v1, i) {
        var row = [];
        matrix.push(row);
        x.allValuesList.forEach(function (v2, j) {
          var zVal = undefined;

          try {
            zVal = valueMap[v1.group.index][v2.group.index][v1.val][v2.val];
          } catch (e) {}

          var cell = {
            rowVar: v1,
            colVar: v2,
            row: i,
            col: j,
            value: zVal
          };
          row.push(cell);
          matrixCells.push(cell);
        });
      });
    }
  }, {
    key: "updateGroups",
    value: function updateGroups(d, axisVal, rootGroup, axisGroupsConfig) {
      var config = this.config;
      var currentGroup = rootGroup;
      axisGroupsConfig.keys.forEach(function (groupKey, groupKeyIndex) {
        currentGroup.key = groupKey;

        if (!currentGroup.children) {
          currentGroup.children = {};
        }

        var groupingValue = axisGroupsConfig.value.call(config, d, groupKey);

        if (!currentGroup.children.hasOwnProperty(groupingValue)) {
          rootGroup.lastIndex++;
          currentGroup.children[groupingValue] = {
            values: [],
            children: null,
            groupingValue: groupingValue,
            level: currentGroup.level + 1,
            index: rootGroup.lastIndex,
            key: groupKey
          };
        }

        currentGroup = currentGroup.children[groupingValue];
      });

      if (currentGroup.values.indexOf(axisVal) === -1) {
        currentGroup.values.push(axisVal);
      }

      return currentGroup;
    }
  }, {
    key: "sortGroups",
    value: function sortGroups(axis, group, axisConfig, gaps) {
      if (axisConfig.groups.labels && axisConfig.groups.labels.length > group.level) {
        group.label = axisConfig.groups.labels[group.level];
      } else {
        group.label = group.key;
      }

      if (!gaps) {
        gaps = [0];
      }

      if (gaps.length <= group.level) {
        gaps.push(0);
      }

      group.allValuesCount = group.allValuesCount || 0;
      group.allValuesBeforeCount = group.allValuesBeforeCount || 0;
      group.gaps = gaps.slice();
      group.gapsBefore = gaps.slice();
      group.gapsSize = Heatmap.computeGapsSize(group.gaps);
      group.gapsBeforeSize = group.gapsSize;

      if (group.values) {
        if (axisConfig.sortLabels) {
          group.values.sort(axisConfig.sortComparator);
        }

        group.values.forEach(function (v) {
          return axis.allValuesList.push({
            val: v,
            group: group
          });
        });
        group.allValuesBeforeCount = axis.totalValuesCount;
        axis.totalValuesCount += group.values.length;
        group.allValuesCount += group.values.length;
      }

      group.childrenList = [];

      if (group.children) {
        var childrenCount = 0;

        for (var childProp in group.children) {
          if (group.children.hasOwnProperty(childProp)) {
            var child = group.children[childProp];
            group.childrenList.push(child);
            childrenCount++;
            this.sortGroups(axis, child, axisConfig, gaps);
            group.allValuesCount += child.allValuesCount;
            gaps[group.level] += 1;
          }
        }

        if (gaps && childrenCount > 1) {
          gaps[group.level] -= 1;
        }

        group.gapsInside = [];
        gaps.forEach(function (d, i) {
          group.gapsInside.push(d - (group.gapsBefore[i] || 0));
        });
        group.gapsInsideSize = Heatmap.computeGapsSize(group.gapsInside);

        if (axis.gaps.length < gaps.length) {
          axis.gaps = gaps;
        }
      }
    }
  }, {
    key: "computeYAxisLabelsWidth",
    value: function computeYAxisLabelsWidth(offset) {
      var maxWidth = this.plot.margin.left;

      if (this.config.y.title) {
        maxWidth -= 15;
      }

      if (offset && offset.x) {
        maxWidth += offset.x;
      }

      if (this.config.y.rotateLabels) {
        maxWidth *= _utils.Utils.SQRT_2;
        var fontSize = 11; //todo check actual font size

        maxWidth -= fontSize / 2;
      }

      return maxWidth;
    }
  }, {
    key: "computeXAxisLabelsWidth",
    value: function computeXAxisLabelsWidth(offset) {
      if (!this.config.x.rotateLabels) {
        return this.plot.cellWidth - 2;
      }

      var size = this.plot.margin.bottom;

      if (this.config.x.title) {
        size -= 15;
      }

      if (offset && offset.y) {
        size -= offset.y;
      }

      size *= _utils.Utils.SQRT_2;
      var fontSize = 11; //todo check actual font size

      size -= fontSize / 2;
      return size;
    }
  }, {
    key: "computePlotSize",
    value: function computePlotSize() {
      var plot = this.plot;
      var conf = this.config;
      var margin = plot.margin;

      var availableWidth = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), this.plot.margin);

      var availableHeight = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), this.plot.margin);

      var width = availableWidth;
      var height = availableHeight;
      var xGapsSize = Heatmap.computeGapsSize(plot.x.gaps);
      var computedCellWidth = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (availableWidth - xGapsSize) / this.plot.x.totalValuesCount));

      if (this.config.width) {
        if (!this.config.cell.width) {
          this.plot.cellWidth = computedCellWidth;
        }
      } else {
        this.plot.cellWidth = this.config.cell.width;

        if (!this.plot.cellWidth) {
          this.plot.cellWidth = computedCellWidth;
        }
      }

      width = this.plot.cellWidth * this.plot.x.totalValuesCount + margin.left + margin.right + xGapsSize;
      var yGapsSize = Heatmap.computeGapsSize(plot.y.gaps);
      var computedCellHeight = Math.max(conf.cell.sizeMin, Math.min(conf.cell.sizeMax, (availableHeight - yGapsSize) / this.plot.y.totalValuesCount));

      if (this.config.height) {
        if (!this.config.cell.height) {
          this.plot.cellHeight = computedCellHeight;
        }
      } else {
        this.plot.cellHeight = this.config.cell.height;

        if (!this.plot.cellHeight) {
          this.plot.cellHeight = computedCellHeight;
        }
      }

      height = this.plot.cellHeight * this.plot.y.totalValuesCount + margin.top + margin.bottom + yGapsSize;
      this.plot.width = width - margin.left - margin.right;
      this.plot.height = height - margin.top - margin.bottom;
    }
  }, {
    key: "setupZScale",
    value: function setupZScale() {
      var self = this;
      var config = self.config;
      var z = self.plot.z;
      var range = config.color.range;
      var extent = z.max - z.min;
      var scale;
      z.domain = [];

      if (config.color.scale == "pow") {
        var exponent = 10;
        range.forEach(function (c, i) {
          var v = z.max - extent / Math.pow(10, i);
          z.domain.push(v);
        });
        scale = d3.scalePow().exponent(exponent);
      } else if (config.color.scale == "log") {
        range.forEach(function (c, i) {
          var v = z.min + extent / Math.pow(10, i);
          z.domain.unshift(v);
        });
        scale = d3.scaleLog();
      } else {
        range.forEach(function (c, i) {
          var v = z.min + extent * (i / (range.length - 1));
          z.domain.push(v);
        });
        scale = _utils.Utils.createScale(config.color.scale);
      }

      z.domain[0] = z.min; //removing unnecessary floating points

      z.domain[z.domain.length - 1] = z.max; //removing unnecessary floating points
      // console.log(z.domain);

      if (config.color.reverseScale) {
        z.domain.reverse();
      }

      var plot = this.plot; // console.log(range);

      plot.z.color.scale = scale.domain(z.domain).range(range);
      var shape = plot.z.shape = {};
      var cellConf = this.config.cell;
      shape.type = "rect";
      plot.z.shape.width = plot.cellWidth - cellConf.padding * 2;
      plot.z.shape.height = plot.cellHeight - cellConf.padding * 2;
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(Heatmap.prototype), "update", this).call(this, newData);

      if (this.plot.groupByY) {
        this.drawGroupsY(this.plot.y.groups, this.svgG);
      }

      if (this.plot.groupByX) {
        this.drawGroupsX(this.plot.x.groups, this.svgG);
      }

      this.updateCells(); // this.updateVariableLabels();

      this.updateAxisX();
      this.updateAxisY();

      if (this.config.showLegend) {
        this.updateLegend();
      }

      this.updateAxisTitles();
    }
  }, {
    key: "updateAxisTitles",
    value: function updateAxisTitles() {
      var self = this;
      var plot = self.plot;
    }
  }, {
    key: "updateAxisX",
    value: function updateAxisX() {
      var self = this;
      var plot = self.plot;
      var labelClass = self.prefixClass("label");
      var labelXClass = labelClass + "-x";
      var labelYClass = labelClass + "-y";
      plot.labelClass = labelClass;
      var offsetX = {
        x: 0,
        y: 0
      };
      var gapSize = Heatmap.computeGapSize(0);

      if (plot.groupByX) {
        var overlap = self.config.x.groups.overlap;
        offsetX.x = gapSize / 2;
        offsetX.y = overlap.bottom + gapSize / 2 + 6;
      } else if (plot.groupByY) {
        offsetX.y = gapSize;
      }

      var labels = self.svgG.selectAll("text." + labelXClass).data(plot.x.allValuesList, function (d, i) {
        return i;
      });
      var labelsMerge = labels.enter().append("text").attr("class", function (d, i) {
        return labelClass + " " + labelXClass + " " + labelXClass + "-" + i;
      }).merge(labels);
      labelsMerge.attr("x", function (d, i) {
        return i * plot.cellWidth + plot.cellWidth / 2 + d.group.gapsSize + offsetX.x;
      }).attr("y", plot.height + offsetX.y).attr("dy", 10).attr("text-anchor", "middle").text(function (d) {
        return self.formatValueX(d.val);
      });
      var maxWidth = self.computeXAxisLabelsWidth(offsetX);
      labelsMerge.each(function (label) {
        var elem = d3.select(this),
            text = self.formatValueX(label.val);

        _utils.Utils.placeTextWithEllipsisAndTooltip(elem, text, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });

      if (self.config.x.rotateLabels) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + (i * plot.cellWidth + plot.cellWidth / 2 + d.group.gapsSize + offsetX.x) + ", " + (plot.height + offsetX.y) + ")";
        }).attr("dx", -2).attr("dy", 8).attr("text-anchor", "end");
      }

      labels.exit().remove();
      self.svgG.selectOrAppend("g." + self.prefixClass('axis-x')).attr("transform", "translate(" + plot.width / 2 + "," + (plot.height + plot.margin.bottom) + ")").selectOrAppend("text." + self.prefixClass('label')).attr("dy", "-0.5em").style("text-anchor", "middle").text(self.config.x.title);
    }
  }, {
    key: "updateAxisY",
    value: function updateAxisY() {
      var self = this;
      var plot = self.plot;
      var labelClass = self.prefixClass("label");
      var labelYClass = labelClass + "-y";
      plot.labelClass = labelClass;
      var labels = self.svgG.selectAll("text." + labelYClass).data(plot.y.allValuesList);
      var labelsEnter = labels.enter().append("text");
      var labelsMerge = labelsEnter.merge(labels);
      var offsetY = {
        x: 0,
        y: 0
      };

      if (plot.groupByY) {
        var overlap = self.config.y.groups.overlap;
        var gapSize = Heatmap.computeGapSize(0);
        offsetY.x = -overlap.left;
        offsetY.y = gapSize / 2;
      }

      labelsMerge.attr("x", offsetY.x).attr("y", function (d, i) {
        return i * plot.cellHeight + plot.cellHeight / 2 + d.group.gapsSize + offsetY.y;
      }).attr("dx", -2).attr("text-anchor", "end").attr("class", function (d, i) {
        return labelClass + " " + labelYClass + " " + labelYClass + "-" + i;
      }).text(function (d) {
        var formatted = self.formatValueY(d.val);
        return formatted;
      });
      var maxWidth = self.computeYAxisLabelsWidth(offsetY);
      labelsMerge.each(function (label) {
        var elem = d3.select(this),
            text = self.formatValueY(label.val);

        _utils.Utils.placeTextWithEllipsisAndTooltip(elem, text, maxWidth, self.config.showTooltip ? self.plot.tooltip : false);
      });

      if (self.config.y.rotateLabels) {
        labelsMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + offsetY.x + ", " + (d.group.gapsSize + (i * plot.cellHeight + plot.cellHeight / 2) + offsetY.y) + ")";
        }).attr("text-anchor", "end"); // .attr("dx", -7);
      } else {
        labelsMerge.attr("dominant-baseline", "middle");
      }

      labels.exit().remove();
      self.svgG.selectOrAppend("g." + self.prefixClass('axis-y')).selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)").attr("dy", "1em").style("text-anchor", "middle").text(self.config.y.title);
    }
  }, {
    key: "drawGroupsY",
    value: function drawGroupsY(parentGroup, container, availableWidth) {
      var self = this;
      var plot = self.plot;
      var groupClass = self.prefixClass("group");
      var groupYClass = groupClass + "-y";
      var groups = container.selectAll("g." + groupClass + "." + groupYClass).data(parentGroup.childrenList);
      var valuesBeforeCount = 0;
      var gapsBeforeSize = 0;
      var groupsEnter = groups.enter().append("g");
      groupsEnter.classed(groupClass, true).classed(groupYClass, true).append("rect").classed("group-rect", true);
      var titleGroupEnter = groupsEnter.appendSelector("g.title");
      titleGroupEnter.append("rect");
      titleGroupEnter.append("text");
      var gapSize = Heatmap.computeGapSize(parentGroup.level);
      var padding = gapSize / 4;
      var titleRectWidth = Heatmap.groupTitleRectHeight;
      var depth = self.config.y.groups.keys.length - parentGroup.level;
      var overlap = {
        left: 0,
        right: 0
      };

      if (!availableWidth) {
        overlap.right = plot.y.overlap.left;
        overlap.left = plot.y.overlap.left;
        availableWidth = plot.width + gapSize + overlap.left + overlap.right;
      }

      var groupsMerge = groupsEnter.merge(groups);
      groupsMerge.attr("transform", function (d, i) {
        var translate = "translate(" + (padding - overlap.left) + "," + (plot.cellHeight * valuesBeforeCount + i * gapSize + gapsBeforeSize + padding) + ")";
        gapsBeforeSize += d.gapsInsideSize || 0;
        valuesBeforeCount += d.allValuesCount || 0;
        return translate;
      });
      var groupWidth = availableWidth - padding * 2;
      var titleGroups = groupsMerge.selectAll("g.title").attr("transform", function (d, i) {
        return "translate(" + (groupWidth - titleRectWidth) + ", 0)";
      });
      var tileRects = titleGroups.selectAll("rect").attr("width", titleRectWidth).attr("height", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellHeight * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0) // .attr("fill", "lightgrey")
      .attr("stroke-width", 0);
      this.setGroupMouseCallbacks(parentGroup, tileRects);
      groupsMerge.selectAll("rect.group-rect").attr("class", function (d) {
        return "group-rect group-rect-" + d.index;
      }).attr("width", groupWidth).attr("height", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellHeight * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0).attr("fill", "white").attr("fill-opacity", 0).attr("stroke-width", 0.5).attr("stroke", "black");
      groupsMerge.each(function (group) {
        self.drawGroupsY.call(self, group, d3.select(this), groupWidth - titleRectWidth);
      });
      groups.exit().remove();
    }
  }, {
    key: "drawGroupsX",
    value: function drawGroupsX(parentGroup, container, availableHeight) {
      var self = this;
      var plot = self.plot;
      var groupClass = self.prefixClass("group");
      var groupXClass = groupClass + "-x";
      var groups = container.selectAll("g." + groupClass + "." + groupXClass).data(parentGroup.childrenList);
      var valuesBeforeCount = 0;
      var gapsBeforeSize = 0;
      var groupsEnter = groups.enter().append("g");
      groupsEnter.classed(groupClass, true).classed(groupXClass, true).append("rect").classed("group-rect", true);
      var titleGroupEnter = groupsEnter.appendSelector("g.title");
      titleGroupEnter.append("rect");
      titleGroupEnter.append("text");
      var gapSize = Heatmap.computeGapSize(parentGroup.level);
      var padding = gapSize / 4;
      var titleRectHeight = Heatmap.groupTitleRectHeight;
      var depth = self.config.x.groups.keys.length - parentGroup.level;
      var overlap = {
        top: 0,
        bottom: 0
      };

      if (!availableHeight) {
        overlap.bottom = plot.x.overlap.bottom;
        overlap.top = plot.x.overlap.top;
        availableHeight = plot.height + gapSize + overlap.top + overlap.bottom;
      } else {
        overlap.top = -titleRectHeight;
      } // console.log('parentGroup',parentGroup, 'gapSize', gapSize, plot.x.overlap);


      var groupsMerge = groupsEnter.merge(groups);
      groupsMerge.attr("transform", function (d, i) {
        var translate = "translate(" + (plot.cellWidth * valuesBeforeCount + i * gapSize + gapsBeforeSize + padding) + ", " + (padding - overlap.top) + ")";
        gapsBeforeSize += d.gapsInsideSize || 0;
        valuesBeforeCount += d.allValuesCount || 0;
        return translate;
      });
      var groupHeight = availableHeight - padding * 2;
      var titleGroups = groupsMerge.selectAll("g.title").attr("transform", function (d, i) {
        return "translate(0, " + 0 + ")";
      });
      var tileRects = titleGroups.selectAll("rect").attr("height", titleRectHeight).attr("width", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellWidth * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0) // .attr("fill", "lightgrey")
      .attr("stroke-width", 0);
      this.setGroupMouseCallbacks(parentGroup, tileRects);
      groupsMerge.selectAll("rect.group-rect").attr("class", function (d) {
        return "group-rect group-rect-" + d.index;
      }).attr("height", groupHeight).attr("width", function (d) {
        return (d.gapsInsideSize || 0) + plot.cellWidth * d.allValuesCount + padding * 2;
      }).attr("x", 0).attr("y", 0).attr("fill", "white").attr("fill-opacity", 0).attr("stroke-width", 0.5).attr("stroke", "black");
      groupsMerge.each(function (group) {
        self.drawGroupsX.call(self, group, d3.select(this), groupHeight - titleRectHeight);
      });
      groups.exit().remove();
    }
  }, {
    key: "setGroupMouseCallbacks",
    value: function setGroupMouseCallbacks(parentGroup, tileRects) {
      var plot = this.plot;
      var self = this;
      var mouseoverCallbacks = [];
      mouseoverCallbacks.push(function (d) {
        d3.select(this).classed('highlighted', true);
        d3.select(this.parentNode.parentNode).selectAll("rect.group-rect-" + d.index).classed('highlighted', true);
      });
      var mouseoutCallbacks = [];
      mouseoutCallbacks.push(function (d) {
        d3.select(this).classed('highlighted', false);
        d3.select(this.parentNode.parentNode).selectAll("rect.group-rect-" + d.index).classed('highlighted', false);
      });

      if (plot.tooltip) {
        mouseoverCallbacks.push(function (d) {
          var html = parentGroup.label + ": " + d.groupingValue;
          self.showTooltip(html);
        });
        mouseoutCallbacks.push(function (d) {
          self.hideTooltip();
        });
      }

      tileRects.on("mouseover", function (d) {
        var self = this;
        mouseoverCallbacks.forEach(function (callback) {
          callback.call(self, d);
        });
      });
      tileRects.on("mouseout", function (d) {
        var self = this;
        mouseoutCallbacks.forEach(function (callback) {
          callback.call(self, d);
        });
      });
    }
  }, {
    key: "updateCells",
    value: function updateCells() {
      var self = this;
      var plot = self.plot;
      var cellContainerClass = self.prefixClass("cells");
      var gapSize = Heatmap.computeGapSize(0);
      var paddingX = plot.x.groups.childrenList.length ? gapSize / 2 : 0;
      var paddingY = plot.y.groups.childrenList.length ? gapSize / 2 : 0;
      var cellContainer = self.svgG.selectOrAppend("g." + cellContainerClass);
      cellContainer.attr("transform", "translate(" + paddingX + ", " + paddingY + ")");
      var cellClass = self.prefixClass("cell");
      var cellShape = plot.z.shape.type;
      var cells = cellContainer.selectAll("g." + cellClass).data(self.plot.cells);
      var cellEnter = cells.enter().append("g").classed(cellClass, true);
      var cellsMerge = cellEnter.merge(cells);
      cellsMerge.attr("transform", function (c) {
        return "translate(" + (plot.cellWidth * c.col + plot.cellWidth / 2 + c.colVar.group.gapsSize) + "," + (plot.cellHeight * c.row + plot.cellHeight / 2 + c.rowVar.group.gapsSize) + ")";
      });
      var shapes = cellsMerge.selectOrAppend(cellShape + ".cell-shape-" + cellShape);
      shapes.attr("width", plot.z.shape.width).attr("height", plot.z.shape.height).attr("x", -plot.cellWidth / 2).attr("y", -plot.cellHeight / 2);
      shapes.style("fill", function (c) {
        return c.value === undefined ? self.config.color.noDataColor : plot.z.color.scale(c.value);
      });
      shapes.attr("fill-opacity", function (d) {
        return d.value === undefined ? 0 : 1;
      });
      var mouseoverCallbacks = [];
      var mouseoutCallbacks = [];

      if (plot.tooltip) {
        mouseoverCallbacks.push(function (c) {
          var html = c.value === undefined ? self.config.tooltip.noDataText : self.formatValueZ(c.value);
          self.showTooltip(html);
        });
        mouseoutCallbacks.push(function (c) {
          self.hideTooltip();
        });
      }

      if (self.config.highlightLabels) {
        var highlightClass = self.config.cssClassPrefix + "highlight";

        var xLabelClass = function xLabelClass(c) {
          return plot.labelClass + "-x-" + c.col;
        };

        var yLabelClass = function yLabelClass(c) {
          return plot.labelClass + "-y-" + c.row;
        };

        mouseoverCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, true);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, true);
        });
        mouseoutCallbacks.push(function (c) {
          self.svgG.selectAll("text." + xLabelClass(c)).classed(highlightClass, false);
          self.svgG.selectAll("text." + yLabelClass(c)).classed(highlightClass, false);
        });
      }

      cellsMerge.on("mouseover", function (c) {
        mouseoverCallbacks.forEach(function (callback) {
          return callback(c);
        });
      }).on("mouseout", function (c) {
        mouseoutCallbacks.forEach(function (callback) {
          return callback(c);
        });
      });
      cellsMerge.on("click", function (c) {
        self.trigger("cell-selected", c);
      });
      cells.exit().remove();
    }
  }, {
    key: "formatValueX",
    value: function formatValueX(value) {
      if (!this.config.x.formatter) return value;
      return this.config.x.formatter.call(this.config, value);
    }
  }, {
    key: "formatValueY",
    value: function formatValueY(value) {
      if (!this.config.y.formatter) return value;
      return this.config.y.formatter.call(this.config, value);
    }
  }, {
    key: "formatValueZ",
    value: function formatValueZ(value) {
      if (!this.config.z.formatter) return value;
      return this.config.z.formatter.call(this.config, value);
    }
  }, {
    key: "formatLegendValue",
    value: function formatLegendValue(value) {
      if (!this.config.legend.formatter) return value;
      return this.config.legend.formatter.call(this.config, value);
    }
  }, {
    key: "updateLegend",
    value: function updateLegend() {
      var self = this;
      var plot = this.plot;
      var legendX = this.plot.width + 10;
      var gapSize = Heatmap.computeGapSize(0);

      if (this.plot.groupByY) {
        legendX += gapSize / 2 + plot.y.overlap.right;
      } else if (this.plot.groupByX) {
        legendX += gapSize;
      }

      var legendY = 0;

      if (this.plot.groupByX || this.plot.groupByY) {
        legendY += gapSize / 2;
      }

      var barWidth = 10;
      var barHeight = this.plot.height - 2;
      var scale = plot.z.color.scale;
      plot.legend = new _legend.Legend(this.svg, this.svgG, scale, legendX, legendY, function (v) {
        return self.formatLegendValue(v);
      }).setRotateLabels(self.config.legend.rotateLabels).linearGradientBar(barWidth, barHeight);
    }
  }], [{
    key: "computeGapSize",
    value: function computeGapSize(gapLevel) {
      return Heatmap.maxGroupGapSize / (gapLevel + 1);
    }
  }, {
    key: "computeGapsSize",
    value: function computeGapsSize(gaps) {
      var gapsSize = 0;
      gaps.forEach(function (gapsNumber, gapsLevel) {
        return gapsSize += gapsNumber * Heatmap.computeGapSize(gapsLevel);
      });
      return gapsSize;
    }
  }]);

  return Heatmap;
}(_chart.Chart);

exports.Heatmap = Heatmap;
Heatmap.maxGroupGapSize = 24;
Heatmap.groupTitleRectHeight = 6;

},{"./chart":46,"./d3":49,"./legend":55,"./utils":62}],53:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Histogram = exports.HistogramConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var HistogramConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(HistogramConfig, _ChartWithColorGroups);

  function HistogramConfig(custom) {
    var _this;

    _classCallCheck(this, HistogramConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HistogramConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'histogram';
    _this.showLegend = true;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return _utils.Utils.isNumber(d) ? d : parseFloat(d[key]);
      },
      // x value accessor
      scale: "linear",
      orient: "bottom",
      ticks: undefined
    };
    _this.y = {
      // Y axis config
      title: '',
      // axis label,
      orient: "left",
      scale: "linear"
    };
    _this.frequency = true;
    _this.groups = {
      key: 1
    };
    _this.transition = true;

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return HistogramConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.HistogramConfig = HistogramConfig;

var Histogram =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(Histogram, _ChartWithColorGroups2);

  function Histogram(placeholderSelector, data, config) {
    _classCallCheck(this, Histogram);

    return _possibleConstructorReturn(this, _getPrototypeOf(Histogram).call(this, placeholderSelector, data, new HistogramConfig(config)));
  }

  _createClass(Histogram, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(Histogram.prototype), "setConfig", this).call(this, new HistogramConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(Histogram.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.plot.bar = {
        color: null //color scale mapping function

      };
      this.computePlotSize();
      this.setupX();
      this.setupHistogram();
      this.setupGroupStacks();
      this.setupY();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);

      if (conf.ticks) {
        x.axis.ticks(conf.ticks);
      }

      var data = this.plot.groupedData;
      plot.x.scale.domain([d3.min(data, function (s) {
        return d3.min(s.values, plot.x.value);
      }), d3.max(data, function (s) {
        return d3.max(s.values, plot.x.value);
      })]);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;
      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);
      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);
      var data = this.plot.data;
      var yStackMax = d3.max(plot.stackedHistograms, function (layer) {
        return d3.max(layer.histogramBins, function (d) {
          return d.y0 + d.y;
        });
      });
      plot.y.scale.domain([0, yStackMax]);
    }
  }, {
    key: "setupHistogram",
    value: function setupHistogram() {
      var plot = this.plot;
      var x = plot.x;
      var y = plot.y;
      var ticks = this.config.x.ticks ? x.scale.ticks(this.config.x.ticks) : x.scale.ticks();
      plot.histogram = d3.histogram().domain(x.scale.domain()).value(x.value).thresholds(ticks);
    }
  }, {
    key: "setupGroupStacks",
    value: function setupGroupStacks() {
      var _this2 = this;

      var self = this;
      var y0s = [];
      this.plot.groupedData.forEach(function (d) {
        d.histogramBins = _this2.plot.histogram(d.values);
        d.histogramBins.forEach(function (b, i) {
          b.x = b.x0;
          b.dx = b.x1 - b.x0;
          b.y = b.length;
          var prevY0 = y0s[i];
          if (!prevY0) prevY0 = 0;
          b.y0 = prevY0;

          if (!_this2.config.frequency) {
            b.y /= _this2.plot.dataLength;
          }

          y0s[i] = b.y + prevY0;
        });
      });
      var keys = this.plot.groupedData.map(function (d) {
        return d.key;
      }); // console.log(this.plot.groupedData);

      this.plot.stack = d3.stack().keys(keys).value(function (d) {
        return d.histogramBins;
      });
      this.plot.stackedHistograms = this.plot.groupedData;
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.config.transition) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawHistogram",
    value: function drawHistogram() {
      var self = this;
      var plot = self.plot;
      var layerClass = this.prefixClass("layer");
      var barClass = this.prefixClass("bar");
      var layer = self.svgG.selectAll("." + layerClass).data(plot.stackedHistograms);
      var layerMerge = layer.enter().append("g").attr("class", layerClass).merge(layer);
      var bar = layerMerge.selectAll("." + barClass).data(function (d) {
        return d.histogramBins;
      });
      var barEnter = bar.enter().append("g");
      barEnter.attr("class", barClass).append("rect").attr("x", 1);
      var barMerge = barEnter.merge(bar);
      var barRect = barMerge.select("rect");
      var barRectT = barRect;
      var barT = barMerge;
      var layerT = layerMerge;

      if (this.transitionEnabled()) {
        barRectT = barRect.transition();
        barT = barMerge.transition();
        layerT = layerMerge.transition();
      }

      barT.attr("transform", function (d) {
        return "translate(" + plot.x.scale(d.x) + "," + plot.y.scale(d.y0 + d.y) + ")";
      });
      var rectWidth = plot.stackedHistograms.length ? plot.stackedHistograms[0].histogramBins.length ? plot.x.scale(plot.stackedHistograms[0].histogramBins[0].x1) - plot.x.scale(plot.stackedHistograms[0].histogramBins[0].x0) - 1 : 0 : 0;
      barRectT.attr("width", function (d) {
        return Math.max(0, plot.x.scale(d.x1) - plot.x.scale(d.x0) - 1);
      }).attr("height", function (d) {
        return plot.height - plot.y.scale(d.y);
      });

      if (this.plot.color) {
        layerT.attr("fill", this.plot.seriesColor);
      }

      if (plot.tooltip) {
        barMerge.on("mouseover", function (d) {
          self.showTooltip(d.y);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      layer.exit().remove();
      bar.exit().remove();
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(Histogram.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.drawHistogram();
      return this;
    }
  }]);

  return Histogram;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.Histogram = Histogram;

},{"./chart-with-color-groups":45,"./d3":49,"./utils":62}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ScatterPlot", {
  enumerable: true,
  get: function get() {
    return _scatterplot.ScatterPlot;
  }
});
Object.defineProperty(exports, "ScatterPlotConfig", {
  enumerable: true,
  get: function get() {
    return _scatterplot.ScatterPlotConfig;
  }
});
Object.defineProperty(exports, "ScatterPlotMatrix", {
  enumerable: true,
  get: function get() {
    return _scatterplotMatrix.ScatterPlotMatrix;
  }
});
Object.defineProperty(exports, "ScatterPlotMatrixConfig", {
  enumerable: true,
  get: function get() {
    return _scatterplotMatrix.ScatterPlotMatrixConfig;
  }
});
Object.defineProperty(exports, "Regression", {
  enumerable: true,
  get: function get() {
    return _regression.Regression;
  }
});
Object.defineProperty(exports, "RegressionConfig", {
  enumerable: true,
  get: function get() {
    return _regression.RegressionConfig;
  }
});
Object.defineProperty(exports, "CorrelationMatrix", {
  enumerable: true,
  get: function get() {
    return _correlationMatrix.CorrelationMatrix;
  }
});
Object.defineProperty(exports, "CorrelationMatrixConfig", {
  enumerable: true,
  get: function get() {
    return _correlationMatrix.CorrelationMatrixConfig;
  }
});
Object.defineProperty(exports, "Heatmap", {
  enumerable: true,
  get: function get() {
    return _heatmap.Heatmap;
  }
});
Object.defineProperty(exports, "HeatmapConfig", {
  enumerable: true,
  get: function get() {
    return _heatmap.HeatmapConfig;
  }
});
Object.defineProperty(exports, "HeatmapTimeSeries", {
  enumerable: true,
  get: function get() {
    return _heatmapTimeseries.HeatmapTimeSeries;
  }
});
Object.defineProperty(exports, "HeatmapTimeSeriesConfig", {
  enumerable: true,
  get: function get() {
    return _heatmapTimeseries.HeatmapTimeSeriesConfig;
  }
});
Object.defineProperty(exports, "Histogram", {
  enumerable: true,
  get: function get() {
    return _histogram.Histogram;
  }
});
Object.defineProperty(exports, "HistogramConfig", {
  enumerable: true,
  get: function get() {
    return _histogram.HistogramConfig;
  }
});
Object.defineProperty(exports, "BarChart", {
  enumerable: true,
  get: function get() {
    return _barChart.BarChart;
  }
});
Object.defineProperty(exports, "BarChartConfig", {
  enumerable: true,
  get: function get() {
    return _barChart.BarChartConfig;
  }
});
Object.defineProperty(exports, "BoxPlotBase", {
  enumerable: true,
  get: function get() {
    return _boxPlotBase.BoxPlotBase;
  }
});
Object.defineProperty(exports, "BoxPlotBaseConfig", {
  enumerable: true,
  get: function get() {
    return _boxPlotBase.BoxPlotBaseConfig;
  }
});
Object.defineProperty(exports, "BoxPlot", {
  enumerable: true,
  get: function get() {
    return _boxPlot.BoxPlot;
  }
});
Object.defineProperty(exports, "BoxPlotConfig", {
  enumerable: true,
  get: function get() {
    return _boxPlot.BoxPlotConfig;
  }
});
Object.defineProperty(exports, "DivergingStackedBarChart", {
  enumerable: true,
  get: function get() {
    return _divergingStackedBarChart.DivergingStackedBarChart;
  }
});
Object.defineProperty(exports, "DivergingStackedBarChartConfig", {
  enumerable: true,
  get: function get() {
    return _divergingStackedBarChart.DivergingStackedBarChartConfig;
  }
});
Object.defineProperty(exports, "LineChart", {
  enumerable: true,
  get: function get() {
    return _lineChart.LineChart;
  }
});
Object.defineProperty(exports, "LineChartConfig", {
  enumerable: true,
  get: function get() {
    return _lineChart.LineChartConfig;
  }
});
Object.defineProperty(exports, "StatisticsUtils", {
  enumerable: true,
  get: function get() {
    return _statisticsUtils.StatisticsUtils;
  }
});
Object.defineProperty(exports, "Utils", {
  enumerable: true,
  get: function get() {
    return _utils.Utils;
  }
});
Object.defineProperty(exports, "Legend", {
  enumerable: true,
  get: function get() {
    return _legend.Legend;
  }
});

var _d3Extensions = require("./d3-extensions");

var _scatterplot = require("./scatterplot");

var _scatterplotMatrix = require("./scatterplot-matrix");

var _regression = require("./regression");

var _correlationMatrix = require("./correlation-matrix");

var _heatmap = require("./heatmap");

var _heatmapTimeseries = require("./heatmap-timeseries");

var _histogram = require("./histogram");

var _barChart = require("./bar-chart");

var _boxPlotBase = require("./box-plot-base");

var _boxPlot = require("./box-plot");

var _divergingStackedBarChart = require("./diverging-stacked-bar-chart");

var _lineChart = require("./line-chart");

var _statisticsUtils = require("./statistics-utils");

var _utils = require("./utils");

var _legend = require("./legend");

_d3Extensions.D3Extensions.extend();

},{"./bar-chart":42,"./box-plot":44,"./box-plot-base":43,"./correlation-matrix":47,"./d3-extensions":48,"./diverging-stacked-bar-chart":50,"./heatmap":52,"./heatmap-timeseries":51,"./histogram":53,"./legend":55,"./line-chart":56,"./regression":57,"./scatterplot":59,"./scatterplot-matrix":58,"./statistics-utils":61,"./utils":62}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Legend = void 0;

var _utils = require("./utils");

var _d3SvgLegend = require("d3-svg-legend");

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/*var d3 = require('../bower_components/d3');
*/
// var legend = require('../bower_components/d3-legend/no-extend');
//
// module.exports.legend = legend;


var Legend =
/*#__PURE__*/
function () {
  function Legend(svg, legendParent, scale, legendX, legendY, labelFormat) {
    _classCallCheck(this, Legend);

    this.cssClassPrefix = "odc-";
    this.legendClass = this.cssClassPrefix + "legend";
    this.color = _d3SvgLegend.legendColor;
    this.size = _d3SvgLegend.legendSize;
    this.symbol = _d3SvgLegend.legendSymbol;
    this.labelFormat = undefined;
    this.scale = scale;
    this.svg = svg;
    this.guid = _utils.Utils.guid();
    this.container = _utils.Utils.selectOrAppend(legendParent, "g." + this.legendClass, "g").attr("transform", "translate(" + legendX + "," + legendY + ")").classed(this.legendClass, true);
    this.labelFormat = labelFormat;
  }

  _createClass(Legend, [{
    key: "linearGradientBar",
    value: function linearGradientBar(barWidth, barHeight, title) {
      var gradientId = this.cssClassPrefix + "linear-gradient" + "-" + this.guid;
      var scale = this.scale;
      var self = this;
      this.linearGradient = _utils.Utils.linearGradient(this.svg, gradientId, this.scale.range(), 0, 100, 0, 0);
      this.container.selectOrAppend("rect").attr("width", barWidth).attr("height", barHeight).attr("x", 0).attr("y", 0).style("fill", "url(#" + gradientId + ")");
      var ticks = this.container.selectAll("text").data(scale.domain());
      var ticksNumber = scale.domain().length - 1;
      var ticksMerge = ticks.enter().append("text").merge(ticks);
      ticksMerge.attr("x", barWidth).attr("y", function (d, i) {
        return barHeight - i * barHeight / ticksNumber;
      }).attr("dx", 3) // .attr("dy", 1)
      .attr("alignment-baseline", "middle").text(function (d) {
        return self.labelFormat ? self.labelFormat(d) : d;
      });
      ticksMerge.attr("dominant-baseline", "middle");

      if (this.rotateLabels) {
        ticksMerge.attr("transform", function (d, i) {
          return "rotate(-45, " + barWidth + ", " + (barHeight - i * barHeight / ticksNumber) + ")";
        }).attr("text-anchor", "start").attr("dx", 5).attr("dy", 5);
      } else {}

      ticks.exit().remove();
      return this;
    }
  }, {
    key: "setRotateLabels",
    value: function setRotateLabels(rotateLabels) {
      this.rotateLabels = rotateLabels;
      return this;
    }
  }]);

  return Legend;
}();

exports.Legend = Legend;

},{"./utils":62,"d3-svg-legend":16}],56:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineChart = exports.LineChartConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var LineChartConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(LineChartConfig, _ChartWithColorGroups); //show axis guides
  //show tooltip on dot hover


  function LineChartConfig(custom) {
    var _this;

    _classCallCheck(this, LineChartConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineChartConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'line-chart';
    _this.guides = false;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return d[key];
      },
      // x value accessor
      orient: "bottom",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.y = {
      // Y axis config
      title: '',
      // axis label,
      key: 1,
      value: function value(d, key) {
        return d[key];
      },
      // y value accessor
      orient: "left",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.groups = {
      key: 2
    };
    _this.dotRadius = 2;

    _this.dotId = function (d, i) {
      return undefined;
    };

    _this.transition = true;

    _this.onDotHover = function (d, i) {};

    _this.onDotHoverOut = function (d, i) {};

    _this.lineId = function (d, i) {
      return undefined;
    };

    _this.transition = true;

    _this.onLineHover = function (d, i) {};

    _this.onLineHoverOut = function (d, i) {};

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return LineChartConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.LineChartConfig = LineChartConfig;

var LineChart =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(LineChart, _ChartWithColorGroups2);

  function LineChart(placeholderSelector, data, config) {
    _classCallCheck(this, LineChart);

    return _possibleConstructorReturn(this, _getPrototypeOf(LineChart).call(this, placeholderSelector, data, new LineChartConfig(config)));
  }

  _createClass(LineChart, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(LineChart.prototype), "setConfig", this).call(this, new LineChartConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(LineChart.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.computePlotSize();
      this.setupX();
      this.setupY();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);
      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.x.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.x.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.x.scale.domain(domain);

      if (this.config.guides) {
        x.axis.tickSize(-plot.height);
      }
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;
      /*
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       */

      y.value = function (d) {
        return conf.value(d, conf.key);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (this.config.guides) {
        y.axis.tickSize(-plot.width);
      }

      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.y.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.y.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.y.scale.domain(domain); // plot.y.scale.domain([d3.min(data, plot.y.value)-1, d3.max(data, plot.y.value)+1]);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(LineChart.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.updateLines();
    }
  }, {
    key: "updateLines",
    value: function updateLines() {
      var self = this;
      var plot = self.plot;
      var data = plot.data;
      var layerClass = self.prefixClass('layer');
      var lineClass = this.lineClass = self.prefixClass('line');
      self.linesContainerClass = self.prefixClass('lines-container');
      var linesContainer = self.svgG.selectOrAppend("g." + self.linesContainerClass);
      var layer = linesContainer.selectAll("g." + layerClass).data(plot.groupedData);
      var layerEnter = layer.enter().appendSelector("g." + layerClass);
      var linePathEnter = layerEnter.append("path").attr("class", lineClass);
      var layerMerge = layerEnter.merge(layer);
      var linePath = layerMerge.select('.' + lineClass).datum(function (d) {
        return d.values;
      });
      var linePathMerge = linePathEnter.merge(linePath);
      var linePathT = linePathMerge;

      if (self.transitionEnabled()) {
        linePathT = linePathMerge.transition();
      }

      var line = d3.line().x(plot.x.map).y(plot.y.map);
      linePathT.attr("fill", "none") // .attr("stroke", "steelblue")
      .attr("stroke-linejoin", "round").attr("stroke-linecap", "round").attr("stroke-width", 1.5).attr("id", this.config.lineId).attr("d", line); //TODO add tooltip

      linePathMerge.on("mouseover.onLineHover", this.config.onLineHover);
      linePathMerge.on("mouseout.onLineHoverOut", this.config.onLineHoverOut);

      if (plot.seriesColor) {
        layerMerge.style("stroke", plot.seriesColor);
      } else if (plot.color) {
        linePathMerge.style("stroke", plot.color);
      }

      linePath.exit().remove();
      var dotClass = this.dotClass = self.prefixClass('dot');
      var dots = layerMerge.selectAll('.' + dotClass).data(function (d) {
        return d.values;
      });
      var dotsEnter = dots.enter().append("circle").attr("class", dotClass);
      var dotsMerge = dotsEnter.merge(dots);
      var dotsT = dotsMerge;

      if (self.transitionEnabled()) {
        dotsT = dotsMerge.transition();
      }

      dotsT.attr("r", self.config.dotRadius).attr("cx", plot.x.map).attr("cy", plot.y.map).attr("id", this.config.dotId);

      if (plot.tooltip) {
        dotsMerge.on("mouseover", function (d) {
          var html = "(" + plot.x.value(d) + ", " + plot.y.value(d) + ")";
          var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;

          if (group || group === 0) {
            group = plot.groupToLabel[group];
            html += "<br/>";
            var label = self.config.groups.label;

            if (label) {
              html += label + ": ";
            }

            html += group;
          }

          self.showTooltip(html);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      dotsMerge.on("mouseover.onDotHover", this.config.onDotHover);
      dotsMerge.on("mouseout.onDotHoverOut", this.config.onDotHoverOut);

      if (plot.seriesColor) {
        layerMerge.style("fill", plot.seriesColor);
      } else if (plot.color) {
        dotsMerge.style("fill", plot.color);
      }

      dots.exit().remove();
      layer.exit().remove();
    }
  }]);

  return LineChart;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.LineChart = LineChart;

},{"./chart-with-color-groups":45,"./d3":49,"./utils":62}],57:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Regression = exports.RegressionConfig = void 0;

var _chart = require("./chart");

var _scatterplot = require("./scatterplot");

var _utils = require("./utils");

var _statisticsUtils = require("./statistics-utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var RegressionConfig =
/*#__PURE__*/
function (_ScatterPlotConfig) {
  _inherits(RegressionConfig, _ScatterPlotConfig);

  function RegressionConfig(custom) {
    var _this;

    _classCallCheck(this, RegressionConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RegressionConfig).call(this));
    _this.mainRegression = true;
    _this.groupRegression = true;
    _this.confidence = {
      level: 0.95,
      criticalValue: function criticalValue(degreesOfFreedom, criticalProbability) {
        return _statisticsUtils.StatisticsUtils.tValue(degreesOfFreedom, criticalProbability);
      },
      marginOfError: undefined,
      //custom  margin Of Error function (x, points)
      areaCurve: d3.curveNatural
    };

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return RegressionConfig;
}(_scatterplot.ScatterPlotConfig);

exports.RegressionConfig = RegressionConfig;

var Regression =
/*#__PURE__*/
function (_ScatterPlot) {
  _inherits(Regression, _ScatterPlot);

  function Regression(placeholderSelector, data, config) {
    _classCallCheck(this, Regression);

    return _possibleConstructorReturn(this, _getPrototypeOf(Regression).call(this, placeholderSelector, data, new RegressionConfig(config)));
  }

  _createClass(Regression, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(Regression.prototype), "setConfig", this).call(this, new RegressionConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(Regression.prototype), "initPlot", this).call(this);

      this.initRegressionLines();
    }
  }, {
    key: "initRegressionLines",
    value: function initRegressionLines() {
      var self = this;
      var groupsAvailable = self.plot.groupingEnabled;
      self.plot.regressions = [];

      if (groupsAvailable && self.config.mainRegression) {
        var regression = this.initRegression(this.plot.data, false);
        self.plot.regressions.push(regression);
      }

      if (self.config.groupRegression) {
        this.initGroupRegression();
      }
    }
  }, {
    key: "initGroupRegression",
    value: function initGroupRegression() {
      var _this2 = this;

      var self = this;
      self.plot.groupedData.forEach(function (group) {
        if (group.values.length < 2) {
          return;
        }

        var regression = _this2.initRegression(group.values, group.key);

        self.plot.regressions.push(regression);
      });
    }
  }, {
    key: "initRegression",
    value: function initRegression(values, groupVal) {
      var self = this;
      var points = values.map(function (d) {
        return [parseFloat(self.plot.x.value(d)), parseFloat(self.plot.y.value(d))];
      }); // points.sort((a,b) => a[0]-b[0]);

      var linearRegression = _statisticsUtils.StatisticsUtils.linearRegression(points);

      var linearRegressionLine = _statisticsUtils.StatisticsUtils.linearRegressionLine(linearRegression);

      var extentX = d3.extent(points, function (d) {
        return d[0];
      });
      var linePoints = [{
        x: extentX[0],
        y: linearRegressionLine(extentX[0])
      }, {
        x: extentX[1],
        y: linearRegressionLine(extentX[1])
      }];
      var line = d3.line().curve(d3.curveBasis).x(function (d) {
        return self.plot.x.scale(d.x);
      }).y(function (d) {
        return self.plot.y.scale(d.y);
      });
      var color = self.plot.color;
      var defaultColor = "black";

      if (_utils.Utils.isFunction(color)) {
        if (values.length && groupVal !== false) {
          if (self.config.series) {
            color = self.plot.colorCategory(groupVal);
          } else {
            color = color(values[0]);
          }
        } else {
          color = defaultColor;
        }
      } else if (!color && groupVal === false) {
        color = defaultColor;
      }

      var confidence = this.computeConfidence(points, extentX, linearRegression, linearRegressionLine);
      return {
        group: groupVal || false,
        line: line,
        linePoints: linePoints,
        color: color,
        confidence: confidence
      };
    }
  }, {
    key: "computeConfidence",
    value: function computeConfidence(points, extentX, linearRegression, linearRegressionLine) {
      var self = this;
      var slope = linearRegression.m;
      var n = points.length;
      var degreesOfFreedom = Math.max(0, n - 2);
      var alpha = 1 - self.config.confidence.level;
      var criticalProbability = 1 - alpha / 2;
      var criticalValue = self.config.confidence.criticalValue(degreesOfFreedom, criticalProbability);
      var xValues = points.map(function (d) {
        return d[0];
      });

      var meanX = _statisticsUtils.StatisticsUtils.mean(xValues);

      var xMySum = 0;
      var xSum = 0;
      var xPowSum = 0;
      var ySum = 0;
      var yPowSum = 0;
      points.forEach(function (p) {
        var x = p[0];
        var y = p[1];
        xMySum += x * y;
        xSum += x;
        ySum += y;
        xPowSum += x * x;
        yPowSum += y * y;
      });
      var a = linearRegression.m;
      var b = linearRegression.b;
      var Sa2 = n / (n + 2) * ((yPowSum - a * xMySum - b * ySum) / (n * xPowSum - xSum * xSum)); //Wariancja współczynnika kierunkowego regresji liniowej a

      var Sy2 = (yPowSum - a * xMySum - b * ySum) / (n * (n - 2)); //Sa2 //Mean y value variance

      var errorFn = function errorFn(x) {
        return Math.sqrt(Sy2 + Math.pow(x - meanX, 2) * Sa2);
      }; //pierwiastek kwadratowy z wariancji dowolnego punktu prostej


      var marginOfError = function marginOfError(x) {
        return criticalValue * errorFn(x);
      }; // console.log('n', n, 'degreesOfFreedom', degreesOfFreedom, 'criticalProbability',criticalProbability);
      // var confidenceDown = x => linearRegressionLine(x) -  marginOfError(x);
      // var confidenceUp = x => linearRegressionLine(x) +  marginOfError(x);


      var computeConfidenceAreaPoint = function computeConfidenceAreaPoint(x) {
        var linearRegression = linearRegressionLine(x);
        var moe = marginOfError(x);
        var confDown = linearRegression - moe;
        var confUp = linearRegression + moe;
        return {
          x: x,
          y0: confDown,
          y1: confUp
        };
      };

      var centerX = (extentX[1] + extentX[0]) / 2; // var confidenceAreaPoints = [extentX[0], centerX,  extentX[1]].map(computeConfidenceAreaPoint);

      var confidenceAreaPoints = [extentX[0], centerX, extentX[1]].map(computeConfidenceAreaPoint);

      var fitInPlot = function fitInPlot(y) {
        return y;
      };

      var confidenceArea = d3.area().curve(self.config.confidence.areaCurve).x(function (d) {
        return self.plot.x.scale(d.x);
      }).y0(function (d) {
        return fitInPlot(self.plot.y.scale(d.y0));
      }).y1(function (d) {
        return fitInPlot(self.plot.y.scale(d.y1));
      });
      return {
        area: confidenceArea,
        points: confidenceAreaPoints
      };
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(Regression.prototype), "update", this).call(this, newData);

      this.updateRegressionLines();
    }
  }, {
    key: "updateRegressionLines",
    value: function updateRegressionLines() {
      var self = this;
      var regressionContainerClass = this.prefixClass("regression-container");
      var regressionContainerSelector = "g." + regressionContainerClass;
      var clipPathId = self.prefixClass("clip");
      var regressionContainer = self.svgG.selectOrInsert(regressionContainerSelector, "." + self.dotsContainerClass);
      var regressionContainerClip = regressionContainer.selectOrAppend("clipPath").attr("id", clipPathId);
      regressionContainerClip.selectOrAppend('rect').attr('width', self.plot.width).attr('height', self.plot.height).attr('x', 0).attr('y', 0);
      regressionContainer.attr("clip-path", function (d, i) {
        return "url(#" + clipPathId + ")";
      });
      var regressionClass = this.prefixClass("regression");
      var confidenceAreaClass = self.prefixClass("confidence");
      var regressionSelector = "g." + regressionClass;
      var regression = regressionContainer.selectAll(regressionSelector).data(self.plot.regressions, function (d, i) {
        return d.group;
      });
      var regressionEnter = regression.enter().appendSelector(regressionSelector);
      var regressionMerge = regressionEnter.merge(regression);
      var lineClass = self.prefixClass("line");
      regressionEnter.append("path").attr("class", lineClass).attr("shape-rendering", "optimizeQuality");
      var line = regressionMerge.select("path." + lineClass).style("stroke", function (r) {
        return r.color;
      });
      var lineT = line;

      if (self.transitionEnabled()) {
        lineT = line.transition();
      }

      lineT.attr("d", function (r) {
        return r.line(r.linePoints);
      });
      regressionEnter.append("path").attr("class", confidenceAreaClass).attr("shape-rendering", "optimizeQuality").style("opacity", "0.4");
      var area = regressionMerge.select("path." + confidenceAreaClass);
      var areaT = area;

      if (self.transitionEnabled()) {
        areaT = area.transition();
      }

      areaT.attr("d", function (r) {
        return r.confidence.area(r.confidence.points);
      });
      areaT.style("fill", function (r) {
        return r.color;
      });
      regression.exit().remove();
    }
  }]);

  return Regression;
}(_scatterplot.ScatterPlot);

exports.Regression = Regression;

},{"./chart":46,"./d3":49,"./scatterplot":59,"./statistics-utils":61,"./utils":62}],58:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScatterPlotMatrix = exports.ScatterPlotMatrixConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _scatterplot = require("./scatterplot");

var _utils = require("./utils");

var _legend = require("./legend");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var ScatterPlotMatrixConfig =
/*#__PURE__*/
function (_ScatterPlotConfig) {
  _inherits(ScatterPlotMatrixConfig, _ScatterPlotConfig); //scatter plot cell size
  //scatter plot cell padding
  //show axis guides
  //show tooltip on dot hover
  //ticks number, (default: computed using cell size)


  function ScatterPlotMatrixConfig(custom) {
    var _this;

    _classCallCheck(this, ScatterPlotMatrixConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlotMatrixConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'scatterplot-matrix';
    _this.size = undefined;
    _this.minCellSize = 50;
    _this.maxCellSize = 1000;
    _this.padding = 20;
    _this.brush = true;
    _this.guides = true;
    _this.showTooltip = true;
    _this.ticks = undefined;
    _this.x = {
      // X axis config
      orient: "bottom",
      scale: "linear"
    };
    _this.y = {
      // Y axis config
      orient: "left",
      scale: "linear"
    };
    _this.groups = {
      key: undefined,
      //object property name or array index with grouping variable
      includeInPlot: false //include group as variable in plot, boolean (default: false)

    };
    _this.variables = {
      labels: [],
      //optional array of variable labels (for the diagonal of the plot).
      keys: [],
      //optional array of variable keys
      value: function value(d, variableKey) {
        return d[variableKey];
      } // variable value accessor

    };

    _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);

    return _this;
  }

  return ScatterPlotMatrixConfig;
}(_scatterplot.ScatterPlotConfig);

exports.ScatterPlotMatrixConfig = ScatterPlotMatrixConfig;

var ScatterPlotMatrix =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(ScatterPlotMatrix, _ChartWithColorGroups);

  function ScatterPlotMatrix(placeholderSelector, data, config) {
    _classCallCheck(this, ScatterPlotMatrix);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlotMatrix).call(this, placeholderSelector, data, new ScatterPlotMatrixConfig(config)));
  }

  _createClass(ScatterPlotMatrix, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(ScatterPlotMatrix.prototype), "setConfig", this).call(this, new ScatterPlotMatrixConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(ScatterPlotMatrix.prototype), "initPlot", this).call(this);

      var self = this;
      var margin = this.plot.margin;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.plot.dot = {
        color: null //color scale mapping function

      };
      this.setupVariables();
      this.plot.size = conf.size;
      var width = conf.width;

      var availableWidth = _utils.Utils.availableWidth(this.config.width, this.getBaseContainer(), margin);

      var availableHeight = _utils.Utils.availableHeight(this.config.height, this.getBaseContainer(), margin);

      if (!width) {
        if (!this.plot.size) {
          this.plot.size = Math.min(conf.maxCellSize, Math.max(conf.minCellSize, availableWidth / this.plot.variables.length));
        }

        width = margin.left + margin.right + this.plot.variables.length * this.plot.size;
      }

      if (!this.plot.size) {
        this.plot.size = (width - (margin.left + margin.right)) / this.plot.variables.length;
      }

      var height = width;

      if (!height) {
        height = availableHeight;
      }

      this.plot.width = width - margin.left - margin.right;
      this.plot.height = height - margin.top - margin.bottom;
      this.plot.ticks = conf.ticks;

      if (this.plot.ticks === undefined) {
        this.plot.ticks = this.plot.size / 40;
      }

      this.setupX();
      this.setupY();
      return this;
    }
  }, {
    key: "setupVariables",
    value: function setupVariables() {
      var variablesConf = this.config.variables;
      var data = this.plot.groupedData;
      var plot = this.plot;
      plot.domainByVariable = {};
      plot.variables = variablesConf.keys;

      if (!plot.variables || !plot.variables.length) {
        plot.variables = data.length ? _utils.Utils.inferVariables(data[0].values, this.config.groups.key, this.config.includeInPlot) : [];
      }

      plot.labels = [];
      plot.labelByVariable = {};
      plot.variables.forEach(function (variableKey, index) {
        var min = d3.min(data, function (s) {
          return d3.min(s.values, function (d) {
            return variablesConf.value(d, variableKey);
          });
        });
        var max = d3.max(data, function (s) {
          return d3.max(s.values, function (d) {
            return variablesConf.value(d, variableKey);
          });
        });
        plot.domainByVariable[variableKey] = [min, max];
        var label = variableKey;

        if (variablesConf.labels && variablesConf.labels.length > index) {
          label = variablesConf.labels[index];
        }

        plot.labels.push(label);
        plot.labelByVariable[variableKey] = label;
      });
      plot.subplots = [];
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config;
      x.value = conf.variables.value;
      x.scale = _utils.Utils.createScale(conf.x.scale).range([conf.padding / 2, plot.size - conf.padding / 2]);

      x.map = function (d, variable) {
        return x.scale(x.value(d, variable));
      };

      x.axis = _utils.Utils.createAxis(conf.x.orient, x.scale).ticks(plot.ticks);
      x.axis.tickSize(plot.size * plot.variables.length);
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config;
      y.value = conf.variables.value;
      y.scale = _utils.Utils.createScale(conf.y.scale).range([plot.size - conf.padding / 2, conf.padding / 2]);

      y.map = function (d, variable) {
        return y.scale(y.value(d, variable));
      };

      y.axis = _utils.Utils.createAxis(conf.y.orient, y.scale).ticks(plot.ticks);
      y.axis.tickSize(-plot.size * plot.variables.length);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(ScatterPlotMatrix.prototype), "update", this).call(this, newData);

      var self = this;
      var n = self.plot.variables.length;
      var conf = this.config;
      var axisClass = self.prefixClass("axis");
      var axisXClass = axisClass + "-x";
      var axisYClass = axisClass + "-y";
      var xAxisSelector = "g." + axisXClass + "." + axisClass;
      var yAxisSelector = "g." + axisYClass + "." + axisClass;
      var noGuidesClass = self.prefixClass("no-guides");
      var xAxis = self.svgG.selectAll(xAxisSelector).data(self.plot.variables);
      var xAxisMerge = xAxis.enter().appendSelector(xAxisSelector).classed(noGuidesClass, !conf.guides).merge(xAxis);
      xAxisMerge.attr("transform", function (d, i) {
        return "translate(" + (n - i - 1) * self.plot.size + ",0)";
      }).each(function (d) {
        self.plot.x.scale.domain(self.plot.domainByVariable[d]);
        var axis = d3.select(this);

        if (self.transitionEnabled()) {
          axis = axis.transition();
        }

        axis.call(self.plot.x.axis);
      });
      xAxis.exit().remove();
      var yAxis = self.svgG.selectAll(yAxisSelector).data(self.plot.variables);
      var yAxisMerge = yAxis.enter().appendSelector(yAxisSelector).merge(yAxis);
      yAxisMerge.classed(noGuidesClass, !conf.guides).attr("transform", function (d, i) {
        return "translate(0," + i * self.plot.size + ")";
      });
      yAxisMerge.each(function (d) {
        self.plot.y.scale.domain(self.plot.domainByVariable[d]);
        var axis = d3.select(this);

        if (self.transitionEnabled()) {
          axis = axis.transition();
        }

        axis.call(self.plot.y.axis);
      });
      yAxis.exit().remove();
      var cellClass = self.prefixClass("cell");
      var cell = self.svgG.selectAll("." + cellClass).data(self.utils.cross(self.plot.variables, self.plot.variables));
      var cellEnter = cell.enter().appendSelector("g." + cellClass);
      cellEnter.filter(function (d) {
        return d.i === d.j;
      }).append("text");
      var cellMerge = cellEnter.merge(cell);
      cellMerge.attr("transform", function (d) {
        return "translate(" + (n - d.i - 1) * self.plot.size + "," + d.j * self.plot.size + ")";
      });

      if (conf.brush) {
        this.drawBrush(cellMerge);
      }

      cellMerge.each(plotSubplot); //Labels

      cellMerge.select("text").attr("x", conf.padding).attr("y", conf.padding).attr("dy", ".71em").text(function (d) {
        return self.plot.labelByVariable[d.x];
      });
      cell.exit().remove();

      function plotSubplot(p) {
        var plot = self.plot;
        plot.subplots.push(p);
        var cell = d3.select(this);
        plot.x.scale.domain(plot.domainByVariable[p.x]);
        plot.y.scale.domain(plot.domainByVariable[p.y]);
        var frameClass = self.prefixClass("frame");
        cell.selectOrAppend("rect." + frameClass).attr("class", frameClass).attr("x", conf.padding / 2).attr("y", conf.padding / 2).attr("width", plot.size - conf.padding).attr("height", plot.size - conf.padding);

        p.update = function () {
          var subplot = this;
          var layerClass = self.prefixClass('layer');
          var layer = cell.selectAll("g." + layerClass).data(self.plot.groupedData);
          var layerMerge = layer.enter().appendSelector("g." + layerClass).merge(layer);
          var dots = layerMerge.selectAll("circle").data(function (d) {
            return d.values;
          });
          var dotsMerge = dots.enter().append("circle").merge(dots);
          var dotsT = dotsMerge;

          if (self.transitionEnabled()) {
            dotsT = dotsMerge.transition();
          }

          dotsT.attr("cx", function (d) {
            return plot.x.map(d, subplot.x);
          }).attr("cy", function (d) {
            return plot.y.map(d, subplot.y);
          }).attr("r", self.config.dotRadius);

          if (plot.seriesColor) {
            layerMerge.style("fill", plot.seriesColor);
          } else if (plot.color) {
            dotsMerge.style("fill", plot.color);
          }

          if (plot.tooltip) {
            dotsMerge.on("mouseover", function (d) {
              var html = "(" + plot.x.value(d, subplot.x) + ", " + plot.y.value(d, subplot.y) + ")";
              var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;

              if (group || group === 0) {
                group = plot.groupToLabel[group];
                html += "<br/>";
                var label = self.config.groups.label;

                if (label) {
                  html += label + ": ";
                }

                html += group;
              }

              self.showTooltip(html);
            }).on("mouseout", function (d) {
              self.hideTooltip();
            });
          }

          dots.exit().remove();
          layer.exit().remove();
        };

        p.update();
      }
    }
  }, {
    key: "drawBrush",
    value: function drawBrush(cell) {
      var self = this;
      var hiddenClass = self.plot.hiddenClass = self.prefixClass("hidden");
      var brush = d3.brush() // .x(self.plot.x.scale)
      // .y(self.plot.y.scale)
      .on("start", brushstart).on("brush", brushmove).on("end", brushend);
      brush.extent([[0, 0], [self.plot.size, self.plot.size]]);
      cell.selectOrAppend("g.brush-container").call(brush);
      self.clearBrush(); // Clear the previously-active brush, if any.

      function brushstart(p) {
        if (self.plot.brushCell !== this) {
          self.clearBrush();
          self.plot.x.scale.domain(self.plot.domainByVariable[p.x]);
          self.plot.y.scale.domain(self.plot.domainByVariable[p.y]);
          self.plot.brushCell = this;
          self.plot.brush = brush;
        }
      } // Highlight the selected circles.


      function brushmove(p) {
        var s = d3.event.selection;
        if (!s) return;
        var e = s.map(function (_) {
          return [self.plot.x.scale.invert(_[0]), self.plot.y.scale.invert(_[1])];
        }); // console.log(e);

        self.svgG.selectAll("circle").classed(hiddenClass, function (d) {
          var x = parseFloat(d[p.x]),
              y = parseFloat(d[p.y]);
          return e[0][0] > x || x > e[1][0] || e[1][1] > y || y > e[0][1];
        });
      } // If the brush is empty, select all circles.


      function brushend() {
        if (!d3.event.selection) self.svgG.selectAll("." + hiddenClass).classed(hiddenClass, false);
      }
    }
  }, {
    key: "clearBrush",
    value: function clearBrush() {
      var self = this;

      if (!self.plot.brushCell) {
        return;
      }

      self.plot.brush.move(d3.select(self.plot.brushCell), null);
      self.svgG.selectAll("." + self.plot.hiddenClass).classed(self.plot.hiddenClass, false);
      self.plot.brushCell = null;
    }
  }]);

  return ScatterPlotMatrix;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.ScatterPlotMatrix = ScatterPlotMatrix;

},{"./chart-with-color-groups":45,"./d3":49,"./legend":55,"./scatterplot":59,"./utils":62}],59:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScatterPlot = exports.ScatterPlotConfig = void 0;

var _chartWithColorGroups = require("./chart-with-color-groups");

var _utils = require("./utils");

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var ScatterPlotConfig =
/*#__PURE__*/
function (_ChartWithColorGroups) {
  _inherits(ScatterPlotConfig, _ChartWithColorGroups); //show axis guides
  //show tooltip on dot hover


  function ScatterPlotConfig(custom) {
    var _this;

    _classCallCheck(this, ScatterPlotConfig);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlotConfig).call(this));
    _this.svgClass = _this.cssClassPrefix + 'scatterplot';
    _this.guides = false;
    _this.showTooltip = true;
    _this.x = {
      // X axis config
      title: '',
      // axis label
      key: 0,
      value: function value(d, key) {
        return d[key];
      },
      // x value accessor
      orient: "bottom",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.y = {
      // Y axis config
      title: '',
      // axis label,
      key: 1,
      value: function value(d, key) {
        return d[key];
      },
      // y value accessor
      orient: "left",
      scale: "linear",
      domainMargin: 0.05
    };
    _this.groups = {
      key: 2
    };
    _this.dotRadius = 2;

    _this.dotId = function (d, i) {
      return undefined;
    };

    _this.transition = true;

    _this.onDotHover = function (d, i) {};

    _this.onDotHoverOut = function (d, i) {};

    if (custom) {
      _utils.Utils.deepExtend(_assertThisInitialized(_assertThisInitialized(_this)), custom);
    }

    return _this;
  }

  return ScatterPlotConfig;
}(_chartWithColorGroups.ChartWithColorGroupsConfig);

exports.ScatterPlotConfig = ScatterPlotConfig;

var ScatterPlot =
/*#__PURE__*/
function (_ChartWithColorGroups2) {
  _inherits(ScatterPlot, _ChartWithColorGroups2);

  function ScatterPlot(placeholderSelector, data, config) {
    _classCallCheck(this, ScatterPlot);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScatterPlot).call(this, placeholderSelector, data, new ScatterPlotConfig(config)));
  }

  _createClass(ScatterPlot, [{
    key: "setConfig",
    value: function setConfig(config) {
      return _get(_getPrototypeOf(ScatterPlot.prototype), "setConfig", this).call(this, new ScatterPlotConfig(config));
    }
  }, {
    key: "initPlot",
    value: function initPlot() {
      _get(_getPrototypeOf(ScatterPlot.prototype), "initPlot", this).call(this);

      var self = this;
      var conf = this.config;
      this.plot.x = {};
      this.plot.y = {};
      this.computePlotSize();
      this.setupX();
      this.setupY();
      return this;
    }
  }, {
    key: "setupX",
    value: function setupX() {
      var plot = this.plot;
      var x = plot.x;
      var conf = this.config.x;
      /* *
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       **/

      x.value = function (d) {
        return conf.value(d, conf.key);
      };

      x.scale = _utils.Utils.createScale(conf.scale).range([0, plot.width]);

      x.map = function (d) {
        return x.scale(x.value(d));
      };

      x.axis = _utils.Utils.createAxis(conf.orient, x.scale);
      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.x.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.x.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.x.scale.domain(domain);

      if (this.config.guides) {
        x.axis.tickSize(-plot.height);
      }
    }
  }, {
    key: "setupY",
    value: function setupY() {
      var plot = this.plot;
      var y = plot.y;
      var conf = this.config.y;
      /*
       * value accessor - returns the value to encode for a given data object.
       * scale - maps value to a visual display encoding, such as a pixel position.
       * map function - maps from data value to display value
       * axis - sets up axis
       */

      y.value = function (d) {
        return conf.value(d, conf.key);
      };

      y.scale = _utils.Utils.createScale(conf.scale).range([plot.height, 0]);

      y.map = function (d) {
        return y.scale(y.value(d));
      };

      y.axis = _utils.Utils.createAxis(conf.orient, y.scale);

      if (this.config.guides) {
        y.axis.tickSize(-plot.width);
      }

      var data = this.plot.groupedData;
      var domain = [parseFloat(d3.min(data, function (s) {
        return d3.min(s.values, plot.y.value);
      })), parseFloat(d3.max(data, function (s) {
        return d3.max(s.values, plot.y.value);
      }))];
      var extent = domain[1] - domain[0] || 1;
      var margin = extent * conf.domainMargin;
      domain[0] -= margin;
      domain[1] += margin;
      plot.y.scale.domain(domain); // plot.y.scale.domain([d3.min(data, plot.y.value)-1, d3.max(data, plot.y.value)+1]);
    }
  }, {
    key: "drawAxisX",
    value: function drawAxisX() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.x;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-x') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides'))).attr("transform", "translate(0," + plot.height + ")");
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.x.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + plot.width / 2 + "," + plot.margin.bottom + ")") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "-1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "drawAxisY",
    value: function drawAxisY() {
      var self = this;
      var plot = self.plot;
      var axisConf = this.config.y;
      var axis = self.svgG.selectOrAppend("g." + self.prefixClass('axis-y') + "." + self.prefixClass('axis') + (self.config.guides ? '' : '.' + self.prefixClass('no-guides')));
      var axisT = axis;

      if (self.transitionEnabled()) {
        axisT = axis.transition().ease(d3.easeSinInOut);
      }

      axisT.call(plot.y.axis);
      axis.selectOrAppend("text." + self.prefixClass('label')).attr("transform", "translate(" + -plot.margin.left + "," + plot.height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate
      .attr("dy", "1em").style("text-anchor", "middle").text(axisConf.title);
    }
  }, {
    key: "update",
    value: function update(newData) {
      _get(_getPrototypeOf(ScatterPlot.prototype), "update", this).call(this, newData);

      this.drawAxisX();
      this.drawAxisY();
      this.updateDots();
    }
  }, {
    key: "updateDots",
    value: function updateDots() {
      var self = this;
      var plot = self.plot;
      var data = plot.data;
      var layerClass = self.prefixClass('layer');
      var dotClass = this.dotClass = self.prefixClass('dot');
      self.dotsContainerClass = self.prefixClass('dots-container');
      var dotsContainer = self.svgG.selectOrAppend("g." + self.dotsContainerClass);
      var layer = dotsContainer.selectAll("g." + layerClass).data(plot.groupedData);
      var layerEnter = layer.enter().appendSelector("g." + layerClass);
      var layerMerge = layerEnter.merge(layer);
      var dots = layerMerge.selectAll('.' + dotClass).data(function (d) {
        return d.values;
      });
      var dotsEnter = dots.enter().append("circle").attr("class", dotClass);
      var dotsMerge = dotsEnter.merge(dots);
      var dotsT = dotsMerge;

      if (self.transitionEnabled()) {
        dotsT = dotsMerge.transition();
      }

      dotsT.attr("r", self.config.dotRadius).attr("cx", plot.x.map).attr("cy", plot.y.map).attr("id", this.config.dotId);

      if (plot.tooltip) {
        dotsMerge.on("mouseover", function (d) {
          var html = "(" + plot.x.value(d) + ", " + plot.y.value(d) + ")";
          var group = self.config.groups ? self.config.groups.value.call(self.config, d) : null;

          if (group || group === 0) {
            group = plot.groupToLabel[group];
            html += "<br/>";
            var label = self.config.groups.label;

            if (label) {
              html += label + ": ";
            }

            html += group;
          }

          self.showTooltip(html);
        }).on("mouseout", function (d) {
          self.hideTooltip();
        });
      }

      dotsMerge.on("mouseover.onDotHover", this.config.onDotHover);
      dotsMerge.on("mouseout.onDotHoverOut", this.config.onDotHoverOut);

      if (plot.seriesColor) {
        layerMerge.style("fill", plot.seriesColor);
      } else if (plot.color) {
        dotsMerge.style("fill", plot.color);
      }

      dots.exit().remove();
      layer.exit().remove();
    }
  }]);

  return ScatterPlot;
}(_chartWithColorGroups.ChartWithColorGroups);

exports.ScatterPlot = ScatterPlot;

},{"./chart-with-color-groups":45,"./d3":49,"./utils":62}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tdistr = tdistr;
/*
 * https://gist.github.com/benrasmusen/1261977
 * NAME
 * 
 * statistics-distributions.js - JavaScript library for calculating
 *   critical values and upper probabilities of common statistical
 *   distributions
 * 
 * SYNOPSIS
 * 
 * 
 *   // Chi-squared-crit (2 degrees of freedom, 95th percentile = 0.05 level
 *   chisqrdistr(2, .05)
 *   
 *   // u-crit (95th percentile = 0.05 level)
 *   udistr(.05);
 *   
 *   // t-crit (1 degree of freedom, 99.5th percentile = 0.005 level) 
 *   tdistr(1,.005);
 *   
 *   // F-crit (1 degree of freedom in numerator, 3 degrees of freedom 
 *   //         in denominator, 99th percentile = 0.01 level)
 *   fdistr(1,3,.01);
 *   
 *   // upper probability of the u distribution (u = -0.85): Q(u) = 1-G(u)
 *   uprob(-0.85);
 *   
 *   // upper probability of the chi-square distribution
 *   // (3 degrees of freedom, chi-squared = 6.25): Q = 1-G
 *   chisqrprob(3,6.25);
 *   
 *   // upper probability of the t distribution
 *   // (3 degrees of freedom, t = 6.251): Q = 1-G
 *   tprob(3,6.251);
 *   
 *   // upper probability of the F distribution
 *   // (3 degrees of freedom in numerator, 5 degrees of freedom in
 *   //  denominator, F = 6.25): Q = 1-G
 *   fprob(3,5,.625);
 * 
 * 
 *  DESCRIPTION
 * 
 * This library calculates percentage points (5 significant digits) of the u
 * (standard normal) distribution, the student's t distribution, the
 * chi-square distribution and the F distribution. It can also calculate the
 * upper probability (5 significant digits) of the u (standard normal), the
 * chi-square, the t and the F distribution.
 * 
 * These critical values are needed to perform statistical tests, like the u
 * test, the t test, the F test and the chi-squared test, and to calculate
 * confidence intervals.
 * 
 * If you are interested in more precise algorithms you could look at:
 *   StatLib: http://lib.stat.cmu.edu/apstat/ ; 
 *   Applied Statistics Algorithms by Griffiths, P. and Hill, I.D.
 *   , Ellis Horwood: Chichester (1985)
 * 
 * BUGS 
 * 
 * This port was produced from the Perl module Statistics::Distributions
 * that has had no bug reports in several years.  If you find a bug then
 * please double-check that JavaScript does not thing the numbers you are
 * passing in are strings.  (You can subtract 0 from them as you pass them
 * in so that "5" is properly understood to be 5.)  If you have passed in a
 * number then please contact the author
 * 
 * AUTHOR
 * 
 * Ben Tilly <btilly@gmail.com>
 * 
 * Originl Perl version by Michael Kospach <mike.perl@gmx.at>
 * 
 * Nice formating, simplification and bug repair by Matthias Trautner Kromann
 * <mtk@id.cbs.dk>
 * 
 * COPYRIGHT 
 * 
 * Copyright 2008 Ben Tilly.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the same terms as Perl itself.  This means under either the Perl
 * Artistic License or the GPL v1 or later.
 */

var SIGNIFICANT = 5; // number of significant digits to be returned

function chisqrdistr($n, $p) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* degree of freedom */
  }

  if ($p <= 0 || $p > 1) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subchisqr($n - 0, $p - 0));
}

function udistr($p) {
  if ($p > 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subu($p - 0));
}

function tdistr($n, $p) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
  }

  if ($p <= 0 || $p >= 1) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subt($n - 0, $p - 0));
}

function fdistr($n, $m, $p) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* first degree of freedom */
  }

  if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {
    throw "Invalid m: $m\n";
    /* second degree of freedom */
  }

  if ($p <= 0 || $p > 1) {
    throw "Invalid p: $p\n";
  }

  return precision_string(_subf($n - 0, $m - 0, $p - 0));
}

function uprob($x) {
  return precision_string(_subuprob($x - 0));
}

function chisqrprob($n, $x) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* degree of freedom */
  }

  return precision_string(_subchisqrprob($n - 0, $x - 0));
}

function tprob($n, $x) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* degree of freedom */
  }

  return precision_string(_subtprob($n - 0, $x - 0));
}

function fprob($n, $m, $x) {
  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {
    throw "Invalid n: $n\n";
    /* first degree of freedom */
  }

  if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {
    throw "Invalid m: $m\n";
    /* second degree of freedom */
  }

  return precision_string(_subfprob($n - 0, $m - 0, $x - 0));
}

function _subfprob($n, $m, $x) {
  var $p;

  if ($x <= 0) {
    $p = 1;
  } else if ($m % 2 == 0) {
    var $z = $m / ($m + $n * $x);
    var $a = 1;

    for (var $i = $m - 2; $i >= 2; $i -= 2) {
      $a = 1 + ($n + $i - 2) / $i * $z * $a;
    }

    $p = 1 - Math.pow(1 - $z, $n / 2 * $a);
  } else if ($n % 2 == 0) {
    var $z = $n * $x / ($m + $n * $x);
    var $a = 1;

    for (var $i = $n - 2; $i >= 2; $i -= 2) {
      $a = 1 + ($m + $i - 2) / $i * $z * $a;
    }

    $p = Math.pow(1 - $z, $m / 2) * $a;
  } else {
    var $y = Math.atan2(Math.sqrt($n * $x / $m), 1);
    var $z = Math.pow(Math.sin($y), 2);
    var $a = $n == 1 ? 0 : 1;

    for (var $i = $n - 2; $i >= 3; $i -= 2) {
      $a = 1 + ($m + $i - 2) / $i * $z * $a;
    }

    var $b = Math.PI;

    for (var $i = 2; $i <= $m - 1; $i += 2) {
      $b *= ($i - 1) / $i;
    }

    var $p1 = 2 / $b * Math.sin($y) * Math.pow(Math.cos($y), $m) * $a;
    $z = Math.pow(Math.cos($y), 2);
    $a = $m == 1 ? 0 : 1;

    for (var $i = $m - 2; $i >= 3; $i -= 2) {
      $a = 1 + ($i - 1) / $i * $z * $a;
    }

    $p = max(0, $p1 + 1 - 2 * $y / Math.PI - 2 / Math.PI * Math.sin($y) * Math.cos($y) * $a);
  }

  return $p;
}

function _subchisqrprob($n, $x) {
  var $p;

  if ($x <= 0) {
    $p = 1;
  } else if ($n > 100) {
    $p = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));
  } else if ($x > 400) {
    $p = 0;
  } else {
    var $a;
    var $i;
    var $i1;

    if ($n % 2 != 0) {
      $p = 2 * _subuprob(Math.sqrt($x));
      $a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);
      $i1 = 1;
    } else {
      $p = $a = Math.exp(-$x / 2);
      $i1 = 2;
    }

    for ($i = $i1; $i <= $n - 2; $i += 2) {
      $a *= $x / $i;
      $p += $a;
    }
  }

  return $p;
}

function _subu($p) {
  var $y = -Math.log(4 * $p * (1 - $p));
  var $x = Math.sqrt($y * (1.570796288 + $y * (.03706987906 + $y * (-.8364353589E-3 + $y * (-.2250947176E-3 + $y * (.6841218299E-5 + $y * (0.5824238515E-5 + $y * (-.104527497E-5 + $y * (.8360937017E-7 + $y * (-.3231081277E-8 + $y * (.3657763036E-10 + $y * .6936233982E-12)))))))))));
  if ($p > .5) $x = -$x;
  return $x;
}

function _subuprob($x) {
  var $p = 0;
  /* if ($absx > 100) */

  var $absx = Math.abs($x);

  if ($absx < 1.9) {
    $p = Math.pow(1 + $absx * (.049867347 + $absx * (.0211410061 + $absx * (.0032776263 + $absx * (.0000380036 + $absx * (.0000488906 + $absx * .000005383))))), -16) / 2;
  } else if ($absx <= 100) {
    for (var $i = 18; $i >= 1; $i--) {
      $p = $i / ($absx + $p);
    }

    $p = Math.exp(-.5 * $absx * $absx) / Math.sqrt(2 * Math.PI) / ($absx + $p);
  }

  if ($x < 0) $p = 1 - $p;
  return $p;
}

function _subt($n, $p) {
  if ($p >= 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  }

  if ($p == 0.5) {
    return 0;
  } else if ($p < 0.5) {
    return -_subt($n, 1 - $p);
  }

  var $u = _subu($p);

  var $u2 = Math.pow($u, 2);
  var $a = ($u2 + 1) / 4;
  var $b = ((5 * $u2 + 16) * $u2 + 3) / 96;
  var $c = (((3 * $u2 + 19) * $u2 + 17) * $u2 - 15) / 384;
  var $d = ((((79 * $u2 + 776) * $u2 + 1482) * $u2 - 1920) * $u2 - 945) / 92160;
  var $e = (((((27 * $u2 + 339) * $u2 + 930) * $u2 - 1782) * $u2 - 765) * $u2 + 17955) / 368640;
  var $x = $u * (1 + ($a + ($b + ($c + ($d + $e / $n) / $n) / $n) / $n) / $n);

  if ($n <= Math.pow(log10($p), 2) + 3) {
    var $round;

    do {
      var $p1 = _subtprob($n, $x);

      var $n1 = $n + 1;
      var $delta = ($p1 - $p) / Math.exp(($n1 * Math.log($n1 / ($n + $x * $x)) + Math.log($n / $n1 / 2 / Math.PI) - 1 + (1 / $n1 - 1 / $n) / 6) / 2);
      $x += $delta;
      $round = round_to_precision($delta, Math.abs(integer(log10(Math.abs($x)) - 4)));
    } while ($x && $round != 0);
  }

  return $x;
}

function _subtprob($n, $x) {
  var $a;
  var $b;
  var $w = Math.atan2($x / Math.sqrt($n), 1);
  var $z = Math.pow(Math.cos($w), 2);
  var $y = 1;

  for (var $i = $n - 2; $i >= 2; $i -= 2) {
    $y = 1 + ($i - 1) / $i * $z * $y;
  }

  if ($n % 2 == 0) {
    $a = Math.sin($w) / 2;
    $b = .5;
  } else {
    $a = $n == 1 ? 0 : Math.sin($w) * Math.cos($w) / Math.PI;
    $b = .5 + $w / Math.PI;
  }

  return max(0, 1 - $b - $a * $y);
}

function _subf($n, $m, $p) {
  var $x;

  if ($p >= 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  }

  if ($p == 1) {
    $x = 0;
  } else if ($m == 1) {
    $x = 1 / Math.pow(_subt($n, 0.5 - $p / 2), 2);
  } else if ($n == 1) {
    $x = Math.pow(_subt($m, $p / 2), 2);
  } else if ($m == 2) {
    var $u = _subchisqr($m, 1 - $p);

    var $a = $m - 2;
    $x = 1 / ($u / $m * (1 + (($u - $a) / 2 + (((4 * $u - 11 * $a) * $u + $a * (7 * $m - 10)) / 24 + (((2 * $u - 10 * $a) * $u + $a * (17 * $m - 26)) * $u - $a * $a * (9 * $m - 6)) / 48 / $n) / $n) / $n));
  } else if ($n > $m) {
    $x = 1 / _subf2($m, $n, 1 - $p);
  } else {
    $x = _subf2($n, $m, $p);
  }

  return $x;
}

function _subf2($n, $m, $p) {
  var $u = _subchisqr($n, $p);

  var $n2 = $n - 2;
  var $x = $u / $n * (1 + (($u - $n2) / 2 + (((4 * $u - 11 * $n2) * $u + $n2 * (7 * $n - 10)) / 24 + (((2 * $u - 10 * $n2) * $u + $n2 * (17 * $n - 26)) * $u - $n2 * $n2 * (9 * $n - 6)) / 48 / $m) / $m) / $m);
  var $delta;

  do {
    var $z = Math.exp((($n + $m) * Math.log(($n + $m) / ($n * $x + $m)) + ($n - 2) * Math.log($x) + Math.log($n * $m / ($n + $m)) - Math.log(4 * Math.PI) - (1 / $n + 1 / $m - 1 / ($n + $m)) / 6) / 2);
    $delta = (_subfprob($n, $m, $x) - $p) / $z;
    $x += $delta;
  } while (Math.abs($delta) > 3e-4);

  return $x;
}

function _subchisqr($n, $p) {
  var $x;

  if ($p > 1 || $p <= 0) {
    throw "Invalid p: $p\n";
  } else if ($p == 1) {
    $x = 0;
  } else if ($n == 1) {
    $x = Math.pow(_subu($p / 2), 2);
  } else if ($n == 2) {
    $x = -2 * Math.log($p);
  } else {
    var $u = _subu($p);

    var $u2 = $u * $u;
    $x = max(0, $n + Math.sqrt(2 * $n) * $u + 2 / 3 * ($u2 - 1) + $u * ($u2 - 7) / 9 / Math.sqrt(2 * $n) - 2 / 405 / $n * ($u2 * (3 * $u2 + 7) - 16));

    if ($n <= 100) {
      var $x0;
      var $p1;
      var $z;

      do {
        $x0 = $x;

        if ($x < 0) {
          $p1 = 1;
        } else if ($n > 100) {
          $p1 = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));
        } else if ($x > 400) {
          $p1 = 0;
        } else {
          var $i0;
          var $a;

          if ($n % 2 != 0) {
            $p1 = 2 * _subuprob(Math.sqrt($x));
            $a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);
            $i0 = 1;
          } else {
            $p1 = $a = Math.exp(-$x / 2);
            $i0 = 2;
          }

          for (var $i = $i0; $i <= $n - 2; $i += 2) {
            $a *= $x / $i;
            $p1 += $a;
          }
        }

        $z = Math.exp((($n - 1) * Math.log($x / $n) - Math.log(4 * Math.PI * $x) + $n - $x - 1 / $n / 6) / 2);
        $x += ($p1 - $p) / $z;
        $x = round_to_precision($x, 5);
      } while ($n < 31 && Math.abs($x0 - $x) > 1e-4);
    }
  }

  return $x;
}

function log10($n) {
  return Math.log($n) / Math.log(10);
}

function max() {
  var $max = arguments[0];

  for (var $i = 0; i < arguments.length; i++) {
    if ($max < arguments[$i]) $max = arguments[$i];
  }

  return $max;
}

function min() {
  var $min = arguments[0];

  for (var $i = 0; i < arguments.length; i++) {
    if ($min > arguments[$i]) $min = arguments[$i];
  }

  return $min;
}

function precision($x) {
  return Math.abs(integer(log10(Math.abs($x)) - SIGNIFICANT));
}

function precision_string($x) {
  if ($x) {
    return round_to_precision($x, precision($x));
  } else {
    return "0";
  }
}

function round_to_precision($x, $p) {
  $x = $x * Math.pow(10, $p);
  $x = Math.round($x);
  return $x / Math.pow(10, $p);
}

function integer($i) {
  if ($i > 0) return Math.floor($i);else return Math.ceil($i);
}

},{}],61:[function(require,module,exports){
"use strict";

var _statisticsDistributions = require("./statistics-distributions");

var su = module.exports.StatisticsUtils = {};
su.sampleCorrelation = require('simple-statistics/src/sample_correlation');
su.linearRegression = require('simple-statistics/src/linear_regression');
su.linearRegressionLine = require('simple-statistics/src/linear_regression_line');
su.errorFunction = require('simple-statistics/src/error_function');
su.standardDeviation = require('simple-statistics/src/standard_deviation');
su.sampleStandardDeviation = require('simple-statistics/src/sample_standard_deviation');
su.variance = require('simple-statistics/src/variance');
su.mean = require('simple-statistics/src/mean');
su.zScore = require('simple-statistics/src/z_score');

su.standardError = function (arr) {
  return Math.sqrt(su.variance(arr) / (arr.length - 1));
};

su.quantile = require('simple-statistics/src/quantile');

su.tValue = function (degreesOfFreedom, criticalProbability) {
  //as in http://stattrek.com/online-calculator/t-distribution.aspx
  return (0, _statisticsDistributions.tdistr)(degreesOfFreedom, criticalProbability);
};

},{"./statistics-distributions":60,"simple-statistics/src/error_function":26,"simple-statistics/src/linear_regression":27,"simple-statistics/src/linear_regression_line":28,"simple-statistics/src/mean":29,"simple-statistics/src/quantile":30,"simple-statistics/src/sample_correlation":33,"simple-statistics/src/sample_standard_deviation":35,"simple-statistics/src/standard_deviation":37,"simple-statistics/src/variance":40,"simple-statistics/src/z_score":41}],62:[function(require,module,exports){
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Utils = void 0;

var d3 = _interopRequireWildcard(require("./d3"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Utils =
/*#__PURE__*/
function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: "deepExtend",
    // usage example deepExtend({}, objA, objB); => should work similar to $.extend(true, {}, objA, objB);
    value: function deepExtend(out) {
      var utils = this;
      var emptyOut = {};

      if (!out && arguments.length > 1 && Array.isArray(arguments[1])) {
        out = [];
      }

      out = out || {};

      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        if (!source) continue;

        for (var key in source) {
          if (!source.hasOwnProperty(key)) {
            continue;
          }

          var isArray = Array.isArray(out[key]);
          var isObject = utils.isObject(out[key]);
          var srcObj = utils.isObject(source[key]);

          if (isObject && !isArray && srcObj) {
            utils.deepExtend(out[key], source[key]);
          } else {
            out[key] = source[key];
          }
        }
      }

      return out;
    }
  }, {
    key: "mergeDeep",
    value: function mergeDeep(target, source) {
      var output = Object.assign({}, target);

      if (Utils.isObjectNotArray(target) && Utils.isObjectNotArray(source)) {
        Object.keys(source).forEach(function (key) {
          if (Utils.isObjectNotArray(source[key])) {
            if (!(key in target)) Object.assign(output, _defineProperty({}, key, source[key]));else output[key] = Utils.mergeDeep(target[key], source[key]);
          } else {
            Object.assign(output, _defineProperty({}, key, source[key]));
          }
        });
      }

      return output;
    }
  }, {
    key: "cross",
    value: function cross(a, b) {
      var c = [],
          n = a.length,
          m = b.length,
          i,
          j;

      for (i = -1; ++i < n;) {
        for (j = -1; ++j < m;) {
          c.push({
            x: a[i],
            i: i,
            y: b[j],
            j: j
          });
        }
      }

      return c;
    }
  }, {
    key: "inferVariables",
    value: function inferVariables(data, groupKey, includeGroup) {
      var res = [];

      if (!data) {
        return res;
      }

      if (data.length) {
        var d = data[0];

        if (d instanceof Array) {
          res = d.map(function (v, i) {
            return i;
          });
        } else if (_typeof(d) === 'object') {
          for (var prop in d) {
            if (!d.hasOwnProperty(prop)) continue;
            res.push(prop);
          }
        }
      }

      if (groupKey !== null && groupKey !== undefined && !includeGroup) {
        var index = res.indexOf(groupKey);

        if (index > -1) {
          res.splice(index, 1);
        }
      }

      return res;
    }
  }, {
    key: "isObjectNotArray",
    value: function isObjectNotArray(item) {
      return item && _typeof(item) === 'object' && !Array.isArray(item) && item !== null;
    }
  }, {
    key: "isArray",
    value: function isArray(item) {
      return Array.isArray(item);
    }
  }, {
    key: "isObject",
    value: function isObject(a) {
      return a !== null && _typeof(a) === 'object';
    }
  }, {
    key: "isNumber",
    value: function isNumber(a) {
      return !isNaN(a) && typeof a === 'number';
    }
  }, {
    key: "isFunction",
    value: function isFunction(a) {
      return typeof a === 'function';
    }
  }, {
    key: "isDate",
    value: function isDate(a) {
      return Object.prototype.toString.call(a) === '[object Date]';
    }
  }, {
    key: "isString",
    value: function isString(a) {
      return typeof a === 'string' || a instanceof String;
    }
  }, {
    key: "insertOrAppendSelector",
    value: function insertOrAppendSelector(parent, selector, operation, before) {
      var selectorParts = selector.split(/([\.\#])/);
      var element = parent[operation](selectorParts.shift(), before); //":first-child"

      while (selectorParts.length > 1) {
        var selectorModifier = selectorParts.shift();
        var selectorItem = selectorParts.shift();

        if (selectorModifier === ".") {
          element = element.classed(selectorItem, true);
        } else if (selectorModifier === "#") {
          element = element.attr('id', selectorItem);
        }
      }

      return element;
    }
  }, {
    key: "insertSelector",
    value: function insertSelector(parent, selector, before) {
      return Utils.insertOrAppendSelector(parent, selector, "insert", before);
    }
  }, {
    key: "appendSelector",
    value: function appendSelector(parent, selector) {
      return Utils.insertOrAppendSelector(parent, selector, "append");
    }
  }, {
    key: "selectOrAppend",
    value: function selectOrAppend(parent, selector, element) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        if (element) {
          return parent.append(element);
        }

        return Utils.appendSelector(parent, selector);
      }

      return selection;
    }
  }, {
    key: "selectOrInsert",
    value: function selectOrInsert(parent, selector, before) {
      var selection = parent.select(selector);

      if (selection.empty()) {
        return Utils.insertSelector(parent, selector, before);
      }

      return selection;
    }
  }, {
    key: "linearGradient",
    value: function linearGradient(svg, gradientId, range, x1, y1, x2, y2) {
      var defs = Utils.selectOrAppend(svg, "defs");
      var linearGradient = defs.append("linearGradient").attr("id", gradientId);
      linearGradient.attr("x1", x1 + "%").attr("y1", y1 + "%").attr("x2", x2 + "%").attr("y2", y2 + "%"); //Append multiple color stops by using D3's data/enter step

      var stops = linearGradient.selectAll("stop").data(range);
      var stopsMerge = stops.enter().append("stop").merge(stops);
      stopsMerge.attr("offset", function (d, i) {
        return i / (range.length - 1);
      }).attr("stop-color", function (d) {
        return d;
      });
      stops.exit().remove();
    }
  }, {
    key: "guid",
    value: function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    } //places textString in textObj, adds an ellipsis if text can't fit in width

  }, {
    key: "placeTextWithEllipsis",
    value: function placeTextWithEllipsis(textD3Obj, textString, width) {
      var textObj = textD3Obj.node();
      textObj.textContent = textString;
      var margin = 0;
      var ellipsisLength = 9; //ellipsis is needed

      if (textObj.getComputedTextLength() > width + margin) {
        for (var x = textString.length - 3; x > 0; x -= 1) {
          if (textObj.getSubStringLength(0, x) + ellipsisLength <= width + margin) {
            textObj.textContent = textString.substring(0, x) + "...";
            return true;
          }
        }

        textObj.textContent = "..."; //can't place at all

        return true;
      }

      return false;
    }
  }, {
    key: "placeTextWithEllipsisAndTooltip",
    value: function placeTextWithEllipsisAndTooltip(textD3Obj, textString, width, tooltip) {
      var ellipsisPlaced = Utils.placeTextWithEllipsis(textD3Obj, textString, width);

      if (ellipsisPlaced && tooltip) {
        textD3Obj.on("mouseover", function (d) {
          tooltip.transition().duration(200).style("opacity", .9);
          tooltip.html(textString).style("left", d3.event.pageX + 5 + "px").style("top", d3.event.pageY - 28 + "px");
        });
        textD3Obj.on("mouseout", function (d) {
          tooltip.transition().duration(500).style("opacity", 0);
        });
      }
    }
  }, {
    key: "getFontSize",
    value: function getFontSize(element) {
      return window.getComputedStyle(element, null).getPropertyValue("font-size");
    }
  }, {
    key: "capitalizeFirstLetter",
    value: function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
  }, {
    key: "createScale",
    value: function createScale(scaleName) {
      var scaleFunctionName = 'scale' + Utils.capitalizeFirstLetter(scaleName);

      try {
        return d3[scaleFunctionName]();
      } catch (e) {
        throw 'ODC-D3 - scale not supported: ' + scaleName + ' (' + scaleFunctionName + ')';
      }
    }
  }, {
    key: "createAxis",
    value: function createAxis(orient, scale) {
      var axisFnName = 'axis' + Utils.capitalizeFirstLetter(orient);

      try {
        return d3[axisFnName](scale);
      } catch (e) {
        throw 'ODC-D3 - axis orient not supported: ' + orient;
      }
    }
  }]);

  return Utils;
}();

exports.Utils = Utils;
Utils.SQRT_2 = 1.41421356237;

Utils.sanitizeHeight = function (height, container) {
  return height || parseInt(container.style('height'), 10) || 400;
};

Utils.sanitizeWidth = function (width, container) {
  return width || parseInt(container.style('width'), 10) || 960;
};

Utils.availableHeight = function (height, container, margin) {
  return Math.max(0, Utils.sanitizeHeight(height, container) - margin.top - margin.bottom);
};

Utils.availableWidth = function (width, container, margin) {
  return Math.max(0, Utils.sanitizeWidth(width, container) - margin.left - margin.right);
};

},{"./d3":49}]},{},[54])(54)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMtYXJyYXkvZGlzdC9kMy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9kMy1heGlzL2Rpc3QvZDMtYXhpcy5qcyIsIm5vZGVfbW9kdWxlcy9kMy1icnVzaC9kaXN0L2QzLWJydXNoLmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbGxlY3Rpb24vZGlzdC9kMy1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2Rpc3QvZDMtY29sb3IuanMiLCJub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvZGlzdC9kMy1kaXNwYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1kcmFnL2Rpc3QvZDMtZHJhZy5qcyIsIm5vZGVfbW9kdWxlcy9kMy1lYXNlL2Rpc3QvZDMtZWFzZS5qcyIsIm5vZGVfbW9kdWxlcy9kMy1mb3JtYXQvZGlzdC9kMy1mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzIiwibm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL2Rpc3QvZDMtaW50ZXJwb2xhdGUuanMiLCJub2RlX21vZHVsZXMvZDMtcGF0aC9kaXN0L2QzLXBhdGguanMiLCJub2RlX21vZHVsZXMvZDMtc2NhbGUvYnVpbGQvZDMtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL2Rpc3QvZDMtc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLXNoYXBlL2Rpc3QvZDMtc2hhcGUuanMiLCJub2RlX21vZHVsZXMvZDMtc3ZnLWxlZ2VuZC9pbmRleFJvbGx1cC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1zdmctbGVnZW5kL25vZGVfbW9kdWxlcy9kMy1hcnJheS9idWlsZC9kMy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9kMy1zdmctbGVnZW5kL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9idWlsZC9kMy1kaXNwYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1zdmctbGVnZW5kL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvYnVpbGQvZDMtZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2QzLXN2Zy1sZWdlbmQvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL2J1aWxkL2QzLXNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2QzLXN2Zy1sZWdlbmQvbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9idWlsZC9kMy1zZWxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvZGlzdC9kMy10aW1lLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lL2Rpc3QvZDMtdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lci9kaXN0L2QzLXRpbWVyLmpzIiwibm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vZGlzdC9kMy10cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9lcnJvcl9mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvbGluZWFyX3JlZ3Jlc3Npb24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2xpbmVhcl9yZWdyZXNzaW9uX2xpbmUuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL21lYW4uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3F1YW50aWxlLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9xdWFudGlsZV9zb3J0ZWQuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3F1aWNrc2VsZWN0LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zYW1wbGVfY29ycmVsYXRpb24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3NhbXBsZV9jb3ZhcmlhbmNlLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zYW1wbGVfc3RhbmRhcmRfZGV2aWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zYW1wbGVfdmFyaWFuY2UuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3N0YW5kYXJkX2RldmlhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9zcmMvc3VtLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zdW1fbnRoX3Bvd2VyX2RldmlhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3ZhcmlhbmNlLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL3NyYy96X3Njb3JlLmpzIiwic3JjL2Jhci1jaGFydC5qcyIsInNyYy9ib3gtcGxvdC1iYXNlLmpzIiwic3JjL2JveC1wbG90LmpzIiwic3JjL2NoYXJ0LXdpdGgtY29sb3ItZ3JvdXBzLmpzIiwic3JjL2NoYXJ0LmpzIiwic3JjL2NvcnJlbGF0aW9uLW1hdHJpeC5qcyIsInNyYy9kMy1leHRlbnNpb25zLmpzIiwic3JjL2QzLmpzIiwic3JjL2RpdmVyZ2luZy1zdGFja2VkLWJhci1jaGFydC5qcyIsInNyYy9oZWF0bWFwLXRpbWVzZXJpZXMuanMiLCJzcmMvaGVhdG1hcC5qcyIsInNyYy9oaXN0b2dyYW0uanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbGVnZW5kLmpzIiwic3JjL2xpbmUtY2hhcnQuanMiLCJzcmMvcmVncmVzc2lvbi5qcyIsInNyYy9zY2F0dGVycGxvdC1tYXRyaXguanMiLCJzcmMvc2NhdHRlcnBsb3QuanMiLCJzcmMvc3RhdGlzdGljcy1kaXN0cmlidXRpb25zLmpzIiwic3JjL3N0YXRpc3RpY3MtdXRpbHMuanMiLCJzcmMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ24rQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1L0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcjRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ254QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBLElBQUEscUJBQUEsR0FBQSxPQUFBLENBQUEsMkJBQUEsQ0FBQTs7QUFDQSxJQUFBLE1BQUEsR0FBQSxPQUFBLENBQUEsU0FBQSxDQUFBOztBQUNBLElBQUEsT0FBQSxHQUFBLE9BQUEsQ0FBQSxVQUFBLENBQUE7O0FBQ0EsSUFBQSxFQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBLENBQUEsTUFBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUE7O0FBQ0EsSUFBQSxRQUFBLEdBQUEsT0FBQSxDQUFBLFVBQUEsQ0FBQTs7QUFBQSxNQUFBLENBQUEsSUFBQSxDQUFBLFFBQUEsRUFBQSxPQUFBLENBQUEsVUFBQSxHQUFBLEVBQUE7QUFBQSxNQUFBLEdBQUEsS0FBQSxTQUFBLElBQUEsR0FBQSxLQUFBLFlBQUEsRUFBQTtBQUFBLEVBQUEsTUFBQSxDQUFBLGNBQUEsQ0FBQSxPQUFBLEVBQUEsR0FBQSxFQUFBO0FBQUEsSUFBQSxVQUFBLEVBQUEsSUFBQTtBQUFBLElBQUEsR0FBQSxFQUFBLFNBQUEsR0FBQSxHQUFBO0FBQUEsYUFBQSxRQUFBLENBQUEsR0FBQSxDQUFBO0FBQUE7QUFBQSxHQUFBO0FBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsR0FBQSxPQUFBLENBQUEsY0FBQSxDQUFBOztBQUFBLE1BQUEsQ0FBQSxJQUFBLENBQUEsWUFBQSxFQUFBLE9BQUEsQ0FBQSxVQUFBLEdBQUEsRUFBQTtBQUFBLE1BQUEsR0FBQSxLQUFBLFNBQUEsSUFBQSxHQUFBLEtBQUEsWUFBQSxFQUFBO0FBQUEsRUFBQSxNQUFBLENBQUEsY0FBQSxDQUFBLE9BQUEsRUFBQSxHQUFBLEVBQUE7QUFBQSxJQUFBLFVBQUEsRUFBQSxJQUFBO0FBQUEsSUFBQSxHQUFBLEVBQUEsU0FBQSxHQUFBLEdBQUE7QUFBQSxhQUFBLFlBQUEsQ0FBQSxHQUFBLENBQUE7QUFBQTtBQUFBLEdBQUE7QUFBQSxDQUFBOztBQUNBLElBQUEsUUFBQSxHQUFBLE9BQUEsQ0FBQSxVQUFBLENBQUE7O0FBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxRQUFBLEVBQUEsT0FBQSxDQUFBLFVBQUEsR0FBQSxFQUFBO0FBQUEsTUFBQSxHQUFBLEtBQUEsU0FBQSxJQUFBLEdBQUEsS0FBQSxZQUFBLEVBQUE7QUFBQSxFQUFBLE1BQUEsQ0FBQSxjQUFBLENBQUEsT0FBQSxFQUFBLEdBQUEsRUFBQTtBQUFBLElBQUEsVUFBQSxFQUFBLElBQUE7QUFBQSxJQUFBLEdBQUEsRUFBQSxTQUFBLEdBQUEsR0FBQTtBQUFBLGFBQUEsUUFBQSxDQUFBLEdBQUEsQ0FBQTtBQUFBO0FBQUEsR0FBQTtBQUFBLENBQUE7O0FBQ0EsSUFBQSxPQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7QUFBQSxNQUFBLENBQUEsSUFBQSxDQUFBLE9BQUEsRUFBQSxPQUFBLENBQUEsVUFBQSxHQUFBLEVBQUE7QUFBQSxNQUFBLEdBQUEsS0FBQSxTQUFBLElBQUEsR0FBQSxLQUFBLFlBQUEsRUFBQTtBQUFBLEVBQUEsTUFBQSxDQUFBLGNBQUEsQ0FBQSxPQUFBLEVBQUEsR0FBQSxFQUFBO0FBQUEsSUFBQSxVQUFBLEVBQUEsSUFBQTtBQUFBLElBQUEsR0FBQSxFQUFBLFNBQUEsR0FBQSxHQUFBO0FBQUEsYUFBQSxPQUFBLENBQUEsR0FBQSxDQUFBO0FBQUE7QUFBQSxHQUFBO0FBQUEsQ0FBQTs7QUFDQSxJQUFBLFFBQUEsR0FBQSxPQUFBLENBQUEsVUFBQSxDQUFBOztBQUFBLE1BQUEsQ0FBQSxJQUFBLENBQUEsUUFBQSxFQUFBLE9BQUEsQ0FBQSxVQUFBLEdBQUEsRUFBQTtBQUFBLE1BQUEsR0FBQSxLQUFBLFNBQUEsSUFBQSxHQUFBLEtBQUEsWUFBQSxFQUFBO0FBQUEsRUFBQSxNQUFBLENBQUEsY0FBQSxDQUFBLE9BQUEsRUFBQSxHQUFBLEVBQUE7QUFBQSxJQUFBLFVBQUEsRUFBQSxJQUFBO0FBQUEsSUFBQSxHQUFBLEVBQUEsU0FBQSxHQUFBLEdBQUE7QUFBQSxhQUFBLFFBQUEsQ0FBQSxHQUFBLENBQUE7QUFBQTtBQUFBLEdBQUE7QUFBQSxDQUFBOztBQUNBLElBQUEsUUFBQSxHQUFBLE9BQUEsQ0FBQSxVQUFBLENBQUE7O0FBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxRQUFBLEVBQUEsT0FBQSxDQUFBLFVBQUEsR0FBQSxFQUFBO0FBQUEsTUFBQSxHQUFBLEtBQUEsU0FBQSxJQUFBLEdBQUEsS0FBQSxZQUFBLEVBQUE7QUFBQSxFQUFBLE1BQUEsQ0FBQSxjQUFBLENBQUEsT0FBQSxFQUFBLEdBQUEsRUFBQTtBQUFBLElBQUEsVUFBQSxFQUFBLElBQUE7QUFBQSxJQUFBLEdBQUEsRUFBQSxTQUFBLEdBQUEsR0FBQTtBQUFBLGFBQUEsUUFBQSxDQUFBLEdBQUEsQ0FBQTtBQUFBO0FBQUEsR0FBQTtBQUFBLENBQUE7O0FBQ0EsSUFBQSxZQUFBLEdBQUEsT0FBQSxDQUFBLGNBQUEsQ0FBQTs7QUFBQSxNQUFBLENBQUEsSUFBQSxDQUFBLFlBQUEsRUFBQSxPQUFBLENBQUEsVUFBQSxHQUFBLEVBQUE7QUFBQSxNQUFBLEdBQUEsS0FBQSxTQUFBLElBQUEsR0FBQSxLQUFBLFlBQUEsRUFBQTtBQUFBLEVBQUEsTUFBQSxDQUFBLGNBQUEsQ0FBQSxPQUFBLEVBQUEsR0FBQSxFQUFBO0FBQUEsSUFBQSxVQUFBLEVBQUEsSUFBQTtBQUFBLElBQUEsR0FBQSxFQUFBLFNBQUEsR0FBQSxHQUFBO0FBQUEsYUFBQSxZQUFBLENBQUEsR0FBQSxDQUFBO0FBQUE7QUFBQSxHQUFBO0FBQUEsQ0FBQTs7QUFDQSxJQUFBLGFBQUEsR0FBQSxPQUFBLENBQUEsZ0JBQUEsQ0FBQTs7QUFBQSxNQUFBLENBQUEsSUFBQSxDQUFBLGFBQUEsRUFBQSxPQUFBLENBQUEsVUFBQSxHQUFBLEVBQUE7QUFBQSxNQUFBLEdBQUEsS0FBQSxTQUFBLElBQUEsR0FBQSxLQUFBLFlBQUEsRUFBQTtBQUFBLEVBQUEsTUFBQSxDQUFBLGNBQUEsQ0FBQSxPQUFBLEVBQUEsR0FBQSxFQUFBO0FBQUEsSUFBQSxVQUFBLEVBQUEsSUFBQTtBQUFBLElBQUEsR0FBQSxFQUFBLFNBQUEsR0FBQSxHQUFBO0FBQUEsYUFBQSxhQUFBLENBQUEsR0FBQSxDQUFBO0FBQUE7QUFBQSxHQUFBO0FBQUEsQ0FBQTs7QUFDQSxJQUFBLGFBQUEsR0FBQSxPQUFBLENBQUEsZUFBQSxDQUFBOztBQUFBLE1BQUEsQ0FBQSxJQUFBLENBQUEsYUFBQSxFQUFBLE9BQUEsQ0FBQSxVQUFBLEdBQUEsRUFBQTtBQUFBLE1BQUEsR0FBQSxLQUFBLFNBQUEsSUFBQSxHQUFBLEtBQUEsWUFBQSxFQUFBO0FBQUEsRUFBQSxNQUFBLENBQUEsY0FBQSxDQUFBLE9BQUEsRUFBQSxHQUFBLEVBQUE7QUFBQSxJQUFBLFVBQUEsRUFBQSxJQUFBO0FBQUEsSUFBQSxHQUFBLEVBQUEsU0FBQSxHQUFBLEdBQUE7QUFBQSxhQUFBLGFBQUEsQ0FBQSxHQUFBLENBQUE7QUFBQTtBQUFBLEdBQUE7QUFBQSxDQUFBOztBQUNBLElBQUEsT0FBQSxHQUFBLE9BQUEsQ0FBQSxTQUFBLENBQUE7O0FBQUEsTUFBQSxDQUFBLElBQUEsQ0FBQSxPQUFBLEVBQUEsT0FBQSxDQUFBLFVBQUEsR0FBQSxFQUFBO0FBQUEsTUFBQSxHQUFBLEtBQUEsU0FBQSxJQUFBLEdBQUEsS0FBQSxZQUFBLEVBQUE7QUFBQSxFQUFBLE1BQUEsQ0FBQSxjQUFBLENBQUEsT0FBQSxFQUFBLEdBQUEsRUFBQTtBQUFBLElBQUEsVUFBQSxFQUFBLElBQUE7QUFBQSxJQUFBLEdBQUEsRUFBQSxTQUFBLEdBQUEsR0FBQTtBQUFBLGFBQUEsT0FBQSxDQUFBLEdBQUEsQ0FBQTtBQUFBO0FBQUEsR0FBQTtBQUFBLENBQUE7O0FBQ0EsSUFBQSxPQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7QUFBQSxNQUFBLENBQUEsSUFBQSxDQUFBLE9BQUEsRUFBQSxPQUFBLENBQUEsVUFBQSxHQUFBLEVBQUE7QUFBQSxNQUFBLEdBQUEsS0FBQSxTQUFBLElBQUEsR0FBQSxLQUFBLFlBQUEsRUFBQTtBQUFBLEVBQUEsTUFBQSxDQUFBLGNBQUEsQ0FBQSxPQUFBLEVBQUEsR0FBQSxFQUFBO0FBQUEsSUFBQSxVQUFBLEVBQUEsSUFBQTtBQUFBLElBQUEsR0FBQSxFQUFBLFNBQUEsR0FBQSxHQUFBO0FBQUEsYUFBQSxPQUFBLENBQUEsR0FBQSxDQUFBO0FBQUE7QUFBQSxHQUFBO0FBQUEsQ0FBQTs7Ozs7Ozs7Ozs7O0FDWEEsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7QUFDQSxJQUFBLE1BQUEsR0FBQSxPQUFBLENBQUEsU0FBQSxDQUFBOztBQUNBLElBQUEsT0FBQSxH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Q0FBSixJQUFBLENBQVIsQ0FBQTtBQUNBLFVBQUksQ0FBQyxHQUFHLElBQUksQ0FBSixJQUFBLENBQVIsQ0FBQTtBQUNBLFVBQUksQ0FBQyxHQUFHLElBQUksQ0FBSixJQUFBLENBQVIsQ0FBQTs7QUFHQSxNQUFBLENBQUMsQ0FBRCxLQUFBLEdBQVUsVUFBQSxDQUFBLEVBQUM7QUFBQSxlQUFJLE1BQU0sQ0FBTixDQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLEVBQUosQ0FBSSxDQUFKO0FBQVgsT0FBQTs7QUFDQSxNQUFBLENBQUMsQ0FBRCxLQUFBLEdBQVUsVUFBQSxDQUFBLEVBQUM7QUFBQSxlQUFJLE1BQU0sQ0FBTixDQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLEVBQUosQ0FBSSxDQUFKO0FBQVgsT0FBQTs7QUFDQSxNQUFBLENBQUMsQ0FBRCxLQUFBLEdBQVUsVUFBQSxDQUFBLEVBQUM7QUFBQSxlQUFJLE1BQU0sQ0FBTixDQUFBLENBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLEVBQUosQ0FBSSxDQUFKO0FBQVgsT0FBQTs7QUFFQSxNQUFBLENBQUMsQ0FBRCxZQUFBLEdBQUEsRUFBQTtBQUNBLE1BQUEsQ0FBQyxDQUFELFlBQUEsR0FBQSxFQUFBO0FBR0EsTUFBQSxJQUFJLENBQUosSUFBQSxDQUFBLFFBQUEsR0FBcUIsQ0FBQyxDQUFDLE1BQU0sQ0FBTixDQUFBLENBQUEsTUFBQSxDQUFBLElBQUEsQ0FBdkIsTUFBQTtBQUNBLE1BQUEsSUFBSSxDQUFKLElBQUEsQ0FBQSxRQUFBLEdBQXFCLENBQUMsQ0FBQyxNQUFNLENBQU4sQ0FBQSxDQUFBLE1BQUEsQ0FBQSxJQUFBLENBQXZCLE1BQUE7QUFFQSxNQUFBLENBQUMsQ0FBRCxNQUFBLEdBQVc7QUFDUCxRQUFBLEdBQUcsRUFESSxTQUFBO0FBRVAsUUFBQSxLQUFLLEVBRkUsRUFBQTtBQUdQLFFBQUEsTUFBTSxFQUhDLEVBQUE7QUFJUCxRQUFBLFFBQVEsRUFKRCxJQUFBO0FBS1AsUUFBQSxLQUFLLEVB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LEVBQUEsRUFBQSxFQUFBLEVBQXdCO0FBRXZCLE1BQUksRUFBRSxJQUFGLENBQUEsSUFBVyxFQUFFLElBQWpCLENBQUEsRUFBd0I7QUFDdkIsVUFBQSxpQkFBQTtBQUNBOztBQUVELE1BQUksRUFBRSxJQUFOLEdBQUEsRUFBZTtBQUNkLFdBQUEsQ0FBQTtBQURELEdBQUEsTUFFTyxJQUFJLEVBQUUsR0FBTixHQUFBLEVBQWM7QUFDcEIsV0FBTyxDQUFFLEtBQUssQ0FBQSxFQUFBLEVBQUssSUFBbkIsRUFBYyxDQUFkO0FBQ0E7O0FBRUQsTUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFkLEVBQWMsQ0FBZDs7QUFDQSxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUosR0FBQSxDQUFBLEVBQUEsRUFBVixDQUFVLENBQVY7QUFFQSxNQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBSixDQUFBLElBQVQsQ0FBQTtBQUNBLE1BQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFBLEdBQUEsR0FBRCxFQUFBLElBQUEsR0FBQSxHQUFELENBQUEsSUFBVCxFQUFBO0FBQ0EsTUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBQSxHQUFBLEdBQUQsRUFBQSxJQUFBLEdBQUEsR0FBRCxFQUFBLElBQUEsR0FBQSxHQUFELEVBQUEsSUFBVCxHQUFBO0FBQ0EsTUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFBLEdBQUEsR0FBRCxHQUFBLElBQUEsR0FBQSxHQUFELElBQUEsSUFBQSxHQUFBLEdBQUQsSUFBQSxJQUFBLEdBQUEsR0FBRCxHQUFBLElBQVQsS0FBQTtBQUVBLE1BQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFBLEdBQUEsR0FBRCxHQUFBLElBQUEsR0FBQSxHQUFELEdBQUEsSUFBQSxHQUFBLEdBQUQsSUFBQSxJQUFBLEdBQUEsR0FBRCxHQUFBLElBQUEsR0FBQSxHQUFELEtBQUEsSUFBVCxNQUFBO0FBR0EsTUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FB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QU0sQ0FBOUMsSUFBQSxHQUFzRCxNQUFNLENBQS9FLEtBQU8sQ0FBUDtDQXhNSyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtYXJyYXkvIHYxLjIuNCBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBiaXNlY3Rvcihjb21wYXJlKSB7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoY29tcGFyZSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7XG4gICAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiBmdW5jdGlvbihkLCB4KSB7XG4gICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgfTtcbn1cblxudmFyIGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG52YXIgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG52YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuXG5mdW5jdGlvbiBwYWlycyhhcnJheSwgZikge1xuICBpZiAoZiA9PSBudWxsKSBmID0gcGFpcjtcbiAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcCA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IGYocCwgcCA9IGFycmF5WysraV0pO1xuICByZXR1cm4gcGFpcnM7XG59XG5cbmZ1bmN0aW9uIHBhaXIoYSwgYikge1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG5mdW5jdGlvbiBjcm9zcyh2YWx1ZXMwLCB2YWx1ZXMxLCByZWR1Y2UpIHtcbiAgdmFyIG4wID0gdmFsdWVzMC5sZW5ndGgsXG4gICAgICBuMSA9IHZhbHVlczEubGVuZ3RoLFxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4wICogbjEpLFxuICAgICAgaTAsXG4gICAgICBpMSxcbiAgICAgIGksXG4gICAgICB2YWx1ZTA7XG5cbiAgaWYgKHJlZHVjZSA9PSBudWxsKSByZWR1Y2UgPSBwYWlyO1xuXG4gIGZvciAoaTAgPSBpID0gMDsgaTAgPCBuMDsgKytpMCkge1xuICAgIGZvciAodmFsdWUwID0gdmFsdWVzMFtpMF0sIGkxID0gMDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWR1Y2UodmFsdWUwLCB2YWx1ZXMxW2kxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cblxuZnVuY3Rpb24gdmFyaWFuY2UodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG0gPSAwLFxuICAgICAgaSA9IC0xLFxuICAgICAgbWVhbiA9IDAsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRlbHRhLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtID4gMSkgcmV0dXJuIHN1bSAvIChtIC0gMSk7XG59XG5cbmZ1bmN0aW9uIGRldmlhdGlvbihhcnJheSwgZikge1xuICB2YXIgdiA9IHZhcmlhbmNlKGFycmF5LCBmKTtcbiAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xufVxuXG5mdW5jdGlvbiBleHRlbnQodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWluLFxuICAgICAgbWF4O1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbnZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG52YXIgbWFwID0gYXJyYXkubWFwO1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG52YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgcmV2ZXJzZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4sXG4gICAgICB0aWNrcyxcbiAgICAgIHN0ZXA7XG5cbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIGlmIChzdGFydCA9PT0gc3RvcCAmJiBjb3VudCA+IDApIHJldHVybiBbc3RhcnRdO1xuICBpZiAocmV2ZXJzZSA9IHN0b3AgPCBzdGFydCkgbiA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBuO1xuICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSkgcmV0dXJuIFtdO1xuXG4gIGlmIChzdGVwID4gMCkge1xuICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCk7XG4gICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RvcCAtIHN0YXJ0ICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgKiBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgKiBzdGVwKTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0YXJ0IC0gc3RvcCArIDEpKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAoc3RhcnQgLSBpKSAvIHN0ZXA7XG4gIH1cblxuICBpZiAocmV2ZXJzZSkgdGlja3MucmV2ZXJzZSgpO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG59XG5cbmZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgc3RlcDAgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgc3RlcDEgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwMCkgLyBNYXRoLkxOMTApKSxcbiAgICAgIGVycm9yID0gc3RlcDAgLyBzdGVwMTtcbiAgaWYgKGVycm9yID49IGUxMCkgc3RlcDEgKj0gMTA7XG4gIGVsc2UgaWYgKGVycm9yID49IGU1KSBzdGVwMSAqPSA1O1xuICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcDEgKj0gMjtcbiAgcmV0dXJuIHN0b3AgPCBzdGFydCA/IC1zdGVwMSA6IHN0ZXAxO1xufVxuXG5mdW5jdGlvbiBzdHVyZ2VzKHZhbHVlcykge1xuICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIpICsgMTtcbn1cblxuZnVuY3Rpb24gaGlzdG9ncmFtKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgIGRvbWFpbiA9IGV4dGVudCxcbiAgICAgIHRocmVzaG9sZCA9IHN0dXJnZXM7XG5cbiAgZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICB4LFxuICAgICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkobik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgeHogPSBkb21haW4odmFsdWVzKSxcbiAgICAgICAgeDAgPSB4elswXSxcbiAgICAgICAgeDEgPSB4elsxXSxcbiAgICAgICAgdHogPSB0aHJlc2hvbGQodmFsdWVzLCB4MCwgeDEpO1xuXG4gICAgLy8gQ29udmVydCBudW1iZXIgb2YgdGhyZXNob2xkcyBpbnRvIHVuaWZvcm0gdGhyZXNob2xkcy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XG4gICAgICB0eiA9IHRpY2tTdGVwKHgwLCB4MSwgdHopO1xuICAgICAgdHogPSByYW5nZShNYXRoLmNlaWwoeDAgLyB0eikgKiB0eiwgeDEsIHR6KTsgLy8gZXhjbHVzaXZlXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSB0aHJlc2hvbGRzIG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICB2YXIgbSA9IHR6Lmxlbmd0aDtcbiAgICB3aGlsZSAodHpbMF0gPD0geDApIHR6LnNoaWZ0KCksIC0tbTtcbiAgICB3aGlsZSAodHpbbSAtIDFdID4geDEpIHR6LnBvcCgpLCAtLW07XG5cbiAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksXG4gICAgICAgIGJpbjtcblxuICAgIC8vIEluaXRpYWxpemUgYmlucy5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG07ICsraSkge1xuICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgYmluLngwID0gaSA+IDAgPyB0eltpIC0gMV0gOiB4MDtcbiAgICAgIGJpbi54MSA9IGkgPCBtID8gdHpbaV0gOiB4MTtcbiAgICB9XG5cbiAgICAvLyBBc3NpZ24gZGF0YSB0byBiaW5zIGJ5IHZhbHVlLCBpZ25vcmluZyBhbnkgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICBpZiAoeDAgPD0geCAmJiB4IDw9IHgxKSB7XG4gICAgICAgIGJpbnNbYmlzZWN0UmlnaHQodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5zO1xuICB9XG5cbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIGhpc3RvZ3JhbTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHZhbHVlb2YgPSBudW1iZXI7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLFxuICAgICAgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmZ1bmN0aW9uIGZyZWVkbWFuRGlhY29uaXModmFsdWVzLCBtaW4sIG1heCkge1xuICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAocXVhbnRpbGUodmFsdWVzLCAwLjc1KSAtIHF1YW50aWxlKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufVxuXG5mdW5jdGlvbiBzY290dCh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMy41ICogZGV2aWF0aW9uKHZhbHVlcykgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG59XG5cbmZ1bmN0aW9uIG1heCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4O1xufVxuXG5mdW5jdGlvbiBtZWFuKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gbixcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtKSByZXR1cm4gc3VtIC8gbTtcbn1cblxuZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG51bWJlcnMgPSBbXTtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1YW50aWxlKG51bWJlcnMuc29ydChhc2NlbmRpbmcpLCAwLjUpO1xufVxuXG5mdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgdmFyIG4gPSBhcnJheXMubGVuZ3RoLFxuICAgICAgbSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIGogPSAwLFxuICAgICAgbWVyZ2VkLFxuICAgICAgYXJyYXk7XG5cbiAgd2hpbGUgKCsraSA8IG4pIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgbWVyZ2VkID0gbmV3IEFycmF5KGopO1xuXG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIG1pbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW47XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG5mdW5jdGlvbiBwZXJtdXRlKGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSBwZXJtdXRlc1tpXSA9IGFycmF5W2luZGV4ZXNbaV1dO1xuICByZXR1cm4gcGVybXV0ZXM7XG59XG5cbmZ1bmN0aW9uIHNjYW4odmFsdWVzLCBjb21wYXJlKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgaiA9IDAsXG4gICAgICB4aSxcbiAgICAgIHhqID0gdmFsdWVzW2pdO1xuXG4gIGlmIChjb21wYXJlID09IG51bGwpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBpZiAoY29tcGFyZSh4aSA9IHZhbHVlc1tpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHtcbiAgICAgIHhqID0geGksIGogPSBpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wYXJlKHhqLCB4aikgPT09IDApIHJldHVybiBqO1xufVxuXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBpMCwgaTEpIHtcbiAgdmFyIG0gPSAoaTEgPT0gbnVsbCA/IGFycmF5Lmxlbmd0aCA6IGkxKSAtIChpMCA9IGkwID09IG51bGwgPyAwIDogK2kwKSxcbiAgICAgIHQsXG4gICAgICBpO1xuXG4gIHdoaWxlIChtKSB7XG4gICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgIHQgPSBhcnJheVttICsgaTBdO1xuICAgIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdO1xuICAgIGFycmF5W2kgKyBpMF0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBzdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZXNbaV0pIHN1bSArPSB2YWx1ZTsgLy8gTm90ZTogemVybyBhbmQgbnVsbCBhcmUgZXF1aXZhbGVudC5cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSBzdW0gKz0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG1hdHJpeCkge1xuICBpZiAoIShuID0gbWF0cml4Lmxlbmd0aCkpIHJldHVybiBbXTtcbiAgZm9yICh2YXIgaSA9IC0xLCBtID0gbWluKG1hdHJpeCwgbGVuZ3RoKSwgdHJhbnNwb3NlID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOykge1xuICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOykge1xuICAgICAgcm93W2pdID0gbWF0cml4W2pdW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhbnNwb3NlO1xufVxuXG5mdW5jdGlvbiBsZW5ndGgoZCkge1xuICByZXR1cm4gZC5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHppcCgpIHtcbiAgcmV0dXJuIHRyYW5zcG9zZShhcmd1bWVudHMpO1xufVxuXG5leHBvcnRzLmJpc2VjdCA9IGJpc2VjdFJpZ2h0O1xuZXhwb3J0cy5iaXNlY3RSaWdodCA9IGJpc2VjdFJpZ2h0O1xuZXhwb3J0cy5iaXNlY3RMZWZ0ID0gYmlzZWN0TGVmdDtcbmV4cG9ydHMuYXNjZW5kaW5nID0gYXNjZW5kaW5nO1xuZXhwb3J0cy5iaXNlY3RvciA9IGJpc2VjdG9yO1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5kZXNjZW5kaW5nID0gZGVzY2VuZGluZztcbmV4cG9ydHMuZGV2aWF0aW9uID0gZGV2aWF0aW9uO1xuZXhwb3J0cy5leHRlbnQgPSBleHRlbnQ7XG5leHBvcnRzLmhpc3RvZ3JhbSA9IGhpc3RvZ3JhbTtcbmV4cG9ydHMudGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcyA9IGZyZWVkbWFuRGlhY29uaXM7XG5leHBvcnRzLnRocmVzaG9sZFNjb3R0ID0gc2NvdHQ7XG5leHBvcnRzLnRocmVzaG9sZFN0dXJnZXMgPSBzdHVyZ2VzO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLm1lYW4gPSBtZWFuO1xuZXhwb3J0cy5tZWRpYW4gPSBtZWRpYW47XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMucGFpcnMgPSBwYWlycztcbmV4cG9ydHMucGVybXV0ZSA9IHBlcm11dGU7XG5leHBvcnRzLnF1YW50aWxlID0gcXVhbnRpbGU7XG5leHBvcnRzLnJhbmdlID0gcmFuZ2U7XG5leHBvcnRzLnNjYW4gPSBzY2FuO1xuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmV4cG9ydHMuc3VtID0gc3VtO1xuZXhwb3J0cy50aWNrcyA9IHRpY2tzO1xuZXhwb3J0cy50aWNrSW5jcmVtZW50ID0gdGlja0luY3JlbWVudDtcbmV4cG9ydHMudGlja1N0ZXAgPSB0aWNrU3RlcDtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy52YXJpYW5jZSA9IHZhcmlhbmNlO1xuZXhwb3J0cy56aXAgPSB6aXA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWF4aXMvIHYxLjAuMTIgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxudmFyIHRvcCA9IDEsXG4gICAgcmlnaHQgPSAyLFxuICAgIGJvdHRvbSA9IDMsXG4gICAgbGVmdCA9IDQsXG4gICAgZXBzaWxvbiA9IDFlLTY7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVgoeCkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAoeCArIDAuNSkgKyBcIiwwKVwiO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVZKHkpIHtcbiAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyAoeSArIDAuNSkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICtzY2FsZShkKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHNjYWxlKSB7XG4gIHZhciBvZmZzZXQgPSBNYXRoLm1heCgwLCBzY2FsZS5iYW5kd2lkdGgoKSAtIDEpIC8gMjsgLy8gQWRqdXN0IGZvciAwLjVweCBvZmZzZXQuXG4gIGlmIChzY2FsZS5yb3VuZCgpKSBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICtzY2FsZShkKSArIG9mZnNldDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW50ZXJpbmcoKSB7XG4gIHJldHVybiAhdGhpcy5fX2F4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXMob3JpZW50LCBzY2FsZSkge1xuICB2YXIgdGlja0FyZ3VtZW50cyA9IFtdLFxuICAgICAgdGlja1ZhbHVlcyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgIHRpY2tTaXplSW5uZXIgPSA2LFxuICAgICAgdGlja1NpemVPdXRlciA9IDYsXG4gICAgICB0aWNrUGFkZGluZyA9IDMsXG4gICAgICBrID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBsZWZ0ID8gLTEgOiAxLFxuICAgICAgeCA9IG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT09IHJpZ2h0ID8gXCJ4XCIgOiBcInlcIixcbiAgICAgIHRyYW5zZm9ybSA9IG9yaWVudCA9PT0gdG9wIHx8IG9yaWVudCA9PT0gYm90dG9tID8gdHJhbnNsYXRlWCA6IHRyYW5zbGF0ZVk7XG5cbiAgZnVuY3Rpb24gYXhpcyhjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbCA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKSA6IHRpY2tWYWx1ZXMsXG4gICAgICAgIGZvcm1hdCA9IHRpY2tGb3JtYXQgPT0gbnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBpZGVudGl0eSkgOiB0aWNrRm9ybWF0LFxuICAgICAgICBzcGFjaW5nID0gTWF0aC5tYXgodGlja1NpemVJbm5lciwgMCkgKyB0aWNrUGFkZGluZyxcbiAgICAgICAgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpLFxuICAgICAgICByYW5nZTAgPSArcmFuZ2VbMF0gKyAwLjUsXG4gICAgICAgIHJhbmdlMSA9ICtyYW5nZVtyYW5nZS5sZW5ndGggLSAxXSArIDAuNSxcbiAgICAgICAgcG9zaXRpb24gPSAoc2NhbGUuYmFuZHdpZHRoID8gY2VudGVyIDogbnVtYmVyKShzY2FsZS5jb3B5KCkpLFxuICAgICAgICBzZWxlY3Rpb24gPSBjb250ZXh0LnNlbGVjdGlvbiA/IGNvbnRleHQuc2VsZWN0aW9uKCkgOiBjb250ZXh0LFxuICAgICAgICBwYXRoID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbbnVsbF0pLFxuICAgICAgICB0aWNrID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEodmFsdWVzLCBzY2FsZSkub3JkZXIoKSxcbiAgICAgICAgdGlja0V4aXQgPSB0aWNrLmV4aXQoKSxcbiAgICAgICAgdGlja0VudGVyID0gdGljay5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKSxcbiAgICAgICAgbGluZSA9IHRpY2suc2VsZWN0KFwibGluZVwiKSxcbiAgICAgICAgdGV4dCA9IHRpY2suc2VsZWN0KFwidGV4dFwiKTtcblxuICAgIHBhdGggPSBwYXRoLm1lcmdlKHBhdGguZW50ZXIoKS5pbnNlcnQoXCJwYXRoXCIsIFwiLnRpY2tcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKSk7XG5cbiAgICB0aWNrID0gdGljay5tZXJnZSh0aWNrRW50ZXIpO1xuXG4gICAgbGluZSA9IGxpbmUubWVyZ2UodGlja0VudGVyLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJjdXJyZW50Q29sb3JcIilcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcikpO1xuXG4gICAgdGV4dCA9IHRleHQubWVyZ2UodGlja0VudGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiY3VycmVudENvbG9yXCIpXG4gICAgICAgIC5hdHRyKHgsIGsgKiBzcGFjaW5nKVxuICAgICAgICAuYXR0cihcImR5XCIsIG9yaWVudCA9PT0gdG9wID8gXCIwZW1cIiA6IG9yaWVudCA9PT0gYm90dG9tID8gXCIwLjcxZW1cIiA6IFwiMC4zMmVtXCIpKTtcblxuICAgIGlmIChjb250ZXh0ICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHBhdGggPSBwYXRoLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICB0aWNrID0gdGljay50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgbGluZSA9IGxpbmUudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIHRleHQgPSB0ZXh0LnRyYW5zaXRpb24oY29udGV4dCk7XG5cbiAgICAgIHRpY2tFeGl0ID0gdGlja0V4aXQudHJhbnNpdGlvbihjb250ZXh0KVxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBlcHNpbG9uKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGlzRmluaXRlKGQgPSBwb3NpdGlvbihkKSkgPyB0cmFuc2Zvcm0oZCkgOiB0aGlzLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTsgfSk7XG5cbiAgICAgIHRpY2tFbnRlclxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBlcHNpbG9uKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgdmFyIHAgPSB0aGlzLnBhcmVudE5vZGUuX19heGlzOyByZXR1cm4gdHJhbnNmb3JtKHAgJiYgaXNGaW5pdGUocCA9IHAoZCkpID8gcCA6IHBvc2l0aW9uKGQpKTsgfSk7XG4gICAgfVxuXG4gICAgdGlja0V4aXQucmVtb3ZlKCk7XG5cbiAgICBwYXRoXG4gICAgICAgIC5hdHRyKFwiZFwiLCBvcmllbnQgPT09IGxlZnQgfHwgb3JpZW50ID09IHJpZ2h0XG4gICAgICAgICAgICA/ICh0aWNrU2l6ZU91dGVyID8gXCJNXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiLFwiICsgcmFuZ2UwICsgXCJIMC41VlwiICsgcmFuZ2UxICsgXCJIXCIgKyBrICogdGlja1NpemVPdXRlciA6IFwiTTAuNSxcIiArIHJhbmdlMCArIFwiVlwiICsgcmFuZ2UxKVxuICAgICAgICAgICAgOiAodGlja1NpemVPdXRlciA/IFwiTVwiICsgcmFuZ2UwICsgXCIsXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiVjAuNUhcIiArIHJhbmdlMSArIFwiVlwiICsgayAqIHRpY2tTaXplT3V0ZXIgOiBcIk1cIiArIHJhbmdlMCArIFwiLDAuNUhcIiArIHJhbmdlMSkpO1xuXG4gICAgdGlja1xuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNmb3JtKHBvc2l0aW9uKGQpKTsgfSk7XG5cbiAgICBsaW5lXG4gICAgICAgIC5hdHRyKHggKyBcIjJcIiwgayAqIHRpY2tTaXplSW5uZXIpO1xuXG4gICAgdGV4dFxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLnRleHQoZm9ybWF0KTtcblxuICAgIHNlbGVjdGlvbi5maWx0ZXIoZW50ZXJpbmcpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgLmF0dHIoXCJmb250LXNpemVcIiwgMTApXG4gICAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJzYW5zLXNlcmlmXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgb3JpZW50ID09PSByaWdodCA/IFwic3RhcnRcIiA6IG9yaWVudCA9PT0gbGVmdCA/IFwiZW5kXCIgOiBcIm1pZGRsZVwiKTtcblxuICAgIHNlbGVjdGlvblxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHsgdGhpcy5fX2F4aXMgPSBwb3NpdGlvbjsgfSk7XG4gIH1cblxuICBheGlzLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlID0gXywgYXhpcykgOiBzY2FsZTtcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRpY2tBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrQXJndW1lbnRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tBcmd1bWVudHMgPSBfID09IG51bGwgPyBbXSA6IHNsaWNlLmNhbGwoXyksIGF4aXMpIDogdGlja0FyZ3VtZW50cy5zbGljZSgpO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrVmFsdWVzID0gXyA9PSBudWxsID8gbnVsbCA6IHNsaWNlLmNhbGwoXyksIGF4aXMpIDogdGlja1ZhbHVlcyAmJiB0aWNrVmFsdWVzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tGb3JtYXQgPSBfLCBheGlzKSA6IHRpY2tGb3JtYXQ7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZUlubmVyID0gdGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZUlubmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZUlubmVyO1xuICB9O1xuXG4gIGF4aXMudGlja1NpemVPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVPdXRlcjtcbiAgfTtcblxuICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tQYWRkaW5nID0gK18sIGF4aXMpIDogdGlja1BhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXNUb3Aoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXModG9wLCBzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNSaWdodChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhyaWdodCwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzQm90dG9tKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGJvdHRvbSwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzTGVmdChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhsZWZ0LCBzY2FsZSk7XG59XG5cbmV4cG9ydHMuYXhpc1RvcCA9IGF4aXNUb3A7XG5leHBvcnRzLmF4aXNSaWdodCA9IGF4aXNSaWdodDtcbmV4cG9ydHMuYXhpc0JvdHRvbSA9IGF4aXNCb3R0b207XG5leHBvcnRzLmF4aXNMZWZ0ID0gYXhpc0xlZnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWJydXNoLyB2MS4wLjYgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtZGlzcGF0Y2gnKSwgcmVxdWlyZSgnZDMtZHJhZycpLCByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpLCByZXF1aXJlKCdkMy10cmFuc2l0aW9uJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtc2VsZWN0aW9uJywgJ2QzLWRpc3BhdGNoJywgJ2QzLWRyYWcnLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtdHJhbnNpdGlvbiddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1NlbGVjdGlvbixkM0Rpc3BhdGNoLGQzRHJhZyxkM0ludGVycG9sYXRlLGQzVHJhbnNpdGlvbikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBCcnVzaEV2ZW50KHRhcmdldCwgdHlwZSwgc2VsZWN0aW9uKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbigpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5vZXZlbnQoKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG52YXIgTU9ERV9EUkFHID0ge25hbWU6IFwiZHJhZ1wifSxcbiAgICBNT0RFX1NQQUNFID0ge25hbWU6IFwic3BhY2VcIn0sXG4gICAgTU9ERV9IQU5ETEUgPSB7bmFtZTogXCJoYW5kbGVcIn0sXG4gICAgTU9ERV9DRU5URVIgPSB7bmFtZTogXCJjZW50ZXJcIn07XG5cbnZhciBYID0ge1xuICBuYW1lOiBcInhcIixcbiAgaGFuZGxlczogW1wiZVwiLCBcIndcIl0ubWFwKHR5cGUpLFxuICBpbnB1dDogZnVuY3Rpb24oeCwgZSkgeyByZXR1cm4geCAmJiBbW3hbMF0sIGVbMF1bMV1dLCBbeFsxXSwgZVsxXVsxXV1dOyB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eSAmJiBbeHlbMF1bMF0sIHh5WzFdWzBdXTsgfVxufTtcblxudmFyIFkgPSB7XG4gIG5hbWU6IFwieVwiLFxuICBoYW5kbGVzOiBbXCJuXCIsIFwic1wiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih5LCBlKSB7IHJldHVybiB5ICYmIFtbZVswXVswXSwgeVswXV0sIFtlWzFdWzBdLCB5WzFdXV07IH0sXG4gIG91dHB1dDogZnVuY3Rpb24oeHkpIHsgcmV0dXJuIHh5ICYmIFt4eVswXVsxXSwgeHlbMV1bMV1dOyB9XG59O1xuXG52YXIgWFkgPSB7XG4gIG5hbWU6IFwieHlcIixcbiAgaGFuZGxlczogW1wiblwiLCBcImVcIiwgXCJzXCIsIFwid1wiLCBcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCJdLm1hcCh0eXBlKSxcbiAgaW5wdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eTsgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHk7IH1cbn07XG5cbnZhciBjdXJzb3JzID0ge1xuICBvdmVybGF5OiBcImNyb3NzaGFpclwiLFxuICBzZWxlY3Rpb246IFwibW92ZVwiLFxuICBuOiBcIm5zLXJlc2l6ZVwiLFxuICBlOiBcImV3LXJlc2l6ZVwiLFxuICBzOiBcIm5zLXJlc2l6ZVwiLFxuICB3OiBcImV3LXJlc2l6ZVwiLFxuICBudzogXCJud3NlLXJlc2l6ZVwiLFxuICBuZTogXCJuZXN3LXJlc2l6ZVwiLFxuICBzZTogXCJud3NlLXJlc2l6ZVwiLFxuICBzdzogXCJuZXN3LXJlc2l6ZVwiXG59O1xuXG52YXIgZmxpcFggPSB7XG4gIGU6IFwid1wiLFxuICB3OiBcImVcIixcbiAgbnc6IFwibmVcIixcbiAgbmU6IFwibndcIixcbiAgc2U6IFwic3dcIixcbiAgc3c6IFwic2VcIlxufTtcblxudmFyIGZsaXBZID0ge1xuICBuOiBcInNcIixcbiAgczogXCJuXCIsXG4gIG53OiBcInN3XCIsXG4gIG5lOiBcInNlXCIsXG4gIHNlOiBcIm5lXCIsXG4gIHN3OiBcIm53XCJcbn07XG5cbnZhciBzaWduc1ggPSB7XG4gIG92ZXJsYXk6ICsxLFxuICBzZWxlY3Rpb246ICsxLFxuICBuOiBudWxsLFxuICBlOiArMSxcbiAgczogbnVsbCxcbiAgdzogLTEsXG4gIG53OiAtMSxcbiAgbmU6ICsxLFxuICBzZTogKzEsXG4gIHN3OiAtMVxufTtcblxudmFyIHNpZ25zWSA9IHtcbiAgb3ZlcmxheTogKzEsXG4gIHNlbGVjdGlvbjogKzEsXG4gIG46IC0xLFxuICBlOiBudWxsLFxuICBzOiArMSxcbiAgdzogbnVsbCxcbiAgbnc6IC0xLFxuICBuZTogLTEsXG4gIHNlOiArMSxcbiAgc3c6ICsxXG59O1xuXG5mdW5jdGlvbiB0eXBlKHQpIHtcbiAgcmV0dXJuIHt0eXBlOiB0fTtcbn1cblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWQzU2VsZWN0aW9uLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIHN2ZyA9IHRoaXMub3duZXJTVkdFbGVtZW50IHx8IHRoaXM7XG4gIHJldHVybiBbWzAsIDBdLCBbc3ZnLndpZHRoLmJhc2VWYWwudmFsdWUsIHN2Zy5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xufVxuXG4vLyBMaWtlIGQzLmxvY2FsLCBidXQgd2l0aCB0aGUgbmFtZSDigJxfX2JydXNo4oCdIHJhdGhlciB0aGFuIGF1dG8tZ2VuZXJhdGVkLlxuZnVuY3Rpb24gbG9jYWwobm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX19icnVzaCkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgcmV0dXJuIG5vZGUuX19icnVzaDtcbn1cblxuZnVuY3Rpb24gZW1wdHkoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMF1bMF0gPT09IGV4dGVudFsxXVswXVxuICAgICAgfHwgZXh0ZW50WzBdWzFdID09PSBleHRlbnRbMV1bMV07XG59XG5cbmZ1bmN0aW9uIGJydXNoU2VsZWN0aW9uKG5vZGUpIHtcbiAgdmFyIHN0YXRlID0gbm9kZS5fX2JydXNoO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS5kaW0ub3V0cHV0KHN0YXRlLnNlbGVjdGlvbikgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBicnVzaFgoKSB7XG4gIHJldHVybiBicnVzaCQxKFgpO1xufVxuXG5mdW5jdGlvbiBicnVzaFkoKSB7XG4gIHJldHVybiBicnVzaCQxKFkpO1xufVxuXG5mdW5jdGlvbiBicnVzaCgpIHtcbiAgcmV0dXJuIGJydXNoJDEoWFkpO1xufVxuXG5mdW5jdGlvbiBicnVzaCQxKGRpbSkge1xuICB2YXIgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBsaXN0ZW5lcnMgPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKGJydXNoLCBcInN0YXJ0XCIsIFwiYnJ1c2hcIiwgXCJlbmRcIiksXG4gICAgICBoYW5kbGVTaXplID0gNixcbiAgICAgIHRvdWNoZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGJydXNoKGdyb3VwKSB7XG4gICAgdmFyIG92ZXJsYXkgPSBncm91cFxuICAgICAgICAucHJvcGVydHkoXCJfX2JydXNoXCIsIGluaXRpYWxpemUpXG4gICAgICAuc2VsZWN0QWxsKFwiLm92ZXJsYXlcIilcbiAgICAgIC5kYXRhKFt0eXBlKFwib3ZlcmxheVwiKV0pO1xuXG4gICAgb3ZlcmxheS5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm92ZXJsYXlcIilcbiAgICAgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKVxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzLm92ZXJsYXkpXG4gICAgICAubWVyZ2Uob3ZlcmxheSlcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IGxvY2FsKHRoaXMpLmV4dGVudDtcbiAgICAgICAgICBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGV4dGVudFswXVswXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGV4dGVudFswXVsxXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0pXG4gICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSk7XG4gICAgICAgIH0pO1xuXG4gICAgZ3JvdXAuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKVxuICAgICAgLmRhdGEoW3R5cGUoXCJzZWxlY3Rpb25cIildKVxuICAgICAgLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2VsZWN0aW9uXCIpXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjNzc3XCIpXG4gICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDAuMylcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjZmZmXCIpXG4gICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwiY3Jpc3BFZGdlc1wiKTtcblxuICAgIHZhciBoYW5kbGUgPSBncm91cC5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpXG4gICAgICAuZGF0YShkaW0uaGFuZGxlcywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlOyB9KTtcblxuICAgIGhhbmRsZS5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICBoYW5kbGUuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJoYW5kbGUgaGFuZGxlLS1cIiArIGQudHlwZTsgfSlcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY3Vyc29yc1tkLnR5cGVdOyB9KTtcblxuICAgIGdyb3VwXG4gICAgICAgIC5lYWNoKHJlZHJhdylcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIilcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmJydXNoIHRvdWNoc3RhcnQuYnJ1c2hcIiwgc3RhcnRlZCk7XG4gIH1cblxuICBicnVzaC5tb3ZlID0gZnVuY3Rpb24oZ3JvdXAsIHNlbGVjdGlvbikge1xuICAgIGlmIChncm91cC5zZWxlY3Rpb24pIHtcbiAgICAgIGdyb3VwXG4gICAgICAgICAgLm9uKFwic3RhcnQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7IGVtaXR0ZXIodGhpcywgYXJndW1lbnRzKS5iZWZvcmVzdGFydCgpLnN0YXJ0KCk7IH0pXG4gICAgICAgICAgLm9uKFwiaW50ZXJydXB0LmJydXNoIGVuZC5icnVzaFwiLCBmdW5jdGlvbigpIHsgZW1pdHRlcih0aGlzLCBhcmd1bWVudHMpLmVuZCgpOyB9KVxuICAgICAgICAgIC50d2VlbihcImJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhhdC5fX2JydXNoLFxuICAgICAgICAgICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24xID0gZGltLmlucHV0KHR5cGVvZiBzZWxlY3Rpb24gPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc2VsZWN0aW9uLCBzdGF0ZS5leHRlbnQpLFxuICAgICAgICAgICAgICAgIGkgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlKHNlbGVjdGlvbjAsIHNlbGVjdGlvbjEpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0d2Vlbih0KSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHQgPT09IDEgJiYgZW1wdHkoc2VsZWN0aW9uMSkgPyBudWxsIDogaSh0KTtcbiAgICAgICAgICAgICAgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICAgICAgICAgIGVtaXQuYnJ1c2goKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjAgJiYgc2VsZWN0aW9uMSA/IHR3ZWVuIDogdHdlZW4oMSk7XG4gICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwXG4gICAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoYXQuX19icnVzaCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24xID0gZGltLmlucHV0KHR5cGVvZiBzZWxlY3Rpb24gPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdGlvbi5hcHBseSh0aGF0LCBhcmdzKSA6IHNlbGVjdGlvbiwgc3RhdGUuZXh0ZW50KSxcbiAgICAgICAgICAgICAgICBlbWl0ID0gZW1pdHRlcih0aGF0LCBhcmdzKS5iZWZvcmVzdGFydCgpO1xuXG4gICAgICAgICAgICBkM1RyYW5zaXRpb24uaW50ZXJydXB0KHRoYXQpO1xuICAgICAgICAgICAgc3RhdGUuc2VsZWN0aW9uID0gc2VsZWN0aW9uMSA9PSBudWxsIHx8IGVtcHR5KHNlbGVjdGlvbjEpID8gbnVsbCA6IHNlbGVjdGlvbjE7XG4gICAgICAgICAgICByZWRyYXcuY2FsbCh0aGF0KTtcbiAgICAgICAgICAgIGVtaXQuc3RhcnQoKS5icnVzaCgpLmVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgdmFyIGdyb3VwID0gZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLFxuICAgICAgICBzZWxlY3Rpb24gPSBsb2NhbCh0aGlzKS5zZWxlY3Rpb247XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBncm91cC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uXCIpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwieFwiLCBzZWxlY3Rpb25bMF1bMF0pXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIHNlbGVjdGlvblswXVsxXSlcbiAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHNlbGVjdGlvblsxXVswXSAtIHNlbGVjdGlvblswXVswXSlcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBzZWxlY3Rpb25bMV1bMV0gLSBzZWxlY3Rpb25bMF1bMV0pO1xuXG4gICAgICBncm91cC5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGVbZC50eXBlLmxlbmd0aCAtIDFdID09PSBcImVcIiA/IHNlbGVjdGlvblsxXVswXSAtIGhhbmRsZVNpemUgLyAyIDogc2VsZWN0aW9uWzBdWzBdIC0gaGFuZGxlU2l6ZSAvIDI7IH0pXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZVswXSA9PT0gXCJzXCIgPyBzZWxlY3Rpb25bMV1bMV0gLSBoYW5kbGVTaXplIC8gMiA6IHNlbGVjdGlvblswXVsxXSAtIGhhbmRsZVNpemUgLyAyOyB9KVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlID09PSBcIm5cIiB8fCBkLnR5cGUgPT09IFwic1wiID8gc2VsZWN0aW9uWzFdWzBdIC0gc2VsZWN0aW9uWzBdWzBdICsgaGFuZGxlU2l6ZSA6IGhhbmRsZVNpemU7IH0pXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlID09PSBcImVcIiB8fCBkLnR5cGUgPT09IFwid1wiID8gc2VsZWN0aW9uWzFdWzFdIC0gc2VsZWN0aW9uWzBdWzFdICsgaGFuZGxlU2l6ZSA6IGhhbmRsZVNpemU7IH0pO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgZ3JvdXAuc2VsZWN0QWxsKFwiLnNlbGVjdGlvbiwuaGFuZGxlXCIpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgICAuYXR0cihcInhcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcInlcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdHRlcih0aGF0LCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoYXQuX19icnVzaC5lbWl0dGVyIHx8IG5ldyBFbWl0dGVyKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gRW1pdHRlcih0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuc3RhdGUgPSB0aGF0Ll9fYnJ1c2g7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICB9XG5cbiAgRW1pdHRlci5wcm90b3R5cGUgPSB7XG4gICAgYmVmb3Jlc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHRoaXMuc3RhdGUuZW1pdHRlciA9IHRoaXMsIHRoaXMuc3RhcnRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGluZykgdGhpcy5zdGFydGluZyA9IGZhbHNlLCB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYnJ1c2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KFwiYnJ1c2hcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkgZGVsZXRlIHRoaXMuc3RhdGUuZW1pdHRlciwgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBkM1NlbGVjdGlvbi5jdXN0b21FdmVudChuZXcgQnJ1c2hFdmVudChicnVzaCwgdHlwZSwgZGltLm91dHB1dCh0aGlzLnN0YXRlLnNlbGVjdGlvbikpLCBsaXN0ZW5lcnMuYXBwbHksIGxpc3RlbmVycywgW3R5cGUsIHRoaXMudGhhdCwgdGhpcy5hcmdzXSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0YXJ0ZWQoKSB7XG4gICAgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMpIHsgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA8IGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMubGVuZ3RoKSByZXR1cm4gbm9ldmVudCgpOyB9XG4gICAgZWxzZSBpZiAodG91Y2hlbmRpbmcpIHJldHVybjtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG5cbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIHR5cGUgPSBkM1NlbGVjdGlvbi5ldmVudC50YXJnZXQuX19kYXRhX18udHlwZSxcbiAgICAgICAgbW9kZSA9IChkM1NlbGVjdGlvbi5ldmVudC5tZXRhS2V5ID8gdHlwZSA9IFwib3ZlcmxheVwiIDogdHlwZSkgPT09IFwic2VsZWN0aW9uXCIgPyBNT0RFX0RSQUcgOiAoZDNTZWxlY3Rpb24uZXZlbnQuYWx0S2V5ID8gTU9ERV9DRU5URVIgOiBNT0RFX0hBTkRMRSksXG4gICAgICAgIHNpZ25YID0gZGltID09PSBZID8gbnVsbCA6IHNpZ25zWFt0eXBlXSxcbiAgICAgICAgc2lnblkgPSBkaW0gPT09IFggPyBudWxsIDogc2lnbnNZW3R5cGVdLFxuICAgICAgICBzdGF0ZSA9IGxvY2FsKHRoYXQpLFxuICAgICAgICBleHRlbnQgPSBzdGF0ZS5leHRlbnQsXG4gICAgICAgIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgVyA9IGV4dGVudFswXVswXSwgdzAsIHcxLFxuICAgICAgICBOID0gZXh0ZW50WzBdWzFdLCBuMCwgbjEsXG4gICAgICAgIEUgPSBleHRlbnRbMV1bMF0sIGUwLCBlMSxcbiAgICAgICAgUyA9IGV4dGVudFsxXVsxXSwgczAsIHMxLFxuICAgICAgICBkeCxcbiAgICAgICAgZHksXG4gICAgICAgIG1vdmluZyxcbiAgICAgICAgc2hpZnRpbmcgPSBzaWduWCAmJiBzaWduWSAmJiBkM1NlbGVjdGlvbi5ldmVudC5zaGlmdEtleSxcbiAgICAgICAgbG9ja1gsXG4gICAgICAgIGxvY2tZLFxuICAgICAgICBwb2ludDAgPSBkM1NlbGVjdGlvbi5tb3VzZSh0aGF0KSxcbiAgICAgICAgcG9pbnQgPSBwb2ludDAsXG4gICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3VtZW50cykuYmVmb3Jlc3RhcnQoKTtcblxuICAgIGlmICh0eXBlID09PSBcIm92ZXJsYXlcIikge1xuICAgICAgc3RhdGUuc2VsZWN0aW9uID0gc2VsZWN0aW9uID0gW1xuICAgICAgICBbdzAgPSBkaW0gPT09IFkgPyBXIDogcG9pbnQwWzBdLCBuMCA9IGRpbSA9PT0gWCA/IE4gOiBwb2ludDBbMV1dLFxuICAgICAgICBbZTAgPSBkaW0gPT09IFkgPyBFIDogdzAsIHMwID0gZGltID09PSBYID8gUyA6IG4wXVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdzAgPSBzZWxlY3Rpb25bMF1bMF07XG4gICAgICBuMCA9IHNlbGVjdGlvblswXVsxXTtcbiAgICAgIGUwID0gc2VsZWN0aW9uWzFdWzBdO1xuICAgICAgczAgPSBzZWxlY3Rpb25bMV1bMV07XG4gICAgfVxuXG4gICAgdzEgPSB3MDtcbiAgICBuMSA9IG4wO1xuICAgIGUxID0gZTA7XG4gICAgczEgPSBzMDtcblxuICAgIHZhciBncm91cCA9IGQzU2VsZWN0aW9uLnNlbGVjdCh0aGF0KVxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblxuICAgIHZhciBvdmVybGF5ID0gZ3JvdXAuc2VsZWN0QWxsKFwiLm92ZXJsYXlcIilcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlXSk7XG5cbiAgICBpZiAoZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcykge1xuICAgICAgZ3JvdXBcbiAgICAgICAgICAub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgbW92ZWQsIHRydWUpXG4gICAgICAgICAgLm9uKFwidG91Y2hlbmQuYnJ1c2ggdG91Y2hjYW5jZWwuYnJ1c2hcIiwgZW5kZWQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KVxuICAgICAgICAgIC5vbihcImtleWRvd24uYnJ1c2hcIiwga2V5ZG93bmVkLCB0cnVlKVxuICAgICAgICAgIC5vbihcImtleXVwLmJydXNoXCIsIGtleXVwcGVkLCB0cnVlKVxuICAgICAgICAgIC5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBtb3ZlZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJtb3VzZXVwLmJydXNoXCIsIGVuZGVkLCB0cnVlKTtcblxuICAgICAgZDNEcmFnLmRyYWdEaXNhYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcpO1xuICAgIH1cblxuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBkM1RyYW5zaXRpb24uaW50ZXJydXB0KHRoYXQpO1xuICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgIGVtaXQuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgdmFyIHBvaW50MSA9IGQzU2VsZWN0aW9uLm1vdXNlKHRoYXQpO1xuICAgICAgaWYgKHNoaWZ0aW5nICYmICFsb2NrWCAmJiAhbG9ja1kpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHBvaW50MVswXSAtIHBvaW50WzBdKSA+IE1hdGguYWJzKHBvaW50MVsxXSAtIHBvaW50WzFdKSkgbG9ja1kgPSB0cnVlO1xuICAgICAgICBlbHNlIGxvY2tYID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBvaW50ID0gcG9pbnQxO1xuICAgICAgbW92aW5nID0gdHJ1ZTtcbiAgICAgIG5vZXZlbnQoKTtcbiAgICAgIG1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlKCkge1xuICAgICAgdmFyIHQ7XG5cbiAgICAgIGR4ID0gcG9pbnRbMF0gLSBwb2ludDBbMF07XG4gICAgICBkeSA9IHBvaW50WzFdIC0gcG9pbnQwWzFdO1xuXG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSBNT0RFX1NQQUNFOlxuICAgICAgICBjYXNlIE1PREVfRFJBRzoge1xuICAgICAgICAgIGlmIChzaWduWCkgZHggPSBNYXRoLm1heChXIC0gdzAsIE1hdGgubWluKEUgLSBlMCwgZHgpKSwgdzEgPSB3MCArIGR4LCBlMSA9IGUwICsgZHg7XG4gICAgICAgICAgaWYgKHNpZ25ZKSBkeSA9IE1hdGgubWF4KE4gLSBuMCwgTWF0aC5taW4oUyAtIHMwLCBkeSkpLCBuMSA9IG4wICsgZHksIHMxID0gczAgKyBkeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1PREVfSEFORExFOiB7XG4gICAgICAgICAgaWYgKHNpZ25YIDwgMCkgZHggPSBNYXRoLm1heChXIC0gdzAsIE1hdGgubWluKEUgLSB3MCwgZHgpKSwgdzEgPSB3MCArIGR4LCBlMSA9IGUwO1xuICAgICAgICAgIGVsc2UgaWYgKHNpZ25YID4gMCkgZHggPSBNYXRoLm1heChXIC0gZTAsIE1hdGgubWluKEUgLSBlMCwgZHgpKSwgdzEgPSB3MCwgZTEgPSBlMCArIGR4O1xuICAgICAgICAgIGlmIChzaWduWSA8IDApIGR5ID0gTWF0aC5tYXgoTiAtIG4wLCBNYXRoLm1pbihTIC0gbjAsIGR5KSksIG4xID0gbjAgKyBkeSwgczEgPSBzMDtcbiAgICAgICAgICBlbHNlIGlmIChzaWduWSA+IDApIGR5ID0gTWF0aC5tYXgoTiAtIHMwLCBNYXRoLm1pbihTIC0gczAsIGR5KSksIG4xID0gbjAsIHMxID0gczAgKyBkeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1PREVfQ0VOVEVSOiB7XG4gICAgICAgICAgaWYgKHNpZ25YKSB3MSA9IE1hdGgubWF4KFcsIE1hdGgubWluKEUsIHcwIC0gZHggKiBzaWduWCkpLCBlMSA9IE1hdGgubWF4KFcsIE1hdGgubWluKEUsIGUwICsgZHggKiBzaWduWCkpO1xuICAgICAgICAgIGlmIChzaWduWSkgbjEgPSBNYXRoLm1heChOLCBNYXRoLm1pbihTLCBuMCAtIGR5ICogc2lnblkpKSwgczEgPSBNYXRoLm1heChOLCBNYXRoLm1pbihTLCBzMCArIGR5ICogc2lnblkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZTEgPCB3MSkge1xuICAgICAgICBzaWduWCAqPSAtMTtcbiAgICAgICAgdCA9IHcwLCB3MCA9IGUwLCBlMCA9IHQ7XG4gICAgICAgIHQgPSB3MSwgdzEgPSBlMSwgZTEgPSB0O1xuICAgICAgICBpZiAodHlwZSBpbiBmbGlwWCkgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZSA9IGZsaXBYW3R5cGVdXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzMSA8IG4xKSB7XG4gICAgICAgIHNpZ25ZICo9IC0xO1xuICAgICAgICB0ID0gbjAsIG4wID0gczAsIHMwID0gdDtcbiAgICAgICAgdCA9IG4xLCBuMSA9IHMxLCBzMSA9IHQ7XG4gICAgICAgIGlmICh0eXBlIGluIGZsaXBZKSBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlID0gZmxpcFlbdHlwZV1dKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbikgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uOyAvLyBNYXkgYmUgc2V0IGJ5IGJydXNoLm1vdmUhXG4gICAgICBpZiAobG9ja1gpIHcxID0gc2VsZWN0aW9uWzBdWzBdLCBlMSA9IHNlbGVjdGlvblsxXVswXTtcbiAgICAgIGlmIChsb2NrWSkgbjEgPSBzZWxlY3Rpb25bMF1bMV0sIHMxID0gc2VsZWN0aW9uWzFdWzFdO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uWzBdWzBdICE9PSB3MVxuICAgICAgICAgIHx8IHNlbGVjdGlvblswXVsxXSAhPT0gbjFcbiAgICAgICAgICB8fCBzZWxlY3Rpb25bMV1bMF0gIT09IGUxXG4gICAgICAgICAgfHwgc2VsZWN0aW9uWzFdWzFdICE9PSBzMSkge1xuICAgICAgICBzdGF0ZS5zZWxlY3Rpb24gPSBbW3cxLCBuMV0sIFtlMSwgczFdXTtcbiAgICAgICAgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICAgIGVtaXQuYnJ1c2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgICAgIGdyb3VwLm9uKFwidG91Y2htb3ZlLmJydXNoIHRvdWNoZW5kLmJydXNoIHRvdWNoY2FuY2VsLmJydXNoXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZDNEcmFnLmRyYWdFbmFibGUoZDNTZWxlY3Rpb24uZXZlbnQudmlldywgbW92aW5nKTtcbiAgICAgICAgdmlldy5vbihcImtleWRvd24uYnJ1c2gga2V5dXAuYnJ1c2ggbW91c2Vtb3ZlLmJydXNoIG1vdXNldXAuYnJ1c2hcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBncm91cC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5vdmVybGF5KTtcbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24pIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjsgLy8gTWF5IGJlIHNldCBieSBicnVzaC5tb3ZlIChvbiBzdGFydCkhXG4gICAgICBpZiAoZW1wdHkoc2VsZWN0aW9uKSkgc3RhdGUuc2VsZWN0aW9uID0gbnVsbCwgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICBlbWl0LmVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleWRvd25lZCgpIHtcbiAgICAgIHN3aXRjaCAoZDNTZWxlY3Rpb24uZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDE2OiB7IC8vIFNISUZUXG4gICAgICAgICAgc2hpZnRpbmcgPSBzaWduWCAmJiBzaWduWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE4OiB7IC8vIEFMVFxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0hBTkRMRSkge1xuICAgICAgICAgICAgaWYgKHNpZ25YKSBlMCA9IGUxIC0gZHggKiBzaWduWCwgdzAgPSB3MSArIGR4ICogc2lnblg7XG4gICAgICAgICAgICBpZiAoc2lnblkpIHMwID0gczEgLSBkeSAqIHNpZ25ZLCBuMCA9IG4xICsgZHkgKiBzaWduWTtcbiAgICAgICAgICAgIG1vZGUgPSBNT0RFX0NFTlRFUjtcbiAgICAgICAgICAgIG1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzMjogeyAvLyBTUEFDRTsgdGFrZXMgcHJpb3JpdHkgb3ZlciBBTFRcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9IQU5ETEUgfHwgbW9kZSA9PT0gTU9ERV9DRU5URVIpIHtcbiAgICAgICAgICAgIGlmIChzaWduWCA8IDApIGUwID0gZTEgLSBkeDsgZWxzZSBpZiAoc2lnblggPiAwKSB3MCA9IHcxIC0gZHg7XG4gICAgICAgICAgICBpZiAoc2lnblkgPCAwKSBzMCA9IHMxIC0gZHk7IGVsc2UgaWYgKHNpZ25ZID4gMCkgbjAgPSBuMSAtIGR5O1xuICAgICAgICAgICAgbW9kZSA9IE1PREVfU1BBQ0U7XG4gICAgICAgICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgICB9XG4gICAgICBub2V2ZW50KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5dXBwZWQoKSB7XG4gICAgICBzd2l0Y2ggKGQzU2VsZWN0aW9uLmV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxuICAgICAgICAgIGlmIChzaGlmdGluZykge1xuICAgICAgICAgICAgbG9ja1ggPSBsb2NrWSA9IHNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTg6IHsgLy8gQUxUXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfQ0VOVEVSKSB7XG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XG4gICAgICAgICAgICBpZiAoc2lnblkgPCAwKSBzMCA9IHMxOyBlbHNlIGlmIChzaWduWSA+IDApIG4wID0gbjE7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9IQU5ETEU7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzI6IHsgLy8gU1BBQ0VcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9TUEFDRSkge1xuICAgICAgICAgICAgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICBpZiAoc2lnblgpIGUwID0gZTEgLSBkeCAqIHNpZ25YLCB3MCA9IHcxICsgZHggKiBzaWduWDtcbiAgICAgICAgICAgICAgaWYgKHNpZ25ZKSBzMCA9IHMxIC0gZHkgKiBzaWduWSwgbjAgPSBuMSArIGR5ICogc2lnblk7XG4gICAgICAgICAgICAgIG1vZGUgPSBNT0RFX0NFTlRFUjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzaWduWCA8IDApIGUwID0gZTE7IGVsc2UgaWYgKHNpZ25YID4gMCkgdzAgPSB3MTtcbiAgICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMTsgZWxzZSBpZiAoc2lnblkgPiAwKSBuMCA9IG4xO1xuICAgICAgICAgICAgICBtb2RlID0gTU9ERV9IQU5ETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlXSk7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZXZlbnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX19icnVzaCB8fCB7c2VsZWN0aW9uOiBudWxsfTtcbiAgICBzdGF0ZS5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBzdGF0ZS5kaW0gPSBkaW07XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgYnJ1c2guZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCBicnVzaCkgOiBleHRlbnQ7XG4gIH07XG5cbiAgYnJ1c2guZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYnJ1c2gpIDogZmlsdGVyO1xuICB9O1xuXG4gIGJydXNoLmhhbmRsZVNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaGFuZGxlU2l6ZSA9ICtfLCBicnVzaCkgOiBoYW5kbGVTaXplO1xuICB9O1xuXG4gIGJydXNoLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGJydXNoIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGJydXNoO1xufVxuXG5leHBvcnRzLmJydXNoID0gYnJ1c2g7XG5leHBvcnRzLmJydXNoWCA9IGJydXNoWDtcbmV4cG9ydHMuYnJ1c2hZID0gYnJ1c2hZO1xuZXhwb3J0cy5icnVzaFNlbGVjdGlvbiA9IGJydXNoU2VsZWN0aW9uO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1jb2xsZWN0aW9uLyB2MS4wLjcgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBwcmVmaXggPSBcIiRcIjtcblxuZnVuY3Rpb24gTWFwKCkge31cblxuTWFwLnByb3RvdHlwZSA9IG1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNYXAsXG4gIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIChwcmVmaXggKyBrZXkpIGluIHRoaXM7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJlZml4ICsga2V5XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1twcmVmaXggKyBrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHByb3BlcnR5ID0gcHJlZml4ICsga2V5O1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGtleXMucHVzaChwcm9wZXJ0eS5zbGljZSgxKSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH0sXG4gIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSB2YWx1ZXMucHVzaCh0aGlzW3Byb3BlcnR5XSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSxcbiAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZW50cmllcy5wdXNoKHtrZXk6IHByb3BlcnR5LnNsaWNlKDEpLCB2YWx1ZTogdGhpc1twcm9wZXJ0eV19KTtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSArK3NpemU7XG4gICAgcmV0dXJuIHNpemU7XG4gIH0sXG4gIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGYodGhpc1twcm9wZXJ0eV0sIHByb3BlcnR5LnNsaWNlKDEpLCB0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFwKG9iamVjdCwgZikge1xuICB2YXIgbWFwID0gbmV3IE1hcDtcblxuICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKSBvYmplY3QuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7IG1hcC5zZXQoa2V5LCB2YWx1ZSk7IH0pO1xuXG4gIC8vIEluZGV4IGFycmF5IGJ5IG51bWVyaWMgaW5kZXggb3Igc3BlY2lmaWVkIGtleSBmdW5jdGlvbi5cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IG9iamVjdC5sZW5ndGgsXG4gICAgICAgIG87XG5cbiAgICBpZiAoZiA9PSBudWxsKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pO1xuICAgIGVsc2Ugd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoZihvID0gb2JqZWN0W2ldLCBpLCBvYmplY3QpLCBvKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgb2JqZWN0IHRvIG1hcC5cbiAgZWxzZSBpZiAob2JqZWN0KSBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBtYXAuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xuXG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIG5lc3QoKSB7XG4gIHZhciBrZXlzID0gW10sXG4gICAgICBzb3J0S2V5cyA9IFtdLFxuICAgICAgc29ydFZhbHVlcyxcbiAgICAgIHJvbGx1cCxcbiAgICAgIG5lc3Q7XG5cbiAgZnVuY3Rpb24gYXBwbHkoYXJyYXksIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkge1xuICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbCkgYXJyYXkuc29ydChzb3J0VmFsdWVzKTtcbiAgICAgIHJldHVybiByb2xsdXAgIT0gbnVsbCA/IHJvbGx1cChhcnJheSkgOiBhcnJheTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBrZXkgPSBrZXlzW2RlcHRoKytdLFxuICAgICAgICBrZXlWYWx1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbHVlc0J5S2V5ID0gbWFwKCksXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUmVzdWx0KCk7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHZhbHVlcyA9IHZhbHVlc0J5S2V5LmdldChrZXlWYWx1ZSA9IGtleSh2YWx1ZSA9IGFycmF5W2ldKSArIFwiXCIpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc0J5S2V5LnNldChrZXlWYWx1ZSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWVzQnlLZXkuZWFjaChmdW5jdGlvbih2YWx1ZXMsIGtleSkge1xuICAgICAgc2V0UmVzdWx0KHJlc3VsdCwga2V5LCBhcHBseSh2YWx1ZXMsIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVudHJpZXMobWFwJCQxLCBkZXB0aCkge1xuICAgIGlmICgrK2RlcHRoID4ga2V5cy5sZW5ndGgpIHJldHVybiBtYXAkJDE7XG4gICAgdmFyIGFycmF5LCBzb3J0S2V5ID0gc29ydEtleXNbZGVwdGggLSAxXTtcbiAgICBpZiAocm9sbHVwICE9IG51bGwgJiYgZGVwdGggPj0ga2V5cy5sZW5ndGgpIGFycmF5ID0gbWFwJCQxLmVudHJpZXMoKTtcbiAgICBlbHNlIGFycmF5ID0gW10sIG1hcCQkMS5lYWNoKGZ1bmN0aW9uKHYsIGspIHsgYXJyYXkucHVzaCh7a2V5OiBrLCB2YWx1ZXM6IGVudHJpZXModiwgZGVwdGgpfSk7IH0pO1xuICAgIHJldHVybiBzb3J0S2V5ICE9IG51bGwgPyBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHNvcnRLZXkoYS5rZXksIGIua2V5KTsgfSkgOiBhcnJheTtcbiAgfVxuXG4gIHJldHVybiBuZXN0ID0ge1xuICAgIG9iamVjdDogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVPYmplY3QsIHNldE9iamVjdCk7IH0sXG4gICAgbWFwOiBmdW5jdGlvbihhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKTsgfSxcbiAgICBlbnRyaWVzOiBmdW5jdGlvbihhcnJheSkgeyByZXR1cm4gZW50cmllcyhhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApLCAwKTsgfSxcbiAgICBrZXk6IGZ1bmN0aW9uKGQpIHsga2V5cy5wdXNoKGQpOyByZXR1cm4gbmVzdDsgfSxcbiAgICBzb3J0S2V5czogZnVuY3Rpb24ob3JkZXIpIHsgc29ydEtleXNba2V5cy5sZW5ndGggLSAxXSA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcbiAgICBzb3J0VmFsdWVzOiBmdW5jdGlvbihvcmRlcikgeyBzb3J0VmFsdWVzID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgIHJvbGx1cDogZnVuY3Rpb24oZikgeyByb2xsdXAgPSBmOyByZXR1cm4gbmVzdDsgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gc2V0T2JqZWN0KG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gIHJldHVybiBtYXAoKTtcbn1cblxuZnVuY3Rpb24gc2V0TWFwKG1hcCQkMSwga2V5LCB2YWx1ZSkge1xuICBtYXAkJDEuc2V0KGtleSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBTZXQoKSB7fVxuXG52YXIgcHJvdG8gPSBtYXAucHJvdG90eXBlO1xuXG5TZXQucHJvdG90eXBlID0gc2V0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNldCxcbiAgaGFzOiBwcm90by5oYXMsXG4gIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSArPSBcIlwiO1xuICAgIHRoaXNbcHJlZml4ICsgdmFsdWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogcHJvdG8ucmVtb3ZlLFxuICBjbGVhcjogcHJvdG8uY2xlYXIsXG4gIHZhbHVlczogcHJvdG8ua2V5cyxcbiAgc2l6ZTogcHJvdG8uc2l6ZSxcbiAgZW1wdHk6IHByb3RvLmVtcHR5LFxuICBlYWNoOiBwcm90by5lYWNoXG59O1xuXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBmKSB7XG4gIHZhciBzZXQgPSBuZXcgU2V0O1xuXG4gIC8vIENvcHkgY29uc3RydWN0b3IuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTZXQpIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IHNldC5hZGQodmFsdWUpOyB9KTtcblxuICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdOKAmXMgYW4gYXJyYXkuXG4gIGVsc2UgaWYgKG9iamVjdCkge1xuICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoO1xuICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKG9iamVjdFtpXSk7XG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChmKG9iamVjdFtpXSwgaSwgb2JqZWN0KSk7XG4gIH1cblxuICByZXR1cm4gc2V0O1xufVxuXG5mdW5jdGlvbiBrZXlzKG1hcCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIHZhbHVlcyhtYXApIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSB2YWx1ZXMucHVzaChtYXBba2V5XSk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIGVudHJpZXMobWFwKSB7XG4gIHZhciBlbnRyaWVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBtYXApIGVudHJpZXMucHVzaCh7a2V5OiBrZXksIHZhbHVlOiBtYXBba2V5XX0pO1xuICByZXR1cm4gZW50cmllcztcbn1cblxuZXhwb3J0cy5uZXN0ID0gbmVzdDtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLmtleXMgPSBrZXlzO1xuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5leHBvcnRzLmVudHJpZXMgPSBlbnRyaWVzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1jb2xvci8gdjEuMi4zIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZWZpbmUoY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG52YXIgZGFya2VyID0gMC43O1xudmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXgzID0gL14jKFswLTlhLWZdezN9KSQvLFxuICAgIHJlSGV4NiA9IC9eIyhbMC05YS1mXXs2fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuaGV4KCk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCI7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG07XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXgzLmV4ZWMoZm9ybWF0KSkgPyAobSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweDBmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkpIC8vICNmMDBcbiAgICAgIDogKG0gPSByZUhleDYuZXhlYyhmb3JtYXQpKSA/IHJnYm4ocGFyc2VJbnQobVsxXSwgMTYpKSAvLyAjZmYwMDAwXG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKVxuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5mdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMuciAmJiB0aGlzLnIgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmcgJiYgdGhpcy5nIDw9IDI1NSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5iICYmIHRoaXMuYiA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgaGV4KHRoaXMucikgKyBoZXgodGhpcy5nKSArIGhleCh0aGlzLmIpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCIpXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuYikgfHwgMCkpXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5mdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH1cbn0pKTtcblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuXG52YXIgZGVnMnJhZCA9IE1hdGguUEkgLyAxODA7XG52YXIgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIGh0dHBzOi8vYmV0YS5vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxudmFyIEsgPSAxOCxcbiAgICBYbiA9IDAuOTY0MjIsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMC44MjUyMSxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgICB2YXIgaCA9IG8uaCAqIGRlZzJyYWQ7XG4gICAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG4gIH1cbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiByYWQyZGVnO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsYWJDb252ZXJ0KHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG5cbnZhciBBID0gLTAuMTQ4NjEsXG4gICAgQiA9ICsxLjc4Mjc3LFxuICAgIEMgPSAtMC4yOTIyNyxcbiAgICBEID0gLTAuOTA2NDksXG4gICAgRSA9ICsxLjk3Mjk0LFxuICAgIEVEID0gRSAqIEQsXG4gICAgRUIgPSBFICogQixcbiAgICBCQ19EQSA9IEIgKiBDIC0gRCAqIEE7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEN1YmVoZWxpeCkgcmV0dXJuIG5ldyBDdWJlaGVsaXgoby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbCA9IChCQ19EQSAqIGIgKyBFRCAqIHIgLSBFQiAqIGcpIC8gKEJDX0RBICsgRUQgLSBFQiksXG4gICAgICBibCA9IGIgLSBsLFxuICAgICAgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBELFxuICAgICAgcyA9IE1hdGguc3FydChrICogayArIGJsICogYmwpIC8gKEUgKiBsICogKDEgLSBsKSksIC8vIE5hTiBpZiBsPTAgb3IgbD0xXG4gICAgICBoID0gcyA/IE1hdGguYXRhbjIoaywgYmwpICogcmFkMmRlZyAtIDEyMCA6IE5hTjtcbiAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCA8IDAgPyBoICsgMzYwIDogaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjdWJlaGVsaXhDb252ZXJ0KGgpIDogbmV3IEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoQ3ViZWhlbGl4LCBjdWJlaGVsaXgsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmV4cG9ydHMuY29sb3IgPSBjb2xvcjtcbmV4cG9ydHMucmdiID0gcmdiO1xuZXhwb3J0cy5oc2wgPSBoc2w7XG5leHBvcnRzLmxhYiA9IGxhYjtcbmV4cG9ydHMuaGNsID0gaGNsO1xuZXhwb3J0cy5sY2ggPSBsY2g7XG5leHBvcnRzLmdyYXkgPSBncmF5O1xuZXhwb3J0cy5jdWJlaGVsaXggPSBjdWJlaGVsaXg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWRpc3BhdGNoLyB2MS4wLjUgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBub29wID0ge3ZhbHVlOiBmdW5jdGlvbigpIHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydHMuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZHJhZy8gdjEuMi4zIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtc2VsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtc2VsZWN0aW9uJywgJ2QzLWRpc3BhdGNoJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMyxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzU2VsZWN0aW9uLGQzRGlzcGF0Y2gpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gbm9ldmVudCgpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5vZHJhZyh2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IGQzU2VsZWN0aW9uLnNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBEcmFnRXZlbnQodGFyZ2V0LCB0eXBlLCBzdWJqZWN0LCBpZCwgYWN0aXZlLCB4LCB5LCBkeCwgZHksIGRpc3BhdGNoKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICB0aGlzLmlkZW50aWZpZXIgPSBpZDtcbiAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZHggPSBkeDtcbiAgdGhpcy5keSA9IGR5O1xuICB0aGlzLl8gPSBkaXNwYXRjaDtcbn1cblxuRHJhZ0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcbn07XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcigpIHtcbiAgcmV0dXJuICFkM1NlbGVjdGlvbi5ldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBkM1NlbGVjdGlvbi5ldmVudC54LCB5OiBkM1NlbGVjdGlvbi5ldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRyYWcoKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcixcbiAgICAgIHN1YmplY3QgPSBkZWZhdWx0U3ViamVjdCxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBnZXN0dXJlcyA9IHt9LFxuICAgICAgbGlzdGVuZXJzID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImVuZFwiKSxcbiAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICBtb3VzZWRvd254LFxuICAgICAgbW91c2Vkb3dueSxcbiAgICAgIG1vdXNlbW92aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KFwibW91c2VcIiwgY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGQzU2VsZWN0aW9uLm1vdXNlLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghZ2VzdHVyZSkgcmV0dXJuO1xuICAgIGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIHRydWUpO1xuICAgIG5vZHJhZyhkM1NlbGVjdGlvbi5ldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgbW91c2Vtb3ZpbmcgPSBmYWxzZTtcbiAgICBtb3VzZWRvd254ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WTtcbiAgICBnZXN0dXJlKFwic3RhcnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XG4gICAgICB2YXIgZHggPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRYIC0gbW91c2Vkb3dueCwgZHkgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIiwgbnVsbCk7XG4gICAgeWVzZHJhZyhkM1NlbGVjdGlvbi5ldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XG4gICAgbm9ldmVudCgpO1xuICAgIGdlc3R1cmVzLm1vdXNlKFwiZW5kXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodG91Y2hlc1tpXS5pZGVudGlmaWVyLCBjLCBkM1NlbGVjdGlvbi50b3VjaCwgdGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIHZhciB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub2V2ZW50KCk7XG4gICAgICAgIGdlc3R1cmUoXCJkcmFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcImVuZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVzdGFydChpZCwgY29udGFpbmVyLCBwb2ludCwgdGhhdCwgYXJncykge1xuICAgIHZhciBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIHMsIGR4LCBkeSxcbiAgICAgICAgc3VibGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvcHkoKTtcblxuICAgIGlmICghZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCBcImJlZm9yZXN0YXJ0XCIsIHMsIGlkLCBhY3RpdmUsIHBbMF0sIHBbMV0sIDAsIDAsIHN1Ymxpc3RlbmVycyksIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChkM1NlbGVjdGlvbi5ldmVudC5zdWJqZWN0ID0gcyA9IHN1YmplY3QuYXBwbHkodGhhdCwgYXJncykpID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgICAgZHkgPSBzLnkgLSBwWzFdIHx8IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRdID0gZ2VzdHVyZSwgbiA9IGFjdGl2ZSsrOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRdLCAtLWFjdGl2ZTsgLy8gbm9icmVha1xuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCB0eXBlLCBzLCBpZCwgbiwgcFswXSArIGR4LCBwWzFdICsgZHksIHBbMF0gLSBwMFswXSwgcFsxXSAtIHAwWzFdLCBzdWJsaXN0ZW5lcnMpLCBzdWJsaXN0ZW5lcnMuYXBwbHksIHN1Ymxpc3RlbmVycywgW3R5cGUsIHRoYXQsIGFyZ3NdKTtcbiAgICB9O1xuICB9XG5cbiAgZHJhZy5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IGZpbHRlcjtcbiAgfTtcblxuICBkcmFnLmNvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250YWluZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IGNvbnRhaW5lcjtcbiAgfTtcblxuICBkcmFnLnN1YmplY3QgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ViamVjdCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogc3ViamVjdDtcbiAgfTtcblxuICBkcmFnLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGRyYWcub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gZHJhZyA6IHZhbHVlO1xuICB9O1xuXG4gIGRyYWcuY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgZHJhZykgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiBkcmFnO1xufVxuXG5leHBvcnRzLmRyYWcgPSBkcmFnO1xuZXhwb3J0cy5kcmFnRGlzYWJsZSA9IG5vZHJhZztcbmV4cG9ydHMuZHJhZ0VuYWJsZSA9IHllc2RyYWc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWVhc2UvIHYxLjAuNSBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuICt0O1xufVxuXG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICByZXR1cm4gdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICByZXR1cm4gdCAqICgyIC0gdCk7XG59XG5cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG5cbnZhciBleHBvbmVudCA9IDM7XG5cbnZhciBwb2x5SW4gPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICB9XG5cbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW47XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5T3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5T3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBlKTtcbiAgfVxuXG4gIHBvbHlPdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlPdXQ7XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5SW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3codCwgZSkgOiAyIC0gTWF0aC5wb3coMiAtIHQsIGUpKSAvIDI7XG4gIH1cblxuICBwb2x5SW5PdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbk91dDtcbn0pKGV4cG9uZW50KTtcblxudmFyIHBpID0gTWF0aC5QSSxcbiAgICBoYWxmUGkgPSBwaSAvIDI7XG5cbmZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcbn1cblxuZnVuY3Rpb24gc2luT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc2luKHQgKiBoYWxmUGkpO1xufVxuXG5mdW5jdGlvbiBzaW5Jbk91dCh0KSB7XG4gIHJldHVybiAoMSAtIE1hdGguY29zKHBpICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gZXhwSW4odCkge1xuICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApO1xufVxuXG5mdW5jdGlvbiBleHBPdXQodCkge1xuICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpO1xufVxuXG5mdW5jdGlvbiBleHBJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDIgLSBNYXRoLnBvdygyLCAxMCAtIDEwICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xufVxuXG5mdW5jdGlvbiBjaXJjbGVPdXQodCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCkgOiBNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSAvIDI7XG59XG5cbnZhciBiMSA9IDQgLyAxMSxcbiAgICBiMiA9IDYgLyAxMSxcbiAgICBiMyA9IDggLyAxMSxcbiAgICBiNCA9IDMgLyA0LFxuICAgIGI1ID0gOSAvIDExLFxuICAgIGI2ID0gMTAgLyAxMSxcbiAgICBiNyA9IDE1IC8gMTYsXG4gICAgYjggPSAyMSAvIDIyLFxuICAgIGI5ID0gNjMgLyA2NCxcbiAgICBiMCA9IDEgLyBiMSAvIGIxO1xuXG5mdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gIHJldHVybiAxIC0gYm91bmNlT3V0KDEgLSB0KTtcbn1cblxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xufVxuXG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBib3VuY2VPdXQoMSAtIHQpIDogYm91bmNlT3V0KHQgLSAxKSArIDEpIC8gMjtcbn1cblxudmFyIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG5cbnZhciBiYWNrSW4gPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW47XG59KShvdmVyc2hvb3QpO1xuXG52YXIgYmFja091dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH1cblxuICBiYWNrT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja091dDtcbn0pKG92ZXJzaG9vdCk7XG5cbnZhciBiYWNrSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8IDEgPyB0ICogdCAqICgocyArIDEpICogdCAtIHMpIDogKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKSAvIDI7XG4gIH1cblxuICBiYWNrSW5PdXQub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW5PdXQ7XG59KShvdmVyc2hvb3QpO1xuXG52YXIgdGF1ID0gMiAqIE1hdGguUEksXG4gICAgYW1wbGl0dWRlID0gMSxcbiAgICBwZXJpb2QgPSAwLjM7XG5cbnZhciBlbGFzdGljSW4gPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIDEwICogLS10KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNJbi5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbi5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbjtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxudmFyIGVsYXN0aWNPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBhICogTWF0aC5wb3coMiwgLTEwICogKHQgPSArdCkpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG52YXIgZWxhc3RpY0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCA9IHQgKiAyIC0gMSkgPCAwXG4gICAgICAgID8gYSAqIE1hdGgucG93KDIsIDEwICogdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcClcbiAgICAgICAgOiAyIC0gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHMgKyB0KSAvIHApKSAvIDI7XG4gIH1cblxuICBlbGFzdGljSW5PdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljSW5PdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljSW5PdXQ7XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbmV4cG9ydHMuZWFzZUxpbmVhciA9IGxpbmVhcjtcbmV4cG9ydHMuZWFzZVF1YWQgPSBxdWFkSW5PdXQ7XG5leHBvcnRzLmVhc2VRdWFkSW4gPSBxdWFkSW47XG5leHBvcnRzLmVhc2VRdWFkT3V0ID0gcXVhZE91dDtcbmV4cG9ydHMuZWFzZVF1YWRJbk91dCA9IHF1YWRJbk91dDtcbmV4cG9ydHMuZWFzZUN1YmljID0gY3ViaWNJbk91dDtcbmV4cG9ydHMuZWFzZUN1YmljSW4gPSBjdWJpY0luO1xuZXhwb3J0cy5lYXNlQ3ViaWNPdXQgPSBjdWJpY091dDtcbmV4cG9ydHMuZWFzZUN1YmljSW5PdXQgPSBjdWJpY0luT3V0O1xuZXhwb3J0cy5lYXNlUG9seSA9IHBvbHlJbk91dDtcbmV4cG9ydHMuZWFzZVBvbHlJbiA9IHBvbHlJbjtcbmV4cG9ydHMuZWFzZVBvbHlPdXQgPSBwb2x5T3V0O1xuZXhwb3J0cy5lYXNlUG9seUluT3V0ID0gcG9seUluT3V0O1xuZXhwb3J0cy5lYXNlU2luID0gc2luSW5PdXQ7XG5leHBvcnRzLmVhc2VTaW5JbiA9IHNpbkluO1xuZXhwb3J0cy5lYXNlU2luT3V0ID0gc2luT3V0O1xuZXhwb3J0cy5lYXNlU2luSW5PdXQgPSBzaW5Jbk91dDtcbmV4cG9ydHMuZWFzZUV4cCA9IGV4cEluT3V0O1xuZXhwb3J0cy5lYXNlRXhwSW4gPSBleHBJbjtcbmV4cG9ydHMuZWFzZUV4cE91dCA9IGV4cE91dDtcbmV4cG9ydHMuZWFzZUV4cEluT3V0ID0gZXhwSW5PdXQ7XG5leHBvcnRzLmVhc2VDaXJjbGUgPSBjaXJjbGVJbk91dDtcbmV4cG9ydHMuZWFzZUNpcmNsZUluID0gY2lyY2xlSW47XG5leHBvcnRzLmVhc2VDaXJjbGVPdXQgPSBjaXJjbGVPdXQ7XG5leHBvcnRzLmVhc2VDaXJjbGVJbk91dCA9IGNpcmNsZUluT3V0O1xuZXhwb3J0cy5lYXNlQm91bmNlID0gYm91bmNlT3V0O1xuZXhwb3J0cy5lYXNlQm91bmNlSW4gPSBib3VuY2VJbjtcbmV4cG9ydHMuZWFzZUJvdW5jZU91dCA9IGJvdW5jZU91dDtcbmV4cG9ydHMuZWFzZUJvdW5jZUluT3V0ID0gYm91bmNlSW5PdXQ7XG5leHBvcnRzLmVhc2VCYWNrID0gYmFja0luT3V0O1xuZXhwb3J0cy5lYXNlQmFja0luID0gYmFja0luO1xuZXhwb3J0cy5lYXNlQmFja091dCA9IGJhY2tPdXQ7XG5leHBvcnRzLmVhc2VCYWNrSW5PdXQgPSBiYWNrSW5PdXQ7XG5leHBvcnRzLmVhc2VFbGFzdGljID0gZWxhc3RpY091dDtcbmV4cG9ydHMuZWFzZUVsYXN0aWNJbiA9IGVsYXN0aWNJbjtcbmV4cG9ydHMuZWFzZUVsYXN0aWNPdXQgPSBlbGFzdGljT3V0O1xuZXhwb3J0cy5lYXNlRWxhc3RpY0luT3V0ID0gZWxhc3RpY0luT3V0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1mb3JtYXQvIHYxLjMuMiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4vLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbmZ1bmN0aW9uIGZvcm1hdERlY2ltYWwoeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnQoeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgIHQgPSBbXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TnVtZXJhbHMobnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cbnZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5mdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcbiAgdmFyIG1hdGNoO1xuICB0aGlzLmZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIjtcbiAgdGhpcy5hbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiO1xuICB0aGlzLnNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIjtcbiAgdGhpcy5zeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiO1xuICB0aGlzLnplcm8gPSAhIW1hdGNoWzVdO1xuICB0aGlzLndpZHRoID0gbWF0Y2hbNl0gJiYgK21hdGNoWzZdO1xuICB0aGlzLmNvbW1hID0gISFtYXRjaFs3XTtcbiAgdGhpcy5wcmVjaXNpb24gPSBtYXRjaFs4XSAmJiArbWF0Y2hbOF0uc2xpY2UoMSk7XG4gIHRoaXMudHJpbSA9ICEhbWF0Y2hbOV07XG4gIHRoaXMudHlwZSA9IG1hdGNoWzEwXSB8fCBcIlwiO1xufVxuXG5Gb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICsgdGhpcy5hbGlnblxuICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT0gbnVsbCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICArICh0aGlzLnRyaW0gPyBcIn5cIiA6IFwiXCIpXG4gICAgICArIHRoaXMudHlwZTtcbn07XG5cbi8vIFRyaW1zIGluc2lnbmlmaWNhbnQgemVyb3MsIGUuZy4sIHJlcGxhY2VzIDEuMjAwMGsgd2l0aCAxLjJrLlxuZnVuY3Rpb24gZm9ybWF0VHJpbShzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKGkwID4gMCkgeyBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGkwID0gMDsgfSBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkwID4gMCA/IHMuc2xpY2UoMCwgaTApICsgcy5zbGljZShpMSArIDEpIDogcztcbn1cblxudmFyIHByZWZpeEV4cG9uZW50O1xuXG5mdW5jdGlvbiBmb3JtYXRQcmVmaXhBdXRvKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsKHgsIE1hdGgubWF4KDAsIHAgKyBpIC0gMSkpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJvdW5kZWQoeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG5cbnZhciBmb3JtYXRUeXBlcyA9IHtcbiAgXCIlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuICh4ICogMTAwKS50b0ZpeGVkKHApOyB9LFxuICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICBcImRcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxMCk7IH0sXG4gIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gIFwiZ1wiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvUHJlY2lzaW9uKHApOyB9LFxuICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gIFwieFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KTsgfVxufTtcblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxudmFyIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgJiYgbG9jYWxlLnRob3VzYW5kcyA/IGZvcm1hdEdyb3VwKGxvY2FsZS5ncm91cGluZywgbG9jYWxlLnRob3VzYW5kcykgOiBpZGVudGl0eSxcbiAgICAgIGN1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LFxuICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsLFxuICAgICAgbnVtZXJhbHMgPSBsb2NhbGUubnVtZXJhbHMgPyBmb3JtYXROdW1lcmFscyhsb2NhbGUubnVtZXJhbHMpIDogaWRlbnRpdHksXG4gICAgICBwZXJjZW50ID0gbG9jYWxlLnBlcmNlbnQgfHwgXCIlXCI7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllcikge1xuICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgIHRyaW0gPSBzcGVjaWZpZXIudHJpbSxcbiAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gVGhlIFwiXCIgdHlwZSwgYW5kIGFueSBpbnZhbGlkIHR5cGUsIGlzIGFuIGFsaWFzIGZvciBcIi4xMn5nXCIuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSBwcmVjaXNpb24gPT0gbnVsbCAmJiAocHJlY2lzaW9uID0gMTIpLCB0cmltID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzBdIDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMV0gOiAvWyVwXS8udGVzdCh0eXBlKSA/IHBlcmNlbnQgOiBcIlwiO1xuXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgIG1heWJlU3VmZml4ID0gL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gNlxuICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gdmFsdWUgPCAwO1xuICAgICAgICB2YWx1ZSA9IGZvcm1hdFR5cGUoTWF0aC5hYnModmFsdWUpLCBwcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIFRyaW0gaW5zaWduaWZpY2FudCB6ZXJvcy5cbiAgICAgICAgaWYgKHRyaW0pIHZhbHVlID0gZm9ybWF0VHJpbSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gSWYgYSBuZWdhdGl2ZSB2YWx1ZSByb3VuZHMgdG8gemVybyBkdXJpbmcgZm9ybWF0dGluZywgdHJlYXQgYXMgcG9zaXRpdmUuXG4gICAgICAgIGlmICh2YWx1ZU5lZ2F0aXZlICYmICt2YWx1ZSA9PT0gMCkgdmFsdWVOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArIHZhbHVlU3VmZml4ICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI9XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJeXCI6IHZhbHVlID0gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHZhbHVlID0gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudW1lcmFscyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3BlY2lmaWVyICsgXCJcIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgdmFyIGYgPSBuZXdGb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzLFxuICAgICAgICBrID0gTWF0aC5wb3coMTAsIC1lKSxcbiAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmKGsgKiB2YWx1ZSkgKyBwcmVmaXg7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBuZXdGb3JtYXQsXG4gICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgfTtcbn1cblxudmFyIGxvY2FsZTtcblxuZGVmYXVsdExvY2FsZSh7XG4gIGRlY2ltYWw6IFwiLlwiLFxuICB0aG91c2FuZHM6IFwiLFwiLFxuICBncm91cGluZzogWzNdLFxuICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy5mb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG5cbmZ1bmN0aW9uIHByZWNpc2lvblJvdW5kKHN0ZXAsIG1heCkge1xuICBzdGVwID0gTWF0aC5hYnMoc3RlcCksIG1heCA9IE1hdGguYWJzKG1heCkgLSBzdGVwO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQobWF4KSAtIGV4cG9uZW50KHN0ZXApKSArIDE7XG59XG5cbmV4cG9ydHMuZm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG5leHBvcnRzLmZvcm1hdExvY2FsZSA9IGZvcm1hdExvY2FsZTtcbmV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuZXhwb3J0cy5wcmVjaXNpb25GaXhlZCA9IHByZWNpc2lvbkZpeGVkO1xuZXhwb3J0cy5wcmVjaXNpb25QcmVmaXggPSBwcmVjaXNpb25QcmVmaXg7XG5leHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWhpZXJhcmNoeS8gdjEuMS44IENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbihhLCBiKSB7XG4gIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbn1cblxuZnVuY3Rpb24gbWVhblgoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShtZWFuWFJlZHVjZSwgMCkgLyBjaGlsZHJlbi5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIG1lYW5YUmVkdWNlKHgsIGMpIHtcbiAgcmV0dXJuIHggKyBjLng7XG59XG5cbmZ1bmN0aW9uIG1heFkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIDEgKyBjaGlsZHJlbi5yZWR1Y2UobWF4WVJlZHVjZSwgMCk7XG59XG5cbmZ1bmN0aW9uIG1heFlSZWR1Y2UoeSwgYykge1xuICByZXR1cm4gTWF0aC5tYXgoeSwgYy55KTtcbn1cblxuZnVuY3Rpb24gbGVhZkxlZnQobm9kZSkge1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlblswXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGxlYWZSaWdodChub2RlKSB7XG4gIHZhciBjaGlsZHJlbjtcbiAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgbm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gY2x1c3RlcigpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbixcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIG5vZGVTaXplID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2x1c3Rlcihyb290KSB7XG4gICAgdmFyIHByZXZpb3VzTm9kZSxcbiAgICAgICAgeCA9IDA7XG5cbiAgICAvLyBGaXJzdCB3YWxrLCBjb21wdXRpbmcgdGhlIGluaXRpYWwgeCAmIHkgdmFsdWVzLlxuICAgIHJvb3QuZWFjaEFmdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgbm9kZS54ID0gbWVhblgoY2hpbGRyZW4pO1xuICAgICAgICBub2RlLnkgPSBtYXhZKGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUueCA9IHByZXZpb3VzTm9kZSA/IHggKz0gc2VwYXJhdGlvbihub2RlLCBwcmV2aW91c05vZGUpIDogMDtcbiAgICAgICAgbm9kZS55ID0gMDtcbiAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBsZWZ0ID0gbGVhZkxlZnQocm9vdCksXG4gICAgICAgIHJpZ2h0ID0gbGVhZlJpZ2h0KHJvb3QpLFxuICAgICAgICB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMixcbiAgICAgICAgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuXG4gICAgLy8gU2Vjb25kIHdhbGssIG5vcm1hbGl6aW5nIHggJiB5IHRvIHRoZSBkZXNpcmVkIHNpemUuXG4gICAgcmV0dXJuIHJvb3QuZWFjaEFmdGVyKG5vZGVTaXplID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHJvb3QueCkgKiBkeDtcbiAgICAgIG5vZGUueSA9IChyb290LnkgLSBub2RlLnkpICogZHk7XG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSB4MCkgLyAoeDEgLSB4MCkgKiBkeDtcbiAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIGR5O1xuICAgIH0pO1xuICB9XG5cbiAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCBjbHVzdGVyKSA6IHNlcGFyYXRpb247XG4gIH07XG5cbiAgY2x1c3Rlci5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gZmFsc2UsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gbnVsbCA6IFtkeCwgZHldKTtcbiAgfTtcblxuICBjbHVzdGVyLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gdHJ1ZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBbZHgsIGR5XSA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBjbHVzdGVyO1xufVxuXG5mdW5jdGlvbiBjb3VudChub2RlKSB7XG4gIHZhciBzdW0gPSAwLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKCFpKSBzdW0gPSAxO1xuICBlbHNlIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICBub2RlLnZhbHVlID0gc3VtO1xufVxuXG5mdW5jdGlvbiBub2RlX2NvdW50KCkge1xuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoY291bnQpO1xufVxuXG5mdW5jdGlvbiBub2RlX2VhY2goY2FsbGJhY2spIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBjdXJyZW50LCBuZXh0ID0gW25vZGVdLCBjaGlsZHJlbiwgaSwgbjtcbiAgZG8ge1xuICAgIGN1cnJlbnQgPSBuZXh0LnJldmVyc2UoKSwgbmV4dCA9IFtdO1xuICAgIHdoaWxlIChub2RlID0gY3VycmVudC5wb3AoKSkge1xuICAgICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbikgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBuZXh0LnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAobmV4dC5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbm9kZV9lYWNoQmVmb3JlKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIGNoaWxkcmVuLCBpO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfZWFjaEFmdGVyKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIG5leHQgPSBbXSwgY2hpbGRyZW4sIGksIG47XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBuZXh0LnB1c2gobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobm9kZSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhub2RlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbm9kZV9zdW0odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgc3VtID0gK3ZhbHVlKG5vZGUuZGF0YSkgfHwgMCxcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgICBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICAgIG5vZGUudmFsdWUgPSBzdW07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBub2RlX3NvcnQoY29tcGFyZSkge1xuICByZXR1cm4gdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVfcGF0aChlbmQpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcyxcbiAgICAgIGFuY2VzdG9yID0gbGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSxcbiAgICAgIG5vZGVzID0gW3N0YXJ0XTtcbiAgd2hpbGUgKHN0YXJ0ICE9PSBhbmNlc3Rvcikge1xuICAgIHN0YXJ0ID0gc3RhcnQucGFyZW50O1xuICAgIG5vZGVzLnB1c2goc3RhcnQpO1xuICB9XG4gIHZhciBrID0gbm9kZXMubGVuZ3RoO1xuICB3aGlsZSAoZW5kICE9PSBhbmNlc3Rvcikge1xuICAgIG5vZGVzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgIGVuZCA9IGVuZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBsZWFzdENvbW1vbkFuY2VzdG9yKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBhO1xuICB2YXIgYU5vZGVzID0gYS5hbmNlc3RvcnMoKSxcbiAgICAgIGJOb2RlcyA9IGIuYW5jZXN0b3JzKCksXG4gICAgICBjID0gbnVsbDtcbiAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgYiA9IGJOb2Rlcy5wb3AoKTtcbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBjID0gYTtcbiAgICBhID0gYU5vZGVzLnBvcCgpO1xuICAgIGIgPSBiTm9kZXMucG9wKCk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfYW5jZXN0b3JzKCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdO1xuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfZGVzY2VuZGFudHMoKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuICB0aGlzLmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH0pO1xuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfbGVhdmVzKCkge1xuICB2YXIgbGVhdmVzID0gW107XG4gIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBsZWF2ZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGVhdmVzO1xufVxuXG5mdW5jdGlvbiBub2RlX2xpbmtzKCkge1xuICB2YXIgcm9vdCA9IHRoaXMsIGxpbmtzID0gW107XG4gIHJvb3QuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgIT09IHJvb3QpIHsgLy8gRG9u4oCZdCBpbmNsdWRlIHRoZSByb2904oCZcyBwYXJlbnQsIGlmIGFueS5cbiAgICAgIGxpbmtzLnB1c2goe3NvdXJjZTogbm9kZS5wYXJlbnQsIHRhcmdldDogbm9kZX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsaW5rcztcbn1cblxuZnVuY3Rpb24gaGllcmFyY2h5KGRhdGEsIGNoaWxkcmVuKSB7XG4gIHZhciByb290ID0gbmV3IE5vZGUoZGF0YSksXG4gICAgICB2YWx1ZWQgPSArZGF0YS52YWx1ZSAmJiAocm9vdC52YWx1ZSA9IGRhdGEudmFsdWUpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVzID0gW3Jvb3RdLFxuICAgICAgY2hpbGQsXG4gICAgICBjaGlsZHMsXG4gICAgICBpLFxuICAgICAgbjtcblxuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkgY2hpbGRyZW4gPSBkZWZhdWx0Q2hpbGRyZW47XG5cbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGlmICh2YWx1ZWQpIG5vZGUudmFsdWUgPSArbm9kZS5kYXRhLnZhbHVlO1xuICAgIGlmICgoY2hpbGRzID0gY2hpbGRyZW4obm9kZS5kYXRhKSkgJiYgKG4gPSBjaGlsZHMubGVuZ3RoKSkge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShuKTtcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBOb2RlKGNoaWxkc1tpXSkpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICBjaGlsZC5kZXB0aCA9IG5vZGUuZGVwdGggKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290LmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIG5vZGVfY29weSgpIHtcbiAgcmV0dXJuIGhpZXJhcmNoeSh0aGlzKS5lYWNoQmVmb3JlKGNvcHlEYXRhKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENoaWxkcmVuKGQpIHtcbiAgcmV0dXJuIGQuY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNvcHlEYXRhKG5vZGUpIHtcbiAgbm9kZS5kYXRhID0gbm9kZS5kYXRhLmRhdGE7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVIZWlnaHQobm9kZSkge1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgZG8gbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIHdoaWxlICgobm9kZSA9IG5vZGUucGFyZW50KSAmJiAobm9kZS5oZWlnaHQgPCArK2hlaWdodCkpO1xufVxuXG5mdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5kZXB0aCA9XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xufVxuXG5Ob2RlLnByb3RvdHlwZSA9IGhpZXJhcmNoeS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBOb2RlLFxuICBjb3VudDogbm9kZV9jb3VudCxcbiAgZWFjaDogbm9kZV9lYWNoLFxuICBlYWNoQWZ0ZXI6IG5vZGVfZWFjaEFmdGVyLFxuICBlYWNoQmVmb3JlOiBub2RlX2VhY2hCZWZvcmUsXG4gIHN1bTogbm9kZV9zdW0sXG4gIHNvcnQ6IG5vZGVfc29ydCxcbiAgcGF0aDogbm9kZV9wYXRoLFxuICBhbmNlc3RvcnM6IG5vZGVfYW5jZXN0b3JzLFxuICBkZXNjZW5kYW50czogbm9kZV9kZXNjZW5kYW50cyxcbiAgbGVhdmVzOiBub2RlX2xlYXZlcyxcbiAgbGlua3M6IG5vZGVfbGlua3MsXG4gIGNvcHk6IG5vZGVfY29weVxufTtcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gIHZhciBtID0gYXJyYXkubGVuZ3RoLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W21dO1xuICAgIGFycmF5W21dID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlKGNpcmNsZXMpIHtcbiAgdmFyIGkgPSAwLCBuID0gKGNpcmNsZXMgPSBzaHVmZmxlKHNsaWNlLmNhbGwoY2lyY2xlcykpKS5sZW5ndGgsIEIgPSBbXSwgcCwgZTtcblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBwID0gY2lyY2xlc1tpXTtcbiAgICBpZiAoZSAmJiBlbmNsb3Nlc1dlYWsoZSwgcCkpICsraTtcbiAgICBlbHNlIGUgPSBlbmNsb3NlQmFzaXMoQiA9IGV4dGVuZEJhc2lzKEIsIHApKSwgaSA9IDA7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kQmFzaXMoQiwgcCkge1xuICB2YXIgaSwgajtcblxuICBpZiAoZW5jbG9zZXNXZWFrQWxsKHAsIEIpKSByZXR1cm4gW3BdO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGVuY2xvc2VzTm90KHAsIEJbaV0pXG4gICAgICAgICYmIGVuY2xvc2VzV2Vha0FsbChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCKSkge1xuICAgICAgcmV0dXJuIFtCW2ldLCBwXTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBlbGVtZW50cy5cbiAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBCLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBCW2pdKSwgcClcbiAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCW2pdKVxuICAgICAgICAgICYmIGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltqXSwgcCksIEJbaV0pXG4gICAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczMoQltpXSwgQltqXSwgcCksIEIpKSB7XG4gICAgICAgIHJldHVybiBbQltpXSwgQltqXSwgcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBzb21ldGhpbmcgaXMgdmVyeSB3cm9uZy5cbiAgdGhyb3cgbmV3IEVycm9yO1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc05vdChhLCBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPCAwIHx8IGRyICogZHIgPCBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yICsgMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKGEsIEIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFlbmNsb3Nlc1dlYWsoYSwgQltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpcyhCKSB7XG4gIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBlbmNsb3NlQmFzaXMxKEJbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGVuY2xvc2VCYXNpczIoQlswXSwgQlsxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZW5jbG9zZUJhc2lzMyhCWzBdLCBCWzFdLCBCWzJdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMxKGEpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhLngsXG4gICAgeTogYS55LFxuICAgIHI6IGEuclxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMyKGEsIGIpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDIxID0geDIgLSB4MSwgeTIxID0geTIgLSB5MSwgcjIxID0gcjIgLSByMSxcbiAgICAgIGwgPSBNYXRoLnNxcnQoeDIxICogeDIxICsgeTIxICogeTIxKTtcbiAgcmV0dXJuIHtcbiAgICB4OiAoeDEgKyB4MiArIHgyMSAvIGwgKiByMjEpIC8gMixcbiAgICB5OiAoeTEgKyB5MiArIHkyMSAvIGwgKiByMjEpIC8gMixcbiAgICByOiAobCArIHIxICsgcjIpIC8gMlxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMzKGEsIGIsIGMpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDMgPSBjLngsIHkzID0gYy55LCByMyA9IGMucixcbiAgICAgIGEyID0geDEgLSB4MixcbiAgICAgIGEzID0geDEgLSB4MyxcbiAgICAgIGIyID0geTEgLSB5MixcbiAgICAgIGIzID0geTEgLSB5MyxcbiAgICAgIGMyID0gcjIgLSByMSxcbiAgICAgIGMzID0gcjMgLSByMSxcbiAgICAgIGQxID0geDEgKiB4MSArIHkxICogeTEgLSByMSAqIHIxLFxuICAgICAgZDIgPSBkMSAtIHgyICogeDIgLSB5MiAqIHkyICsgcjIgKiByMixcbiAgICAgIGQzID0gZDEgLSB4MyAqIHgzIC0geTMgKiB5MyArIHIzICogcjMsXG4gICAgICBhYiA9IGEzICogYjIgLSBhMiAqIGIzLFxuICAgICAgeGEgPSAoYjIgKiBkMyAtIGIzICogZDIpIC8gKGFiICogMikgLSB4MSxcbiAgICAgIHhiID0gKGIzICogYzIgLSBiMiAqIGMzKSAvIGFiLFxuICAgICAgeWEgPSAoYTMgKiBkMiAtIGEyICogZDMpIC8gKGFiICogMikgLSB5MSxcbiAgICAgIHliID0gKGEyICogYzMgLSBhMyAqIGMyKSAvIGFiLFxuICAgICAgQSA9IHhiICogeGIgKyB5YiAqIHliIC0gMSxcbiAgICAgIEIgPSAyICogKHIxICsgeGEgKiB4YiArIHlhICogeWIpLFxuICAgICAgQyA9IHhhICogeGEgKyB5YSAqIHlhIC0gcjEgKiByMSxcbiAgICAgIHIgPSAtKEEgPyAoQiArIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKSA6IEMgLyBCKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MSArIHhhICsgeGIgKiByLFxuICAgIHk6IHkxICsgeWEgKyB5YiAqIHIsXG4gICAgcjogclxuICB9O1xufVxuXG5mdW5jdGlvbiBwbGFjZShiLCBhLCBjKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueCwgeCwgYTIsXG4gICAgICBkeSA9IGIueSAtIGEueSwgeSwgYjIsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICBpZiAoZDIpIHtcbiAgICBhMiA9IGEuciArIGMuciwgYTIgKj0gYTI7XG4gICAgYjIgPSBiLnIgKyBjLnIsIGIyICo9IGIyO1xuICAgIGlmIChhMiA+IGIyKSB7XG4gICAgICB4ID0gKGQyICsgYjIgLSBhMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYjIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBiLnggLSB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBiLnkgLSB4ICogZHkgKyB5ICogZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAoZDIgKyBhMiAtIGIyKSAvICgyICogZDIpO1xuICAgICAgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBhMiAvIGQyIC0geCAqIHgpKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSArIHkgKiBkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYy54ID0gYS54ICsgYy5yO1xuICAgIGMueSA9IGEueTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yICsgYi5yIC0gMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gc2NvcmUobm9kZSkge1xuICB2YXIgYSA9IG5vZGUuXyxcbiAgICAgIGIgPSBub2RlLm5leHQuXyxcbiAgICAgIGFiID0gYS5yICsgYi5yLFxuICAgICAgZHggPSAoYS54ICogYi5yICsgYi54ICogYS5yKSAvIGFiLFxuICAgICAgZHkgPSAoYS55ICogYi5yICsgYi55ICogYS5yKSAvIGFiO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIE5vZGUkMShjaXJjbGUpIHtcbiAgdGhpcy5fID0gY2lyY2xlO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFja0VuY2xvc2UoY2lyY2xlcykge1xuICBpZiAoIShuID0gY2lyY2xlcy5sZW5ndGgpKSByZXR1cm4gMDtcblxuICB2YXIgYSwgYiwgYywgbiwgYWEsIGNhLCBpLCBqLCBrLCBzaiwgc2s7XG5cbiAgLy8gUGxhY2UgdGhlIGZpcnN0IGNpcmNsZS5cbiAgYSA9IGNpcmNsZXNbMF0sIGEueCA9IDAsIGEueSA9IDA7XG4gIGlmICghKG4gPiAxKSkgcmV0dXJuIGEucjtcblxuICAvLyBQbGFjZSB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgYiA9IGNpcmNsZXNbMV0sIGEueCA9IC1iLnIsIGIueCA9IGEuciwgYi55ID0gMDtcbiAgaWYgKCEobiA+IDIpKSByZXR1cm4gYS5yICsgYi5yO1xuXG4gIC8vIFBsYWNlIHRoZSB0aGlyZCBjaXJjbGUuXG4gIHBsYWNlKGIsIGEsIGMgPSBjaXJjbGVzWzJdKTtcblxuICAvLyBJbml0aWFsaXplIHRoZSBmcm9udC1jaGFpbiB1c2luZyB0aGUgZmlyc3QgdGhyZWUgY2lyY2xlcyBhLCBiIGFuZCBjLlxuICBhID0gbmV3IE5vZGUkMShhKSwgYiA9IG5ldyBOb2RlJDEoYiksIGMgPSBuZXcgTm9kZSQxKGMpO1xuICBhLm5leHQgPSBjLnByZXZpb3VzID0gYjtcbiAgYi5uZXh0ID0gYS5wcmV2aW91cyA9IGM7XG4gIGMubmV4dCA9IGIucHJldmlvdXMgPSBhO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGxhY2UgZWFjaCByZW1haW5pbmcgY2lyY2xl4oCmXG4gIHBhY2s6IGZvciAoaSA9IDM7IGkgPCBuOyArK2kpIHtcbiAgICBwbGFjZShhLl8sIGIuXywgYyA9IGNpcmNsZXNbaV0pLCBjID0gbmV3IE5vZGUkMShjKTtcblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW5nIGNpcmNsZSBvbiB0aGUgZnJvbnQtY2hhaW4sIGlmIGFueS5cbiAgICAvLyDigJxDbG9zZW5lc3PigJ0gaXMgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UgYWxvbmcgdGhlIGZyb250LWNoYWluLlxuICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cbiAgICBqID0gYi5uZXh0LCBrID0gYS5wcmV2aW91cywgc2ogPSBiLl8uciwgc2sgPSBhLl8ucjtcbiAgICBkbyB7XG4gICAgICBpZiAoc2ogPD0gc2spIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoai5fLCBjLl8pKSB7XG4gICAgICAgICAgYiA9IGosIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzaiArPSBqLl8uciwgaiA9IGoubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGsuXywgYy5fKSkge1xuICAgICAgICAgIGEgPSBrLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2sgKz0gay5fLnIsIGsgPSBrLnByZXZpb3VzO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGogIT09IGsubmV4dCk7XG5cbiAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgYy5wcmV2aW91cyA9IGEsIGMubmV4dCA9IGIsIGEubmV4dCA9IGIucHJldmlvdXMgPSBiID0gYztcblxuICAgIC8vIENvbXB1dGUgdGhlIG5ldyBjbG9zZXN0IGNpcmNsZSBwYWlyIHRvIHRoZSBjZW50cm9pZC5cbiAgICBhYSA9IHNjb3JlKGEpO1xuICAgIHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpIHtcbiAgICAgIGlmICgoY2EgPSBzY29yZShjKSkgPCBhYSkge1xuICAgICAgICBhID0gYywgYWEgPSBjYTtcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IGEubmV4dDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGVuY2xvc2luZyBjaXJjbGUgb2YgdGhlIGZyb250IGNoYWluLlxuICBhID0gW2IuX10sIGMgPSBiOyB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSBhLnB1c2goYy5fKTsgYyA9IGVuY2xvc2UoYSk7XG5cbiAgLy8gVHJhbnNsYXRlIHRoZSBjaXJjbGVzIHRvIHB1dCB0aGUgZW5jbG9zaW5nIGNpcmNsZSBhcm91bmQgdGhlIG9yaWdpbi5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYSA9IGNpcmNsZXNbaV0sIGEueCAtPSBjLngsIGEueSAtPSBjLnk7XG5cbiAgcmV0dXJuIGMucjtcbn1cblxuZnVuY3Rpb24gc2libGluZ3MoY2lyY2xlcykge1xuICBwYWNrRW5jbG9zZShjaXJjbGVzKTtcbiAgcmV0dXJuIGNpcmNsZXM7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbmFsKGYpIHtcbiAgcmV0dXJuIGYgPT0gbnVsbCA/IG51bGwgOiByZXF1aXJlZChmKTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZWQoZikge1xuICBpZiAodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnRaZXJvKCkge1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSYWRpdXMoZCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpbmRleCgpIHtcbiAgdmFyIHJhZGl1cyA9IG51bGwsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHBhY2socm9vdCkge1xuICAgIHJvb3QueCA9IGR4IC8gMiwgcm9vdC55ID0gZHkgLyAyO1xuICAgIGlmIChyYWRpdXMpIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKHJhZGl1cykpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgMC41KSlcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZCgxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKGRlZmF1bHRSYWRpdXMpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKGNvbnN0YW50WmVybywgMSkpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgcm9vdC5yIC8gTWF0aC5taW4oZHgsIGR5KSkpXG4gICAgICAgICAgLmVhY2hCZWZvcmUodHJhbnNsYXRlQ2hpbGQoTWF0aC5taW4oZHgsIGR5KSAvICgyICogcm9vdC5yKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIHBhY2sucmFkaXVzID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IG9wdGlvbmFsKHgpLCBwYWNrKSA6IHJhZGl1cztcbiAgfTtcblxuICBwYWNrLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFjaykgOiBbZHgsIGR5XTtcbiAgfTtcblxuICBwYWNrLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZyA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCBwYWNrKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIHBhY2s7XG59XG5cbmZ1bmN0aW9uIHJhZGl1c0xlYWYocmFkaXVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLnIgPSBNYXRoLm1heCgwLCArcmFkaXVzKG5vZGUpIHx8IDApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFja0NoaWxkcmVuKHBhZGRpbmcsIGspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGRyZW4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIHIgPSBwYWRkaW5nKG5vZGUpICogayB8fCAwLFxuICAgICAgICAgIGU7XG5cbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yICs9IHI7XG4gICAgICBlID0gcGFja0VuY2xvc2UoY2hpbGRyZW4pO1xuICAgICAgaWYgKHIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoaWxkcmVuW2ldLnIgLT0gcjtcbiAgICAgIG5vZGUuciA9IGUgKyByO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlQ2hpbGQoaykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBub2RlLnggPSBwYXJlbnQueCArIGsgKiBub2RlLng7XG4gICAgICBub2RlLnkgPSBwYXJlbnQueSArIGsgKiBub2RlLnk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByb3VuZE5vZGUobm9kZSkge1xuICBub2RlLngwID0gTWF0aC5yb3VuZChub2RlLngwKTtcbiAgbm9kZS55MCA9IE1hdGgucm91bmQobm9kZS55MCk7XG4gIG5vZGUueDEgPSBNYXRoLnJvdW5kKG5vZGUueDEpO1xuICBub2RlLnkxID0gTWF0aC5yb3VuZChub2RlLnkxKTtcbn1cblxuZnVuY3Rpb24gdHJlZW1hcERpY2UocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBub2RlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGsgPSBwYXJlbnQudmFsdWUgJiYgKHgxIC0geDApIC8gcGFyZW50LnZhbHVlO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnkwID0geTAsIG5vZGUueTEgPSB5MTtcbiAgICBub2RlLngwID0geDAsIG5vZGUueDEgPSB4MCArPSBub2RlLnZhbHVlICogaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aXRpb24oKSB7XG4gIHZhciBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gMCxcbiAgICAgIHJvdW5kID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKHJvb3QpIHtcbiAgICB2YXIgbiA9IHJvb3QuaGVpZ2h0ICsgMTtcbiAgICByb290LngwID1cbiAgICByb290LnkwID0gcGFkZGluZztcbiAgICByb290LngxID0gZHg7XG4gICAgcm9vdC55MSA9IGR5IC8gbjtcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKGR5LCBuKSk7XG4gICAgaWYgKHJvdW5kKSByb290LmVhY2hCZWZvcmUocm91bmROb2RlKTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShkeSwgbikge1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICB0cmVlbWFwRGljZShub2RlLCBub2RlLngwLCBkeSAqIChub2RlLmRlcHRoICsgMSkgLyBuLCBub2RlLngxLCBkeSAqIChub2RlLmRlcHRoICsgMikgLyBuKTtcbiAgICAgIH1cbiAgICAgIHZhciB4MCA9IG5vZGUueDAsXG4gICAgICAgICAgeTAgPSBub2RlLnkwLFxuICAgICAgICAgIHgxID0gbm9kZS54MSAtIHBhZGRpbmcsXG4gICAgICAgICAgeTEgPSBub2RlLnkxIC0gcGFkZGluZztcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIG5vZGUueDAgPSB4MDtcbiAgICAgIG5vZGUueTAgPSB5MDtcbiAgICAgIG5vZGUueDEgPSB4MTtcbiAgICAgIG5vZGUueTEgPSB5MTtcbiAgICB9O1xuICB9XG5cbiAgcGFydGl0aW9uLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCBwYXJ0aXRpb24pIDogcm91bmQ7XG4gIH07XG5cbiAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFydGl0aW9uKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHBhcnRpdGlvbi5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSAreCwgcGFydGl0aW9uKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIHBhcnRpdGlvbjtcbn1cblxudmFyIGtleVByZWZpeCA9IFwiJFwiLCAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cbiAgICBwcmVyb290ID0ge2RlcHRoOiAtMX0sXG4gICAgYW1iaWd1b3VzID0ge307XG5cbmZ1bmN0aW9uIGRlZmF1bHRJZChkKSB7XG4gIHJldHVybiBkLmlkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyZW50SWQoZCkge1xuICByZXR1cm4gZC5wYXJlbnRJZDtcbn1cblxuZnVuY3Rpb24gc3RyYXRpZnkoKSB7XG4gIHZhciBpZCA9IGRlZmF1bHRJZCxcbiAgICAgIHBhcmVudElkID0gZGVmYXVsdFBhcmVudElkO1xuXG4gIGZ1bmN0aW9uIHN0cmF0aWZ5KGRhdGEpIHtcbiAgICB2YXIgZCxcbiAgICAgICAgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICByb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIG5vZGVLZXksXG4gICAgICAgIG5vZGVCeUtleSA9IHt9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZCA9IGRhdGFbaV0sIG5vZGUgPSBub2Rlc1tpXSA9IG5ldyBOb2RlKGQpO1xuICAgICAgaWYgKChub2RlSWQgPSBpZChkLCBpLCBkYXRhKSkgIT0gbnVsbCAmJiAobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIG5vZGVLZXkgPSBrZXlQcmVmaXggKyAobm9kZS5pZCA9IG5vZGVJZCk7XG4gICAgICAgIG5vZGVCeUtleVtub2RlS2V5XSA9IG5vZGVLZXkgaW4gbm9kZUJ5S2V5ID8gYW1iaWd1b3VzIDogbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGVJZCA9IHBhcmVudElkKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgaWYgKG5vZGVJZCA9PSBudWxsIHx8ICEobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIGlmIChyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSByb290c1wiKTtcbiAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBub2RlQnlLZXlba2V5UHJlZml4ICsgbm9kZUlkXTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gYW1iaWd1b3VzKSB0aHJvdyBuZXcgRXJyb3IoXCJhbWJpZ3VvdXM6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbikgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIGVsc2UgcGFyZW50LmNoaWxkcmVuID0gW25vZGVdO1xuICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJvb3QpIHRocm93IG5ldyBFcnJvcihcIm5vIHJvb3RcIik7XG4gICAgcm9vdC5wYXJlbnQgPSBwcmVyb290O1xuICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7IG5vZGUuZGVwdGggPSBub2RlLnBhcmVudC5kZXB0aCArIDE7IC0tbjsgfSkuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcbiAgICByb290LnBhcmVudCA9IG51bGw7XG4gICAgaWYgKG4gPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJjeWNsZVwiKTtcblxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgc3RyYXRpZnkuaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogaWQ7XG4gIH07XG5cbiAgc3RyYXRpZnkucGFyZW50SWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFyZW50SWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogcGFyZW50SWQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0cmF0aWZ5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbiQxKGEsIGIpIHtcbiAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xufVxuXG4vLyBmdW5jdGlvbiByYWRpYWxTZXBhcmF0aW9uKGEsIGIpIHtcbi8vICAgcmV0dXJuIChhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMikgLyBhLmRlcHRoO1xuLy8gfVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGxlZnQgY29udG91ciBvZiBhIHN1YnRyZWUgKG9yXG4vLyBzdWJmb3Jlc3QpLiBJdCByZXR1cm5zIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXIuIFRoaXMgc3VjY2Vzc29yIGlzXG4vLyBlaXRoZXIgZ2l2ZW4gYnkgdGhlIGxlZnRtb3N0IGNoaWxkIG9mIHYgb3IgYnkgdGhlIHRocmVhZCBvZiB2LiBUaGUgZnVuY3Rpb25cbi8vIHJldHVybnMgbnVsbCBpZiBhbmQgb25seSBpZiB2IGlzIG9uIHRoZSBoaWdoZXN0IGxldmVsIG9mIGl0cyBzdWJ0cmVlLlxuZnVuY3Rpb24gbmV4dExlZnQodikge1xuICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IHYudDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3b3JrcyBhbmFsb2dvdXNseSB0byBuZXh0TGVmdC5cbmZ1bmN0aW9uIG5leHRSaWdodCh2KSB7XG4gIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIDogdi50O1xufVxuXG4vLyBTaGlmdHMgdGhlIGN1cnJlbnQgc3VidHJlZSByb290ZWQgYXQgdysuIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nXG4vLyBwcmVsaW0odyspIGFuZCBtb2QodyspIGJ5IHNoaWZ0LlxuZnVuY3Rpb24gbW92ZVN1YnRyZWUod20sIHdwLCBzaGlmdCkge1xuICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xuICB3cC5jIC09IGNoYW5nZTtcbiAgd3AucyArPSBzaGlmdDtcbiAgd20uYyArPSBjaGFuZ2U7XG4gIHdwLnogKz0gc2hpZnQ7XG4gIHdwLm0gKz0gc2hpZnQ7XG59XG5cbi8vIEFsbCBvdGhlciBzaGlmdHMsIGFwcGxpZWQgdG8gdGhlIHNtYWxsZXIgc3VidHJlZXMgYmV0d2VlbiB3LSBhbmQgdyssIGFyZVxuLy8gcGVyZm9ybWVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIHByZXBhcmUgdGhlIHNoaWZ0cywgd2UgaGF2ZSB0byBhZGp1c3Rcbi8vIGNoYW5nZSh3KyksIHNoaWZ0KHcrKSwgYW5kIGNoYW5nZSh3LSkuXG5mdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcbiAgdmFyIHNoaWZ0ID0gMCxcbiAgICAgIGNoYW5nZSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sXG4gICAgICBpID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgdztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgIHcueiArPSBzaGlmdDtcbiAgICB3Lm0gKz0gc2hpZnQ7XG4gICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICB9XG59XG5cbi8vIElmIHZpLeKAmXMgYW5jZXN0b3IgaXMgYSBzaWJsaW5nIG9mIHYsIHJldHVybnMgdmkt4oCZcyBhbmNlc3Rvci4gT3RoZXJ3aXNlLFxuLy8gcmV0dXJucyB0aGUgc3BlY2lmaWVkIChkZWZhdWx0KSBhbmNlc3Rvci5cbmZ1bmN0aW9uIG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XG4gIHJldHVybiB2aW0uYS5wYXJlbnQgPT09IHYucGFyZW50ID8gdmltLmEgOiBhbmNlc3Rvcjtcbn1cblxuZnVuY3Rpb24gVHJlZU5vZGUobm9kZSwgaSkge1xuICB0aGlzLl8gPSBub2RlO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLkEgPSBudWxsOyAvLyBkZWZhdWx0IGFuY2VzdG9yXG4gIHRoaXMuYSA9IHRoaXM7IC8vIGFuY2VzdG9yXG4gIHRoaXMueiA9IDA7IC8vIHByZWxpbVxuICB0aGlzLm0gPSAwOyAvLyBtb2RcbiAgdGhpcy5jID0gMDsgLy8gY2hhbmdlXG4gIHRoaXMucyA9IDA7IC8vIHNoaWZ0XG4gIHRoaXMudCA9IG51bGw7IC8vIHRocmVhZFxuICB0aGlzLmkgPSBpOyAvLyBudW1iZXJcbn1cblxuVHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIHRyZWVSb290KHJvb3QpIHtcbiAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUocm9vdCwgMCksXG4gICAgICBub2RlLFxuICAgICAgbm9kZXMgPSBbdHJlZV0sXG4gICAgICBjaGlsZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuXy5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShuID0gY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBUcmVlTm9kZShjaGlsZHJlbltpXSwgaSkpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICh0cmVlLnBhcmVudCA9IG5ldyBUcmVlTm9kZShudWxsLCAwKSkuY2hpbGRyZW4gPSBbdHJlZV07XG4gIHJldHVybiB0cmVlO1xufVxuXG4vLyBOb2RlLWxpbmsgdHJlZSBkaWFncmFtIHVzaW5nIHRoZSBSZWluZ29sZC1UaWxmb3JkIFwidGlkeVwiIGFsZ29yaXRobVxuZnVuY3Rpb24gdHJlZSgpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbiQxLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgbm9kZVNpemUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHRyZWUocm9vdCkge1xuICAgIHZhciB0ID0gdHJlZVJvb3Qocm9vdCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBsYXlvdXQgdXNpbmcgQnVjaGhlaW0gZXQgYWwu4oCZcyBhbGdvcml0aG0uXG4gICAgdC5lYWNoQWZ0ZXIoZmlyc3RXYWxrKSwgdC5wYXJlbnQubSA9IC10Lno7XG4gICAgdC5lYWNoQmVmb3JlKHNlY29uZFdhbGspO1xuXG4gICAgLy8gSWYgYSBmaXhlZCBub2RlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5LlxuICAgIGlmIChub2RlU2l6ZSkgcm9vdC5lYWNoQmVmb3JlKHNpemVOb2RlKTtcblxuICAgIC8vIElmIGEgZml4ZWQgdHJlZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeSBiYXNlZCBvbiB0aGUgZXh0ZW50LlxuICAgIC8vIENvbXB1dGUgdGhlIGxlZnQtbW9zdCwgcmlnaHQtbW9zdCwgYW5kIGRlcHRoLW1vc3Qgbm9kZXMgZm9yIGV4dGVudHMuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgbGVmdCA9IHJvb3QsXG4gICAgICAgICAgcmlnaHQgPSByb290LFxuICAgICAgICAgIGJvdHRvbSA9IHJvb3Q7XG4gICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZS54IDwgbGVmdC54KSBsZWZ0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpIGJvdHRvbSA9IG5vZGU7XG4gICAgICB9KTtcbiAgICAgIHZhciBzID0gbGVmdCA9PT0gcmlnaHQgPyAxIDogc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLFxuICAgICAgICAgIHR4ID0gcyAtIGxlZnQueCxcbiAgICAgICAgICBreCA9IGR4IC8gKHJpZ2h0LnggKyBzICsgdHgpLFxuICAgICAgICAgIGt5ID0gZHkgLyAoYm90dG9tLmRlcHRoIHx8IDEpO1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCArIHR4KSAqIGt4O1xuICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGEgcHJlbGltaW5hcnkgeC1jb29yZGluYXRlIGZvciB2LiBCZWZvcmUgdGhhdCwgRklSU1QgV0FMSyBpc1xuICAvLyBhcHBsaWVkIHJlY3Vyc2l2ZWx5IHRvIHRoZSBjaGlsZHJlbiBvZiB2LCBhcyB3ZWxsIGFzIHRoZSBmdW5jdGlvblxuICAvLyBBUFBPUlRJT04uIEFmdGVyIHNwYWNpbmcgb3V0IHRoZSBjaGlsZHJlbiBieSBjYWxsaW5nIEVYRUNVVEUgU0hJRlRTLCB0aGVcbiAgLy8gbm9kZSB2IGlzIHBsYWNlZCB0byB0aGUgbWlkcG9pbnQgb2YgaXRzIG91dGVybW9zdCBjaGlsZHJlbi5cbiAgZnVuY3Rpb24gZmlyc3RXYWxrKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLFxuICAgICAgICBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLFxuICAgICAgICB3ID0gdi5pID8gc2libGluZ3Nbdi5pIC0gMV0gOiBudWxsO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZXhlY3V0ZVNoaWZ0cyh2KTtcbiAgICAgIHZhciBtaWRwb2ludCA9IChjaGlsZHJlblswXS56ICsgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueikgLyAyO1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgIHYubSA9IHYueiAtIG1pZHBvaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3KSB7XG4gICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICB9XG4gICAgdi5wYXJlbnQuQSA9IGFwcG9ydGlvbih2LCB3LCB2LnBhcmVudC5BIHx8IHNpYmxpbmdzWzBdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGFsbCByZWFsIHgtY29vcmRpbmF0ZXMgYnkgc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIHJlY3Vyc2l2ZWx5LlxuICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcbiAgICB2Ll8ueCA9IHYueiArIHYucGFyZW50Lm07XG4gICAgdi5tICs9IHYucGFyZW50Lm07XG4gIH1cblxuICAvLyBUaGUgY29yZSBvZiB0aGUgYWxnb3JpdGhtLiBIZXJlLCBhIG5ldyBzdWJ0cmVlIGlzIGNvbWJpbmVkIHdpdGggdGhlXG4gIC8vIHByZXZpb3VzIHN1YnRyZWVzLiBUaHJlYWRzIGFyZSB1c2VkIHRvIHRyYXZlcnNlIHRoZSBpbnNpZGUgYW5kIG91dHNpZGVcbiAgLy8gY29udG91cnMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWUgdXAgdG8gdGhlIGhpZ2hlc3QgY29tbW9uIGxldmVsLiBUaGVcbiAgLy8gdmVydGljZXMgdXNlZCBmb3IgdGhlIHRyYXZlcnNhbHMgYXJlIHZpKywgdmktLCB2by0sIGFuZCB2byssIHdoZXJlIHRoZVxuICAvLyBzdXBlcnNjcmlwdCBvIG1lYW5zIG91dHNpZGUgYW5kIGkgbWVhbnMgaW5zaWRlLCB0aGUgc3Vic2NyaXB0IC0gbWVhbnMgbGVmdFxuICAvLyBzdWJ0cmVlIGFuZCArIG1lYW5zIHJpZ2h0IHN1YnRyZWUuIEZvciBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgYWxvbmcgdGhlXG4gIC8vIGNvbnRvdXIsIHdlIHVzZSByZXNwZWN0aXZlIHZhcmlhYmxlcyBzaSssIHNpLSwgc28tLCBhbmQgc28rLiBXaGVuZXZlciB0d29cbiAgLy8gbm9kZXMgb2YgdGhlIGluc2lkZSBjb250b3VycyBjb25mbGljdCwgd2UgY29tcHV0ZSB0aGUgbGVmdCBvbmUgb2YgdGhlXG4gIC8vIGdyZWF0ZXN0IHVuY29tbW9uIGFuY2VzdG9ycyB1c2luZyB0aGUgZnVuY3Rpb24gQU5DRVNUT1IgYW5kIGNhbGwgTU9WRVxuICAvLyBTVUJUUkVFIHRvIHNoaWZ0IHRoZSBzdWJ0cmVlIGFuZCBwcmVwYXJlIHRoZSBzaGlmdHMgb2Ygc21hbGxlciBzdWJ0cmVlcy5cbiAgLy8gRmluYWxseSwgd2UgYWRkIGEgbmV3IHRocmVhZCAoaWYgbmVjZXNzYXJ5KS5cbiAgZnVuY3Rpb24gYXBwb3J0aW9uKHYsIHcsIGFuY2VzdG9yKSB7XG4gICAgaWYgKHcpIHtcbiAgICAgIHZhciB2aXAgPSB2LFxuICAgICAgICAgIHZvcCA9IHYsXG4gICAgICAgICAgdmltID0gdyxcbiAgICAgICAgICB2b20gPSB2aXAucGFyZW50LmNoaWxkcmVuWzBdLFxuICAgICAgICAgIHNpcCA9IHZpcC5tLFxuICAgICAgICAgIHNvcCA9IHZvcC5tLFxuICAgICAgICAgIHNpbSA9IHZpbS5tLFxuICAgICAgICAgIHNvbSA9IHZvbS5tLFxuICAgICAgICAgIHNoaWZ0O1xuICAgICAgd2hpbGUgKHZpbSA9IG5leHRSaWdodCh2aW0pLCB2aXAgPSBuZXh0TGVmdCh2aXApLCB2aW0gJiYgdmlwKSB7XG4gICAgICAgIHZvbSA9IG5leHRMZWZ0KHZvbSk7XG4gICAgICAgIHZvcCA9IG5leHRSaWdodCh2b3ApO1xuICAgICAgICB2b3AuYSA9IHY7XG4gICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICAgIG1vdmVTdWJ0cmVlKG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2ltICs9IHZpbS5tO1xuICAgICAgICBzaXAgKz0gdmlwLm07XG4gICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgc29wICs9IHZvcC5tO1xuICAgICAgfVxuICAgICAgaWYgKHZpbSAmJiAhbmV4dFJpZ2h0KHZvcCkpIHtcbiAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgIHZvcC5tICs9IHNpbSAtIHNvcDtcbiAgICAgIH1cbiAgICAgIGlmICh2aXAgJiYgIW5leHRMZWZ0KHZvbSkpIHtcbiAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcbiAgICAgICAgYW5jZXN0b3IgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgbm9kZS54ICo9IGR4O1xuICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgfVxuXG4gIHRyZWUuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgdHJlZSkgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gdHJlZTtcbn1cblxuZnVuY3Rpb24gdHJlZW1hcFNsaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBrID0gcGFyZW50LnZhbHVlICYmICh5MSAtIHkwKSAvIHBhcmVudC52YWx1ZTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDE7XG4gICAgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gIH1cbn1cblxudmFyIHBoaSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cbmZ1bmN0aW9uIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIHJvd3MgPSBbXSxcbiAgICAgIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgcm93LFxuICAgICAgbm9kZVZhbHVlLFxuICAgICAgaTAgPSAwLFxuICAgICAgaTEgPSAwLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGR4LCBkeSxcbiAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlLFxuICAgICAgc3VtVmFsdWUsXG4gICAgICBtaW5WYWx1ZSxcbiAgICAgIG1heFZhbHVlLFxuICAgICAgbmV3UmF0aW8sXG4gICAgICBtaW5SYXRpbyxcbiAgICAgIGFscGhhLFxuICAgICAgYmV0YTtcblxuICB3aGlsZSAoaTAgPCBuKSB7XG4gICAgZHggPSB4MSAtIHgwLCBkeSA9IHkxIC0geTA7XG5cbiAgICAvLyBGaW5kIHRoZSBuZXh0IG5vbi1lbXB0eSBub2RlLlxuICAgIGRvIHN1bVZhbHVlID0gbm9kZXNbaTErK10udmFsdWU7IHdoaWxlICghc3VtVmFsdWUgJiYgaTEgPCBuKTtcbiAgICBtaW5WYWx1ZSA9IG1heFZhbHVlID0gc3VtVmFsdWU7XG4gICAgYWxwaGEgPSBNYXRoLm1heChkeSAvIGR4LCBkeCAvIGR5KSAvICh2YWx1ZSAqIHJhdGlvKTtcbiAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgIG1pblJhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuXG4gICAgLy8gS2VlcCBhZGRpbmcgbm9kZXMgd2hpbGUgdGhlIGFzcGVjdCByYXRpbyBtYWludGFpbnMgb3IgaW1wcm92ZXMuXG4gICAgZm9yICg7IGkxIDwgbjsgKytpMSkge1xuICAgICAgc3VtVmFsdWUgKz0gbm9kZVZhbHVlID0gbm9kZXNbaTFdLnZhbHVlO1xuICAgICAgaWYgKG5vZGVWYWx1ZSA8IG1pblZhbHVlKSBtaW5WYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgIGlmIChub2RlVmFsdWUgPiBtYXhWYWx1ZSkgbWF4VmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgICAgbmV3UmF0aW8gPSBNYXRoLm1heChtYXhWYWx1ZSAvIGJldGEsIGJldGEgLyBtaW5WYWx1ZSk7XG4gICAgICBpZiAobmV3UmF0aW8gPiBtaW5SYXRpbykgeyBzdW1WYWx1ZSAtPSBub2RlVmFsdWU7IGJyZWFrOyB9XG4gICAgICBtaW5SYXRpbyA9IG5ld1JhdGlvO1xuICAgIH1cblxuICAgIC8vIFBvc2l0aW9uIGFuZCByZWNvcmQgdGhlIHJvdyBvcmllbnRhdGlvbi5cbiAgICByb3dzLnB1c2gocm93ID0ge3ZhbHVlOiBzdW1WYWx1ZSwgZGljZTogZHggPCBkeSwgY2hpbGRyZW46IG5vZGVzLnNsaWNlKGkwLCBpMSl9KTtcbiAgICBpZiAocm93LmRpY2UpIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgdmFsdWUgPyB5MCArPSBkeSAqIHN1bVZhbHVlIC8gdmFsdWUgOiB5MSk7XG4gICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHZhbHVlID8geDAgKz0gZHggKiBzdW1WYWx1ZSAvIHZhbHVlIDogeDEsIHkxKTtcbiAgICB2YWx1ZSAtPSBzdW1WYWx1ZSwgaTAgPSBpMTtcbiAgfVxuXG4gIHJldHVybiByb3dzO1xufVxuXG52YXIgc3F1YXJpZnkgPSAoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHNxdWFyaWZ5O1xufSkocGhpKTtcblxuZnVuY3Rpb24gaW5kZXgkMSgpIHtcbiAgdmFyIHRpbGUgPSBzcXVhcmlmeSxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nU3RhY2sgPSBbMF0sXG4gICAgICBwYWRkaW5nSW5uZXIgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nVG9wID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ1JpZ2h0ID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ0JvdHRvbSA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdMZWZ0ID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHRyZWVtYXAocm9vdCkge1xuICAgIHJvb3QueDAgPVxuICAgIHJvb3QueTAgPSAwO1xuICAgIHJvb3QueDEgPSBkeDtcbiAgICByb290LnkxID0gZHk7XG4gICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZSk7XG4gICAgcGFkZGluZ1N0YWNrID0gWzBdO1xuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUobm9kZSkge1xuICAgIHZhciBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGhdLFxuICAgICAgICB4MCA9IG5vZGUueDAgKyBwLFxuICAgICAgICB5MCA9IG5vZGUueTAgKyBwLFxuICAgICAgICB4MSA9IG5vZGUueDEgLSBwLFxuICAgICAgICB5MSA9IG5vZGUueTEgLSBwO1xuICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgbm9kZS54MCA9IHgwO1xuICAgIG5vZGUueTAgPSB5MDtcbiAgICBub2RlLngxID0geDE7XG4gICAgbm9kZS55MSA9IHkxO1xuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGggKyAxXSA9IHBhZGRpbmdJbm5lcihub2RlKSAvIDI7XG4gICAgICB4MCArPSBwYWRkaW5nTGVmdChub2RlKSAtIHA7XG4gICAgICB5MCArPSBwYWRkaW5nVG9wKG5vZGUpIC0gcDtcbiAgICAgIHgxIC09IHBhZGRpbmdSaWdodChub2RlKSAtIHA7XG4gICAgICB5MSAtPSBwYWRkaW5nQm90dG9tKG5vZGUpIC0gcDtcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIHRpbGUobm9kZSwgeDAsIHkwLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxuXG4gIHRyZWVtYXAucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHRyZWVtYXApIDogcm91bmQ7XG4gIH07XG5cbiAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWVtYXApIDogW2R4LCBkeV07XG4gIH07XG5cbiAgdHJlZW1hcC50aWxlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpbGUgPSByZXF1aXJlZCh4KSwgdHJlZW1hcCkgOiB0aWxlO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ0lubmVyKHgpLnBhZGRpbmdPdXRlcih4KSA6IHRyZWVtYXAucGFkZGluZ0lubmVyKCk7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ091dGVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJlZW1hcC5wYWRkaW5nVG9wKHgpLnBhZGRpbmdSaWdodCh4KS5wYWRkaW5nQm90dG9tKHgpLnBhZGRpbmdMZWZ0KHgpIDogdHJlZW1hcC5wYWRkaW5nVG9wKCk7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nVG9wID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdUb3AgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nVG9wO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ1JpZ2h0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdSaWdodCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdSaWdodDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdCb3R0b20gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0JvdHRvbSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdCb3R0b207XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nTGVmdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nTGVmdCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdMZWZ0O1xuICB9O1xuXG4gIHJldHVybiB0cmVlbWFwO1xufVxuXG5mdW5jdGlvbiBiaW5hcnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBpLCBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgc3VtLCBzdW1zID0gbmV3IEFycmF5KG4gKyAxKTtcblxuICBmb3IgKHN1bXNbMF0gPSBzdW0gPSBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHN1bXNbaSArIDFdID0gc3VtICs9IG5vZGVzW2ldLnZhbHVlO1xuICB9XG5cbiAgcGFydGl0aW9uKDAsIG4sIHBhcmVudC52YWx1ZSwgeDAsIHkwLCB4MSwgeTEpO1xuXG4gIGZ1bmN0aW9uIHBhcnRpdGlvbihpLCBqLCB2YWx1ZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBpZiAoaSA+PSBqIC0gMSkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIG5vZGUueDAgPSB4MCwgbm9kZS55MCA9IHkwO1xuICAgICAgbm9kZS54MSA9IHgxLCBub2RlLnkxID0geTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlT2Zmc2V0ID0gc3Vtc1tpXSxcbiAgICAgICAgdmFsdWVUYXJnZXQgPSAodmFsdWUgLyAyKSArIHZhbHVlT2Zmc2V0LFxuICAgICAgICBrID0gaSArIDEsXG4gICAgICAgIGhpID0gaiAtIDE7XG5cbiAgICB3aGlsZSAoayA8IGhpKSB7XG4gICAgICB2YXIgbWlkID0gayArIGhpID4+PiAxO1xuICAgICAgaWYgKHN1bXNbbWlkXSA8IHZhbHVlVGFyZ2V0KSBrID0gbWlkICsgMTtcbiAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgfVxuXG4gICAgaWYgKCh2YWx1ZVRhcmdldCAtIHN1bXNbayAtIDFdKSA8IChzdW1zW2tdIC0gdmFsdWVUYXJnZXQpICYmIGkgKyAxIDwgaykgLS1rO1xuXG4gICAgdmFyIHZhbHVlTGVmdCA9IHN1bXNba10gLSB2YWx1ZU9mZnNldCxcbiAgICAgICAgdmFsdWVSaWdodCA9IHZhbHVlIC0gdmFsdWVMZWZ0O1xuXG4gICAgaWYgKCh4MSAtIHgwKSA+ICh5MSAtIHkwKSkge1xuICAgICAgdmFyIHhrID0gKHgwICogdmFsdWVSaWdodCArIHgxICogdmFsdWVMZWZ0KSAvIHZhbHVlO1xuICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4aywgeTEpO1xuICAgICAgcGFydGl0aW9uKGssIGosIHZhbHVlUmlnaHQsIHhrLCB5MCwgeDEsIHkxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHlrID0gKHkwICogdmFsdWVSaWdodCArIHkxICogdmFsdWVMZWZ0KSAvIHZhbHVlO1xuICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4MSwgeWspO1xuICAgICAgcGFydGl0aW9uKGssIGosIHZhbHVlUmlnaHQsIHgwLCB5aywgeDEsIHkxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2xpY2VEaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgKHBhcmVudC5kZXB0aCAmIDEgPyB0cmVlbWFwU2xpY2UgOiB0cmVlbWFwRGljZSkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG59XG5cbnZhciByZXNxdWFyaWZ5ID0gKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuXG4gIGZ1bmN0aW9uIHJlc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGlmICgocm93cyA9IHBhcmVudC5fc3F1YXJpZnkpICYmIChyb3dzLnJhdGlvID09PSByYXRpbykpIHtcbiAgICAgIHZhciByb3dzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBub2RlcyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGogPSAtMSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIG0gPSByb3dzLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZTtcblxuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgcm93ID0gcm93c1tqXSwgbm9kZXMgPSByb3cuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaSA9IHJvdy52YWx1ZSA9IDAsIG4gPSBub2Rlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHJvdy52YWx1ZSArPSBub2Rlc1tpXS52YWx1ZTtcbiAgICAgICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHkwICs9ICh5MSAtIHkwKSAqIHJvdy52YWx1ZSAvIHZhbHVlKTtcbiAgICAgICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHgwICs9ICh4MSAtIHgwKSAqIHJvdy52YWx1ZSAvIHZhbHVlLCB5MSk7XG4gICAgICAgIHZhbHVlIC09IHJvdy52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Ll9zcXVhcmlmeSA9IHJvd3MgPSBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgIHJvd3MucmF0aW8gPSByYXRpbztcbiAgICB9XG4gIH1cblxuICByZXNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xuICB9O1xuXG4gIHJldHVybiByZXNxdWFyaWZ5O1xufSkocGhpKTtcblxuZXhwb3J0cy5jbHVzdGVyID0gY2x1c3RlcjtcbmV4cG9ydHMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xuZXhwb3J0cy5wYWNrID0gaW5kZXg7XG5leHBvcnRzLnBhY2tTaWJsaW5ncyA9IHNpYmxpbmdzO1xuZXhwb3J0cy5wYWNrRW5jbG9zZSA9IGVuY2xvc2U7XG5leHBvcnRzLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbmV4cG9ydHMuc3RyYXRpZnkgPSBzdHJhdGlmeTtcbmV4cG9ydHMudHJlZSA9IHRyZWU7XG5leHBvcnRzLnRyZWVtYXAgPSBpbmRleCQxO1xuZXhwb3J0cy50cmVlbWFwQmluYXJ5ID0gYmluYXJ5O1xuZXhwb3J0cy50cmVlbWFwRGljZSA9IHRyZWVtYXBEaWNlO1xuZXhwb3J0cy50cmVlbWFwU2xpY2UgPSB0cmVlbWFwU2xpY2U7XG5leHBvcnRzLnRyZWVtYXBTbGljZURpY2UgPSBzbGljZURpY2U7XG5leHBvcnRzLnRyZWVtYXBTcXVhcmlmeSA9IHNxdWFyaWZ5O1xuZXhwb3J0cy50cmVlbWFwUmVzcXVhcmlmeSA9IHJlc3F1YXJpZnk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWludGVycG9sYXRlLyB2MS4zLjIgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1jb2xvcicpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWNvbG9yJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNDb2xvcikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmZ1bmN0aW9uIGJhc2lzJDEodmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpc0Nsb3NlZCh2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxudmFyIHJnYiA9IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBkM0NvbG9yLnJnYihzdGFydCkpLnIsIChlbmQgPSBkM0NvbG9yLnJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGQzQ29sb3IucmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbnZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyQxKTtcbnZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG5cbmZ1bmN0aW9uIGFycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYSksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGF0ZShhLCBiKSB7XG4gIHZhciBkID0gbmV3IERhdGU7XG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkLnNldFRpbWUoYSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiAtPSBhLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyBiICogdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0KGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSB2YWx1ZShhW2tdLCBiW2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1trXSA9IGJba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXG4gICAgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uZShiKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJpbmcoYSwgYikge1xuICB2YXIgYmkgPSByZUEubGFzdEluZGV4ID0gcmVCLmxhc3RJbmRleCA9IDAsIC8vIHNjYW4gaW5kZXggZm9yIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcbiAgICAgIGJtLCAvLyBjdXJyZW50IG1hdGNoIGluIGJcbiAgICAgIGJzLCAvLyBzdHJpbmcgcHJlY2VkaW5nIGN1cnJlbnQgbnVtYmVyIGluIGIsIGlmIGFueVxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXG4gICAgICBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuXG4gIC8vIENvZXJjZSBpbnB1dHMgdG8gc3RyaW5ncy5cbiAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG5cbiAgLy8gSW50ZXJwb2xhdGUgcGFpcnMgb2YgbnVtYmVycyBpbiBhICYgYi5cbiAgd2hpbGUgKChhbSA9IHJlQS5leGVjKGEpKVxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7IC8vIGEgc3RyaW5nIHByZWNlZGVzIHRoZSBuZXh0IG51bWJlciBpbiBiXG4gICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBibTtcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgIHEucHVzaCh7aTogaSwgeDogbnVtYmVyKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufVxuXG5mdW5jdGlvbiB2YWx1ZShhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gZDNDb2xvci5jb2xvcihiKSkgPyAoYiA9IGMsIHJnYikgOiBzdHJpbmcpXG4gICAgICA6IGIgaW5zdGFuY2VvZiBkM0NvbG9yLmNvbG9yID8gcmdiXG4gICAgICA6IGIgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gYXJyYXlcbiAgICAgIDogdHlwZW9mIGIudmFsdWVPZiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiLnRvU3RyaW5nICE9PSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4oYikgPyBvYmplY3RcbiAgICAgIDogbnVtYmVyKShhLCBiKTtcbn1cblxuZnVuY3Rpb24gZGlzY3JldGUocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHVlJDEoYSwgYikge1xuICB2YXIgaSA9IGh1ZSgrYSwgK2IpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciB4ID0gaSh0KTtcbiAgICByZXR1cm4geCAtIDM2MCAqIE1hdGguZmxvb3IoeCAvIDM2MCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJvdW5kKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiAtPSBhLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSArIGIgKiB0KTtcbiAgfTtcbn1cblxudmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuXG52YXIgaWRlbnRpdHkgPSB7XG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgc2tld1g6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuXG5mdW5jdGlvbiBkZWNvbXBvc2UoYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgc2NhbGVYLCBzY2FsZVksIHNrZXdYO1xuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XG4gIGlmIChza2V3WCA9IGEgKiBjICsgYiAqIGQpIGMgLT0gYSAqIHNrZXdYLCBkIC09IGIgKiBza2V3WDtcbiAgaWYgKHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSkgYyAvPSBzY2FsZVksIGQgLz0gc2NhbGVZLCBza2V3WCAvPSBzY2FsZVk7XG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRlWDogZSxcbiAgICB0cmFuc2xhdGVZOiBmLFxuICAgIHJvdGF0ZTogTWF0aC5hdGFuMihiLCBhKSAqIGRlZ3JlZXMsXG4gICAgc2tld1g6IE1hdGguYXRhbihza2V3WCkgKiBkZWdyZWVzLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG5cbnZhciBjc3NOb2RlLFxuICAgIGNzc1Jvb3QsXG4gICAgY3NzVmlldyxcbiAgICBzdmdOb2RlO1xuXG5mdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IFwibm9uZVwiKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghY3NzTm9kZSkgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIGNzc1Jvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNzc1ZpZXcgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY3NzTm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgdmFsdWUgPSBjc3NWaWV3LmdldENvbXB1dGVkU3R5bGUoY3NzUm9vdC5hcHBlbmRDaGlsZChjc3NOb2RlKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKTtcbiAgY3NzUm9vdC5yZW1vdmVDaGlsZChjc3NOb2RlKTtcbiAgdmFsdWUgPSB2YWx1ZS5zbGljZSg3LCAtMSkuc3BsaXQoXCIsXCIpO1xuICByZXR1cm4gZGVjb21wb3NlKCt2YWx1ZVswXSwgK3ZhbHVlWzFdLCArdmFsdWVbMl0sICt2YWx1ZVszXSwgK3ZhbHVlWzRdLCArdmFsdWVbNV0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gZGVjb21wb3NlKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbnZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xudmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcblxudmFyIHJobyA9IE1hdGguU1FSVDIsXG4gICAgcmhvMiA9IDIsXG4gICAgcmhvNCA9IDQsXG4gICAgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxuZnVuY3Rpb24gem9vbShwMCwgcDEpIHtcbiAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgaSxcbiAgICAgIFM7XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgIF07XG4gICAgfTtcbiAgfVxuXG4gIC8vIEdlbmVyYWwgY2FzZS5cbiAgZWxzZSB7XG4gICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG80ICogZDIpIC8gKDIgKiB3MCAqIHJobzIgKiBkMSksXG4gICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgcyA9IHQgKiBTLFxuICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICB3MCAqIGNvc2hyMCAvIGNvc2gocmhvICogcyArIHIwKVxuICAgICAgXTtcbiAgICB9O1xuICB9XG5cbiAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBoc2woaHVlJCQxKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUkJDEoKHN0YXJ0ID0gZDNDb2xvci5oc2woc3RhcnQpKS5oLCAoZW5kID0gZDNDb2xvci5oc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBub2dhbW1hKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbnZhciBoc2wkMSA9IGhzbChodWUpO1xudmFyIGhzbExvbmcgPSBoc2wobm9nYW1tYSk7XG5cbmZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gbm9nYW1tYSgoc3RhcnQgPSBkM0NvbG9yLmxhYihzdGFydCkpLmwsIChlbmQgPSBkM0NvbG9yLmxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBub2dhbW1hKHN0YXJ0LmEsIGVuZC5hKSxcbiAgICAgIGIgPSBub2dhbW1hKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBoY2woaHVlJCQxKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUkJDEoKHN0YXJ0ID0gZDNDb2xvci5oY2woc3RhcnQpKS5oLCAoZW5kID0gZDNDb2xvci5oY2woZW5kKSkuaCksXG4gICAgICAgIGMgPSBub2dhbW1hKHN0YXJ0LmMsIGVuZC5jKSxcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQuYyA9IGModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbnZhciBoY2wkMSA9IGhjbChodWUpO1xudmFyIGhjbExvbmcgPSBoY2wobm9nYW1tYSk7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeChodWUkJDEpIHtcbiAgcmV0dXJuIChmdW5jdGlvbiBjdWJlaGVsaXhHYW1tYSh5KSB7XG4gICAgeSA9ICt5O1xuXG4gICAgZnVuY3Rpb24gY3ViZWhlbGl4KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBoID0gaHVlJCQxKChzdGFydCA9IGQzQ29sb3IuY3ViZWhlbGl4KHN0YXJ0KSkuaCwgKGVuZCA9IGQzQ29sb3IuY3ViZWhlbGl4KGVuZCkpLmgpLFxuICAgICAgICAgIHMgPSBub2dhbW1hKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgICBsID0gbm9nYW1tYShzdGFydC5sLCBlbmQubCksXG4gICAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICAgIHN0YXJ0LnMgPSBzKHQpO1xuICAgICAgICBzdGFydC5sID0gbChNYXRoLnBvdyh0LCB5KSk7XG4gICAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjdWJlaGVsaXguZ2FtbWEgPSBjdWJlaGVsaXhHYW1tYTtcblxuICAgIHJldHVybiBjdWJlaGVsaXg7XG4gIH0pKDEpO1xufVxuXG52YXIgY3ViZWhlbGl4JDEgPSBjdWJlaGVsaXgoaHVlKTtcbnZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4KG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xuICB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMSwgdiA9IHZhbHVlc1swXSwgSSA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBJW2ldID0gaW50ZXJwb2xhdGUodiwgdiA9IHZhbHVlc1srK2ldKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKj0gbikpKTtcbiAgICByZXR1cm4gSVtpXSh0IC0gaSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1YW50aXplKGludGVycG9sYXRvciwgbikge1xuICB2YXIgc2FtcGxlcyA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoaSAvIChuIC0gMSkpO1xuICByZXR1cm4gc2FtcGxlcztcbn1cblxuZXhwb3J0cy5pbnRlcnBvbGF0ZSA9IHZhbHVlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUFycmF5ID0gYXJyYXk7XG5leHBvcnRzLmludGVycG9sYXRlQmFzaXMgPSBiYXNpcyQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJhc2lzQ2xvc2VkID0gYmFzaXNDbG9zZWQ7XG5leHBvcnRzLmludGVycG9sYXRlRGF0ZSA9IGRhdGU7XG5leHBvcnRzLmludGVycG9sYXRlRGlzY3JldGUgPSBkaXNjcmV0ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIdWUgPSBodWUkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVOdW1iZXIgPSBudW1iZXI7XG5leHBvcnRzLmludGVycG9sYXRlT2JqZWN0ID0gb2JqZWN0O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJvdW5kID0gcm91bmQ7XG5leHBvcnRzLmludGVycG9sYXRlU3RyaW5nID0gc3RyaW5nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtQ3NzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtU3ZnO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVpvb20gPSB6b29tO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYiA9IHJnYjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2JCYXNpcyA9IHJnYkJhc2lzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYkJhc2lzQ2xvc2VkID0gcmdiQmFzaXNDbG9zZWQ7XG5leHBvcnRzLmludGVycG9sYXRlSHNsID0gaHNsJDE7XG5leHBvcnRzLmludGVycG9sYXRlSHNsTG9uZyA9IGhzbExvbmc7XG5leHBvcnRzLmludGVycG9sYXRlTGFiID0gbGFiO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbCA9IGhjbCQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbExvbmcgPSBoY2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeCA9IGN1YmVoZWxpeCQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXhMb25nO1xuZXhwb3J0cy5waWVjZXdpc2UgPSBwaWVjZXdpc2U7XG5leHBvcnRzLnF1YW50aXplID0gcXVhbnRpemU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXBhdGgvIHYxLjAuNyBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHBpID0gTWF0aC5QSSxcbiAgICB0YXUgPSAyICogcGksXG4gICAgZXBzaWxvbiA9IDFlLTYsXG4gICAgdGF1RXBzaWxvbiA9IHRhdSAtIGVwc2lsb247XG5cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5fID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHBhdGgucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICB9XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJRXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkNcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKCt4MikgKyBcIixcIiArICgreTIpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgYXJjVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcbiAgICB2YXIgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24pKTtcblxuICAgIC8vIE9yLCBhcmUgKHgwLHkwKSwgKHgxLHkxKSBhbmQgKHgyLHkyKSBjb2xsaW5lYXI/XG4gICAgLy8gRXF1aXZhbGVudGx5LCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDIseTIpP1xuICAgIC8vIE9yLCBpcyB0aGUgcmFkaXVzIHplcm8/IExpbmUgdG8gKHgxLHkxKS5cbiAgICBlbHNlIGlmICghKE1hdGguYWJzKHkwMSAqIHgyMSAtIHkyMSAqIHgwMSkgPiBlcHNpbG9uKSB8fCAhcikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIHZhciB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSxcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxuICAgICAgICAgIHQyMSA9IGwgLyBsMjE7XG5cbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgIGlmIChNYXRoLmFicyh0MDEgLSAxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHgxICsgdDAxICogeDAxKSArIFwiLFwiICsgKHkxICsgdDAxICogeTAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMCxcIiArICgrKHkwMSAqIHgyMCA+IHgwMSAqIHkyMCkpICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MSArIHQyMSAqIHgyMSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxICsgdDIxICogeTIxKTtcbiAgICB9XG4gIH0sXG4gIGFyYzogZnVuY3Rpb24oeCwgeSwgciwgYTAsIGExLCBjY3cpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyO1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnRzLnBhdGggPSBwYXRoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zY2FsZS8gVmVyc2lvbiAxLjAuNy4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1hcnJheScpLCByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLWZvcm1hdCcpLCByZXF1aXJlKCdkMy10aW1lJyksIHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLWNvbG9yJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1hcnJheScsICdkMy1jb2xsZWN0aW9uJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLWZvcm1hdCcsICdkMy10aW1lJywgJ2QzLXRpbWUtZm9ybWF0JywgJ2QzLWNvbG9yJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0FycmF5LGQzQ29sbGVjdGlvbixkM0ludGVycG9sYXRlLGQzRm9ybWF0LGQzVGltZSxkM1RpbWVGb3JtYXQsZDNDb2xvcikgeyAndXNlIHN0cmljdCc7XG5cbnZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIG1hcCQxID0gYXJyYXkubWFwO1xudmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG5cbnZhciBpbXBsaWNpdCA9IHtuYW1lOiBcImltcGxpY2l0XCJ9O1xuXG5mdW5jdGlvbiBvcmRpbmFsKHJhbmdlJCQxKSB7XG4gIHZhciBpbmRleCA9IGQzQ29sbGVjdGlvbi5tYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgdW5rbm93biA9IGltcGxpY2l0O1xuXG4gIHJhbmdlJCQxID0gcmFuZ2UkJDEgPT0gbnVsbCA/IFtdIDogc2xpY2UuY2FsbChyYW5nZSQkMSk7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZSQkMVsoaSAtIDEpICUgcmFuZ2UkJDEubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBkM0NvbGxlY3Rpb24ubWFwKCk7XG4gICAgdmFyIGkgPSAtMSwgbiA9IF8ubGVuZ3RoLCBkLCBrZXk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghaW5kZXguaGFzKGtleSA9IChkID0gX1tpXSkgKyBcIlwiKSkgaW5kZXguc2V0KGtleSwgZG9tYWluLnB1c2goZCkpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSQkMSA9IHNsaWNlLmNhbGwoXyksIHNjYWxlKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9yZGluYWwoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlJCQxKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHJhbmdlJCQxID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByYW5nZSQkMVsxXSA8IHJhbmdlJCQxWzBdLFxuICAgICAgICBzdGFydCA9IHJhbmdlJCQxW3JldmVyc2UgLSAwXSxcbiAgICAgICAgc3RvcCA9IHJhbmdlJCQxWzEgLSByZXZlcnNlXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBkM0FycmF5LnJhbmdlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSQkMSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2UkJDEuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSQkMSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gcGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdPdXRlcjtcbiAgfTtcblxuICBzY2FsZS5hbGlnbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbGlnbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IGFsaWduO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKCkpXG4gICAgICAgIC5yYW5nZShyYW5nZSQkMSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIHJlc2NhbGUoKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHJldHVybiBwb2ludGlzaChiYW5kKCkucGFkZGluZ0lubmVyKDEpKTtcbn1cblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG52YXIgbnVtYmVyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gK3g7XG59O1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZUxpbmVhcihhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoYik7XG59XG5cbmZ1bmN0aW9uIGRlaW50ZXJwb2xhdGVDbGFtcChkZWludGVycG9sYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGQgPSBkZWludGVycG9sYXRlKGEgPSArYSwgYiA9ICtiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geCA8PSBhID8gMCA6IHggPj0gYiA/IDEgOiBkKHgpOyB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByID0gcmVpbnRlcnBvbGF0ZShhID0gK2EsIGIgPSArYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQgPD0gMCA/IGEgOiB0ID49IDEgPyBiIDogcih0KTsgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSQkMSwgZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlJCQxWzBdLCByMSA9IHJhbmdlJCQxWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBkZWludGVycG9sYXRlKGQxLCBkMCksIHIwID0gcmVpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gZGVpbnRlcnBvbGF0ZShkMCwgZDEpLCByMCA9IHJlaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlJCQxLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gIHZhciBqID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoKSAtIDEsXG4gICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgIGkgPSAtMTtcblxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICByYW5nZSQkMSA9IHJhbmdlJCQxLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgd2hpbGUgKCsraSA8IGopIHtcbiAgICBkW2ldID0gZGVpbnRlcnBvbGF0ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSByZWludGVycG9sYXRlKHJhbmdlJCQxW2ldLCByYW5nZSQkMVtpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaSA9IGQzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xuICAgIHJldHVybiByW2ldKGRbaV0oeCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKTtcbn1cblxuLy8gZGVpbnRlcnBvbGF0ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuLy8gcmVpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdLlxuZnVuY3Rpb24gY29udGludW91cyhkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgcmFuZ2UkJDEgPSB1bml0LFxuICAgICAgaW50ZXJwb2xhdGUkJDEgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlLFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHBpZWNld2lzZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIGlucHV0O1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcGllY2V3aXNlID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoKSA+IDIgPyBwb2x5bWFwIDogYmltYXA7XG4gICAgb3V0cHV0ID0gaW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gKG91dHB1dCB8fCAob3V0cHV0ID0gcGllY2V3aXNlKGRvbWFpbiwgcmFuZ2UkJDEsIGNsYW1wID8gZGVpbnRlcnBvbGF0ZUNsYW1wKGRlaW50ZXJwb2xhdGUpIDogZGVpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUkJDEpKSkoK3gpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlJCQxLCBkb21haW4sIGRlaW50ZXJwb2xhdGVMaW5lYXIsIGNsYW1wID8gcmVpbnRlcnBvbGF0ZUNsYW1wKHJlaW50ZXJwb2xhdGUpIDogcmVpbnRlcnBvbGF0ZSkpKSgreSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcCQxLmNhbGwoXywgbnVtYmVyKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UkJDEgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSQkMSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCByZXNjYWxlKCkpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUkJDEgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGUkJDE7XG4gIH07XG5cbiAgcmV0dXJuIHJlc2NhbGUoKTtcbn1cblxudmFyIHRpY2tGb3JtYXQgPSBmdW5jdGlvbihkb21haW4sIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0YXJ0ID0gZG9tYWluWzBdLFxuICAgICAgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sXG4gICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpLFxuICAgICAgcHJlY2lzaW9uO1xuICBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICBzd2l0Y2ggKHNwZWNpZmllci50eXBlKSB7XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgIHJldHVybiBkM0Zvcm1hdC5mb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChzcGVjaWZpZXIpO1xufTtcblxuZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIGQzQXJyYXkudGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkb21haW4oKSwgY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICBpMCA9IDAsXG4gICAgICAgIGkxID0gZC5sZW5ndGggLSAxLFxuICAgICAgICBzdGFydCA9IGRbaTBdLFxuICAgICAgICBzdG9wID0gZFtpMV0sXG4gICAgICAgIHN0ZXA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG5cbiAgICBzdGVwID0gZDNBcnJheS50aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdGVwID0gZDNBcnJheS50aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gbGluZWFyKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGVMaW5lYXIsIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXIpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLCAxXTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuICt4O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gc2NhbGU7XG5cbiAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwJDEuY2FsbChfLCBudW1iZXIpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KCkuZG9tYWluKGRvbWFpbik7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbnZhciBuaWNlID0gZnVuY3Rpb24oZG9tYWluLCBpbnRlcnZhbCkge1xuICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICB2YXIgaTAgPSAwLFxuICAgICAgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSxcbiAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgIHgxID0gZG9tYWluW2kxXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHgxIDwgeDApIHtcbiAgICB0ID0gaTAsIGkwID0gaTEsIGkxID0gdDtcbiAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgfVxuXG4gIGRvbWFpbltpMF0gPSBpbnRlcnZhbC5mbG9vcih4MCk7XG4gIGRvbWFpbltpMV0gPSBpbnRlcnZhbC5jZWlsKHgxKTtcbiAgcmV0dXJuIGRvbWFpbjtcbn07XG5cbmZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUoYSwgYikge1xuICByZXR1cm4gKGIgPSBNYXRoLmxvZyhiIC8gYSkpXG4gICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHggLyBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoYik7XG59XG5cbmZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUoYSwgYikge1xuICByZXR1cm4gYSA8IDBcbiAgICAgID8gZnVuY3Rpb24odCkgeyByZXR1cm4gLU1hdGgucG93KC1iLCB0KSAqIE1hdGgucG93KC1hLCAxIC0gdCk7IH1cbiAgICAgIDogZnVuY3Rpb24odCkgeyByZXR1cm4gTWF0aC5wb3coYiwgdCkgKiBNYXRoLnBvdyhhLCAxIC0gdCk7IH07XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpLmRvbWFpbihbMSwgMTBdKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIGJhc2UgPSAxMCxcbiAgICAgIGxvZ3MgPSBsb2dwKDEwKSxcbiAgICAgIHBvd3MgPSBwb3dwKDEwKTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICBpZiAoZG9tYWluKClbMF0gPCAwKSBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHI7XG5cbiAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICBqID0gbG9ncyh2KSxcbiAgICAgICAgcCxcbiAgICAgICAgayxcbiAgICAgICAgdCxcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGgucm91bmQoaSkgLSAxLCBqID0gTWF0aC5yb3VuZChqKSArIDE7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IDEsIHAgPSBwb3dzKGkpOyBrIDwgYmFzZTsgKytrKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMSwgcCA9IHBvd3MoaSk7IGsgPj0gMTsgLS1rKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IGQzQXJyYXkudGlja3MoaSwgaiwgTWF0aC5taW4oaiAtIGksIG4pKS5tYXAocG93cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHIgPyB6LnJldmVyc2UoKSA6IHo7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xuICAgIGlmICh0eXBlb2Ygc3BlY2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHNwZWNpZmllciA9IGQzRm9ybWF0LmZvcm1hdChzcGVjaWZpZXIpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBzcGVjaWZpZXI7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7IC8vIFRPRE8gZmFzdCBlc3RpbWF0ZT9cbiAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgIH07XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5mbG9vcihsb2dzKHgpKSk7IH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cbiAgICB9KSk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKS5iYXNlKGJhc2UpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHJhaXNlKHgsIGV4cG9uZW50KSB7XG4gIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xufVxuXG5mdW5jdGlvbiBwb3coKSB7XG4gIHZhciBleHBvbmVudCA9IDEsXG4gICAgICBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgcmV0dXJuIChiID0gcmFpc2UoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZShhLCBleHBvbmVudCkpKVxuICAgICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIChyYWlzZSh4LCBleHBvbmVudCkgLSBhKSAvIGI7IH1cbiAgICAgICAgOiBjb25zdGFudChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIGIgPSByYWlzZShiLCBleHBvbmVudCkgLSAoYSA9IHJhaXNlKGEsIGV4cG9uZW50KSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHJhaXNlKGEgKyBiICogdCwgMSAvIGV4cG9uZW50KTsgfTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIGRvbWFpbihkb21haW4oKSkpIDogZXhwb25lbnQ7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKS5leHBvbmVudChleHBvbmVudCkpO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBzcXJ0KCkge1xuICByZXR1cm4gcG93KCkuZXhwb25lbnQoMC41KTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpbGUkMSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UkJDEgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlJCQxLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gZDNBcnJheS5xdWFudGlsZShkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gcmFuZ2UkJDFbZDNBcnJheS5iaXNlY3QodGhyZXNob2xkcywgeCldO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UkJDEuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dIDogW1xuICAgICAgaSA+IDAgPyB0aHJlc2hvbGRzW2kgLSAxXSA6IGRvbWFpblswXSxcbiAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgXTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGQzQXJyYXkuYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlJDEoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlJCQxKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXplKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgbiA9IDEsXG4gICAgICBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlJCQxID0gWzAsIDFdO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICBpZiAoeCA8PSB4KSByZXR1cm4gcmFuZ2UkJDFbZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAwLCBuKV07XG4gIH1cblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgZG9tYWluID0gbmV3IEFycmF5KG4pO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkb21haW5baV0gPSAoKGkgKyAxKSAqIHgxIC0gKGkgLSBuKSAqIHgwKSAvIChuICsgMSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF0sIHgxID0gK19bMV0sIHJlc2NhbGUoKSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gKHJhbmdlJCQxID0gc2xpY2UuY2FsbChfKSkubGVuZ3RoIC0gMSwgcmVzY2FsZSgpKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UkJDEuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dXG4gICAgICAgIDogaSA8IDEgPyBbeDAsIGRvbWFpblswXV1cbiAgICAgICAgOiBpID49IG4gPyBbZG9tYWluW24gLSAxXSwgeDFdXG4gICAgICAgIDogW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGl6ZSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSQkMSk7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIHRocmVzaG9sZCgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UkJDEgPSBbMCwgMV0sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlJCQxW2QzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZSQkMS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UkJDEgPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UkJDEuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlJCQxKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDEwMDA7XG52YXIgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwO1xudmFyIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjA7XG52YXIgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNDtcbnZhciBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDc7XG52YXIgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzA7XG52YXIgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlciQxKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCQkMSkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGVMaW5lYXIsIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXIpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdCQkMShcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdCQkMShcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdCQkMShcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdCQkMShcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0JCQxKFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0JCQxKFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdCQkMShcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdCQkMShcIiVZXCIpO1xuXG4gIHZhciB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xuXG4gICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpbnRlcnZhbCBpcyBhbHJlYWR5IGEgdGltZSBpbnRlcnZhbCBhbmQgdXNlIGl0LlxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgaSA9IGQzQXJyYXkuYmlzZWN0b3IoZnVuY3Rpb24oaSkgeyByZXR1cm4gaVsyXTsgfSkucmlnaHQodGlja0ludGVydmFscywgdGFyZ2V0KTtcbiAgICAgIGlmIChpID09PSB0aWNrSW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICBpbnRlcnZhbCA9IHllYXI7XG4gICAgICB9IGVsc2UgaWYgKGkpIHtcbiAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgc3RlcCA9IGlbMV07XG4gICAgICAgIGludGVydmFsID0gaVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBNYXRoLm1heChkM0FycmF5LnRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCksIDEpO1xuICAgICAgICBpbnRlcnZhbCA9IG1pbGxpc2Vjb25kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihtYXAkMS5jYWxsKF8sIG51bWJlciQxKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHQwID0gZFswXSxcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICB0O1xuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgIHQgPSB0ID8gdC5yYW5nZSh0MCwgdDEgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdCQkMShzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpXG4gICAgICAgIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCQkMSkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxudmFyIHRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNhbGVuZGFyKGQzVGltZS50aW1lWWVhciwgZDNUaW1lLnRpbWVNb250aCwgZDNUaW1lLnRpbWVXZWVrLCBkM1RpbWUudGltZURheSwgZDNUaW1lLnRpbWVIb3VyLCBkM1RpbWUudGltZU1pbnV0ZSwgZDNUaW1lLnRpbWVTZWNvbmQsIGQzVGltZS50aW1lTWlsbGlzZWNvbmQsIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KS5kb21haW4oW25ldyBEYXRlKDIwMDAsIDAsIDEpLCBuZXcgRGF0ZSgyMDAwLCAwLCAyKV0pO1xufTtcblxudmFyIHV0Y1RpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNhbGVuZGFyKGQzVGltZS51dGNZZWFyLCBkM1RpbWUudXRjTW9udGgsIGQzVGltZS51dGNXZWVrLCBkM1RpbWUudXRjRGF5LCBkM1RpbWUudXRjSG91ciwgZDNUaW1lLnV0Y01pbnV0ZSwgZDNUaW1lLnV0Y1NlY29uZCwgZDNUaW1lLnV0Y01pbGxpc2Vjb25kLCBkM1RpbWVGb3JtYXQudXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pO1xufTtcblxudmFyIGNvbG9ycyA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMubWF0Y2goLy57Nn0vZykubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gXCIjXCIgKyB4O1xuICB9KTtcbn07XG5cbnZhciBjYXRlZ29yeTEwID0gY29sb3JzKFwiMWY3N2I0ZmY3ZjBlMmNhMDJjZDYyNzI4OTQ2N2JkOGM1NjRiZTM3N2MyN2Y3ZjdmYmNiZDIyMTdiZWNmXCIpO1xuXG52YXIgY2F0ZWdvcnkyMGIgPSBjb2xvcnMoXCIzOTNiNzk1MjU0YTM2YjZlY2Y5YzllZGU2Mzc5Mzk4Y2EyNTJiNWNmNmJjZWRiOWM4YzZkMzFiZDllMzllN2JhNTJlN2NiOTQ4NDNjMzlhZDQ5NGFkNjYxNmJlNzk2OWM3YjQxNzNhNTUxOTRjZTZkYmRkZTllZDZcIik7XG5cbnZhciBjYXRlZ29yeTIwYyA9IGNvbG9ycyhcIjMxODJiZDZiYWVkNjllY2FlMWM2ZGJlZmU2NTUwZGZkOGQzY2ZkYWU2YmZkZDBhMjMxYTM1NDc0YzQ3NmExZDk5YmM3ZTljMDc1NmJiMTllOWFjOGJjYmRkY2RhZGFlYjYzNjM2Mzk2OTY5NmJkYmRiZGQ5ZDlkOVwiKTtcblxudmFyIGNhdGVnb3J5MjAgPSBjb2xvcnMoXCIxZjc3YjRhZWM3ZThmZjdmMGVmZmJiNzgyY2EwMmM5OGRmOGFkNjI3MjhmZjk4OTY5NDY3YmRjNWIwZDU4YzU2NGJjNDljOTRlMzc3YzJmN2I2ZDI3ZjdmN2ZjN2M3YzdiY2JkMjJkYmRiOGQxN2JlY2Y5ZWRhZTVcIik7XG5cbnZhciBjdWJlaGVsaXgkMSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KDMwMCwgMC41LCAwLjApLCBkM0NvbG9yLmN1YmVoZWxpeCgtMjQwLCAwLjUsIDEuMCkpO1xuXG52YXIgd2FybSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KC0xMDAsIDAuNzUsIDAuMzUpLCBkM0NvbG9yLmN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XG5cbnZhciBjb29sID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoMjYwLCAwLjc1LCAwLjM1KSwgZDNDb2xvci5jdWJlaGVsaXgoODAsIDEuNTAsIDAuOCkpO1xuXG52YXIgcmFpbmJvdyA9IGQzQ29sb3IuY3ViZWhlbGl4KCk7XG5cbnZhciByYWluYm93JDEgPSBmdW5jdGlvbih0KSB7XG4gIGlmICh0IDwgMCB8fCB0ID4gMSkgdCAtPSBNYXRoLmZsb29yKHQpO1xuICB2YXIgdHMgPSBNYXRoLmFicyh0IC0gMC41KTtcbiAgcmFpbmJvdy5oID0gMzYwICogdCAtIDEwMDtcbiAgcmFpbmJvdy5zID0gMS41IC0gMS41ICogdHM7XG4gIHJhaW5ib3cubCA9IDAuOCAtIDAuOSAqIHRzO1xuICByZXR1cm4gcmFpbmJvdyArIFwiXCI7XG59O1xuXG5mdW5jdGlvbiByYW1wKHJhbmdlJCQxKSB7XG4gIHZhciBuID0gcmFuZ2UkJDEubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZSQkMVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG5cbnZhciB2aXJpZGlzID0gcmFtcChjb2xvcnMoXCI0NDAxNTQ0NDAyNTY0NTA0NTc0NTA1NTk0NjA3NWE0NjA4NWM0NjBhNWQ0NjBiNWU0NzBkNjA0NzBlNjE0NzEwNjM0NzExNjQ0NzEzNjU0ODE0Njc0ODE2Njg0ODE3Njk0ODE4NmE0ODFhNmM0ODFiNmQ0ODFjNmU0ODFkNmY0ODFmNzA0ODIwNzE0ODIxNzM0ODIzNzQ0ODI0NzU0ODI1NzY0ODI2Nzc0ODI4Nzg0ODI5Nzk0NzJhN2E0NzJjN2E0NzJkN2I0NzJlN2M0NzJmN2Q0NjMwN2U0NjMyN2U0NjMzN2Y0NjM0ODA0NTM1ODE0NTM3ODE0NTM4ODI0NDM5ODM0NDNhODM0NDNiODQ0MzNkODQ0MzNlODU0MjNmODU0MjQwODY0MjQxODY0MTQyODc0MTQ0ODc0MDQ1ODg0MDQ2ODgzZjQ3ODgzZjQ4ODkzZTQ5ODkzZTRhODkzZTRjOGEzZDRkOGEzZDRlOGEzYzRmOGEzYzUwOGIzYjUxOGIzYjUyOGIzYTUzOGIzYTU0OGMzOTU1OGMzOTU2OGMzODU4OGMzODU5OGMzNzVhOGMzNzViOGQzNjVjOGQzNjVkOGQzNTVlOGQzNTVmOGQzNDYwOGQzNDYxOGQzMzYyOGQzMzYzOGQzMjY0OGUzMjY1OGUzMTY2OGUzMTY3OGUzMTY4OGUzMDY5OGUzMDZhOGUyZjZiOGUyZjZjOGUyZTZkOGUyZTZlOGUyZTZmOGUyZDcwOGUyZDcxOGUyYzcxOGUyYzcyOGUyYzczOGUyYjc0OGUyYjc1OGUyYTc2OGUyYTc3OGUyYTc4OGUyOTc5OGUyOTdhOGUyOTdiOGUyODdjOGUyODdkOGUyNzdlOGUyNzdmOGUyNzgwOGUyNjgxOGUyNjgyOGUyNjgyOGUyNTgzOGUyNTg0OGUyNTg1OGUyNDg2OGUyNDg3OGUyMzg4OGUyMzg5OGUyMzhhOGQyMjhiOGQyMjhjOGQyMjhkOGQyMThlOGQyMThmOGQyMTkwOGQyMTkxOGMyMDkyOGMyMDkyOGMyMDkzOGMxZjk0OGMxZjk1OGIxZjk2OGIxZjk3OGIxZjk4OGIxZjk5OGExZjlhOGExZTliOGExZTljODkxZTlkODkxZjllODkxZjlmODgxZmEwODgxZmExODgxZmExODcxZmEyODcyMGEzODYyMGE0ODYyMWE1ODUyMWE2ODUyMmE3ODUyMmE4ODQyM2E5ODMyNGFhODMyNWFiODIyNWFjODIyNmFkODEyN2FkODEyOGFlODAyOWFmN2YyYWIwN2YyY2IxN2UyZGIyN2QyZWIzN2MyZmI0N2MzMWI1N2IzMmI2N2EzNGI2NzkzNWI3NzkzN2I4NzgzOGI5NzczYWJhNzYzYmJiNzUzZGJjNzQzZmJjNzM0MGJkNzI0MmJlNzE0NGJmNzA0NmMwNmY0OGMxNmU0YWMxNmQ0Y2MyNmM0ZWMzNmI1MGM0NmE1MmM1Njk1NGM1Njg1NmM2Njc1OGM3NjU1YWM4NjQ1Y2M4NjM1ZWM5NjI2MGNhNjA2M2NiNWY2NWNiNWU2N2NjNWM2OWNkNWI2Y2NkNWE2ZWNlNTg3MGNmNTc3M2QwNTY3NWQwNTQ3N2QxNTM3YWQxNTE3Y2QyNTA3ZmQzNGU4MWQzNGQ4NGQ0NGI4NmQ1NDk4OWQ1NDg4YmQ2NDY4ZWQ2NDU5MGQ3NDM5M2Q3NDE5NWQ4NDA5OGQ4M2U5YmQ5M2M5ZGQ5M2JhMGRhMzlhMmRhMzdhNWRiMzZhOGRiMzRhYWRjMzJhZGRjMzBiMGRkMmZiMmRkMmRiNWRlMmJiOGRlMjliYWRlMjhiZGRmMjZjMGRmMjVjMmRmMjNjNWUwMjFjOGUwMjBjYWUxMWZjZGUxMWRkMGUxMWNkMmUyMWJkNWUyMWFkOGUyMTlkYWUzMTlkZGUzMThkZmUzMThlMmU0MThlNWU0MTllN2U0MTllYWU1MWFlY2U1MWJlZmU1MWNmMWU1MWRmNGU2MWVmNmU2MjBmOGU2MjFmYmU3MjNmZGU3MjVcIikpO1xuXG52YXIgbWFnbWEgPSByYW1wKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwOTAyMDIwYjAyMDIwZDAzMDMwZjAzMDMxMjA0MDQxNDA1MDQxNjA2MDUxODA2MDUxYTA3MDYxYzA4MDcxZTA5MDcyMDBhMDgyMjBiMDkyNDBjMDkyNjBkMGEyOTBlMGIyYjEwMGIyZDExMGMyZjEyMGQzMTEzMGQzNDE0MGUzNjE1MGUzODE2MGYzYjE4MGYzZDE5MTAzZjFhMTA0MjFjMTA0NDFkMTE0NzFlMTE0OTIwMTE0YjIxMTE0ZTIyMTE1MDI0MTI1MzI1MTI1NTI3MTI1ODI5MTE1YTJhMTE1YzJjMTE1ZjJkMTE2MTJmMTE2MzMxMTE2NTMzMTA2NzM0MTA2OTM2MTA2YjM4MTA2YzM5MGY2ZTNiMGY3MDNkMGY3MTNmMGY3MjQwMGY3NDQyMGY3NTQ0MGY3NjQ1MTA3NzQ3MTA3ODQ5MTA3ODRhMTA3OTRjMTE3YTRlMTE3YjRmMTI3YjUxMTI3YzUyMTM3YzU0MTM3ZDU2MTQ3ZDU3MTU3ZTU5MTU3ZTVhMTY3ZTVjMTY3ZjVkMTc3ZjVmMTg3ZjYwMTg4MDYyMTk4MDY0MWE4MDY1MWE4MDY3MWI4MDY4MWM4MTZhMWM4MTZiMWQ4MTZkMWQ4MTZlMWU4MTcwMWY4MTcyMWY4MTczMjA4MTc1MjE4MTc2MjE4MTc4MjI4MTc5MjI4MjdiMjM4MjdjMjM4MjdlMjQ4MjgwMjU4MjgxMjU4MTgzMjY4MTg0MjY4MTg2Mjc4MTg4Mjc4MTg5Mjg4MThiMjk4MThjMjk4MThlMmE4MTkwMmE4MTkxMmI4MTkzMmI4MDk0MmM4MDk2MmM4MDk4MmQ4MDk5MmQ4MDliMmU3ZjljMmU3ZjllMmY3ZmEwMmY3ZmExMzA3ZWEzMzA3ZWE1MzE3ZWE2MzE3ZGE4MzI3ZGFhMzM3ZGFiMzM3Y2FkMzQ3Y2FlMzQ3YmIwMzU3YmIyMzU3YmIzMzY3YWI1MzY3YWI3Mzc3OWI4Mzc3OWJhMzg3OGJjMzk3OGJkMzk3N2JmM2E3N2MwM2E3NmMyM2I3NWM0M2M3NWM1M2M3NGM3M2Q3M2M4M2U3M2NhM2U3MmNjM2Y3MWNkNDA3MWNmNDA3MGQwNDE2ZmQyNDI2ZmQzNDM2ZWQ1NDQ2ZGQ2NDU2Y2Q4NDU2Y2Q5NDY2YmRiNDc2YWRjNDg2OWRlNDk2OGRmNGE2OGUwNGM2N2UyNGQ2NmUzNGU2NWU0NGY2NGU1NTA2NGU3NTI2M2U4NTM2MmU5NTQ2MmVhNTY2MWViNTc2MGVjNTg2MGVkNWE1ZmVlNWI1ZWVmNWQ1ZWYwNWY1ZWYxNjA1ZGYyNjI1ZGYyNjQ1Y2YzNjU1Y2Y0Njc1Y2Y0Njk1Y2Y1NmI1Y2Y2NmM1Y2Y2NmU1Y2Y3NzA1Y2Y3NzI1Y2Y4NzQ1Y2Y4NzY1Y2Y5Nzg1ZGY5Nzk1ZGY5N2I1ZGZhN2Q1ZWZhN2Y1ZWZhODE1ZmZiODM1ZmZiODU2MGZiODc2MWZjODk2MWZjOGE2MmZjOGM2M2ZjOGU2NGZjOTA2NWZkOTI2NmZkOTQ2N2ZkOTY2OGZkOTg2OWZkOWE2YWZkOWI2YmZlOWQ2Y2ZlOWY2ZGZlYTE2ZWZlYTM2ZmZlYTU3MWZlYTc3MmZlYTk3M2ZlYWE3NGZlYWM3NmZlYWU3N2ZlYjA3OGZlYjI3YWZlYjQ3YmZlYjY3Y2ZlYjc3ZWZlYjk3ZmZlYmI4MWZlYmQ4MmZlYmY4NGZlYzE4NWZlYzI4N2ZlYzQ4OGZlYzY4YWZlYzg4Y2ZlY2E4ZGZlY2M4ZmZlY2Q5MGZlY2Y5MmZlZDE5NGZlZDM5NWZlZDU5N2ZlZDc5OWZlZDg5YWZkZGE5Y2ZkZGM5ZWZkZGVhMGZkZTBhMWZkZTJhM2ZkZTNhNWZkZTVhN2ZkZTdhOWZkZTlhYWZkZWJhY2ZjZWNhZWZjZWViMGZjZjBiMmZjZjJiNGZjZjRiNmZjZjZiOGZjZjdiOWZjZjliYmZjZmJiZGZjZmRiZlwiKSk7XG5cbnZhciBpbmZlcm5vID0gcmFtcChjb2xvcnMoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMGEwMjAyMGMwMjAyMGUwMzAyMTAwNDAzMTIwNDAzMTQwNTA0MTcwNjA0MTkwNzA1MWIwODA1MWQwOTA2MWYwYTA3MjIwYjA3MjQwYzA4MjYwZDA4MjkwZTA5MmIxMDA5MmQxMTBhMzAxMjBhMzIxNDBiMzQxNTBiMzcxNjBiMzkxODBjM2MxOTBjM2UxYjBjNDExYzBjNDMxZTBjNDUxZjBjNDgyMTBjNGEyMzBjNGMyNDBjNGYyNjBjNTEyODBiNTMyOTBiNTUyYjBiNTcyZDBiNTkyZjBhNWIzMTBhNWMzMjBhNWUzNDBhNWYzNjA5NjEzODA5NjIzOTA5NjMzYjA5NjQzZDA5NjUzZTA5NjY0MDBhNjc0MjBhNjg0NDBhNjg0NTBhNjk0NzBiNmE0OTBiNmE0YTBjNmI0YzBjNmI0ZDBkNmM0ZjBkNmM1MTBlNmM1MjBlNmQ1NDBmNmQ1NTBmNmQ1NzEwNmU1OTEwNmU1YTExNmU1YzEyNmU1ZDEyNmU1ZjEzNmU2MTEzNmU2MjE0NmU2NDE1NmU2NTE1NmU2NzE2NmU2OTE2NmU2YTE3NmU2YzE4NmU2ZDE4NmU2ZjE5NmU3MTE5NmU3MjFhNmU3NDFhNmU3NTFiNmU3NzFjNmQ3ODFjNmQ3YTFkNmQ3YzFkNmQ3ZDFlNmQ3ZjFlNmM4MDFmNmM4MjIwNmM4NDIwNmI4NTIxNmI4NzIxNmI4ODIyNmE4YTIyNmE4YzIzNjk4ZDIzNjk4ZjI0Njk5MDI1Njg5MjI1Njg5MzI2Njc5NTI2Njc5NzI3NjY5ODI3NjY5YTI4NjU5YjI5NjQ5ZDI5NjQ5ZjJhNjNhMDJhNjNhMjJiNjJhMzJjNjFhNTJjNjBhNjJkNjBhODJlNWZhOTJlNWVhYjJmNWVhZDMwNWRhZTMwNWNiMDMxNWJiMTMyNWFiMzMyNWFiNDMzNTliNjM0NThiNzM1NTdiOTM1NTZiYTM2NTViYzM3NTRiZDM4NTNiZjM5NTJjMDNhNTFjMTNhNTBjMzNiNGZjNDNjNGVjNjNkNGRjNzNlNGNjODNmNGJjYTQwNGFjYjQxNDljYzQyNDhjZTQzNDdjZjQ0NDZkMDQ1NDVkMjQ2NDRkMzQ3NDNkNDQ4NDJkNTRhNDFkNzRiM2ZkODRjM2VkOTRkM2RkYTRlM2NkYjUwM2JkZDUxM2FkZTUyMzhkZjUzMzdlMDU1MzZlMTU2MzVlMjU3MzRlMzU5MzNlNDVhMzFlNTVjMzBlNjVkMmZlNzVlMmVlODYwMmRlOTYxMmJlYTYzMmFlYjY0MjllYjY2MjhlYzY3MjZlZDY5MjVlZTZhMjRlZjZjMjNlZjZlMjFmMDZmMjBmMTcxMWZmMTczMWRmMjc0MWNmMzc2MWJmMzc4MTlmNDc5MThmNTdiMTdmNTdkMTVmNjdlMTRmNjgwMTNmNzgyMTJmNzg0MTBmODg1MGZmODg3MGVmODg5MGNmOThiMGJmOThjMGFmOThlMDlmYTkwMDhmYTkyMDdmYTk0MDdmYjk2MDZmYjk3MDZmYjk5MDZmYjliMDZmYjlkMDdmYzlmMDdmY2ExMDhmY2EzMDlmY2E1MGFmY2E2MGNmY2E4MGRmY2FhMGZmY2FjMTFmY2FlMTJmY2IwMTRmY2IyMTZmY2I0MThmYmI2MWFmYmI4MWRmYmJhMWZmYmJjMjFmYmJlMjNmYWMwMjZmYWMyMjhmYWM0MmFmYWM2MmRmOWM3MmZmOWM5MzJmOWNiMzVmOGNkMzdmOGNmM2FmN2QxM2RmN2QzNDBmNmQ1NDNmNmQ3NDZmNWQ5NDlmNWRiNGNmNGRkNGZmNGRmNTNmNGUxNTZmM2UzNWFmM2U1NWRmMmU2NjFmMmU4NjVmMmVhNjlmMWVjNmRmMWVkNzFmMWVmNzVmMWYxNzlmMmYyN2RmMmY0ODJmM2Y1ODZmM2Y2OGFmNGY4OGVmNWY5OTJmNmZhOTZmOGZiOWFmOWZjOWRmYWZkYTFmY2ZmYTRcIikpO1xuXG52YXIgcGxhc21hID0gcmFtcChjb2xvcnMoXCIwZDA4ODcxMDA3ODgxMzA3ODkxNjA3OGExOTA2OGMxYjA2OGQxZDA2OGUyMDA2OGYyMjA2OTAyNDA2OTEyNjA1OTEyODA1OTIyYTA1OTMyYzA1OTQyZTA1OTUyZjA1OTYzMTA1OTczMzA1OTczNTA0OTgzNzA0OTkzODA0OWEzYTA0OWEzYzA0OWIzZTA0OWMzZjA0OWM0MTA0OWQ0MzAzOWU0NDAzOWU0NjAzOWY0ODAzOWY0OTAzYTA0YjAzYTE0YzAyYTE0ZTAyYTI1MDAyYTI1MTAyYTM1MzAyYTM1NTAyYTQ1NjAxYTQ1ODAxYTQ1OTAxYTU1YjAxYTU1YzAxYTY1ZTAxYTY2MDAxYTY2MTAwYTc2MzAwYTc2NDAwYTc2NjAwYTc2NzAwYTg2OTAwYTg2YTAwYTg2YzAwYTg2ZTAwYTg2ZjAwYTg3MTAwYTg3MjAxYTg3NDAxYTg3NTAxYTg3NzAxYTg3ODAxYTg3YTAyYTg3YjAyYTg3ZDAzYTg3ZTAzYTg4MDA0YTg4MTA0YTc4MzA1YTc4NDA1YTc4NjA2YTY4NzA3YTY4ODA4YTY4YTA5YTU4YjBhYTU4ZDBiYTU4ZTBjYTQ4ZjBkYTQ5MTBlYTM5MjBmYTM5NDEwYTI5NTExYTE5NjEzYTE5ODE0YTA5OTE1OWY5YTE2OWY5YzE3OWU5ZDE4OWQ5ZTE5OWRhMDFhOWNhMTFiOWJhMjFkOWFhMzFlOWFhNTFmOTlhNjIwOThhNzIxOTdhODIyOTZhYTIzOTVhYjI0OTRhYzI2OTRhZDI3OTNhZTI4OTJiMDI5OTFiMTJhOTBiMjJiOGZiMzJjOGViNDJlOGRiNTJmOGNiNjMwOGJiNzMxOGFiODMyODliYTMzODhiYjM0ODhiYzM1ODdiZDM3ODZiZTM4ODViZjM5ODRjMDNhODNjMTNiODJjMjNjODFjMzNkODBjNDNlN2ZjNTQwN2VjNjQxN2RjNzQyN2NjODQzN2JjOTQ0N2FjYTQ1N2FjYjQ2NzljYzQ3NzhjYzQ5NzdjZDRhNzZjZTRiNzVjZjRjNzRkMDRkNzNkMTRlNzJkMjRmNzFkMzUxNzFkNDUyNzBkNTUzNmZkNTU0NmVkNjU1NmRkNzU2NmNkODU3NmJkOTU4NmFkYTVhNmFkYTViNjlkYjVjNjhkYzVkNjdkZDVlNjZkZTVmNjVkZTYxNjRkZjYyNjNlMDYzNjNlMTY0NjJlMjY1NjFlMjY2NjBlMzY4NWZlNDY5NWVlNTZhNWRlNTZiNWRlNjZjNWNlNzZlNWJlNzZmNWFlODcwNTllOTcxNThlOTcyNTdlYTc0NTdlYjc1NTZlYjc2NTVlYzc3NTRlZDc5NTNlZDdhNTJlZTdiNTFlZjdjNTFlZjdlNTBmMDdmNGZmMDgwNGVmMTgxNGRmMTgzNGNmMjg0NGJmMzg1NGJmMzg3NGFmNDg4NDlmNDg5NDhmNThiNDdmNThjNDZmNjhkNDVmNjhmNDRmNzkwNDRmNzkxNDNmNzkzNDJmODk0NDFmODk1NDBmOTk3M2ZmOTk4M2VmOTlhM2VmYTliM2RmYTljM2NmYTllM2JmYjlmM2FmYmExMzlmYmEyMzhmY2EzMzhmY2E1MzdmY2E2MzZmY2E4MzVmY2E5MzRmZGFiMzNmZGFjMzNmZGFlMzJmZGFmMzFmZGIxMzBmZGIyMmZmZGI0MmZmZGI1MmVmZWI3MmRmZWI4MmNmZWJhMmNmZWJiMmJmZWJkMmFmZWJlMmFmZWMwMjlmZGMyMjlmZGMzMjhmZGM1MjdmZGM2MjdmZGM4MjdmZGNhMjZmZGNiMjZmY2NkMjVmY2NlMjVmY2QwMjVmY2QyMjVmYmQzMjRmYmQ1MjRmYmQ3MjRmYWQ4MjRmYWRhMjRmOWRjMjRmOWRkMjVmOGRmMjVmOGUxMjVmN2UyMjVmN2U0MjVmNmU2MjZmNmU4MjZmNWU5MjZmNWViMjdmNGVkMjdmM2VlMjdmM2YwMjdmMmYyMjdmMWY0MjZmMWY1MjVmMGY3MjRmMGY5MjFcIikpO1xuXG5mdW5jdGlvbiBzZXF1ZW50aWFsKGludGVycG9sYXRvcikge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgY2xhbXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgdmFyIHQgPSAoeCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICByZXR1cm4gaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpIDogdCk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgc2NhbGUpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXF1ZW50aWFsKGludGVycG9sYXRvcikuZG9tYWluKFt4MCwgeDFdKS5jbGFtcChjbGFtcCk7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydHMuc2NhbGVCYW5kID0gYmFuZDtcbmV4cG9ydHMuc2NhbGVQb2ludCA9IHBvaW50O1xuZXhwb3J0cy5zY2FsZUlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnNjYWxlTGluZWFyID0gbGluZWFyO1xuZXhwb3J0cy5zY2FsZUxvZyA9IGxvZztcbmV4cG9ydHMuc2NhbGVPcmRpbmFsID0gb3JkaW5hbDtcbmV4cG9ydHMuc2NhbGVJbXBsaWNpdCA9IGltcGxpY2l0O1xuZXhwb3J0cy5zY2FsZVBvdyA9IHBvdztcbmV4cG9ydHMuc2NhbGVTcXJ0ID0gc3FydDtcbmV4cG9ydHMuc2NhbGVRdWFudGlsZSA9IHF1YW50aWxlJDE7XG5leHBvcnRzLnNjYWxlUXVhbnRpemUgPSBxdWFudGl6ZTtcbmV4cG9ydHMuc2NhbGVUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG5leHBvcnRzLnNjYWxlVGltZSA9IHRpbWU7XG5leHBvcnRzLnNjYWxlVXRjID0gdXRjVGltZTtcbmV4cG9ydHMuc2NoZW1lQ2F0ZWdvcnkxMCA9IGNhdGVnb3J5MTA7XG5leHBvcnRzLnNjaGVtZUNhdGVnb3J5MjBiID0gY2F0ZWdvcnkyMGI7XG5leHBvcnRzLnNjaGVtZUNhdGVnb3J5MjBjID0gY2F0ZWdvcnkyMGM7XG5leHBvcnRzLnNjaGVtZUNhdGVnb3J5MjAgPSBjYXRlZ29yeTIwO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHQgPSBjdWJlaGVsaXgkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSYWluYm93ID0gcmFpbmJvdyQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVdhcm0gPSB3YXJtO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUNvb2wgPSBjb29sO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVZpcmlkaXMgPSB2aXJpZGlzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU1hZ21hID0gbWFnbWE7XG5leHBvcnRzLmludGVycG9sYXRlSW5mZXJubyA9IGluZmVybm87XG5leHBvcnRzLmludGVycG9sYXRlUGxhc21hID0gcGxhc21hO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWwgPSBzZXF1ZW50aWFsO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zZWxlY3Rpb24vIHYxLjMuMiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbnZhciBuYW1lc3BhY2VzID0ge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcblxuZnVuY3Rpb24gbmFtZXNwYWNlKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvcihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cblxuZnVuY3Rpb24gbm9uZSgpIHt9XG5cbmZ1bmN0aW9uIHNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gbm9uZSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0KHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3RBbGwoc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59XG5cbnZhciBtYXRjaGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCFlbGVtZW50Lm1hdGNoZXMpIHtcbiAgICB2YXIgdmVuZG9yTWF0Y2hlcyA9IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgfHwgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yO1xuICAgIG1hdGNoZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmVuZG9yTWF0Y2hlcy5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbWF0Y2hlciQxID0gbWF0Y2hlcjtcblxuZnVuY3Rpb24gc2VsZWN0aW9uX2ZpbHRlcihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlciQxKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBzcGFyc2UodXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9lbnRlcigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbnZhciBrZXlQcmVmaXggPSBcIiRcIjsgLy8gUHJvdGVjdCBhZ2FpbnN0IGtleXMgbGlrZSDigJxfX3Byb3RvX1/igJ0uXG5cbmZ1bmN0aW9uIGJpbmRJbmRleChwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG5vZGUsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAvLyBQdXQgYW55IG51bGwgbm9kZXMgaW50byBlbnRlci5cbiAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cbiAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gIHZhciBpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVCeUtleVZhbHVlID0ge30sXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgICAgaWYgKGtleVZhbHVlIGluIG5vZGVCeUtleVZhbHVlKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICBpZiAobm9kZSA9IG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZXNbaV1dID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9kYXRhKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIGRhdGEgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBqID0gLTE7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGQpIHsgZGF0YVsrK2pdID0gZDsgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYmluZCA9IGtleSA/IGJpbmRLZXkgOiBiaW5kSW5kZXgsXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gY29uc3RhbnQodmFsdWUpO1xuXG4gIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICBncm91cCA9IGdyb3Vwc1tqXSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGEgPSB2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cyksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZXhpdCgpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fbWVyZ2Uoc2VsZWN0aW9uJCQxKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbiQkMS5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fb3JkZXIoKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gbm9kZS5uZXh0U2libGluZykgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zb3J0KGNvbXBhcmUpIHtcbiAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyZShhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzb3J0Z3JvdXAgPSBzb3J0Z3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzb3J0Z3JvdXBzLCB0aGlzLl9wYXJlbnRzKS5vcmRlcigpO1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jYWxsKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fbm9kZXMoKSB7XG4gIHZhciBub2RlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGkgPSAtMTtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBub2Rlc1srK2ldID0gdGhpczsgfSk7XG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX25vZGUoKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zaXplKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgKytzaXplOyB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9lbXB0eSgpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2VhY2goY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Vmlldyhub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XG59XG5cbmZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiB0ZXh0UmVtb3ZlKCkge1xuICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3RleHQodmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHRleHRGdW5jdGlvblxuICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufVxuXG5mdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2h0bWwodmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9yYWlzZSgpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG5cbmZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fbG93ZXIoKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fYXBwZW5kKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9pbnNlcnQobmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9yZW1vdmUoKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUoZmFsc2UpLCB0aGlzLm5leHRTaWJsaW5nKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUodHJ1ZSksIHRoaXMubmV4dFNpYmxpbmcpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmUoZGVlcCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZGVlcCA/IHNlbGVjdGlvbl9jbG9uZURlZXAgOiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2RhdHVtKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSlcbiAgICAgIDogdGhpcy5ub2RlKCkuX19kYXRhX187XG59XG5cbnZhciBmaWx0ZXJFdmVudHMgPSB7fTtcblxuZXhwb3J0cy5ldmVudCA9IG51bGw7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGVsZW1lbnQkMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50JDEpKSB7XG4gICAgZmlsdGVyRXZlbnRzID0ge21vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIn07XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyQ29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCk7XG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgOCkpKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIHJldHVybiBmdW5jdGlvbihldmVudDEpIHtcbiAgICB2YXIgZXZlbnQwID0gZXhwb3J0cy5ldmVudDsgLy8gRXZlbnRzIGNhbiBiZSByZWVudHJhbnQgKGUuZy4sIGZvY3VzKS5cbiAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDA7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uO1xuICAgIGlmICghb24pIHJldHVybjtcbiAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAobyA9IG9uW2pdLCAoIXR5cGVuYW1lLnR5cGUgfHwgby50eXBlID09PSB0eXBlbmFtZS50eXBlKSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uWysraV0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKytpKSBvbi5sZW5ndGggPSBpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BZGQodHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB3cmFwID0gZmlsdGVyRXZlbnRzLmhhc093blByb3BlcnR5KHR5cGVuYW1lLnR5cGUpID8gZmlsdGVyQ29udGV4dExpc3RlbmVyIDogY29udGV4dExpc3RlbmVyO1xuICByZXR1cm4gZnVuY3Rpb24oZCwgaSwgZ3JvdXApIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb24sIG8sIGxpc3RlbmVyID0gd3JhcCh2YWx1ZSwgaSwgZ3JvdXApO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8uY2FwdHVyZSA9IGNhcHR1cmUpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBjYXB0dXJlOiBjYXB0dXJlfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBjdXN0b21FdmVudChldmVudDEsIGxpc3RlbmVyLCB0aGF0LCBhcmdzKSB7XG4gIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50O1xuICBldmVudDEuc291cmNlRXZlbnQgPSBleHBvcnRzLmV2ZW50O1xuICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICB0cnkge1xuICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9kaXNwYXRjaCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGRpc3BhdGNoRnVuY3Rpb25cbiAgICAgIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG59XG5cbnZhciByb290ID0gW251bGxdO1xuXG5mdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gIHNvcnQ6IHNlbGVjdGlvbl9zb3J0LFxuICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX25vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fZWFjaCxcbiAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gIHByb3BlcnR5OiBzZWxlY3Rpb25fcHJvcGVydHksXG4gIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgaHRtbDogc2VsZWN0aW9uX2h0bWwsXG4gIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gIGFwcGVuZDogc2VsZWN0aW9uX2FwcGVuZCxcbiAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gIGNsb25lOiBzZWxlY3Rpb25fY2xvbmUsXG4gIGRhdHVtOiBzZWxlY3Rpb25fZGF0dW0sXG4gIG9uOiBzZWxlY3Rpb25fb24sXG4gIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2hcbn07XG5cbmZ1bmN0aW9uIHNlbGVjdChzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobmFtZSkge1xuICByZXR1cm4gc2VsZWN0KGNyZWF0b3IobmFtZSkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTtcbn1cblxudmFyIG5leHRJZCA9IDA7XG5cbmZ1bmN0aW9uIGxvY2FsKCkge1xuICByZXR1cm4gbmV3IExvY2FsO1xufVxuXG5mdW5jdGlvbiBMb2NhbCgpIHtcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcbn1cblxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTG9jYWwsXG4gIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICB3aGlsZSAoIShpZCBpbiBub2RlKSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gbm9kZVtpZF07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLl8gaW4gbm9kZSAmJiBkZWxldGUgbm9kZVt0aGlzLl9dO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcblxuZnVuY3Rpb24gc291cmNlRXZlbnQoKSB7XG4gIHZhciBjdXJyZW50ID0gZXhwb3J0cy5ldmVudCwgc291cmNlO1xuICB3aGlsZSAoc291cmNlID0gY3VycmVudC5zb3VyY2VFdmVudCkgY3VycmVudCA9IHNvdXJjZTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHBvaW50KG5vZGUsIGV2ZW50KSB7XG4gIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuXG4gIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gIH1cblxuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xufVxuXG5mdW5jdGlvbiBtb3VzZShub2RlKSB7XG4gIHZhciBldmVudCA9IHNvdXJjZUV2ZW50KCk7XG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykgZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgcmV0dXJuIHBvaW50KG5vZGUsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0QWxsKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbn1cblxuZnVuY3Rpb24gdG91Y2gobm9kZSwgdG91Y2hlcywgaWRlbnRpZmllcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGlkZW50aWZpZXIgPSB0b3VjaGVzLCB0b3VjaGVzID0gc291cmNlRXZlbnQoKS5jaGFuZ2VkVG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCh0b3VjaCA9IHRvdWNoZXNbaV0pLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiBwb2ludChub2RlLCB0b3VjaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvdWNoZXMobm9kZSwgdG91Y2hlcykge1xuICBpZiAodG91Y2hlcyA9PSBudWxsKSB0b3VjaGVzID0gc291cmNlRXZlbnQoKS50b3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgcG9pbnRzID0gbmV3IEFycmF5KG4pOyBpIDwgbjsgKytpKSB7XG4gICAgcG9pbnRzW2ldID0gcG9pbnQobm9kZSwgdG91Y2hlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY3JlYXRvciA9IGNyZWF0b3I7XG5leHBvcnRzLmxvY2FsID0gbG9jYWw7XG5leHBvcnRzLm1hdGNoZXIgPSBtYXRjaGVyJDE7XG5leHBvcnRzLm1vdXNlID0gbW91c2U7XG5leHBvcnRzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbmV4cG9ydHMubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5leHBvcnRzLmNsaWVudFBvaW50ID0gcG9pbnQ7XG5leHBvcnRzLnNlbGVjdCA9IHNlbGVjdDtcbmV4cG9ydHMuc2VsZWN0QWxsID0gc2VsZWN0QWxsO1xuZXhwb3J0cy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG5leHBvcnRzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5leHBvcnRzLnNlbGVjdG9yQWxsID0gc2VsZWN0b3JBbGw7XG5leHBvcnRzLnN0eWxlID0gc3R5bGVWYWx1ZTtcbmV4cG9ydHMudG91Y2ggPSB0b3VjaDtcbmV4cG9ydHMudG91Y2hlcyA9IHRvdWNoZXM7XG5leHBvcnRzLndpbmRvdyA9IGRlZmF1bHRWaWV3O1xuZXhwb3J0cy5jdXN0b21FdmVudCA9IGN1c3RvbUV2ZW50O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zaGFwZS8gdjEuMi4yIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtcGF0aCcpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXBhdGgnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1BhdGgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb25zdGFudCgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG52YXIgZXBzaWxvbiA9IDFlLTEyO1xudmFyIHBpID0gTWF0aC5QSTtcbnZhciBoYWxmUGkgPSBwaSAvIDI7XG52YXIgdGF1ID0gMiAqIHBpO1xuXG5mdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5mdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPj0gMSA/IGhhbGZQaSA6IHggPD0gLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5mdW5jdGlvbiBhcmNJbm5lclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLmlubmVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNPdXRlclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLm91dGVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNTdGFydEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjRW5kQW5nbGUoZCkge1xuICByZXR1cm4gZC5lbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjUGFkQW5nbGUoZCkge1xuICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlOyAvLyBOb3RlOiBvcHRpb25hbCFcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgeDEwID0geDEgLSB4MCwgeTEwID0geTEgLSB5MCxcbiAgICAgIHgzMiA9IHgzIC0geDIsIHkzMiA9IHkzIC0geTIsXG4gICAgICB0ID0gKHgzMiAqICh5MCAtIHkyKSAtIHkzMiAqICh4MCAtIHgyKSkgLyAoeTMyICogeDEwIC0geDMyICogeTEwKTtcbiAgcmV0dXJuIFt4MCArIHQgKiB4MTAsIHkwICsgdCAqIHkxMF07XG59XG5cbi8vIENvbXB1dGUgcGVycGVuZGljdWxhciBvZmZzZXQgbGluZSBvZiBsZW5ndGggcmMuXG4vLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1MaW5lSW50ZXJzZWN0aW9uLmh0bWxcbmZ1bmN0aW9uIGNvcm5lclRhbmdlbnRzKHgwLCB5MCwgeDEsIHkxLCByMSwgcmMsIGN3KSB7XG4gIHZhciB4MDEgPSB4MCAtIHgxLFxuICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogc3FydChtYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksXG4gICAgICBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLFxuICAgICAgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsXG4gICAgICBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLFxuICAgICAgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsXG4gICAgICBkeDAgPSBjeDAgLSB4MDAsXG4gICAgICBkeTAgPSBjeTAgLSB5MDAsXG4gICAgICBkeDEgPSBjeDEgLSB4MDAsXG4gICAgICBkeTEgPSBjeTEgLSB5MDA7XG5cbiAgLy8gUGljayB0aGUgY2xvc2VyIG9mIHRoZSB0d28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgLy8gVE9ETyBJcyB0aGVyZSBhIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGludGVyc2VjdGlvbiB0byB1c2U/XG4gIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuXG4gIHJldHVybiB7XG4gICAgY3g6IGN4MCxcbiAgICBjeTogY3kwLFxuICAgIHgwMTogLW94LFxuICAgIHkwMTogLW95LFxuICAgIHgxMTogY3gwICogKHIxIC8gciAtIDEpLFxuICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFyYygpIHtcbiAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gY29uc3RhbnQoMCksXG4gICAgICBwYWRSYWRpdXMgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGFyY0VuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IGFicyhhMSAtIGEwKSxcbiAgICAgICAgY3cgPSBhMSA+IGEwO1xuXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdXRlciByYWRpdXMgaXMgYWx3YXlzIGxhcmdlciB0aGFuIHRoZSBpbm5lciByYWRpdXMuXG4gICAgaWYgKHIxIDwgcjApIHIgPSByMSwgcjEgPSByMCwgcjAgPSByO1xuXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICBpZiAoIShyMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUgLSBlcHNpbG9uKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhyMSAqIGNvcyhhMCksIHIxICogc2luKGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAsIGExLCAhY3cpO1xuICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3FydChyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gbWluKGFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBzaW4oYXApKSxcbiAgICAgICAgICAgIHAxID0gYXNpbihycCAvIHIxICogc2luKGFwKSk7XG4gICAgICAgIGlmICgoZGEwIC09IHAwICogMikgPiBlcHNpbG9uKSBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcbiAgICAgICAgZWxzZSBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICBpZiAoKGRhMSAtPSBwMSAqIDIpID4gZXBzaWxvbikgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XG4gICAgICAgIGVsc2UgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIGNvcyhhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogY29zKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbihhMTEpLFxuICAgICAgICAgICAgeDAwID0gcjAgKiBjb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogc2luKGEwMCk7XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIGNvcm5lciByYWRpdXMgYWNjb3JkaW5nIHRvIHRoZSBzZWN0b3IgYW5nbGUuXG4gICAgICAgIGlmIChkYSA8IHBpKSB7XG4gICAgICAgICAgdmFyIG9jID0gZGEwID4gZXBzaWxvbiA/IGludGVyc2VjdCh4MDEsIHkwMSwgeDAwLCB5MDAsIHgxMSwgeTExLCB4MTAsIHkxMCkgOiBbeDEwLCB5MTBdLFxuICAgICAgICAgICAgICBheCA9IHgwMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBheSA9IHkwMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBieCA9IHgxMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBieSA9IHkxMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBrYyA9IDEgLyBzaW4oYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKHNxcnQoYXggKiBheCArIGF5ICogYXkpICogc3FydChieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLFxuICAgICAgICAgICAgICBsYyA9IHNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IG1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgIHJjMSA9IG1pbihyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cbiAgICAgIGlmICghKGRhMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgb3V0ZXIgcmluZyBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMSA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MDAsIHkwMCwgeDAxLCB5MDEsIHIxLCByYzEsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MTEsIHkxMSwgeDEwLCB5MTAsIHIxLCByYzEsIGN3KTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMxIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMxLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgb3V0ZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSksIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMDEsIGExMSwgIWN3KTtcblxuICAgICAgLy8gSXMgdGhlcmUgbm8gaW5uZXIgcmluZywgYW5kIGl04oCZcyBhIGNpcmN1bGFyIHNlY3Rvcj9cbiAgICAgIC8vIE9yIHBlcmhhcHMgaXTigJlzIGFuIGFubnVsYXIgc2VjdG9yIGNvbGxhcHNlZCBkdWUgdG8gcGFkZGluZz9cbiAgICAgIGlmICghKHIwID4gZXBzaWxvbikgfHwgIShkYTAgPiBlcHNpbG9uKSkgY29udGV4dC5saW5lVG8oeDEwLCB5MTApO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMCA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MTAsIHkxMCwgeDExLCB5MTEsIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDAxLCB5MDEsIHgwMCwgeTAwLCByMCwgLXJjMCwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzAgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMCwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgIHJldHVybiBbY29zKGEpICogciwgc2luKGEpICogcl07XG4gIH07XG5cbiAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlubmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBpbm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3V0ZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IG91dGVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29ybmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBjb3JuZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRSYWRpdXMgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgYXJjLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGFyYykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmM7XG59XG5cbmZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGN1cnZlTGluZWFyKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZnVuY3Rpb24geShwKSB7XG4gIHJldHVybiBwWzFdO1xufVxuXG5mdW5jdGlvbiBsaW5lKCkge1xuICB2YXIgeCQkMSA9IHgsXG4gICAgICB5JCQxID0geSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gZDNQYXRoLnBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSBvdXRwdXQucG9pbnQoK3gkJDEoZCwgaSwgZGF0YSksICt5JCQxKGQsIGksIGRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB4JCQxO1xuICB9O1xuXG4gIGxpbmUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeSQkMTtcbiAgfTtcblxuICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgbGluZSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGxpbmUuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgbGluZSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBsaW5lLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmUpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gYXJlYSgpIHtcbiAgdmFyIHgwID0geCxcbiAgICAgIHgxID0gbnVsbCxcbiAgICAgIHkwID0gY29uc3RhbnQoMCksXG4gICAgICB5MSA9IHksXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgeDB6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBkM1BhdGgucGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDE7XG4gIH07XG5cbiAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMCA9XG4gIGFyZWEubGluZVkwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkxKTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICB9O1xuXG4gIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBhcmVhKSA6IGN1cnZlO1xuICB9O1xuXG4gIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShkKSB7XG4gIHJldHVybiBkO1xufVxuXG5mdW5jdGlvbiBwaWUoKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsXG4gICAgICBzb3J0ID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSxcbiAgICAgIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSxcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQoMCk7XG5cbiAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBpbmRleCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYXJjcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYTAgPSArc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBkYSA9IE1hdGgubWluKHRhdSwgTWF0aC5tYXgoLXRhdSwgZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGEwKSksXG4gICAgICAgIGExLFxuICAgICAgICBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICB2O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh2ID0gYXJjc1tpbmRleFtpXSA9IGldID0gK3ZhbHVlKGRhdGFbaV0sIGksIGRhdGEpKSA+IDApIHtcbiAgICAgICAgc3VtICs9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWxseSBzb3J0IHRoZSBhcmNzIGJ5IHByZXZpb3VzbHktY29tcHV0ZWQgdmFsdWVzIG9yIGJ5IGRhdGEuXG4gICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0VmFsdWVzKGFyY3NbaV0sIGFyY3Nbal0pOyB9KTtcbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhcmNzISBUaGV5IGFyZSBzdG9yZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEncyBvcmRlci5cbiAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcbiAgICAgIGogPSBpbmRleFtpXSwgdiA9IGFyY3Nbal0sIGExID0gYTAgKyAodiA+IDAgPyB2ICogayA6IDApICsgcGEsIGFyY3Nbal0gPSB7XG4gICAgICAgIGRhdGE6IGRhdGFbal0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyY3M7XG4gIH1cblxuICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHZhbHVlO1xuICB9O1xuXG4gIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRWYWx1ZXMgPSBfLCBzb3J0ID0gbnVsbCwgcGllKSA6IHNvcnRWYWx1ZXM7XG4gIH07XG5cbiAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNvcnRWYWx1ZXMgPSBudWxsLCBwaWUpIDogc29ydDtcbiAgfTtcblxuICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBwYWRBbmdsZTtcbiAgfTtcblxuICByZXR1cm4gcGllO1xufVxuXG52YXIgY3VydmVSYWRpYWxMaW5lYXIgPSBjdXJ2ZVJhZGlhbChjdXJ2ZUxpbmVhcik7XG5cbmZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xufVxuXG5SYWRpYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuXG4gIGZ1bmN0aW9uIHJhZGlhbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICB9XG5cbiAgcmFkaWFsLl9jdXJ2ZSA9IGN1cnZlO1xuXG4gIHJldHVybiByYWRpYWw7XG59XG5cbmZ1bmN0aW9uIGxpbmVSYWRpYWwobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxuZnVuY3Rpb24gbGluZVJhZGlhbCQxKCkge1xuICByZXR1cm4gbGluZVJhZGlhbChsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcbn1cblxuZnVuY3Rpb24gYXJlYVJhZGlhbCgpIHtcbiAgdmFyIGEgPSBhcmVhKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpLFxuICAgICAgYyA9IGEuY3VydmUsXG4gICAgICB4MCA9IGEubGluZVgwLFxuICAgICAgeDEgPSBhLmxpbmVYMSxcbiAgICAgIHkwID0gYS5saW5lWTAsXG4gICAgICB5MSA9IGEubGluZVkxO1xuXG4gIGEuYW5nbGUgPSBhLngsIGRlbGV0ZSBhLng7XG4gIGEuc3RhcnRBbmdsZSA9IGEueDAsIGRlbGV0ZSBhLngwO1xuICBhLmVuZEFuZ2xlID0gYS54MSwgZGVsZXRlIGEueDE7XG4gIGEucmFkaXVzID0gYS55LCBkZWxldGUgYS55O1xuICBhLmlubmVyUmFkaXVzID0gYS55MCwgZGVsZXRlIGEueTA7XG4gIGEub3V0ZXJSYWRpdXMgPSBhLnkxLCBkZWxldGUgYS55MTtcbiAgYS5saW5lU3RhcnRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MCgpKTsgfSwgZGVsZXRlIGEubGluZVgwO1xuICBhLmxpbmVFbmRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MSgpKTsgfSwgZGVsZXRlIGEubGluZVgxO1xuICBhLmxpbmVJbm5lclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MCgpKTsgfSwgZGVsZXRlIGEubGluZVkwO1xuICBhLmxpbmVPdXRlclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MSgpKTsgfSwgZGVsZXRlIGEubGluZVkxO1xuXG4gIGEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gIH07XG5cbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIHBvaW50UmFkaWFsKHgsIHkpIHtcbiAgcmV0dXJuIFsoeSA9ICt5KSAqIE1hdGguY29zKHggLT0gTWF0aC5QSSAvIDIpLCB5ICogTWF0aC5zaW4oeCldO1xufVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGxpbmtTb3VyY2UoZCkge1xuICByZXR1cm4gZC5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGxpbmtUYXJnZXQoZCkge1xuICByZXR1cm4gZC50YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGxpbmsoY3VydmUpIHtcbiAgdmFyIHNvdXJjZSA9IGxpbmtTb3VyY2UsXG4gICAgICB0YXJnZXQgPSBsaW5rVGFyZ2V0LFxuICAgICAgeCQkMSA9IHgsXG4gICAgICB5JCQxID0geSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgdmFyIGJ1ZmZlciwgYXJndiA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KSwgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuICAgIGN1cnZlKGNvbnRleHQsICt4JCQxLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLCAreSQkMS5hcHBseSh0aGlzLCBhcmd2KSwgK3gkJDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksICt5JCQxLmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmsuc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvdXJjZSA9IF8sIGxpbmspIDogc291cmNlO1xuICB9O1xuXG4gIGxpbmsudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIGxpbmspIDogdGFyZ2V0O1xuICB9O1xuXG4gIGxpbmsueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeCQkMTtcbiAgfTtcblxuICBsaW5rLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHkkJDE7XG4gIH07XG5cbiAgbGluay5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBsaW5rKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGN1cnZlSG9yaXpvbnRhbChjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICBjb250ZXh0LmJlemllckN1cnZlVG8oeDAgPSAoeDAgKyB4MSkgLyAyLCB5MCwgeDAsIHkxLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVZlcnRpY2FsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyLCB4MSwgeTAsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlUmFkaWFsJDEoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIHAwID0gcG9pbnRSYWRpYWwoeDAsIHkwKSxcbiAgICAgIHAxID0gcG9pbnRSYWRpYWwoeDAsIHkwID0gKHkwICsgeTEpIC8gMiksXG4gICAgICBwMiA9IHBvaW50UmFkaWFsKHgxLCB5MCksXG4gICAgICBwMyA9IHBvaW50UmFkaWFsKHgxLCB5MSk7XG4gIGNvbnRleHQubW92ZVRvKHAwWzBdLCBwMFsxXSk7XG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwMVswXSwgcDFbMV0sIHAyWzBdLCBwMlsxXSwgcDNbMF0sIHAzWzFdKTtcbn1cblxuZnVuY3Rpb24gbGlua0hvcml6b250YWwoKSB7XG4gIHJldHVybiBsaW5rKGN1cnZlSG9yaXpvbnRhbCk7XG59XG5cbmZ1bmN0aW9uIGxpbmtWZXJ0aWNhbCgpIHtcbiAgcmV0dXJuIGxpbmsoY3VydmVWZXJ0aWNhbCk7XG59XG5cbmZ1bmN0aW9uIGxpbmtSYWRpYWwoKSB7XG4gIHZhciBsID0gbGluayhjdXJ2ZVJhZGlhbCQxKTtcbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG4gIHJldHVybiBsO1xufVxuXG52YXIgY2lyY2xlID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIHBpKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICB9XG59O1xuXG52YXIgY3Jvc3MgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIHRhbjMwID0gTWF0aC5zcXJ0KDEgLyAzKSxcbiAgICB0YW4zMF8yID0gdGFuMzAgKiAyO1xuXG52YXIgZGlhbW9uZCA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gTWF0aC5zcXJ0KHNpemUgLyB0YW4zMF8yKSxcbiAgICAgICAgeCA9IHkgKiB0YW4zMDtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXgsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciBrYSA9IDAuODkwODEzMDkxNTI5Mjg1MjI4MTAsXG4gICAga3IgPSBNYXRoLnNpbihwaSAvIDEwKSAvIE1hdGguc2luKDcgKiBwaSAvIDEwKSxcbiAgICBreCA9IE1hdGguc2luKHRhdSAvIDEwKSAqIGtyLFxuICAgIGt5ID0gLU1hdGguY29zKHRhdSAvIDEwKSAqIGtyO1xuXG52YXIgc3RhciA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIgc3F1YXJlID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHcgPSBNYXRoLnNxcnQoc2l6ZSksXG4gICAgICAgIHggPSAtdyAvIDI7XG4gICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICB9XG59O1xuXG52YXIgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG5cbnZhciB0cmlhbmdsZSA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gLU1hdGguc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICBjb250ZXh0LmxpbmVUbygtc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIGMgPSAtMC41LFxuICAgIHMgPSBNYXRoLnNxcnQoMykgLyAyLFxuICAgIGsgPSAxIC8gTWF0aC5zcXJ0KDEyKSxcbiAgICBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG52YXIgd3llID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIGEpLFxuICAgICAgICB4MCA9IHIgLyAyLFxuICAgICAgICB5MCA9IHIgKiBrLFxuICAgICAgICB4MSA9IHgwLFxuICAgICAgICB5MSA9IHIgKiBrICsgcixcbiAgICAgICAgeDIgPSAteDEsXG4gICAgICAgIHkyID0geTE7XG4gICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwIC0gcyAqIHkwLCBzICogeDAgKyBjICogeTApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSAtIHMgKiB5MSwgcyAqIHgxICsgYyAqIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgLSBzICogeTIsIHMgKiB4MiArIGMgKiB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwICsgcyAqIHkwLCBjICogeTAgLSBzICogeDApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSArIHMgKiB5MSwgYyAqIHkxIC0gcyAqIHgxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgKyBzICogeTIsIGMgKiB5MiAtIHMgKiB4Mik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIHN5bWJvbHMgPSBbXG4gIGNpcmNsZSxcbiAgY3Jvc3MsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxuZnVuY3Rpb24gc3ltYm9sKCkge1xuICB2YXIgdHlwZSA9IGNvbnN0YW50KGNpcmNsZSksXG4gICAgICBzaXplID0gY29uc3RhbnQoNjQpLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgfTtcblxuICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN5bWJvbCkgOiBzaXplO1xuICB9O1xuXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgICgyICogdGhhdC5feDAgKyB0aGF0Ll94MSkgLyAzLFxuICAgICgyICogdGhhdC5feTAgKyB0aGF0Ll95MSkgLyAzLFxuICAgICh0aGF0Ll94MCArIDIgKiB0aGF0Ll94MSkgLyAzLFxuICAgICh0aGF0Ll95MCArIDIgKiB0aGF0Ll95MSkgLyAzLFxuICAgICh0aGF0Ll94MCArIDQgKiB0aGF0Ll94MSArIHgpIC8gNixcbiAgICAodGhhdC5feTAgKyA0ICogdGhhdC5feTEgKyB5KSAvIDZcbiAgKTtcbn1cblxuZnVuY3Rpb24gQmFzaXMoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXMucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IC8vIHByb2NlZWRcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9jb250ZXh0LmxpbmVUbygoNSAqIHRoaXMuX3gwICsgdGhpcy5feDEpIC8gNiwgKDUgKiB0aGlzLl95MCArIHRoaXMuX3kxKSAvIDYpOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2lzKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpcyhjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gQmFzaXNDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDIgKyAyICogdGhpcy5feDMpIC8gMywgKHRoaXMuX3kyICsgMiAqIHRoaXMuX3kzKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbygodGhpcy5feDMgKyAyICogdGhpcy5feDIpIC8gMywgKHRoaXMuX3kzICsgMiAqIHRoaXMuX3kyKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gyID0geCwgdGhpcy5feTIgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHk7IHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2KTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc0Nsb3NlZChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gQmFzaXNPcGVuKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHZhciB4MCA9ICh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgeTAgPSAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDY7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MCwgeTApIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeDAsIHkwKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNpc09wZW4oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzT3Blbihjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gQnVuZGxlKGNvbnRleHQsIGJldGEpIHtcbiAgdGhpcy5fYmFzaXMgPSBuZXcgQmFzaXMoY29udGV4dCk7XG4gIHRoaXMuX2JldGEgPSBiZXRhO1xufVxuXG5CdW5kbGUucHJvdG90eXBlID0ge1xuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gICAgdGhpcy5fYmFzaXMubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIGogPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoaiA+IDApIHtcbiAgICAgIHZhciB4MCA9IHhbMF0sXG4gICAgICAgICAgeTAgPSB5WzBdLFxuICAgICAgICAgIGR4ID0geFtqXSAtIHgwLFxuICAgICAgICAgIGR5ID0geVtqXSAtIHkwLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICB0O1xuXG4gICAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgICAgdCA9IGkgLyBqO1xuICAgICAgICB0aGlzLl9iYXNpcy5wb2ludChcbiAgICAgICAgICB0aGlzLl9iZXRhICogeFtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeDAgKyB0ICogZHgpLFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB5W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh5MCArIHQgKiBkeSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gICAgdGhpcy5fYmFzaXMubGluZUVuZCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxudmFyIGJ1bmRsZSA9IChmdW5jdGlvbiBjdXN0b20oYmV0YSkge1xuXG4gIGZ1bmN0aW9uIGJ1bmRsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJldGEgPT09IDEgPyBuZXcgQmFzaXMoY29udGV4dCkgOiBuZXcgQnVuZGxlKGNvbnRleHQsIGJldGEpO1xuICB9XG5cbiAgYnVuZGxlLmJldGEgPSBmdW5jdGlvbihiZXRhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYmV0YSk7XG4gIH07XG5cbiAgcmV0dXJuIGJ1bmRsZTtcbn0pKDAuODUpO1xuXG5mdW5jdGlvbiBwb2ludCQxKHRoYXQsIHgsIHkpIHtcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgIHRoYXQuX3gxICsgdGhhdC5fayAqICh0aGF0Ll94MiAtIHRoYXQuX3gwKSxcbiAgICB0aGF0Ll95MSArIHRoYXQuX2sgKiAodGhhdC5feTIgLSB0aGF0Ll95MCksXG4gICAgdGhhdC5feDIgKyB0aGF0Ll9rICogKHRoYXQuX3gxIC0geCksXG4gICAgdGhhdC5feTIgKyB0aGF0Ll9rICogKHRoYXQuX3kxIC0geSksXG4gICAgdGhhdC5feDIsXG4gICAgdGhhdC5feTJcbiAgKTtcbn1cblxuZnVuY3Rpb24gQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCQxKHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDEodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2FyZGluYWwgPSAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG5cbmZ1bmN0aW9uIENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NSA9IHgsIHRoaXMuX3k1ID0geTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCQxKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsQ2xvc2VkID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwkJDEoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbCQkMS50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbCQkMTtcbn0pKDApO1xuXG5mdW5jdGlvbiBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbE9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQxKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsT3BlbiA9IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsJCQxKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsJCQxLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsJCQxO1xufSkoMCk7XG5cbmZ1bmN0aW9uIHBvaW50JDIodGhhdCwgeCwgeSkge1xuICB2YXIgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICB4MiA9IHRoYXQuX3gyLFxuICAgICAgeTIgPSB0aGF0Ll95MjtcblxuICBpZiAodGhhdC5fbDAxX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGEgPSAyICogdGhhdC5fbDAxXzJhICsgMyAqIHRoYXQuX2wwMV9hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG4gPSAzICogdGhhdC5fbDAxX2EgKiAodGhhdC5fbDAxX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDEgPSAoeDEgKiBhIC0gdGhhdC5feDAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll94MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICAgIHkxID0gKHkxICogYSAtIHRoYXQuX3kwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feTIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgfVxuXG4gIGlmICh0aGF0Ll9sMjNfYSA+IGVwc2lsb24pIHtcbiAgICB2YXIgYiA9IDIgKiB0aGF0Ll9sMjNfMmEgKyAzICogdGhhdC5fbDIzX2EgKiB0aGF0Ll9sMTJfYSArIHRoYXQuX2wxMl8yYSxcbiAgICAgICAgbSA9IDMgKiB0aGF0Ll9sMjNfYSAqICh0aGF0Ll9sMjNfYSArIHRoYXQuX2wxMl9hKTtcbiAgICB4MiA9ICh4MiAqIGIgKyB0aGF0Ll94MSAqIHRoYXQuX2wyM18yYSAtIHggKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgICB5MiA9ICh5MiAqIGIgKyB0aGF0Ll95MSAqIHRoYXQuX2wyM18yYSAtIHkgKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgfVxuXG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgdGhhdC5feDIsIHRoYXQuX3kyKTtcbn1cblxuZnVuY3Rpb24gQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbS5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQyKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXRtdWxsUm9tID0gKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb21DbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDIodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhdG11bGxSb21DbG9zZWQgPSAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG5cbiAgZnVuY3Rpb24gY2F0bXVsbFJvbSQkMShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbSQkMS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tJCQxO1xufSkoMC41KTtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb21PcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQyKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXRtdWxsUm9tT3BlbiA9IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tJCQxKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20kJDEuYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbSQkMTtcbn0pKDAuNSk7XG5cbmZ1bmN0aW9uIExpbmVhckNsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXJDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBlbHNlIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxpbmVhckNsb3NlZChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyQ2xvc2VkKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xufVxuXG4vLyBDYWxjdWxhdGUgdGhlIHNsb3BlcyBvZiB0aGUgdGFuZ2VudHMgKEhlcm1pdGUtdHlwZSBpbnRlcnBvbGF0aW9uKSBiYXNlZCBvblxuLy8gdGhlIGZvbGxvd2luZyBwYXBlcjogU3RlZmZlbiwgTS4gMTk5MC4gQSBTaW1wbGUgTWV0aG9kIGZvciBNb25vdG9uaWNcbi8vIEludGVycG9sYXRpb24gaW4gT25lIERpbWVuc2lvbi4gQXN0cm9ub215IGFuZCBBc3Ryb3BoeXNpY3MsIFZvbC4gMjM5LCBOTy5cbi8vIE5PVihJSSksIFAuIDQ0MywgMTk5MC5cbmZ1bmN0aW9uIHNsb3BlMyh0aGF0LCB4MiwgeTIpIHtcbiAgdmFyIGgwID0gdGhhdC5feDEgLSB0aGF0Ll94MCxcbiAgICAgIGgxID0geDIgLSB0aGF0Ll94MSxcbiAgICAgIHMwID0gKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gKGgwIHx8IGgxIDwgMCAmJiAtMCksXG4gICAgICBzMSA9ICh5MiAtIHRoYXQuX3kxKSAvIChoMSB8fCBoMCA8IDAgJiYgLTApLFxuICAgICAgcCA9IChzMCAqIGgxICsgczEgKiBoMCkgLyAoaDAgKyBoMSk7XG4gIHJldHVybiAoc2lnbihzMCkgKyBzaWduKHMxKSkgKiBNYXRoLm1pbihNYXRoLmFicyhzMCksIE1hdGguYWJzKHMxKSwgMC41ICogTWF0aC5hYnMocCkpIHx8IDA7XG59XG5cbi8vIENhbGN1bGF0ZSBhIG9uZS1zaWRlZCBzbG9wZS5cbmZ1bmN0aW9uIHNsb3BlMih0aGF0LCB0KSB7XG4gIHZhciBoID0gdGhhdC5feDEgLSB0aGF0Ll94MDtcbiAgcmV0dXJuIGggPyAoMyAqICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIGggLSB0KSAvIDIgOiB0O1xufVxuXG4vLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfSGVybWl0ZV9zcGxpbmUjUmVwcmVzZW50YXRpb25zXG4vLyBcInlvdSBjYW4gZXhwcmVzcyBjdWJpYyBIZXJtaXRlIGludGVycG9sYXRpb24gaW4gdGVybXMgb2YgY3ViaWMgQsOpemllciBjdXJ2ZXNcbi8vIHdpdGggcmVzcGVjdCB0byB0aGUgZm91ciB2YWx1ZXMgcDAsIHAwICsgbTAgLyAzLCBwMSAtIG0xIC8gMywgcDFcIi5cbmZ1bmN0aW9uIHBvaW50JDModGhhdCwgdDAsIHQxKSB7XG4gIHZhciB4MCA9IHRoYXQuX3gwLFxuICAgICAgeTAgPSB0aGF0Ll95MCxcbiAgICAgIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgZHggPSAoeDEgLSB4MCkgLyAzO1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDAgKyBkeCwgeTAgKyBkeCAqIHQwLCB4MSAtIGR4LCB5MSAtIGR4ICogdDEsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5Nb25vdG9uZVgucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPVxuICAgIHRoaXMuX3QwID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQkMyh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0MSA9IE5hTjtcblxuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBwb2ludCQzKHRoaXMsIHNsb3BlMih0aGlzLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSksIHQxKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCQzKHRoaXMsIHRoaXMuX3QwLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gICAgdGhpcy5fdDAgPSB0MTtcbiAgfVxufTtcblxuZnVuY3Rpb24gTW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IG5ldyBSZWZsZWN0Q29udGV4dChjb250ZXh0KTtcbn1cblxuKE1vbm90b25lWS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vbm90b25lWC5wcm90b3R5cGUpKS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgTW9ub3RvbmVYLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIHksIHgpO1xufTtcblxuZnVuY3Rpb24gUmVmbGVjdENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUmVmbGVjdENvbnRleHQucHJvdG90eXBlID0ge1xuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5tb3ZlVG8oeSwgeCk7IH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7IHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0LmxpbmVUbyh5LCB4KTsgfSxcbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHsgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHkxLCB4MSwgeTIsIHgyLCB5LCB4KTsgfVxufTtcblxuZnVuY3Rpb24gbW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVgoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVZKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBOYXR1cmFsKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk5hdHVyYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcblxuICAgIGlmIChuKSB7XG4gICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeFswXSwgeVswXSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4WzBdLCB5WzBdKTtcbiAgICAgIGlmIChuID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHhbMV0sIHlbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB4ID0gY29udHJvbFBvaW50cyh4KSxcbiAgICAgICAgICAgIHB5ID0gY29udHJvbFBvaW50cyh5KTtcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDE7IGkxIDwgbjsgKytpMCwgKytpMSkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhweFswXVtpMF0sIHB5WzBdW2kwXSwgcHhbMV1baTBdLCBweVsxXVtpMF0sIHhbaTFdLCB5W2kxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiBuID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuLy8gU2VlIGh0dHBzOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS8yMDEyL2Jlemllci1zcGxpbmVzLyBmb3IgZGVyaXZhdGlvbi5cbmZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoeCkge1xuICB2YXIgaSxcbiAgICAgIG4gPSB4Lmxlbmd0aCAtIDEsXG4gICAgICBtLFxuICAgICAgYSA9IG5ldyBBcnJheShuKSxcbiAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICByID0gbmV3IEFycmF5KG4pO1xuICBhWzBdID0gMCwgYlswXSA9IDIsIHJbMF0gPSB4WzBdICsgMiAqIHhbMV07XG4gIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSBhW2ldID0gMSwgYltpXSA9IDQsIHJbaV0gPSA0ICogeFtpXSArIDIgKiB4W2kgKyAxXTtcbiAgYVtuIC0gMV0gPSAyLCBiW24gLSAxXSA9IDcsIHJbbiAtIDFdID0gOCAqIHhbbiAtIDFdICsgeFtuXTtcbiAgZm9yIChpID0gMTsgaSA8IG47ICsraSkgbSA9IGFbaV0gLyBiW2kgLSAxXSwgYltpXSAtPSBtLCByW2ldIC09IG0gKiByW2kgLSAxXTtcbiAgYVtuIC0gMV0gPSByW24gLSAxXSAvIGJbbiAtIDFdO1xuICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIGFbaV0gPSAocltpXSAtIGFbaSArIDFdKSAvIGJbaV07XG4gIGJbbiAtIDFdID0gKHhbbl0gKyBhW24gLSAxXSkgLyAyO1xuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7ICsraSkgYltpXSA9IDIgKiB4W2kgKyAxXSAtIGFbaSArIDFdO1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG5mdW5jdGlvbiBuYXR1cmFsKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBOYXR1cmFsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBTdGVwKGNvbnRleHQsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX3QgPSB0O1xufVxuXG5TdGVwLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICgwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiB0aGlzLl9wb2ludCA9PT0gMikgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSk7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGlmICh0aGlzLl9saW5lID49IDApIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fdCA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHgxID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyB4ICogdGhpcy5fdDtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgdGhpcy5feSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94ID0geCwgdGhpcy5feSA9IHk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0ZXAoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMC41KTtcbn1cblxuZnVuY3Rpb24gc3RlcEJlZm9yZShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwKTtcbn1cblxuZnVuY3Rpb24gc3RlcEFmdGVyKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDEpO1xufVxuXG5mdW5jdGlvbiBub25lKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDEpKSByZXR1cm47XG4gIGZvciAodmFyIGkgPSAxLCBqLCBzMCwgczEgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgczAgPSBzMSwgczEgPSBzZXJpZXNbb3JkZXJbaV1dO1xuICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIHMxW2pdWzFdICs9IHMxW2pdWzBdID0gaXNOYU4oczBbal1bMV0pID8gczBbal1bMF0gOiBzMFtqXVsxXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9uZSQxKHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkobik7XG4gIHdoaWxlICgtLW4gPj0gMCkgb1tuXSA9IG47XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBzdGFja1ZhbHVlKGQsIGtleSkge1xuICByZXR1cm4gZFtrZXldO1xufVxuXG5mdW5jdGlvbiBzdGFjaygpIHtcbiAgdmFyIGtleXMgPSBjb25zdGFudChbXSksXG4gICAgICBvcmRlciA9IG5vbmUkMSxcbiAgICAgIG9mZnNldCA9IG5vbmUsXG4gICAgICB2YWx1ZSA9IHN0YWNrVmFsdWU7XG5cbiAgZnVuY3Rpb24gc3RhY2soZGF0YSkge1xuICAgIHZhciBreiA9IGtleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgaSxcbiAgICAgICAgbSA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBuID0ga3oubGVuZ3RoLFxuICAgICAgICBzeiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgb3o7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmb3IgKHZhciBraSA9IGt6W2ldLCBzaSA9IHN6W2ldID0gbmV3IEFycmF5KG0pLCBqID0gMCwgc2lqOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHNpW2pdID0gc2lqID0gWzAsICt2YWx1ZShkYXRhW2pdLCBraSwgaiwgZGF0YSldO1xuICAgICAgICBzaWouZGF0YSA9IGRhdGFbal07XG4gICAgICB9XG4gICAgICBzaS5rZXkgPSBraTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBveiA9IG9yZGVyKHN6KTsgaSA8IG47ICsraSkge1xuICAgICAgc3pbb3pbaV1dLmluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBvZmZzZXQoc3osIG96KTtcbiAgICByZXR1cm4gc3o7XG4gIH1cblxuICBzdGFjay5rZXlzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGtleXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBrZXlzO1xuICB9O1xuXG4gIHN0YWNrLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN0YWNrKSA6IHZhbHVlO1xuICB9O1xuXG4gIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gXyA9PSBudWxsID8gbm9uZSQxIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDogb3JkZXI7XG4gIH07XG5cbiAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG5vbmUgOiBfLCBzdGFjaykgOiBvZmZzZXQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiBleHBhbmQoc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaSwgbiwgaiA9IDAsIG0gPSBzZXJpZXNbMF0ubGVuZ3RoLCB5OyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh5ID0gaSA9IDA7IGkgPCBuOyArK2kpIHkgKz0gc2VyaWVzW2ldW2pdWzFdIHx8IDA7XG4gICAgaWYgKHkpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHNlcmllc1tpXVtqXVsxXSAvPSB5O1xuICB9XG4gIG5vbmUoc2VyaWVzLCBvcmRlcik7XG59XG5cbmZ1bmN0aW9uIGRpdmVyZ2luZyhzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpLCBqID0gMCwgZCwgZHksIHlwLCB5biwgbiwgbSA9IHNlcmllc1tvcmRlclswXV0ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh5cCA9IHluID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoZHkgPSAoZCA9IHNlcmllc1tvcmRlcltpXV1bal0pWzFdIC0gZFswXSkgPj0gMCkge1xuICAgICAgICBkWzBdID0geXAsIGRbMV0gPSB5cCArPSBkeTtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGRbMV0gPSB5biwgZFswXSA9IHluICs9IGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFswXSA9IHlwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaWxob3VldHRlKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGogPSAwLCBzMCA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMC5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgeSA9IDA7IGkgPCBuOyArK2kpIHkgKz0gc2VyaWVzW2ldW2pdWzFdIHx8IDA7XG4gICAgczBbal1bMV0gKz0gczBbal1bMF0gPSAteSAvIDI7XG4gIH1cbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cblxuZnVuY3Rpb24gd2lnZ2xlKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApIHx8ICEoKG0gPSAoczAgPSBzZXJpZXNbb3JkZXJbMF1dKS5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgeSA9IDAsIGogPSAxLCBzMCwgbSwgbjsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCBzMSA9IDAsIHMyID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHNpID0gc2VyaWVzW29yZGVyW2ldXSxcbiAgICAgICAgICBzaWowID0gc2lbal1bMV0gfHwgMCxcbiAgICAgICAgICBzaWoxID0gc2lbaiAtIDFdWzFdIHx8IDAsXG4gICAgICAgICAgczMgPSAoc2lqMCAtIHNpajEpIC8gMjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaTsgKytrKSB7XG4gICAgICAgIHZhciBzayA9IHNlcmllc1tvcmRlcltrXV0sXG4gICAgICAgICAgICBza2owID0gc2tbal1bMV0gfHwgMCxcbiAgICAgICAgICAgIHNrajEgPSBza1tqIC0gMV1bMV0gfHwgMDtcbiAgICAgICAgczMgKz0gc2tqMCAtIHNrajE7XG4gICAgICB9XG4gICAgICBzMSArPSBzaWowLCBzMiArPSBzMyAqIHNpajA7XG4gICAgfVxuICAgIHMwW2ogLSAxXVsxXSArPSBzMFtqIC0gMV1bMF0gPSB5O1xuICAgIGlmIChzMSkgeSAtPSBzMiAvIHMxO1xuICB9XG4gIHMwW2ogLSAxXVsxXSArPSBzMFtqIC0gMV1bMF0gPSB5O1xuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmcoc2VyaWVzKSB7XG4gIHZhciBzdW1zID0gc2VyaWVzLm1hcChzdW0pO1xuICByZXR1cm4gbm9uZSQxKHNlcmllcykuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzdW1zW2FdIC0gc3Vtc1tiXTsgfSk7XG59XG5cbmZ1bmN0aW9uIHN1bShzZXJpZXMpIHtcbiAgdmFyIHMgPSAwLCBpID0gLTEsIG4gPSBzZXJpZXMubGVuZ3RoLCB2O1xuICB3aGlsZSAoKytpIDwgbikgaWYgKHYgPSArc2VyaWVzW2ldWzFdKSBzICs9IHY7XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nJDEoc2VyaWVzKSB7XG4gIHJldHVybiBhc2NlbmRpbmcoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIGluc2lkZU91dChzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBzdW1zID0gc2VyaWVzLm1hcChzdW0pLFxuICAgICAgb3JkZXIgPSBub25lJDEoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYl0gLSBzdW1zW2FdOyB9KSxcbiAgICAgIHRvcCA9IDAsXG4gICAgICBib3R0b20gPSAwLFxuICAgICAgdG9wcyA9IFtdLFxuICAgICAgYm90dG9tcyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBqID0gb3JkZXJbaV07XG4gICAgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgdG9wICs9IHN1bXNbal07XG4gICAgICB0b3BzLnB1c2goaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdHRvbSArPSBzdW1zW2pdO1xuICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2Uoc2VyaWVzKSB7XG4gIHJldHVybiBub25lJDEoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG5cbmV4cG9ydHMuYXJjID0gYXJjO1xuZXhwb3J0cy5hcmVhID0gYXJlYTtcbmV4cG9ydHMubGluZSA9IGxpbmU7XG5leHBvcnRzLnBpZSA9IHBpZTtcbmV4cG9ydHMuYXJlYVJhZGlhbCA9IGFyZWFSYWRpYWw7XG5leHBvcnRzLnJhZGlhbEFyZWEgPSBhcmVhUmFkaWFsO1xuZXhwb3J0cy5saW5lUmFkaWFsID0gbGluZVJhZGlhbCQxO1xuZXhwb3J0cy5yYWRpYWxMaW5lID0gbGluZVJhZGlhbCQxO1xuZXhwb3J0cy5wb2ludFJhZGlhbCA9IHBvaW50UmFkaWFsO1xuZXhwb3J0cy5saW5rSG9yaXpvbnRhbCA9IGxpbmtIb3Jpem9udGFsO1xuZXhwb3J0cy5saW5rVmVydGljYWwgPSBsaW5rVmVydGljYWw7XG5leHBvcnRzLmxpbmtSYWRpYWwgPSBsaW5rUmFkaWFsO1xuZXhwb3J0cy5zeW1ib2wgPSBzeW1ib2w7XG5leHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzO1xuZXhwb3J0cy5zeW1ib2xDaXJjbGUgPSBjaXJjbGU7XG5leHBvcnRzLnN5bWJvbENyb3NzID0gY3Jvc3M7XG5leHBvcnRzLnN5bWJvbERpYW1vbmQgPSBkaWFtb25kO1xuZXhwb3J0cy5zeW1ib2xTcXVhcmUgPSBzcXVhcmU7XG5leHBvcnRzLnN5bWJvbFN0YXIgPSBzdGFyO1xuZXhwb3J0cy5zeW1ib2xUcmlhbmdsZSA9IHRyaWFuZ2xlO1xuZXhwb3J0cy5zeW1ib2xXeWUgPSB3eWU7XG5leHBvcnRzLmN1cnZlQmFzaXNDbG9zZWQgPSBiYXNpc0Nsb3NlZDtcbmV4cG9ydHMuY3VydmVCYXNpc09wZW4gPSBiYXNpc09wZW47XG5leHBvcnRzLmN1cnZlQmFzaXMgPSBiYXNpcztcbmV4cG9ydHMuY3VydmVCdW5kbGUgPSBidW5kbGU7XG5leHBvcnRzLmN1cnZlQ2FyZGluYWxDbG9zZWQgPSBjYXJkaW5hbENsb3NlZDtcbmV4cG9ydHMuY3VydmVDYXJkaW5hbE9wZW4gPSBjYXJkaW5hbE9wZW47XG5leHBvcnRzLmN1cnZlQ2FyZGluYWwgPSBjYXJkaW5hbDtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tQ2xvc2VkID0gY2F0bXVsbFJvbUNsb3NlZDtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tT3BlbiA9IGNhdG11bGxSb21PcGVuO1xuZXhwb3J0cy5jdXJ2ZUNhdG11bGxSb20gPSBjYXRtdWxsUm9tO1xuZXhwb3J0cy5jdXJ2ZUxpbmVhckNsb3NlZCA9IGxpbmVhckNsb3NlZDtcbmV4cG9ydHMuY3VydmVMaW5lYXIgPSBjdXJ2ZUxpbmVhcjtcbmV4cG9ydHMuY3VydmVNb25vdG9uZVggPSBtb25vdG9uZVg7XG5leHBvcnRzLmN1cnZlTW9ub3RvbmVZID0gbW9ub3RvbmVZO1xuZXhwb3J0cy5jdXJ2ZU5hdHVyYWwgPSBuYXR1cmFsO1xuZXhwb3J0cy5jdXJ2ZVN0ZXAgPSBzdGVwO1xuZXhwb3J0cy5jdXJ2ZVN0ZXBBZnRlciA9IHN0ZXBBZnRlcjtcbmV4cG9ydHMuY3VydmVTdGVwQmVmb3JlID0gc3RlcEJlZm9yZTtcbmV4cG9ydHMuc3RhY2sgPSBzdGFjaztcbmV4cG9ydHMuc3RhY2tPZmZzZXRFeHBhbmQgPSBleHBhbmQ7XG5leHBvcnRzLnN0YWNrT2Zmc2V0RGl2ZXJnaW5nID0gZGl2ZXJnaW5nO1xuZXhwb3J0cy5zdGFja09mZnNldE5vbmUgPSBub25lO1xuZXhwb3J0cy5zdGFja09mZnNldFNpbGhvdWV0dGUgPSBzaWxob3VldHRlO1xuZXhwb3J0cy5zdGFja09mZnNldFdpZ2dsZSA9IHdpZ2dsZTtcbmV4cG9ydHMuc3RhY2tPcmRlckFzY2VuZGluZyA9IGFzY2VuZGluZztcbmV4cG9ydHMuc3RhY2tPcmRlckRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nJDE7XG5leHBvcnRzLnN0YWNrT3JkZXJJbnNpZGVPdXQgPSBpbnNpZGVPdXQ7XG5leHBvcnRzLnN0YWNrT3JkZXJOb25lID0gbm9uZSQxO1xuZXhwb3J0cy5zdGFja09yZGVyUmV2ZXJzZSA9IHJldmVyc2U7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpLCByZXF1aXJlKCdkMy1mb3JtYXQnKSwgcmVxdWlyZSgnZDMtZGlzcGF0Y2gnKSwgcmVxdWlyZSgnZDMtc2NhbGUnKSwgcmVxdWlyZSgnZDMtYXJyYXknKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXNlbGVjdGlvbicsICdkMy1mb3JtYXQnLCAnZDMtZGlzcGF0Y2gnLCAnZDMtc2NhbGUnLCAnZDMtYXJyYXknXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmluZGV4Um9sbHVwID0gZ2xvYmFsLmluZGV4Um9sbHVwIHx8IHt9KSxnbG9iYWwuZDNTZWxlY3Rpb24sZ2xvYmFsLmQzRm9ybWF0LGdsb2JhbC5kM0Rpc3BhdGNoLGdsb2JhbC5kM1NjYWxlLGdsb2JhbC5kM0FycmF5KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1NlbGVjdGlvbixkM0Zvcm1hdCxkM0Rpc3BhdGNoLGQzU2NhbGUsZDNBcnJheSkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgZDNfaWRlbnRpdHkgPSBmdW5jdGlvbiBkM19pZGVudGl0eShkKSB7XG4gIHJldHVybiBkO1xufTtcblxudmFyIGQzX3JldmVyc2UgPSBmdW5jdGlvbiBkM19yZXZlcnNlKGFycikge1xuICB2YXIgbWlycm9yID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG1pcnJvcltpXSA9IGFycltsIC0gaSAtIDFdO1xuICB9XG4gIHJldHVybiBtaXJyb3I7XG59O1xuXG4vL1RleHQgd3JhcHBpbmcgY29kZSBhZGFwdGVkIGZyb20gTWlrZSBCb3N0b2NrXG52YXIgZDNfdGV4dFdyYXBwaW5nID0gZnVuY3Rpb24gZDNfdGV4dFdyYXBwaW5nKHRleHQsIHdpZHRoKSB7XG4gIHRleHQuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRleHQgPSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcyksXG4gICAgICAgIHdvcmRzID0gdGV4dC50ZXh0KCkuc3BsaXQoL1xccysvKS5yZXZlcnNlKCksXG4gICAgICAgIHdvcmQsXG4gICAgICAgIGxpbmUgPSBbXSxcbiAgICAgICAgbGluZU51bWJlciA9IDAsXG4gICAgICAgIGxpbmVIZWlnaHQgPSAxLjIsXG4gICAgICAgIC8vZW1zXG4gICAgeSA9IHRleHQuYXR0cihcInlcIiksXG4gICAgICAgIGR5ID0gcGFyc2VGbG9hdCh0ZXh0LmF0dHIoXCJkeVwiKSkgfHwgMCxcbiAgICAgICAgdHNwYW4gPSB0ZXh0LnRleHQobnVsbCkuYXBwZW5kKFwidHNwYW5cIikuYXR0cihcInhcIiwgMCkuYXR0cihcImR5XCIsIGR5ICsgXCJlbVwiKTtcblxuICAgIHdoaWxlICh3b3JkID0gd29yZHMucG9wKCkpIHtcbiAgICAgIGxpbmUucHVzaCh3b3JkKTtcbiAgICAgIHRzcGFuLnRleHQobGluZS5qb2luKFwiIFwiKSk7XG4gICAgICBpZiAodHNwYW4ubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpID4gd2lkdGggJiYgbGluZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxpbmUucG9wKCk7XG4gICAgICAgIHRzcGFuLnRleHQobGluZS5qb2luKFwiIFwiKSk7XG4gICAgICAgIGxpbmUgPSBbd29yZF07XG4gICAgICAgIHRzcGFuID0gdGV4dC5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwiZHlcIiwgbGluZUhlaWdodCArIGR5ICsgXCJlbVwiKS50ZXh0KHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZDNfbWVyZ2VMYWJlbHMgPSBmdW5jdGlvbiBkM19tZXJnZUxhYmVscygpIHtcbiAgdmFyIGdlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHZhciBsYWJlbHMgPSBhcmd1bWVudHNbMV07XG4gIHZhciBkb21haW4gPSBhcmd1bWVudHNbMl07XG4gIHZhciByYW5nZSA9IGFyZ3VtZW50c1szXTtcbiAgdmFyIGxhYmVsRGVsaW1pdGVyID0gYXJndW1lbnRzWzRdO1xuXG4gIGlmICgodHlwZW9mIGxhYmVscyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGxhYmVscykpID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDApIHJldHVybiBnZW47XG5cbiAgICB2YXIgaSA9IGxhYmVscy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBnZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxhYmVscy5wdXNoKGdlbltpXSk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVscyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGN1c3RvbUxhYmVscyA9IFtdO1xuICAgIHZhciBnZW5MZW5ndGggPSBnZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBnZW5MZW5ndGg7IF9pKyspIHtcbiAgICAgIGN1c3RvbUxhYmVscy5wdXNoKGxhYmVscyh7XG4gICAgICAgIGk6IF9pLFxuICAgICAgICBnZW5MZW5ndGg6IGdlbkxlbmd0aCxcbiAgICAgICAgZ2VuZXJhdGVkTGFiZWxzOiBnZW4sXG4gICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIGxhYmVsRGVsaW1pdGVyOiBsYWJlbERlbGltaXRlclxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gY3VzdG9tTGFiZWxzO1xuICB9XG5cbiAgcmV0dXJuIGdlbjtcbn07XG5cbnZhciBkM19saW5lYXJMZWdlbmQgPSBmdW5jdGlvbiBkM19saW5lYXJMZWdlbmQoc2NhbGUsIGNlbGxzLCBsYWJlbEZvcm1hdCkge1xuICB2YXIgZGF0YSA9IFtdO1xuXG4gIGlmIChjZWxscy5sZW5ndGggPiAxKSB7XG4gICAgZGF0YSA9IGNlbGxzO1xuICB9IGVsc2Uge1xuICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW4oKSxcbiAgICAgICAgaW5jcmVtZW50ID0gKGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gLSBkb21haW5bMF0pIC8gKGNlbGxzIC0gMSk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBjZWxsczsgaSsrKSB7XG4gICAgICBkYXRhLnB1c2goZG9tYWluWzBdICsgaSAqIGluY3JlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhYmVscyA9IGRhdGEubWFwKGxhYmVsRm9ybWF0KTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIGxhYmVsczogbGFiZWxzLFxuICAgIGZlYXR1cmU6IGZ1bmN0aW9uIGZlYXR1cmUoZCkge1xuICAgICAgcmV0dXJuIHNjYWxlKGQpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBkM19xdWFudExlZ2VuZCA9IGZ1bmN0aW9uIGQzX3F1YW50TGVnZW5kKHNjYWxlLCBsYWJlbEZvcm1hdCwgbGFiZWxEZWxpbWl0ZXIpIHtcbiAgdmFyIGxhYmVscyA9IHNjYWxlLnJhbmdlKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIGludmVydCA9IHNjYWxlLmludmVydEV4dGVudChkKTtcbiAgICByZXR1cm4gbGFiZWxGb3JtYXQoaW52ZXJ0WzBdKSArIFwiIFwiICsgbGFiZWxEZWxpbWl0ZXIgKyBcIiBcIiArIGxhYmVsRm9ybWF0KGludmVydFsxXSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZGF0YTogc2NhbGUucmFuZ2UoKSxcbiAgICBsYWJlbHM6IGxhYmVscyxcbiAgICBmZWF0dXJlOiBkM19pZGVudGl0eVxuICB9O1xufTtcblxudmFyIGQzX29yZGluYWxMZWdlbmQgPSBmdW5jdGlvbiBkM19vcmRpbmFsTGVnZW5kKHNjYWxlKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YTogc2NhbGUuZG9tYWluKCksXG4gICAgbGFiZWxzOiBzY2FsZS5kb21haW4oKSxcbiAgICBmZWF0dXJlOiBmdW5jdGlvbiBmZWF0dXJlKGQpIHtcbiAgICAgIHJldHVybiBzY2FsZShkKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgZDNfY2VsbE92ZXIgPSBmdW5jdGlvbiBkM19jZWxsT3ZlcihjZWxsRGlzcGF0Y2hlciwgZCwgb2JqKSB7XG4gIGNlbGxEaXNwYXRjaGVyLmNhbGwoXCJjZWxsb3ZlclwiLCBvYmosIGQpO1xufTtcblxudmFyIGQzX2NlbGxPdXQgPSBmdW5jdGlvbiBkM19jZWxsT3V0KGNlbGxEaXNwYXRjaGVyLCBkLCBvYmopIHtcbiAgY2VsbERpc3BhdGNoZXIuY2FsbChcImNlbGxvdXRcIiwgb2JqLCBkKTtcbn07XG5cbnZhciBkM19jZWxsQ2xpY2sgPSBmdW5jdGlvbiBkM19jZWxsQ2xpY2soY2VsbERpc3BhdGNoZXIsIGQsIG9iaikge1xuICBjZWxsRGlzcGF0Y2hlci5jYWxsKFwiY2VsbGNsaWNrXCIsIG9iaiwgZCk7XG59O1xuXG52YXIgaGVscGVyID0ge1xuICBkM19kcmF3U2hhcGVzOiBmdW5jdGlvbiBkM19kcmF3U2hhcGVzKHNoYXBlLCBzaGFwZXMsIHNoYXBlSGVpZ2h0LCBzaGFwZVdpZHRoLCBzaGFwZVJhZGl1cywgcGF0aCkge1xuICAgIGlmIChzaGFwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICAgIHNoYXBlcy5hdHRyKFwiaGVpZ2h0XCIsIHNoYXBlSGVpZ2h0KS5hdHRyKFwid2lkdGhcIiwgc2hhcGVXaWR0aCk7XG4gICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgc2hhcGVzLmF0dHIoXCJyXCIsIHNoYXBlUmFkaXVzKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlID09PSBcImxpbmVcIikge1xuICAgICAgc2hhcGVzLmF0dHIoXCJ4MVwiLCAwKS5hdHRyKFwieDJcIiwgc2hhcGVXaWR0aCkuYXR0cihcInkxXCIsIDApLmF0dHIoXCJ5MlwiLCAwKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlID09PSBcInBhdGhcIikge1xuICAgICAgc2hhcGVzLmF0dHIoXCJkXCIsIHBhdGgpO1xuICAgIH1cbiAgfSxcblxuICBkM19hZGRUZXh0OiBmdW5jdGlvbiBkM19hZGRUZXh0KHN2ZywgZW50ZXIsIGxhYmVscywgY2xhc3NQcmVmaXgsIGxhYmVsV2lkdGgpIHtcbiAgICBlbnRlci5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwibGFiZWxcIik7XG4gICAgdmFyIHRleHQgPSBzdmcuc2VsZWN0QWxsKFwiZy5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsIHRleHQuXCIgKyBjbGFzc1ByZWZpeCArIFwibGFiZWxcIikuZGF0YShsYWJlbHMpLnRleHQoZDNfaWRlbnRpdHkpO1xuXG4gICAgaWYgKGxhYmVsV2lkdGgpIHtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoXCJnLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGwgdGV4dC5cIiArIGNsYXNzUHJlZml4ICsgXCJsYWJlbFwiKS5jYWxsKGQzX3RleHRXcmFwcGluZywgbGFiZWxXaWR0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH0sXG5cbiAgZDNfY2FsY1R5cGU6IGZ1bmN0aW9uIGQzX2NhbGNUeXBlKHNjYWxlLCBhc2NlbmRpbmcsIGNlbGxzLCBsYWJlbHMsIGxhYmVsRm9ybWF0LCBsYWJlbERlbGltaXRlcikge1xuICAgIHZhciB0eXBlID0gc2NhbGUuaW52ZXJ0RXh0ZW50ID8gZDNfcXVhbnRMZWdlbmQoc2NhbGUsIGxhYmVsRm9ybWF0LCBsYWJlbERlbGltaXRlcikgOiBzY2FsZS50aWNrcyA/IGQzX2xpbmVhckxlZ2VuZChzY2FsZSwgY2VsbHMsIGxhYmVsRm9ybWF0KSA6IGQzX29yZGluYWxMZWdlbmQoc2NhbGUpO1xuXG4gICAgLy9mb3IgZDMuc2NhbGVTZXF1ZW50aWFsIHRoYXQgZG9lc24ndCBoYXZlIGEgcmFuZ2UgZnVuY3Rpb25cbiAgICB2YXIgcmFuZ2UgPSBzY2FsZS5yYW5nZSAmJiBzY2FsZS5yYW5nZSgpIHx8IHNjYWxlLmRvbWFpbigpO1xuICAgIHR5cGUubGFiZWxzID0gZDNfbWVyZ2VMYWJlbHModHlwZS5sYWJlbHMsIGxhYmVscywgc2NhbGUuZG9tYWluKCksIHJhbmdlLCBsYWJlbERlbGltaXRlcik7XG5cbiAgICBpZiAoYXNjZW5kaW5nKSB7XG4gICAgICB0eXBlLmxhYmVscyA9IGQzX3JldmVyc2UodHlwZS5sYWJlbHMpO1xuICAgICAgdHlwZS5kYXRhID0gZDNfcmV2ZXJzZSh0eXBlLmRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9LFxuXG4gIGQzX2ZpbHRlckNlbGxzOiBmdW5jdGlvbiBkM19maWx0ZXJDZWxscyh0eXBlLCBjZWxsRmlsdGVyKSB7XG4gICAgdmFyIGZpbHRlckNlbGxzID0gdHlwZS5kYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIHsgZGF0YTogZCwgbGFiZWw6IHR5cGUubGFiZWxzW2ldIH07XG4gICAgfSkuZmlsdGVyKGNlbGxGaWx0ZXIpO1xuICAgIHZhciBkYXRhVmFsdWVzID0gZmlsdGVyQ2VsbHMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5kYXRhO1xuICAgIH0pO1xuICAgIHZhciBsYWJlbFZhbHVlcyA9IGZpbHRlckNlbGxzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQubGFiZWw7XG4gICAgfSk7XG4gICAgdHlwZS5kYXRhID0gdHlwZS5kYXRhLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGRhdGFWYWx1ZXMuaW5kZXhPZihkKSAhPT0gLTE7XG4gICAgfSk7XG4gICAgdHlwZS5sYWJlbHMgPSB0eXBlLmxhYmVscy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBsYWJlbFZhbHVlcy5pbmRleE9mKGQpICE9PSAtMTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfSxcblxuICBkM19wbGFjZW1lbnQ6IGZ1bmN0aW9uIGQzX3BsYWNlbWVudChvcmllbnQsIGNlbGwsIGNlbGxUcmFucywgdGV4dCwgdGV4dFRyYW5zLCBsYWJlbEFsaWduKSB7XG4gICAgY2VsbC5hdHRyKFwidHJhbnNmb3JtXCIsIGNlbGxUcmFucyk7XG4gICAgdGV4dC5hdHRyKFwidHJhbnNmb3JtXCIsIHRleHRUcmFucyk7XG4gICAgaWYgKG9yaWVudCA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIHRleHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBsYWJlbEFsaWduKTtcbiAgICB9XG4gIH0sXG5cbiAgZDNfYWRkRXZlbnRzOiBmdW5jdGlvbiBkM19hZGRFdmVudHMoY2VsbHMsIGRpc3BhdGNoZXIpIHtcbiAgICBjZWxscy5vbihcIm1vdXNlb3Zlci5sZWdlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzX2NlbGxPdmVyKGRpc3BhdGNoZXIsIGQsIHRoaXMpO1xuICAgIH0pLm9uKFwibW91c2VvdXQubGVnZW5kXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBkM19jZWxsT3V0KGRpc3BhdGNoZXIsIGQsIHRoaXMpO1xuICAgIH0pLm9uKFwiY2xpY2subGVnZW5kXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBkM19jZWxsQ2xpY2soZGlzcGF0Y2hlciwgZCwgdGhpcyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZDNfdGl0bGU6IGZ1bmN0aW9uIGQzX3RpdGxlKHN2ZywgdGl0bGUsIGNsYXNzUHJlZml4LCB0aXRsZVdpZHRoKSB7XG4gICAgaWYgKHRpdGxlICE9PSBcIlwiKSB7XG4gICAgICB2YXIgdGl0bGVUZXh0ID0gc3ZnLnNlbGVjdEFsbChcInRleHQuXCIgKyBjbGFzc1ByZWZpeCArIFwibGVnZW5kVGl0bGVcIik7XG5cbiAgICAgIHRpdGxlVGV4dC5kYXRhKFt0aXRsZV0pLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcImxlZ2VuZFRpdGxlXCIpO1xuXG4gICAgICBzdmcuc2VsZWN0QWxsKFwidGV4dC5cIiArIGNsYXNzUHJlZml4ICsgXCJsZWdlbmRUaXRsZVwiKS50ZXh0KHRpdGxlKTtcblxuICAgICAgaWYgKHRpdGxlV2lkdGgpIHtcbiAgICAgICAgc3ZnLnNlbGVjdEFsbChcInRleHQuXCIgKyBjbGFzc1ByZWZpeCArIFwibGVnZW5kVGl0bGVcIikuY2FsbChkM190ZXh0V3JhcHBpbmcsIHRpdGxlV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VsbHNTdmcgPSBzdmcuc2VsZWN0KFwiLlwiICsgY2xhc3NQcmVmaXggKyBcImxlZ2VuZENlbGxzXCIpO1xuICAgICAgdmFyIHlPZmZzZXQgPSBzdmcuc2VsZWN0KFwiLlwiICsgY2xhc3NQcmVmaXggKyBcImxlZ2VuZFRpdGxlXCIpLm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICB9KVswXSxcbiAgICAgICAgICB4T2Zmc2V0ID0gLWNlbGxzU3ZnLm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmdldEJCb3goKS54O1xuICAgICAgfSlbMF07XG4gICAgICBjZWxsc1N2Zy5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeE9mZnNldCArIFwiLFwiICsgeU9mZnNldCArIFwiKVwiKTtcbiAgICB9XG4gIH0sXG5cbiAgZDNfZGVmYXVsdExvY2FsZToge1xuICAgIGZvcm1hdDogZDNGb3JtYXQuZm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZDNGb3JtYXQuZm9ybWF0UHJlZml4XG4gIH0sXG5cbiAgZDNfZGVmYXVsdEZvcm1hdFNwZWNpZmllcjogXCIuMDFmXCIsXG5cbiAgZDNfZGVmYXVsdERlbGltaXRlcjogXCJ0b1wiXG59O1xuXG5mdW5jdGlvbiBjb2xvcigpIHtcbiAgdmFyIHNjYWxlID0gZDNTY2FsZS5zY2FsZUxpbmVhcigpLFxuICAgICAgc2hhcGUgPSBcInJlY3RcIixcbiAgICAgIHNoYXBlV2lkdGggPSAxNSxcbiAgICAgIHNoYXBlSGVpZ2h0ID0gMTUsXG4gICAgICBzaGFwZVJhZGl1cyA9IDEwLFxuICAgICAgc2hhcGVQYWRkaW5nID0gMixcbiAgICAgIGNlbGxzID0gWzVdLFxuICAgICAgY2VsbEZpbHRlciA9IHZvaWQgMCxcbiAgICAgIGxhYmVscyA9IFtdLFxuICAgICAgY2xhc3NQcmVmaXggPSBcIlwiLFxuICAgICAgdXNlQ2xhc3MgPSBmYWxzZSxcbiAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgIGxvY2FsZSA9IGhlbHBlci5kM19kZWZhdWx0TG9jYWxlLFxuICAgICAgc3BlY2lmaWVyID0gaGVscGVyLmQzX2RlZmF1bHRGb3JtYXRTcGVjaWZpZXIsXG4gICAgICBsYWJlbE9mZnNldCA9IDEwLFxuICAgICAgbGFiZWxBbGlnbiA9IFwibWlkZGxlXCIsXG4gICAgICBsYWJlbERlbGltaXRlciA9IGhlbHBlci5kM19kZWZhdWx0RGVsaW1pdGVyLFxuICAgICAgbGFiZWxXcmFwID0gdm9pZCAwLFxuICAgICAgb3JpZW50ID0gXCJ2ZXJ0aWNhbFwiLFxuICAgICAgYXNjZW5kaW5nID0gZmFsc2UsXG4gICAgICBwYXRoID0gdm9pZCAwLFxuICAgICAgdGl0bGVXaWR0aCA9IHZvaWQgMCxcbiAgICAgIGxlZ2VuZERpc3BhdGNoZXIgPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKFwiY2VsbG92ZXJcIiwgXCJjZWxsb3V0XCIsIFwiY2VsbGNsaWNrXCIpO1xuXG4gIGZ1bmN0aW9uIGxlZ2VuZChzdmcpIHtcbiAgICB2YXIgdHlwZSA9IGhlbHBlci5kM19jYWxjVHlwZShzY2FsZSwgYXNjZW5kaW5nLCBjZWxscywgbGFiZWxzLCBsb2NhbGUuZm9ybWF0KHNwZWNpZmllciksIGxhYmVsRGVsaW1pdGVyKSxcbiAgICAgICAgbGVnZW5kRyA9IHN2Zy5zZWxlY3RBbGwoXCJnXCIpLmRhdGEoW3NjYWxlXSk7XG5cbiAgICBsZWdlbmRHLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcImxlZ2VuZENlbGxzXCIpO1xuXG4gICAgaWYgKGNlbGxGaWx0ZXIpIHtcbiAgICAgIGhlbHBlci5kM19maWx0ZXJDZWxscyh0eXBlLCBjZWxsRmlsdGVyKTtcbiAgICB9XG5cbiAgICB2YXIgY2VsbCA9IHN2Zy5zZWxlY3QoXCIuXCIgKyBjbGFzc1ByZWZpeCArIFwibGVnZW5kQ2VsbHNcIikuc2VsZWN0QWxsKFwiLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGxcIikuZGF0YSh0eXBlLmRhdGEpO1xuXG4gICAgdmFyIGNlbGxFbnRlciA9IGNlbGwuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwiY2VsbFwiKTtcbiAgICBjZWxsRW50ZXIuYXBwZW5kKHNoYXBlKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcInN3YXRjaFwiKTtcblxuICAgIHZhciBzaGFwZXMgPSBzdmcuc2VsZWN0QWxsKFwiZy5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsIFwiICsgc2hhcGUgKyBcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJzd2F0Y2hcIikuZGF0YSh0eXBlLmRhdGEpO1xuXG4gICAgLy9hZGQgZXZlbnQgaGFuZGxlcnNcbiAgICBoZWxwZXIuZDNfYWRkRXZlbnRzKGNlbGxFbnRlciwgbGVnZW5kRGlzcGF0Y2hlcik7XG5cbiAgICBjZWxsLmV4aXQoKS50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuICAgIHNoYXBlcy5leGl0KCkudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAwKS5yZW1vdmUoKTtcblxuICAgIHNoYXBlcyA9IHNoYXBlcy5tZXJnZShzaGFwZXMpO1xuXG4gICAgaGVscGVyLmQzX2RyYXdTaGFwZXMoc2hhcGUsIHNoYXBlcywgc2hhcGVIZWlnaHQsIHNoYXBlV2lkdGgsIHNoYXBlUmFkaXVzLCBwYXRoKTtcbiAgICB2YXIgdGV4dCA9IGhlbHBlci5kM19hZGRUZXh0KHN2ZywgY2VsbEVudGVyLCB0eXBlLmxhYmVscywgY2xhc3NQcmVmaXgsIGxhYmVsV3JhcCk7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIHRoZSBzZWxlY3Rpb24sIG90aGVyd2lzZSBjaGFuZ2VzIGluIHRoZSBsZWdlbmQgKGUuZy4gY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBhcmUgYXBwbGllZCBvbmx5IHRvIHRoZSBuZXcgY2VsbHMgYW5kIG5vdCB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBjZWxsID0gY2VsbEVudGVyLm1lcmdlKGNlbGwpO1xuXG4gICAgLy8gc2V0cyBwbGFjZW1lbnRcbiAgICB2YXIgdGV4dFNpemUgPSB0ZXh0Lm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5nZXRCQm94KCk7XG4gICAgfSksXG4gICAgICAgIHNoYXBlU2l6ZSA9IHNoYXBlcy5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpO1xuICAgIH0pO1xuICAgIC8vc2V0cyBzY2FsZVxuICAgIC8vZXZlcnl0aGluZyBpcyBmaWxsIGV4Y2VwdCBmb3IgbGluZSB3aGljaCBpcyBzdHJva2UsXG4gICAgaWYgKCF1c2VDbGFzcykge1xuICAgICAgaWYgKHNoYXBlID09IFwibGluZVwiKSB7XG4gICAgICAgIHNoYXBlcy5zdHlsZShcInN0cm9rZVwiLCB0eXBlLmZlYXR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVzLnN0eWxlKFwiZmlsbFwiLCB0eXBlLmZlYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZXMuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBjbGFzc1ByZWZpeCArIFwic3dhdGNoIFwiICsgdHlwZS5mZWF0dXJlKGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNlbGxUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dFRyYW5zID0gdm9pZCAwLFxuICAgICAgICB0ZXh0QWxpZ24gPSBsYWJlbEFsaWduID09IFwic3RhcnRcIiA/IDAgOiBsYWJlbEFsaWduID09IFwibWlkZGxlXCIgPyAwLjUgOiAxO1xuXG4gICAgLy9wb3NpdGlvbnMgY2VsbHMgYW5kIHRleHRcbiAgICBpZiAob3JpZW50ID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsU2l6ZSA9IHRleHRTaXplLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChkLmhlaWdodCwgc2hhcGVTaXplW2ldLmhlaWdodCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNlbGxUcmFucyA9IGZ1bmN0aW9uIGNlbGxUcmFucyhkLCBpKSB7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGQzQXJyYXkuc3VtKGNlbGxTaXplLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIgKyAoaGVpZ2h0ICsgaSAqIHNoYXBlUGFkZGluZykgKyBcIilcIjtcbiAgICAgICAgfTtcblxuICAgICAgICB0ZXh0VHJhbnMgPSBmdW5jdGlvbiB0ZXh0VHJhbnMoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSggXCIgKyAoc2hhcGVTaXplW2ldLndpZHRoICsgc2hhcGVTaXplW2ldLnggKyBsYWJlbE9mZnNldCkgKyBcIiwgXCIgKyAoc2hhcGVTaXplW2ldLnkgKyBzaGFwZVNpemVbaV0uaGVpZ2h0IC8gMiArIDUpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAob3JpZW50ID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgY2VsbFRyYW5zID0gZnVuY3Rpb24gY2VsbFRyYW5zKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgaSAqIChzaGFwZVNpemVbaV0ud2lkdGggKyBzaGFwZVBhZGRpbmcpICsgXCIsMClcIjtcbiAgICAgIH07XG4gICAgICB0ZXh0VHJhbnMgPSBmdW5jdGlvbiB0ZXh0VHJhbnMoZCwgaSkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAoc2hhcGVTaXplW2ldLndpZHRoICogdGV4dEFsaWduICsgc2hhcGVTaXplW2ldLngpICsgXCIsXFxuICAgICAgICAgIFwiICsgKHNoYXBlU2l6ZVtpXS5oZWlnaHQgKyBzaGFwZVNpemVbaV0ueSArIGxhYmVsT2Zmc2V0ICsgOCkgKyBcIilcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaGVscGVyLmQzX3BsYWNlbWVudChvcmllbnQsIGNlbGwsIGNlbGxUcmFucywgdGV4dCwgdGV4dFRyYW5zLCBsYWJlbEFsaWduKTtcbiAgICBoZWxwZXIuZDNfdGl0bGUoc3ZnLCB0aXRsZSwgY2xhc3NQcmVmaXgsIHRpdGxlV2lkdGgpO1xuXG4gICAgY2VsbC50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICB9XG5cbiAgbGVnZW5kLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZTtcbiAgICBzY2FsZSA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2VsbHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbGxzO1xuICAgIGlmIChfLmxlbmd0aCA+IDEgfHwgXyA+PSAyKSB7XG4gICAgICBjZWxscyA9IF87XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNlbGxGaWx0ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbGxGaWx0ZXI7XG4gICAgY2VsbEZpbHRlciA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGUgPSBmdW5jdGlvbiAoXywgZCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlO1xuICAgIGlmIChfID09IFwicmVjdFwiIHx8IF8gPT0gXCJjaXJjbGVcIiB8fCBfID09IFwibGluZVwiIHx8IF8gPT0gXCJwYXRoXCIgJiYgdHlwZW9mIGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHNoYXBlID0gXztcbiAgICAgIHBhdGggPSBkO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZVdpZHRoO1xuICAgIHNoYXBlV2lkdGggPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZUhlaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVIZWlnaHQ7XG4gICAgc2hhcGVIZWlnaHQgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVJhZGl1cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVSYWRpdXM7XG4gICAgc2hhcGVSYWRpdXMgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5zaGFwZVBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlUGFkZGluZztcbiAgICBzaGFwZVBhZGRpbmcgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVscztcbiAgICBsYWJlbHMgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsQWxpZ24gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsQWxpZ247XG4gICAgaWYgKF8gPT0gXCJzdGFydFwiIHx8IF8gPT0gXCJlbmRcIiB8fCBfID09IFwibWlkZGxlXCIpIHtcbiAgICAgIGxhYmVsQWxpZ24gPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sb2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvY2FsZTtcbiAgICBsb2NhbGUgPSBkM0Zvcm1hdC5mb3JtYXRMb2NhbGUoXyk7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxGb3JtYXQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxlZ2VuZC5sb2NhbGUoKS5mb3JtYXQoc3BlY2lmaWVyKTtcbiAgICBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXRTcGVjaWZpZXIoXyk7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxPZmZzZXQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsT2Zmc2V0O1xuICAgIGxhYmVsT2Zmc2V0ID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxEZWxpbWl0ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsRGVsaW1pdGVyO1xuICAgIGxhYmVsRGVsaW1pdGVyID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbFdyYXAgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsV3JhcDtcbiAgICBsYWJlbFdyYXAgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnVzZUNsYXNzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB1c2VDbGFzcztcbiAgICBpZiAoXyA9PT0gdHJ1ZSB8fCBfID09PSBmYWxzZSkge1xuICAgICAgdXNlQ2xhc3MgPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5vcmllbnQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBfID0gXy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChfID09IFwiaG9yaXpvbnRhbFwiIHx8IF8gPT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICBvcmllbnQgPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5hc2NlbmRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFzY2VuZGluZztcbiAgICBhc2NlbmRpbmcgPSAhIV87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2xhc3NQcmVmaXggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsYXNzUHJlZml4O1xuICAgIGNsYXNzUHJlZml4ID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgdGl0bGUgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnRpdGxlV2lkdGggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlV2lkdGg7XG4gICAgdGl0bGVXaWR0aCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGV4dFdyYXAgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRleHRXcmFwO1xuICAgIHRleHRXcmFwID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBsZWdlbmREaXNwYXRjaGVyLm9uLmFwcGx5KGxlZ2VuZERpc3BhdGNoZXIsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsZWdlbmREaXNwYXRjaGVyID8gbGVnZW5kIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGxlZ2VuZDtcbn1cblxuZnVuY3Rpb24gc2l6ZSgpIHtcbiAgdmFyIHNjYWxlID0gZDNTY2FsZS5zY2FsZUxpbmVhcigpLFxuICAgICAgc2hhcGUgPSBcInJlY3RcIixcbiAgICAgIHNoYXBlV2lkdGggPSAxNSxcbiAgICAgIHNoYXBlUGFkZGluZyA9IDIsXG4gICAgICBjZWxscyA9IFs1XSxcbiAgICAgIGNlbGxGaWx0ZXIgPSB2b2lkIDAsXG4gICAgICBsYWJlbHMgPSBbXSxcbiAgICAgIGNsYXNzUHJlZml4ID0gXCJcIixcbiAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgIGxvY2FsZSA9IGhlbHBlci5kM19kZWZhdWx0TG9jYWxlLFxuICAgICAgc3BlY2lmaWVyID0gaGVscGVyLmQzX2RlZmF1bHRGb3JtYXRTcGVjaWZpZXIsXG4gICAgICBsYWJlbE9mZnNldCA9IDEwLFxuICAgICAgbGFiZWxBbGlnbiA9IFwibWlkZGxlXCIsXG4gICAgICBsYWJlbERlbGltaXRlciA9IGhlbHBlci5kM19kZWZhdWx0RGVsaW1pdGVyLFxuICAgICAgbGFiZWxXcmFwID0gdm9pZCAwLFxuICAgICAgb3JpZW50ID0gXCJ2ZXJ0aWNhbFwiLFxuICAgICAgYXNjZW5kaW5nID0gZmFsc2UsXG4gICAgICBwYXRoID0gdm9pZCAwLFxuICAgICAgdGl0bGVXaWR0aCA9IHZvaWQgMCxcbiAgICAgIGxlZ2VuZERpc3BhdGNoZXIgPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKFwiY2VsbG92ZXJcIiwgXCJjZWxsb3V0XCIsIFwiY2VsbGNsaWNrXCIpO1xuXG4gIGZ1bmN0aW9uIGxlZ2VuZChzdmcpIHtcbiAgICB2YXIgdHlwZSA9IGhlbHBlci5kM19jYWxjVHlwZShzY2FsZSwgYXNjZW5kaW5nLCBjZWxscywgbGFiZWxzLCBsb2NhbGUuZm9ybWF0KHNwZWNpZmllciksIGxhYmVsRGVsaW1pdGVyKSxcbiAgICAgICAgbGVnZW5kRyA9IHN2Zy5zZWxlY3RBbGwoXCJnXCIpLmRhdGEoW3NjYWxlXSk7XG5cbiAgICBpZiAoY2VsbEZpbHRlcikge1xuICAgICAgaGVscGVyLmQzX2ZpbHRlckNlbGxzKHR5cGUsIGNlbGxGaWx0ZXIpO1xuICAgIH1cblxuICAgIGxlZ2VuZEcuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwibGVnZW5kQ2VsbHNcIik7XG5cbiAgICB2YXIgY2VsbCA9IHN2Zy5zZWxlY3QoXCIuXCIgKyBjbGFzc1ByZWZpeCArIFwibGVnZW5kQ2VsbHNcIikuc2VsZWN0QWxsKFwiLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGxcIikuZGF0YSh0eXBlLmRhdGEpO1xuICAgIHZhciBjZWxsRW50ZXIgPSBjZWxsLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcImNlbGxcIik7XG4gICAgY2VsbEVudGVyLmFwcGVuZChzaGFwZSkuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJzd2F0Y2hcIik7XG5cbiAgICB2YXIgc2hhcGVzID0gc3ZnLnNlbGVjdEFsbChcImcuXCIgKyBjbGFzc1ByZWZpeCArIFwiY2VsbCBcIiArIHNoYXBlICsgXCIuXCIgKyBjbGFzc1ByZWZpeCArIFwic3dhdGNoXCIpO1xuXG4gICAgLy9hZGQgZXZlbnQgaGFuZGxlcnNcbiAgICBoZWxwZXIuZDNfYWRkRXZlbnRzKGNlbGxFbnRlciwgbGVnZW5kRGlzcGF0Y2hlcik7XG5cbiAgICBjZWxsLmV4aXQoKS50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuXG4gICAgc2hhcGVzLmV4aXQoKS50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuICAgIHNoYXBlcyA9IHNoYXBlcy5tZXJnZShzaGFwZXMpO1xuXG4gICAgLy9jcmVhdGVzIHNoYXBlXG4gICAgaWYgKHNoYXBlID09PSBcImxpbmVcIikge1xuICAgICAgaGVscGVyLmQzX2RyYXdTaGFwZXMoc2hhcGUsIHNoYXBlcywgMCwgc2hhcGVXaWR0aCk7XG4gICAgICBzaGFwZXMuYXR0cihcInN0cm9rZS13aWR0aFwiLCB0eXBlLmZlYXR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWxwZXIuZDNfZHJhd1NoYXBlcyhzaGFwZSwgc2hhcGVzLCB0eXBlLmZlYXR1cmUsIHR5cGUuZmVhdHVyZSwgdHlwZS5mZWF0dXJlLCBwYXRoKTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IGhlbHBlci5kM19hZGRUZXh0KHN2ZywgY2VsbEVudGVyLCB0eXBlLmxhYmVscywgY2xhc3NQcmVmaXgsIGxhYmVsV3JhcCk7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIHRoZSBzZWxlY3Rpb24sIG90aGVyd2lzZSBjaGFuZ2VzIGluIHRoZSBsZWdlbmQgKGUuZy4gY2hhbmdlIG9mIG9yaWVudGF0aW9uKSBhcmUgYXBwbGllZCBvbmx5IHRvIHRoZSBuZXcgY2VsbHMgYW5kIG5vdCB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBjZWxsID0gY2VsbEVudGVyLm1lcmdlKGNlbGwpO1xuXG4gICAgLy9zZXRzIHBsYWNlbWVudFxuXG4gICAgdmFyIHRleHRTaXplID0gdGV4dC5ub2RlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuZ2V0QkJveCgpO1xuICAgIH0pLFxuICAgICAgICBzaGFwZVNpemUgPSBzaGFwZXMubm9kZXMoKS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHZhciBiYm94ID0gZC5nZXRCQm94KCk7XG4gICAgICB2YXIgc3Ryb2tlID0gc2NhbGUodHlwZS5kYXRhW2ldKTtcblxuICAgICAgaWYgKHNoYXBlID09PSBcImxpbmVcIiAmJiBvcmllbnQgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIGJib3guaGVpZ2h0ID0gYmJveC5oZWlnaHQgKyBzdHJva2U7XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSBcImxpbmVcIiAmJiBvcmllbnQgPT09IFwidmVydGljYWxcIikge1xuICAgICAgICBiYm94LndpZHRoID0gYmJveC53aWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYm94O1xuICAgIH0pO1xuXG4gICAgdmFyIG1heEggPSBkM0FycmF5Lm1heChzaGFwZVNpemUsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5oZWlnaHQgKyBkLnk7XG4gICAgfSksXG4gICAgICAgIG1heFcgPSBkM0FycmF5Lm1heChzaGFwZVNpemUsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC53aWR0aCArIGQueDtcbiAgICB9KTtcblxuICAgIHZhciBjZWxsVHJhbnMgPSB2b2lkIDAsXG4gICAgICAgIHRleHRUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dEFsaWduID0gbGFiZWxBbGlnbiA9PSBcInN0YXJ0XCIgPyAwIDogbGFiZWxBbGlnbiA9PSBcIm1pZGRsZVwiID8gMC41IDogMTtcblxuICAgIC8vcG9zaXRpb25zIGNlbGxzIGFuZCB0ZXh0XG4gICAgaWYgKG9yaWVudCA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbFNpemUgPSB0ZXh0U2l6ZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZC5oZWlnaHQsIHNoYXBlU2l6ZVtpXS5oZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHkgPSBzaGFwZSA9PSBcImNpcmNsZVwiIHx8IHNoYXBlID09IFwibGluZVwiID8gc2hhcGVTaXplWzBdLmhlaWdodCAvIDIgOiAwO1xuICAgICAgICBjZWxsVHJhbnMgPSBmdW5jdGlvbiBjZWxsVHJhbnMoZCwgaSkge1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBkM0FycmF5LnN1bShjZWxsU2l6ZS5zbGljZSgwLCBpKSk7XG5cbiAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIgKyAoeSArIGhlaWdodCArIGkgKiBzaGFwZVBhZGRpbmcpICsgXCIpXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGV4dFRyYW5zID0gZnVuY3Rpb24gdGV4dFRyYW5zKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoIFwiICsgKG1heFcgKyBsYWJlbE9mZnNldCkgKyBcIixcXG4gICAgICAgICAgXCIgKyAoc2hhcGVTaXplW2ldLnkgKyBzaGFwZVNpemVbaV0uaGVpZ2h0IC8gMiArIDUpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAob3JpZW50ID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2VsbFRyYW5zID0gZnVuY3Rpb24gY2VsbFRyYW5zKGQsIGkpIHtcbiAgICAgICAgICB2YXIgd2lkdGggPSBkM0FycmF5LnN1bShzaGFwZVNpemUuc2xpY2UoMCwgaSksIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC53aWR0aDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgeSA9IHNoYXBlID09IFwiY2lyY2xlXCIgfHwgc2hhcGUgPT0gXCJsaW5lXCIgPyBtYXhIIC8gMiA6IDA7XG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKHdpZHRoICsgaSAqIHNoYXBlUGFkZGluZykgKyBcIiwgXCIgKyB5ICsgXCIpXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHNoYXBlID09IFwibGluZVwiID8gbWF4SCAvIDIgOiBtYXhIO1xuICAgICAgICB0ZXh0VHJhbnMgPSBmdW5jdGlvbiB0ZXh0VHJhbnMoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSggXCIgKyAoc2hhcGVTaXplW2ldLndpZHRoICogdGV4dEFsaWduICsgc2hhcGVTaXplW2ldLngpICsgXCIsXFxuICAgICAgICAgICAgICBcIiArIChvZmZzZXQgKyBsYWJlbE9mZnNldCkgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgaGVscGVyLmQzX3BsYWNlbWVudChvcmllbnQsIGNlbGwsIGNlbGxUcmFucywgdGV4dCwgdGV4dFRyYW5zLCBsYWJlbEFsaWduKTtcbiAgICBoZWxwZXIuZDNfdGl0bGUoc3ZnLCB0aXRsZSwgY2xhc3NQcmVmaXgsIHRpdGxlV2lkdGgpO1xuXG4gICAgY2VsbC50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICB9XG5cbiAgbGVnZW5kLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZTtcbiAgICBzY2FsZSA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2VsbHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbGxzO1xuICAgIGlmIChfLmxlbmd0aCA+IDEgfHwgXyA+PSAyKSB7XG4gICAgICBjZWxscyA9IF87XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNlbGxGaWx0ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbGxGaWx0ZXI7XG4gICAgY2VsbEZpbHRlciA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGUgPSBmdW5jdGlvbiAoXywgZCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlO1xuICAgIGlmIChfID09IFwicmVjdFwiIHx8IF8gPT0gXCJjaXJjbGVcIiB8fCBfID09IFwibGluZVwiKSB7XG4gICAgICBzaGFwZSA9IF87XG4gICAgICBwYXRoID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGVXaWR0aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVXaWR0aDtcbiAgICBzaGFwZVdpZHRoID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuc2hhcGVQYWRkaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaGFwZVBhZGRpbmc7XG4gICAgc2hhcGVQYWRkaW5nID0gK187XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbHM7XG4gICAgbGFiZWxzID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbEFsaWduID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbEFsaWduO1xuICAgIGlmIChfID09IFwic3RhcnRcIiB8fCBfID09IFwiZW5kXCIgfHwgXyA9PSBcIm1pZGRsZVwiKSB7XG4gICAgICBsYWJlbEFsaWduID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubG9jYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb2NhbGU7XG4gICAgbG9jYWxlID0gZDNGb3JtYXQuZm9ybWF0TG9jYWxlKF8pO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsRm9ybWF0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsZWdlbmQubG9jYWxlKCkuZm9ybWF0KHNwZWNpZmllcik7XG4gICAgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0U3BlY2lmaWVyKF8pO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsT2Zmc2V0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbE9mZnNldDtcbiAgICBsYWJlbE9mZnNldCA9ICtfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsRGVsaW1pdGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbERlbGltaXRlcjtcbiAgICBsYWJlbERlbGltaXRlciA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxXcmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbFdyYXA7XG4gICAgbGFiZWxXcmFwID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5vcmllbnQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBfID0gXy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChfID09IFwiaG9yaXpvbnRhbFwiIHx8IF8gPT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICBvcmllbnQgPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5hc2NlbmRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFzY2VuZGluZztcbiAgICBhc2NlbmRpbmcgPSAhIV87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuY2xhc3NQcmVmaXggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsYXNzUHJlZml4O1xuICAgIGNsYXNzUHJlZml4ID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgdGl0bGUgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnRpdGxlV2lkdGggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlV2lkdGg7XG4gICAgdGl0bGVXaWR0aCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gbGVnZW5kRGlzcGF0Y2hlci5vbi5hcHBseShsZWdlbmREaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGVnZW5kRGlzcGF0Y2hlciA/IGxlZ2VuZCA6IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBsZWdlbmQ7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgdmFyIHNjYWxlID0gZDNTY2FsZS5zY2FsZUxpbmVhcigpLFxuICAgICAgc2hhcGUgPSBcInBhdGhcIixcbiAgICAgIHNoYXBlV2lkdGggPSAxNSxcbiAgICAgIHNoYXBlSGVpZ2h0ID0gMTUsXG4gICAgICBzaGFwZVJhZGl1cyA9IDEwLFxuICAgICAgc2hhcGVQYWRkaW5nID0gNSxcbiAgICAgIGNlbGxzID0gWzVdLFxuICAgICAgY2VsbEZpbHRlciA9IHZvaWQgMCxcbiAgICAgIGxhYmVscyA9IFtdLFxuICAgICAgY2xhc3NQcmVmaXggPSBcIlwiLFxuICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgbG9jYWxlID0gaGVscGVyLmQzX2RlZmF1bHRMb2NhbGUsXG4gICAgICBzcGVjaWZpZXIgPSBoZWxwZXIuZDNfZGVmYXVsdEZvcm1hdFNwZWNpZmllcixcbiAgICAgIGxhYmVsQWxpZ24gPSBcIm1pZGRsZVwiLFxuICAgICAgbGFiZWxPZmZzZXQgPSAxMCxcbiAgICAgIGxhYmVsRGVsaW1pdGVyID0gaGVscGVyLmQzX2RlZmF1bHREZWxpbWl0ZXIsXG4gICAgICBsYWJlbFdyYXAgPSB2b2lkIDAsXG4gICAgICBvcmllbnQgPSBcInZlcnRpY2FsXCIsXG4gICAgICBhc2NlbmRpbmcgPSBmYWxzZSxcbiAgICAgIHRpdGxlV2lkdGggPSB2b2lkIDAsXG4gICAgICBsZWdlbmREaXNwYXRjaGVyID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcImNlbGxvdmVyXCIsIFwiY2VsbG91dFwiLCBcImNlbGxjbGlja1wiKTtcblxuICBmdW5jdGlvbiBsZWdlbmQoc3ZnKSB7XG4gICAgdmFyIHR5cGUgPSBoZWxwZXIuZDNfY2FsY1R5cGUoc2NhbGUsIGFzY2VuZGluZywgY2VsbHMsIGxhYmVscywgbG9jYWxlLmZvcm1hdChzcGVjaWZpZXIpLCBsYWJlbERlbGltaXRlciksXG4gICAgICAgIGxlZ2VuZEcgPSBzdmcuc2VsZWN0QWxsKFwiZ1wiKS5kYXRhKFtzY2FsZV0pO1xuXG4gICAgaWYgKGNlbGxGaWx0ZXIpIHtcbiAgICAgIGhlbHBlci5kM19maWx0ZXJDZWxscyh0eXBlLCBjZWxsRmlsdGVyKTtcbiAgICB9XG5cbiAgICBsZWdlbmRHLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NQcmVmaXggKyBcImxlZ2VuZENlbGxzXCIpO1xuXG4gICAgdmFyIGNlbGwgPSBzdmcuc2VsZWN0KFwiLlwiICsgY2xhc3NQcmVmaXggKyBcImxlZ2VuZENlbGxzXCIpLnNlbGVjdEFsbChcIi5cIiArIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpLmRhdGEodHlwZS5kYXRhKTtcbiAgICB2YXIgY2VsbEVudGVyID0gY2VsbC5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzUHJlZml4ICsgXCJjZWxsXCIpO1xuICAgIGNlbGxFbnRlci5hcHBlbmQoc2hhcGUpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc1ByZWZpeCArIFwic3dhdGNoXCIpO1xuXG4gICAgdmFyIHNoYXBlcyA9IHN2Zy5zZWxlY3RBbGwoXCJnLlwiICsgY2xhc3NQcmVmaXggKyBcImNlbGwgXCIgKyBzaGFwZSArIFwiLlwiICsgY2xhc3NQcmVmaXggKyBcInN3YXRjaFwiKTtcblxuICAgIC8vYWRkIGV2ZW50IGhhbmRsZXJzXG4gICAgaGVscGVyLmQzX2FkZEV2ZW50cyhjZWxsRW50ZXIsIGxlZ2VuZERpc3BhdGNoZXIpO1xuXG4gICAgLy9yZW1vdmUgb2xkIHNoYXBlc1xuICAgIGNlbGwuZXhpdCgpLnRyYW5zaXRpb24oKS5zdHlsZShcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG4gICAgc2hhcGVzLmV4aXQoKS50cmFuc2l0aW9uKCkuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuICAgIHNoYXBlcyA9IHNoYXBlcy5tZXJnZShzaGFwZXMpO1xuXG4gICAgaGVscGVyLmQzX2RyYXdTaGFwZXMoc2hhcGUsIHNoYXBlcywgc2hhcGVIZWlnaHQsIHNoYXBlV2lkdGgsIHNoYXBlUmFkaXVzLCB0eXBlLmZlYXR1cmUpO1xuICAgIHZhciB0ZXh0ID0gaGVscGVyLmQzX2FkZFRleHQoc3ZnLCBjZWxsRW50ZXIsIHR5cGUubGFiZWxzLCBjbGFzc1ByZWZpeCwgbGFiZWxXcmFwKTtcblxuICAgIC8vIHdlIG5lZWQgdG8gbWVyZ2UgdGhlIHNlbGVjdGlvbiwgb3RoZXJ3aXNlIGNoYW5nZXMgaW4gdGhlIGxlZ2VuZCAoZS5nLiBjaGFuZ2Ugb2Ygb3JpZW50YXRpb24pIGFyZSBhcHBsaWVkIG9ubHkgdG8gdGhlIG5ldyBjZWxscyBhbmQgbm90IHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGNlbGwgPSBjZWxsRW50ZXIubWVyZ2UoY2VsbCk7XG5cbiAgICAvLyBzZXRzIHBsYWNlbWVudFxuICAgIHZhciB0ZXh0U2l6ZSA9IHRleHQubm9kZXMoKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmdldEJCb3goKTtcbiAgICB9KSxcbiAgICAgICAgc2hhcGVTaXplID0gc2hhcGVzLm5vZGVzKCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5nZXRCQm94KCk7XG4gICAgfSk7XG5cbiAgICB2YXIgbWF4SCA9IGQzQXJyYXkubWF4KHNoYXBlU2l6ZSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmhlaWdodDtcbiAgICB9KSxcbiAgICAgICAgbWF4VyA9IGQzQXJyYXkubWF4KHNoYXBlU2l6ZSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLndpZHRoO1xuICAgIH0pO1xuXG4gICAgdmFyIGNlbGxUcmFucyA9IHZvaWQgMCxcbiAgICAgICAgdGV4dFRyYW5zID0gdm9pZCAwLFxuICAgICAgICB0ZXh0QWxpZ24gPSBsYWJlbEFsaWduID09IFwic3RhcnRcIiA/IDAgOiBsYWJlbEFsaWduID09IFwibWlkZGxlXCIgPyAwLjUgOiAxO1xuXG4gICAgLy9wb3NpdGlvbnMgY2VsbHMgYW5kIHRleHRcbiAgICBpZiAob3JpZW50ID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsU2l6ZSA9IHRleHRTaXplLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChtYXhILCBkLmhlaWdodCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNlbGxUcmFucyA9IGZ1bmN0aW9uIGNlbGxUcmFucyhkLCBpKSB7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGQzQXJyYXkuc3VtKGNlbGxTaXplLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIgKyAoaGVpZ2h0ICsgaSAqIHNoYXBlUGFkZGluZykgKyBcIiApXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRleHRUcmFucyA9IGZ1bmN0aW9uIHRleHRUcmFucyhkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKCBcIiArIChtYXhXICsgbGFiZWxPZmZzZXQpICsgXCIsXFxuICAgICAgICAgICAgICBcIiArIChzaGFwZVNpemVbaV0ueSArIHNoYXBlU2l6ZVtpXS5oZWlnaHQgLyAyICsgNSkgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmIChvcmllbnQgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBjZWxsVHJhbnMgPSBmdW5jdGlvbiBjZWxsVHJhbnMoZCwgaSkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoIFwiICsgaSAqIChtYXhXICsgc2hhcGVQYWRkaW5nKSArIFwiLDApXCI7XG4gICAgICB9O1xuICAgICAgdGV4dFRyYW5zID0gZnVuY3Rpb24gdGV4dFRyYW5zKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKCBcIiArIChzaGFwZVNpemVbaV0ud2lkdGggKiB0ZXh0QWxpZ24gKyBzaGFwZVNpemVbaV0ueCkgKyBcIixcXG4gICAgICAgICAgICAgIFwiICsgKG1heEggKyBsYWJlbE9mZnNldCkgKyBcIilcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaGVscGVyLmQzX3BsYWNlbWVudChvcmllbnQsIGNlbGwsIGNlbGxUcmFucywgdGV4dCwgdGV4dFRyYW5zLCBsYWJlbEFsaWduKTtcbiAgICBoZWxwZXIuZDNfdGl0bGUoc3ZnLCB0aXRsZSwgY2xhc3NQcmVmaXgsIHRpdGxlV2lkdGgpO1xuICAgIGNlbGwudHJhbnNpdGlvbigpLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgfVxuXG4gIGxlZ2VuZC5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgc2NhbGUgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNlbGxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZWxscztcbiAgICBpZiAoXy5sZW5ndGggPiAxIHx8IF8gPj0gMikge1xuICAgICAgY2VsbHMgPSBfO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5jZWxsRmlsdGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZWxsRmlsdGVyO1xuICAgIGNlbGxGaWx0ZXIgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlUGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hhcGVQYWRkaW5nO1xuICAgIHNoYXBlUGFkZGluZyA9ICtfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVscyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxzO1xuICAgIGxhYmVscyA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQubGFiZWxBbGlnbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxBbGlnbjtcbiAgICBpZiAoXyA9PSBcInN0YXJ0XCIgfHwgXyA9PSBcImVuZFwiIHx8IF8gPT0gXCJtaWRkbGVcIikge1xuICAgICAgbGFiZWxBbGlnbiA9IF87XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxvY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG9jYWxlO1xuICAgIGxvY2FsZSA9IGQzRm9ybWF0LmZvcm1hdExvY2FsZShfKTtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbEZvcm1hdCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGVnZW5kLmxvY2FsZSgpLmZvcm1hdChzcGVjaWZpZXIpO1xuICAgIHNwZWNpZmllciA9IGQzRm9ybWF0LmZvcm1hdFNwZWNpZmllcihfKTtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbE9mZnNldCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxPZmZzZXQ7XG4gICAgbGFiZWxPZmZzZXQgPSArXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5sYWJlbERlbGltaXRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxEZWxpbWl0ZXI7XG4gICAgbGFiZWxEZWxpbWl0ZXIgPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsV3JhcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxXcmFwO1xuICAgIGxhYmVsV3JhcCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgXyA9IF8udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoXyA9PSBcImhvcml6b250YWxcIiB8fCBfID09IFwidmVydGljYWxcIikge1xuICAgICAgb3JpZW50ID0gXztcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQuYXNjZW5kaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhc2NlbmRpbmc7XG4gICAgYXNjZW5kaW5nID0gISFfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmNsYXNzUHJlZml4ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFzc1ByZWZpeDtcbiAgICBjbGFzc1ByZWZpeCA9IF87XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIHRpdGxlID0gXztcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC50aXRsZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVdpZHRoO1xuICAgIHRpdGxlV2lkdGggPSBfO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLm9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IGxlZ2VuZERpc3BhdGNoZXIub24uYXBwbHkobGVnZW5kRGlzcGF0Y2hlciwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxlZ2VuZERpc3BhdGNoZXIgPyBsZWdlbmQgOiB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gbGVnZW5kO1xufVxuXG52YXIgdGhyZXNob2xkTGFiZWxzID0gZnVuY3Rpb24gdGhyZXNob2xkTGFiZWxzKF9yZWYpIHtcbiAgdmFyIGkgPSBfcmVmLmksXG4gICAgICBnZW5MZW5ndGggPSBfcmVmLmdlbkxlbmd0aCxcbiAgICAgIGdlbmVyYXRlZExhYmVscyA9IF9yZWYuZ2VuZXJhdGVkTGFiZWxzLFxuICAgICAgbGFiZWxEZWxpbWl0ZXIgPSBfcmVmLmxhYmVsRGVsaW1pdGVyO1xuXG4gIGlmIChpID09PSAwKSB7XG4gICAgdmFyIHZhbHVlcyA9IGdlbmVyYXRlZExhYmVsc1tpXS5zcGxpdChcIiBcIiArIGxhYmVsRGVsaW1pdGVyICsgXCIgXCIpO1xuICAgIHJldHVybiBcIkxlc3MgdGhhbiBcIiArIHZhbHVlc1sxXTtcbiAgfSBlbHNlIGlmIChpID09PSBnZW5MZW5ndGggLSAxKSB7XG4gICAgdmFyIF92YWx1ZXMgPSBnZW5lcmF0ZWRMYWJlbHNbaV0uc3BsaXQoXCIgXCIgKyBsYWJlbERlbGltaXRlciArIFwiIFwiKTtcbiAgICByZXR1cm4gX3ZhbHVlc1swXSArIFwiIG9yIG1vcmVcIjtcbiAgfVxuICByZXR1cm4gZ2VuZXJhdGVkTGFiZWxzW2ldO1xufTtcblxudmFyIGxlZ2VuZEhlbHBlcnMgPSB7XG4gIHRocmVzaG9sZExhYmVsczogdGhyZXNob2xkTGFiZWxzXG59O1xuXG52YXIgaW5kZXggPSB7XG4gIGxlZ2VuZENvbG9yOiBjb2xvcixcbiAgbGVnZW5kU2l6ZTogc2l6ZSxcbiAgbGVnZW5kU3ltYm9sOiBzeW1ib2wsXG4gIGxlZ2VuZEhlbHBlcnM6IGxlZ2VuZEhlbHBlcnNcbn07XG5cbmV4cG9ydHMubGVnZW5kQ29sb3IgPSBjb2xvcjtcbmV4cG9ydHMubGVnZW5kU2l6ZSA9IHNpemU7XG5leHBvcnRzLmxlZ2VuZFN5bWJvbCA9IHN5bWJvbDtcbmV4cG9ydHMubGVnZW5kSGVscGVycyA9IGxlZ2VuZEhlbHBlcnM7XG5leHBvcnRzWydkZWZhdWx0J10gPSBpbmRleDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Um9sbHVwLmpzLm1hcFxuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1hcnJheS8gVmVyc2lvbiAxLjAuMS4gQ29weXJpZ2h0IDIwMTYgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG4gIH1cblxuICBmdW5jdGlvbiBiaXNlY3Rvcihjb21wYXJlKSB7XG4gICAgaWYgKGNvbXBhcmUubGVuZ3RoID09PSAxKSBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihjb21wYXJlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9LFxuICAgICAgcmlnaHQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7XG4gICAgICAgICAgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgeCkge1xuICAgICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG4gIHZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbiAgdmFyIGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcblxuICBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG4gIH1cblxuICBmdW5jdGlvbiBudW1iZXIoeCkge1xuICAgIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG4gIH1cblxuICBmdW5jdGlvbiB2YXJpYW5jZShhcnJheSwgZikge1xuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBtID0gMCxcbiAgICAgICAgYSxcbiAgICAgICAgZCxcbiAgICAgICAgcyA9IDAsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgaiA9IDA7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoIWlzTmFOKGEgPSBudW1iZXIoYXJyYXlbaV0pKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKCFpc05hTihhID0gbnVtYmVyKGYoYXJyYXlbaV0sIGksIGFycmF5KSkpKSB7XG4gICAgICAgICAgZCA9IGEgLSBtO1xuICAgICAgICAgIG0gKz0gZCAvICsrajtcbiAgICAgICAgICBzICs9IGQgKiAoYSAtIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGogPiAxKSByZXR1cm4gcyAvIChqIC0gMSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXZpYXRpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgdiA9IHZhcmlhbmNlKGFycmF5LCBmKTtcbiAgICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbnQoYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYyA9IGI7IGJyZWFrOyB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBjID0gYjsgYnJlYWs7IH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2EsIGNdO1xuICB9XG5cbiAgdmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuICB2YXIgbWFwID0gYXJyYXkubWFwO1xuXG4gIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIHZhciBlMTAgPSBNYXRoLnNxcnQoNTApO1xuICB2YXIgZTUgPSBNYXRoLnNxcnQoMTApO1xuICB2YXIgZTIgPSBNYXRoLnNxcnQoMik7XG4gIGZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICByZXR1cm4gcmFuZ2UoXG4gICAgICBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKSAqIHN0ZXAsXG4gICAgICBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKSAqIHN0ZXAgKyBzdGVwIC8gMiwgLy8gaW5jbHVzaXZlXG4gICAgICBzdGVwXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICAgIGVycm9yID0gc3RlcDAgLyBzdGVwMTtcbiAgICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcDEgKj0gMjtcbiAgICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG4gIH1cblxuICBmdW5jdGlvbiBzdHVyZ2VzKHZhbHVlcykge1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLkxOMikgKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlzdG9ncmFtKCkge1xuICAgIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgICBkb21haW4gPSBleHRlbnQsXG4gICAgICAgIHRocmVzaG9sZCA9IHN0dXJnZXM7XG5cbiAgICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeHogPSBkb21haW4odmFsdWVzKSxcbiAgICAgICAgICB4MCA9IHh6WzBdLFxuICAgICAgICAgIHgxID0geHpbMV0sXG4gICAgICAgICAgdHogPSB0aHJlc2hvbGQodmFsdWVzLCB4MCwgeDEpO1xuXG4gICAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHR6KSkgdHogPSB0aWNrcyh4MCwgeDEsIHR6KTtcblxuICAgICAgLy8gUmVtb3ZlIGFueSB0aHJlc2hvbGRzIG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICAgIHZhciBtID0gdHoubGVuZ3RoO1xuICAgICAgd2hpbGUgKHR6WzBdIDw9IHgwKSB0ei5zaGlmdCgpLCAtLW07XG4gICAgICB3aGlsZSAodHpbbSAtIDFdID49IHgxKSB0ei5wb3AoKSwgLS1tO1xuXG4gICAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksXG4gICAgICAgICAgYmluO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGJpbnMuXG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IG07ICsraSkge1xuICAgICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICAgIGJpbi54MCA9IGkgPiAwID8gdHpbaSAtIDFdIDogeDA7XG4gICAgICAgIGJpbi54MSA9IGkgPCBtID8gdHpbaV0gOiB4MTtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzaWduIGRhdGEgdG8gYmlucyBieSB2YWx1ZSwgaWdub3JpbmcgYW55IG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHgwIDw9IHggJiYgeCA8PSB4MSkge1xuICAgICAgICAgIGJpbnNbYmlzZWN0UmlnaHQodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5zO1xuICAgIH1cblxuICAgIGhpc3RvZ3JhbS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICAgIH07XG5cbiAgICBoaXN0b2dyYW0uZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICAgIH07XG5cbiAgICBoaXN0b2dyYW0udGhyZXNob2xkcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGlsZShhcnJheSwgcCwgZikge1xuICAgIGlmIChmID09IG51bGwpIGYgPSBudW1iZXI7XG4gICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuICtmKGFycmF5WzBdLCAwLCBhcnJheSk7XG4gICAgaWYgKHAgPj0gMSkgcmV0dXJuICtmKGFycmF5W24gLSAxXSwgbiAtIDEsIGFycmF5KTtcbiAgICB2YXIgbixcbiAgICAgICAgaCA9IChuIC0gMSkgKiBwLFxuICAgICAgICBpID0gTWF0aC5mbG9vcihoKSxcbiAgICAgICAgYSA9ICtmKGFycmF5W2ldLCBpLCBhcnJheSksXG4gICAgICAgIGIgPSArZihhcnJheVtpICsgMV0sIGkgKyAxLCBhcnJheSk7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogKGggLSBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVkbWFuRGlhY29uaXModmFsdWVzLCBtaW4sIG1heCkge1xuICAgIHZhbHVlcyA9IG1hcC5jYWxsKHZhbHVlcywgbnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgyICogKHF1YW50aWxlKHZhbHVlcywgMC43NSkgLSBxdWFudGlsZSh2YWx1ZXMsIDAuMjUpKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjb3R0KHZhbHVlcywgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDMuNSAqIGRldmlhdGlvbih2YWx1ZXMpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgYSxcbiAgICAgICAgYjtcblxuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGI7IGJyZWFrOyB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGI7IGJyZWFrOyB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYW4oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgaiA9IG47XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpc05hTihhID0gbnVtYmVyKGFycmF5W2ldKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpc05hTihhID0gbnVtYmVyKGYoYXJyYXlbaV0sIGksIGFycmF5KSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH1cblxuICAgIGlmIChqKSByZXR1cm4gcyAvIGo7XG4gIH1cblxuICBmdW5jdGlvbiBtZWRpYW4oYXJyYXksIGYpIHtcbiAgICB2YXIgbnVtYmVycyA9IFtdLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBpID0gLTE7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpc05hTihhID0gbnVtYmVyKGFycmF5W2ldKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWlzTmFOKGEgPSBudW1iZXIoZihhcnJheVtpXSwgaSwgYXJyYXkpKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVhbnRpbGUobnVtYmVycy5zb3J0KGFzY2VuZGluZyksIDAuNSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgIG0sXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIG1lcmdlZCxcbiAgICAgICAgYXJyYXk7XG5cbiAgICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcblxuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgICBtID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGI7XG5cbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSkpICE9IG51bGwgJiYgYiA+PSBiKSB7IGEgPSBiOyBicmVhazsgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBwYWlycyhhcnJheSkge1xuICAgIHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aCAtIDEsIHAgPSBhcnJheVswXSwgcGFpcnMgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gICAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IFtwLCBwID0gYXJyYXlbKytpXV07XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVybXV0ZShhcnJheSwgaW5kZXhlcykge1xuICAgIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gICAgcmV0dXJuIHBlcm11dGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbihhcnJheSwgY29tcGFyZSkge1xuICAgIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgeGksXG4gICAgICAgIHhqID0gYXJyYXlbal07XG5cbiAgICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKGNvbXBhcmUoeGkgPSBhcnJheVtpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHhqID0geGksIGogPSBpO1xuXG4gICAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XG4gIH1cblxuICBmdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBpMCwgaTEpIHtcbiAgICB2YXIgbSA9IChpMSA9PSBudWxsID8gYXJyYXkubGVuZ3RoIDogaTEpIC0gKGkwID0gaTAgPT0gbnVsbCA/IDAgOiAraTApLFxuICAgICAgICB0LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICAgIHQgPSBhcnJheVttICsgaTBdO1xuICAgICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgICBhcnJheVtpICsgaTBdID0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzdW0oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGEsXG4gICAgICAgIGkgPSAtMTtcblxuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoYSA9ICthcnJheVtpXSkgcyArPSBhOyAvLyBOb3RlOiB6ZXJvIGFuZCBudWxsIGFyZSBlcXVpdmFsZW50LlxuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChhID0gK2YoYXJyYXlbaV0sIGksIGFycmF5KSkgcyArPSBhO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNwb3NlKG1hdHJpeCkge1xuICAgIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICAgIGZvciAodmFyIGkgPSAtMSwgbSA9IG1pbihtYXRyaXgsIGxlbmd0aCksIHRyYW5zcG9zZSA9IG5ldyBBcnJheShtKTsgKytpIDwgbTspIHtcbiAgICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOykge1xuICAgICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3Bvc2U7XG4gIH1cblxuICBmdW5jdGlvbiBsZW5ndGgoZCkge1xuICAgIHJldHVybiBkLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHppcCgpIHtcbiAgICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XG4gIH1cblxuICBleHBvcnRzLmJpc2VjdCA9IGJpc2VjdFJpZ2h0O1xuICBleHBvcnRzLmJpc2VjdFJpZ2h0ID0gYmlzZWN0UmlnaHQ7XG4gIGV4cG9ydHMuYmlzZWN0TGVmdCA9IGJpc2VjdExlZnQ7XG4gIGV4cG9ydHMuYXNjZW5kaW5nID0gYXNjZW5kaW5nO1xuICBleHBvcnRzLmJpc2VjdG9yID0gYmlzZWN0b3I7XG4gIGV4cG9ydHMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG4gIGV4cG9ydHMuZGV2aWF0aW9uID0gZGV2aWF0aW9uO1xuICBleHBvcnRzLmV4dGVudCA9IGV4dGVudDtcbiAgZXhwb3J0cy5oaXN0b2dyYW0gPSBoaXN0b2dyYW07XG4gIGV4cG9ydHMudGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcyA9IGZyZWVkbWFuRGlhY29uaXM7XG4gIGV4cG9ydHMudGhyZXNob2xkU2NvdHQgPSBzY290dDtcbiAgZXhwb3J0cy50aHJlc2hvbGRTdHVyZ2VzID0gc3R1cmdlcztcbiAgZXhwb3J0cy5tYXggPSBtYXg7XG4gIGV4cG9ydHMubWVhbiA9IG1lYW47XG4gIGV4cG9ydHMubWVkaWFuID0gbWVkaWFuO1xuICBleHBvcnRzLm1lcmdlID0gbWVyZ2U7XG4gIGV4cG9ydHMubWluID0gbWluO1xuICBleHBvcnRzLnBhaXJzID0gcGFpcnM7XG4gIGV4cG9ydHMucGVybXV0ZSA9IHBlcm11dGU7XG4gIGV4cG9ydHMucXVhbnRpbGUgPSBxdWFudGlsZTtcbiAgZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuICBleHBvcnRzLnNjYW4gPSBzY2FuO1xuICBleHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuICBleHBvcnRzLnN1bSA9IHN1bTtcbiAgZXhwb3J0cy50aWNrcyA9IHRpY2tzO1xuICBleHBvcnRzLnRpY2tTdGVwID0gdGlja1N0ZXA7XG4gIGV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuICBleHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gIGV4cG9ydHMuemlwID0gemlwO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTsiLCIvLyBodHRwczovL2QzanMub3JnL2QzLWRpc3BhdGNoLyBWZXJzaW9uIDEuMC4xLiBDb3B5cmlnaHQgMjAxNiBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbm9vcCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7fX07XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgICAgX1t0XSA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xuICB9XG5cbiAgZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICAgIHRoaXMuXyA9IF87XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gICAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgICB9KTtcbiAgfVxuXG4gIERpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gICAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgICAgdCxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICAgIH0sXG4gICAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGV4cG9ydHMuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1mb3JtYXQvIFZlcnNpb24gMS4wLjIuIENvcHlyaWdodCAyMDE2IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbiAgLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4gIC8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuICBmdW5jdGlvbiBmb3JtYXREZWNpbWFsKHgsIHApIHtcbiAgICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gICAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAgIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gICAgcmV0dXJuIFtcbiAgICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgICAreC5zbGljZShpICsgMSlcbiAgICBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwb25lbnQoeCkge1xuICAgIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbChNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIHQgPSBbXSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0KHgsIHApIHtcbiAgICB4ID0geC50b1ByZWNpc2lvbihwKTtcblxuICAgIG91dDogZm9yICh2YXIgbiA9IHgubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN3aXRjaCAoeFtpXSkge1xuICAgICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZVwiOiBicmVhayBvdXQ7XG4gICAgICAgIGRlZmF1bHQ6IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGkwID4gMCA/IHguc2xpY2UoMCwgaTApICsgeC5zbGljZShpMSArIDEpIDogeDtcbiAgfVxuXG4gIHZhciBwcmVmaXhFeHBvbmVudDtcblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXhBdXRvKHgsIHApIHtcbiAgICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gICAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gICAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWwoeCwgTWF0aC5tYXgoMCwgcCArIGkgLSAxKSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdW5kZWQoeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV07XG4gICAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbiAgfVxuXG4gIHZhciBmb3JtYXRUeXBlcyA9IHtcbiAgICBcIlwiOiBmb3JtYXREZWZhdWx0LFxuICAgIFwiJVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiAoeCAqIDEwMCkudG9GaXhlZChwKTsgfSxcbiAgICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgICBcImNcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4geCArIFwiXCI7IH0sXG4gICAgXCJkXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTApOyB9LFxuICAgIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gICAgXCJmXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9GaXhlZChwKTsgfSxcbiAgICBcImdcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b1ByZWNpc2lvbihwKTsgfSxcbiAgICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgICBcInBcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKTsgfSxcbiAgICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgICBcIlhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfSxcbiAgICBcInhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNik7IH1cbiAgfTtcblxuICAvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW3R5cGVdXG4gIHZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC1cXCggXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC5cXGQrKT8oW2EteiVdKT8kL2k7XG5cbiAgZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG4gIH1cblxuICBmdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuXG4gICAgdmFyIG1hdGNoLFxuICAgICAgICBmaWxsID0gbWF0Y2hbMV0gfHwgXCIgXCIsXG4gICAgICAgIGFsaWduID0gbWF0Y2hbMl0gfHwgXCI+XCIsXG4gICAgICAgIHNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIixcbiAgICAgICAgc3ltYm9sID0gbWF0Y2hbNF0gfHwgXCJcIixcbiAgICAgICAgemVybyA9ICEhbWF0Y2hbNV0sXG4gICAgICAgIHdpZHRoID0gbWF0Y2hbNl0gJiYgK21hdGNoWzZdLFxuICAgICAgICBjb21tYSA9ICEhbWF0Y2hbN10sXG4gICAgICAgIHByZWNpc2lvbiA9IG1hdGNoWzhdICYmICttYXRjaFs4XS5zbGljZSgxKSxcbiAgICAgICAgdHlwZSA9IG1hdGNoWzldIHx8IFwiXCI7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBNYXAgaW52YWxpZCB0eXBlcyB0byB0aGUgZGVmYXVsdCBmb3JtYXQuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSB0eXBlID0gXCJcIjtcblxuICAgIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xuXG4gICAgdGhpcy5maWxsID0gZmlsbDtcbiAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgdGhpcy5zaWduID0gc2lnbjtcbiAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICB0aGlzLnplcm8gPSB6ZXJvO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmNvbW1hID0gY29tbWE7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIEZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXG4gICAgICAgICsgdGhpcy5hbGlnblxuICAgICAgICArIHRoaXMuc2lnblxuICAgICAgICArIHRoaXMuc3ltYm9sXG4gICAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICAgKyAodGhpcy53aWR0aCA9PSBudWxsID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT0gbnVsbCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICAgICsgdGhpcy50eXBlO1xuICB9O1xuXG4gIHZhciBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICAgIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyAmJiBsb2NhbGUudGhvdXNhbmRzID8gZm9ybWF0R3JvdXAobG9jYWxlLmdyb3VwaW5nLCBsb2NhbGUudGhvdXNhbmRzKSA6IGlkZW50aXR5LFxuICAgICAgICBjdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSxcbiAgICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsO1xuXG4gICAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllcikge1xuICAgICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVswXSA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMV0gOiAvWyVwXS8udGVzdCh0eXBlKSA/IFwiJVwiIDogXCJcIjtcblxuICAgICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgICAgbWF5YmVTdWZmaXggPSAhdHlwZSB8fCAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gKHR5cGUgPyA2IDogMTIpXG4gICAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgbmVnYXRpdmUgdG8gcG9zaXRpdmUsIGFuZCBjb21wdXRlIHRoZSBwcmVmaXguXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9ICh2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMCkgJiYgKHZhbHVlICo9IC0xLCB0cnVlKTtcblxuICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgICB2YWx1ZSA9IGZvcm1hdFR5cGUodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgdmFsdWUgd2FzIG5lZ2F0aXZlLCBpdCBtYXkgYmUgcm91bmRlZCB0byB6ZXJvIGR1cmluZ1xuICAgICAgICAgIC8vIGZvcm1hdHRpbmc7IHRyZWF0IHRoaXMgYXMgKHBvc2l0aXZlKSB6ZXJvLlxuICAgICAgICAgIGlmICh2YWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksICg0OCA8IGMgJiYgYyA8IDU4KVxuICAgICAgICAgICAgICAgICAgfHwgKHR5cGUgPT09IFwieFwiICYmIDk2IDwgYyAmJiBjIDwgMTAzKVxuICAgICAgICAgICAgICAgICAgfHwgKHR5cGUgPT09IFwiWFwiICYmIDY0IDwgYyAmJiBjIDwgNzEpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XG4gICAgICAgICAgdmFsdWVTdWZmaXggPSB2YWx1ZVN1ZmZpeCArICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nO1xuICAgICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIGNhc2UgXCJeXCI6IHJldHVybiBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgfVxuXG4gICAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgICBrID0gTWF0aC5wb3coMTAsIC1lKSxcbiAgICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmKGsgKiB2YWx1ZSkgKyBwcmVmaXg7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6IG5ld0Zvcm1hdCxcbiAgICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gICAgfTtcbiAgfVxuXG4gIHZhciBsb2NhbGU7XG4gIGRlZmF1bHRMb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gICAgZXhwb3J0cy5mb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICAgIGV4cG9ydHMuZm9ybWF0UHJlZml4ID0gbG9jYWxlLmZvcm1hdFByZWZpeDtcbiAgICByZXR1cm4gbG9jYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uRml4ZWQoc3RlcCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25Sb3VuZChzdGVwLCBtYXgpIHtcbiAgICBzdGVwID0gTWF0aC5hYnMoc3RlcCksIG1heCA9IE1hdGguYWJzKG1heCkgLSBzdGVwO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChtYXgpIC0gZXhwb25lbnQoc3RlcCkpICsgMTtcbiAgfVxuXG4gIGV4cG9ydHMuZm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gIGV4cG9ydHMuZm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xuICBleHBvcnRzLmZvcm1hdFNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcjtcbiAgZXhwb3J0cy5wcmVjaXNpb25GaXhlZCA9IHByZWNpc2lvbkZpeGVkO1xuICBleHBvcnRzLnByZWNpc2lvblByZWZpeCA9IHByZWNpc2lvblByZWZpeDtcbiAgZXhwb3J0cy5wcmVjaXNpb25Sb3VuZCA9IHByZWNpc2lvblJvdW5kO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTsiLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNjYWxlLyBWZXJzaW9uIDEuMC4zLiBDb3B5cmlnaHQgMjAxNiBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWFycmF5JyksIHJlcXVpcmUoJ2QzLWNvbGxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKSwgcmVxdWlyZSgnZDMtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLXRpbWUnKSwgcmVxdWlyZSgnZDMtdGltZS1mb3JtYXQnKSwgcmVxdWlyZSgnZDMtY29sb3InKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWFycmF5JywgJ2QzLWNvbGxlY3Rpb24nLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtZm9ybWF0JywgJ2QzLXRpbWUnLCAnZDMtdGltZS1mb3JtYXQnLCAnZDMtY29sb3InXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsZDNBcnJheSxkM0NvbGxlY3Rpb24sZDNJbnRlcnBvbGF0ZSxkM0Zvcm1hdCxkM1RpbWUsZDNUaW1lRm9ybWF0LGQzQ29sb3IpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgbWFwJDEgPSBhcnJheS5tYXA7XG4gIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuXG4gIHZhciBpbXBsaWNpdCA9IHtuYW1lOiBcImltcGxpY2l0XCJ9O1xuXG4gIGZ1bmN0aW9uIG9yZGluYWwocmFuZ2UpIHtcbiAgICB2YXIgaW5kZXggPSBkM0NvbGxlY3Rpb24ubWFwKCksXG4gICAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgICByYW5nZSA9IHJhbmdlID09IG51bGwgPyBbXSA6IHNsaWNlLmNhbGwocmFuZ2UpO1xuXG4gICAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgICBpZiAoIWkpIHtcbiAgICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZVsoaSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgICB9XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IGQzQ29sbGVjdGlvbi5tYXAoKTtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBfLmxlbmd0aCwgZCwga2V5O1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghaW5kZXguaGFzKGtleSA9IChkID0gX1tpXSkgKyBcIlwiKSkgaW5kZXguc2V0KGtleSwgZG9tYWluLnB1c2goZCkpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gb3JkaW5hbCgpXG4gICAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAgIC51bmtub3duKHVua25vd24pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBiYW5kKCkge1xuICAgIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgICAgb3JkaW5hbFJhbmdlID0gc2NhbGUucmFuZ2UsXG4gICAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgICBzdGVwLFxuICAgICAgICBiYW5kd2lkdGgsXG4gICAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICAgIHBhZGRpbmdPdXRlciA9IDAsXG4gICAgICAgIGFsaWduID0gMC41O1xuXG4gICAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgICAgcmV2ZXJzZSA9IHJhbmdlWzFdIDwgcmFuZ2VbMF0sXG4gICAgICAgICAgc3RhcnQgPSByYW5nZVtyZXZlcnNlIC0gMF0sXG4gICAgICAgICAgc3RvcCA9IHJhbmdlWzEgLSByZXZlcnNlXTtcbiAgICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICAgIGlmIChyb3VuZCkgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgICBpZiAocm91bmQpIHN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCksIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBkM0FycmF5LnJhbmdlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICAgIHJldHVybiBvcmRpbmFsUmFuZ2UocmV2ZXJzZSA/IHZhbHVlcy5yZXZlcnNlKCkgOiB2YWx1ZXMpO1xuICAgIH1cblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gWytfWzBdLCArX1sxXV0sIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIHJhbmdlID0gWytfWzBdLCArX1sxXV0sIHJvdW5kID0gdHJ1ZSwgcmVzY2FsZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBiYW5kd2lkdGg7XG4gICAgfTtcblxuICAgIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH07XG5cbiAgICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISFfLCByZXNjYWxlKCkpIDogcm91bmQ7XG4gICAgfTtcblxuICAgIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gICAgfTtcblxuICAgIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgICB9O1xuXG4gICAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICAgIH07XG5cbiAgICBzY2FsZS5hbGlnbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBiYW5kKClcbiAgICAgICAgICAuZG9tYWluKGRvbWFpbigpKVxuICAgICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgICAgLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpXG4gICAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gICAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gICAgc2NhbGUucGFkZGluZyA9IHNjYWxlLnBhZGRpbmdPdXRlcjtcbiAgICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICAgIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQoKSB7XG4gICAgcmV0dXJuIHBvaW50aXNoKGJhbmQoKS5wYWRkaW5nSW5uZXIoMSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBudW1iZXIoeCkge1xuICAgIHJldHVybiAreDtcbiAgfVxuXG4gIHZhciB1bml0ID0gWzAsIDFdO1xuXG4gIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAoeCAtIGEpIC8gYjsgfVxuICAgICAgICA6IGNvbnN0YW50KGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZUNsYW1wKGRlaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIGQgPSBkZWludGVycG9sYXRlKGEgPSArYSwgYiA9ICtiKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiB4IDw9IGEgPyAwIDogeCA+PSBiID8gMSA6IGQoeCk7IH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlaW50ZXJwb2xhdGVDbGFtcChyZWludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciByID0gcmVpbnRlcnBvbGF0ZShhID0gK2EsIGIgPSArYik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gdCA8PSAwID8gYSA6IHQgPj0gMSA/IGIgOiByKHQpOyB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gICAgdmFyIGQwID0gZG9tYWluWzBdLCBkMSA9IGRvbWFpblsxXSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXTtcbiAgICBpZiAoZDEgPCBkMCkgZDAgPSBkZWludGVycG9sYXRlKGQxLCBkMCksIHIwID0gcmVpbnRlcnBvbGF0ZShyMSwgcjApO1xuICAgIGVsc2UgZDAgPSBkZWludGVycG9sYXRlKGQwLCBkMSksIHIwID0gcmVpbnRlcnBvbGF0ZShyMCwgcjEpO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiByMChkMCh4KSk7IH07XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5bWFwKGRvbWFpbiwgcmFuZ2UsIGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpIHtcbiAgICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgICByID0gbmV3IEFycmF5KGopLFxuICAgICAgICBpID0gLTE7XG5cbiAgICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XG4gICAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgICBkW2ldID0gZGVpbnRlcnBvbGF0ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgICAgcltpXSA9IHJlaW50ZXJwb2xhdGUocmFuZ2VbaV0sIHJhbmdlW2kgKyAxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBpID0gZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgICByZXR1cm4gcltpXShkW2ldKHgpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAgIC5yYW5nZShzb3VyY2UucmFuZ2UoKSlcbiAgICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpO1xuICB9XG5cbiAgLy8gZGVpbnRlcnBvbGF0ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuICAvLyByZWludGVycG9sYXRlKGEsIGIpKHQpIHRha2VzIGEgcGFyYW1ldGVyIHQgaW4gWzAsMV0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0uXG4gIGZ1bmN0aW9uIGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSQkLCByZWludGVycG9sYXRlKSB7XG4gICAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICAgIHJhbmdlID0gdW5pdCxcbiAgICAgICAgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlLFxuICAgICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgICBwaWVjZXdpc2UsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgaW5wdXQ7XG5cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgcGllY2V3aXNlID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSA+IDIgPyBwb2x5bWFwIDogYmltYXA7XG4gICAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4sIHJhbmdlLCBjbGFtcCA/IGRlaW50ZXJwb2xhdGVDbGFtcChkZWludGVycG9sYXRlJCQpIDogZGVpbnRlcnBvbGF0ZSQkLCBpbnRlcnBvbGF0ZSkpKSgreCk7XG4gICAgfVxuXG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIChpbnB1dCB8fCAoaW5wdXQgPSBwaWVjZXdpc2UocmFuZ2UsIGRvbWFpbiwgZGVpbnRlcnBvbGF0ZSwgY2xhbXAgPyByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkgOiByZWludGVycG9sYXRlKSkpKCt5KTtcbiAgICB9O1xuXG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwJDEuY2FsbChfLCBudW1iZXIpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiByYW5nZSA9IHNsaWNlLmNhbGwoXyksIGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJvdW5kLCByZXNjYWxlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHJlc2NhbGUoKSkgOiBjbGFtcDtcbiAgICB9O1xuXG4gICAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHJlc2NhbGUoKSkgOiBpbnRlcnBvbGF0ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tGb3JtYXQoZG9tYWluLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgdmFyIHN0YXJ0ID0gZG9tYWluWzBdLFxuICAgICAgICBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXSxcbiAgICAgICAgc3RlcCA9IGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KSxcbiAgICAgICAgcHJlY2lzaW9uO1xuICAgIHNwZWNpZmllciA9IGQzRm9ybWF0LmZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XG4gICAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgICAgY2FzZSBcInNcIjoge1xuICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICAgIHJldHVybiBkM0Zvcm1hdC5mb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjYXNlIFwiXCI6XG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgY2FzZSBcImdcIjpcbiAgICAgIGNhc2UgXCJwXCI6XG4gICAgICBjYXNlIFwiclwiOiB7XG4gICAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IGQzRm9ybWF0LnByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZlwiOlxuICAgICAgY2FzZSBcIiVcIjoge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNGb3JtYXQuZm9ybWF0KHNwZWNpZmllcik7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lYXJpc2goc2NhbGUpIHtcbiAgICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICAgIHJldHVybiBkM0FycmF5LnRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpO1xuICAgIH07XG5cbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgICAgcmV0dXJuIHRpY2tGb3JtYXQoZG9tYWluKCksIGNvdW50LCBzcGVjaWZpZXIpO1xuICAgIH07XG5cbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgICAgaSA9IGQubGVuZ3RoIC0gMSxcbiAgICAgICAgICBuID0gY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQsXG4gICAgICAgICAgc3RhcnQgPSBkWzBdLFxuICAgICAgICAgIHN0b3AgPSBkW2ldLFxuICAgICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBuKTtcblxuICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgc3RlcCA9IGQzQXJyYXkudGlja1N0ZXAoTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcCwgTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXAsIG4pO1xuICAgICAgICBkWzBdID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgZFtpXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgICBkb21haW4oZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZWFyKCkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZU51bWJlcik7XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KCkge1xuICAgIHZhciBkb21haW4gPSBbMCwgMV07XG5cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gK3g7XG4gICAgfVxuXG4gICAgc2NhbGUuaW52ZXJ0ID0gc2NhbGU7XG5cbiAgICBzY2FsZS5kb21haW4gPSBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcCQxLmNhbGwoXywgbnVtYmVyKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpZGVudGl0eSgpLmRvbWFpbihkb21haW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5pY2UoZG9tYWluLCBpbnRlcnZhbCkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuXG4gICAgdmFyIGkwID0gMCxcbiAgICAgICAgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSxcbiAgICAgICAgeDAgPSBkb21haW5baTBdLFxuICAgICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICAgIHQ7XG5cbiAgICBpZiAoeDEgPCB4MCkge1xuICAgICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgICB9XG5cbiAgICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICAgIGRvbWFpbltpMV0gPSBpbnRlcnZhbC5jZWlsKHgxKTtcbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZSQxKGEsIGIpIHtcbiAgICByZXR1cm4gKGIgPSBNYXRoLmxvZyhiIC8gYSkpXG4gICAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCAvIGEpIC8gYjsgfVxuICAgICAgICA6IGNvbnN0YW50KGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCAwXG4gICAgICAgID8gZnVuY3Rpb24odCkgeyByZXR1cm4gLU1hdGgucG93KC1iLCB0KSAqIE1hdGgucG93KC1hLCAxIC0gdCk7IH1cbiAgICAgICAgOiBmdW5jdGlvbih0KSB7IHJldHVybiBNYXRoLnBvdyhiLCB0KSAqIE1hdGgucG93KGEsIDEgLSB0KTsgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgICByZXR1cm4gaXNGaW5pdGUoeCkgPyArKFwiMWVcIiArIHgpIDogeCA8IDAgPyAwIDogeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICAgIHJldHVybiBiYXNlID09PSAxMCA/IHBvdzEwXG4gICAgICAgIDogYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5leHBcbiAgICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ3AoYmFzZSkge1xuICAgIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcbiAgICAgICAgfHwgYmFzZSA9PT0gMiAmJiBNYXRoLmxvZzJcbiAgICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZmxlY3QoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gLWYoLXgpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2coKSB7XG4gICAgdmFyIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlJDEsIHJlaW50ZXJwb2xhdGUpLmRvbWFpbihbMSwgMTBdKSxcbiAgICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgICBiYXNlID0gMTAsXG4gICAgICAgIGxvZ3MgPSBsb2dwKDEwKSxcbiAgICAgICAgcG93cyA9IHBvd3AoMTApO1xuXG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICAgIGlmIChkb21haW4oKVswXSA8IDApIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG5cbiAgICBzY2FsZS5iYXNlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYmFzZSA9ICtfLCByZXNjYWxlKCkpIDogYmFzZTtcbiAgICB9O1xuXG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgICAgdiA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICByO1xuXG4gICAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgICB2YXIgaSA9IGxvZ3ModSksXG4gICAgICAgICAgaiA9IGxvZ3ModiksXG4gICAgICAgICAgcCxcbiAgICAgICAgICBrLFxuICAgICAgICAgIHQsXG4gICAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgICB6ID0gW107XG5cbiAgICAgIGlmICghKGJhc2UgJSAxKSAmJiBqIC0gaSA8IG4pIHtcbiAgICAgICAgaSA9IE1hdGgucm91bmQoaSkgLSAxLCBqID0gTWF0aC5yb3VuZChqKSArIDE7XG4gICAgICAgIGlmICh1ID4gMCkgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMSwgcCA9IHBvd3MoaSk7IGsgPj0gMTsgLS1rKSB7XG4gICAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHogPSBkM0FycmF5LnRpY2tzKGksIGosIE1hdGgubWluKGogLSBpLCBuKSkubWFwKHBvd3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgICB9O1xuXG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgICBpZiAodHlwZW9mIHNwZWNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXQoc3BlY2lmaWVyKTtcbiAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBzcGVjaWZpZXI7XG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICAgIHZhciBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIGNvdW50IC8gc2NhbGUudGlja3MoKS5sZW5ndGgpOyAvLyBUT0RPIGZhc3QgZXN0aW1hdGU/XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gMC41KSBpICo9IGJhc2U7XG4gICAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguZmxvb3IobG9ncyh4KSkpOyB9LFxuICAgICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxvZygpLmJhc2UoYmFzZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiByYWlzZSh4LCBleHBvbmVudCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG93KCkge1xuICAgIHZhciBleHBvbmVudCA9IDEsXG4gICAgICAgIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSxcbiAgICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gICAgZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgICByZXR1cm4gKGIgPSByYWlzZShiLCBleHBvbmVudCkgLSAoYSA9IHJhaXNlKGEsIGV4cG9uZW50KSkpXG4gICAgICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAocmFpc2UoeCwgZXhwb25lbnQpIC0gYSkgLyBiOyB9XG4gICAgICAgICAgOiBjb25zdGFudChiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWludGVycG9sYXRlKGEsIGIpIHtcbiAgICAgIGIgPSByYWlzZShiLCBleHBvbmVudCkgLSAoYSA9IHJhaXNlKGEsIGV4cG9uZW50KSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gcmFpc2UoYSArIGIgKiB0LCAxIC8gZXhwb25lbnQpOyB9O1xuICAgIH1cblxuICAgIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXhwb25lbnQgPSArXywgZG9tYWluKGRvbWFpbigpKSkgOiBleHBvbmVudDtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvcHkoc2NhbGUsIHBvdygpLmV4cG9uZW50KGV4cG9uZW50KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3FydCgpIHtcbiAgICByZXR1cm4gcG93KCkuZXhwb25lbnQoMC41KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50aWxlJDEoKSB7XG4gICAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgICByYW5nZSA9IFtdLFxuICAgICAgICB0aHJlc2hvbGRzID0gW107XG5cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIGkgPSAwLCBuID0gTWF0aC5tYXgoMSwgcmFuZ2UubGVuZ3RoKTtcbiAgICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gZDNBcnJheS5xdWFudGlsZShkb21haW4sIGkgLyBuKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoIWlzTmFOKHggPSAreCkpIHJldHVybiByYW5nZVtkM0FycmF5LmJpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gICAgfVxuXG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgICAgaSA+IDAgPyB0aHJlc2hvbGRzW2kgLSAxXSA6IGRvbWFpblswXSxcbiAgICAgICAgaSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1tpXSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV1cbiAgICAgIF07XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgICAgZG9tYWluID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IF8ubGVuZ3RoLCBkOyBpIDwgbjsgKytpKSBpZiAoZCA9IF9baV0sIGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgICBkb21haW4uc29ydChkM0FycmF5LmFzY2VuZGluZyk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1YW50aWxlJDEoKVxuICAgICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAgIC5yYW5nZShyYW5nZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50aXplKCkge1xuICAgIHZhciB4MCA9IDAsXG4gICAgICAgIHgxID0gMSxcbiAgICAgICAgbiA9IDEsXG4gICAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgICByYW5nZSA9IFswLCAxXTtcblxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIGlmICh4IDw9IHgpIHJldHVybiByYW5nZVtkM0FycmF5LmJpc2VjdChkb21haW4sIHgsIDAsIG4pXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkb21haW5baV0gPSAoKGkgKyAxKSAqIHgxIC0gKGkgLSBuKSAqIHgwKSAvIChuICsgMSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuXG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZS5jYWxsKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICAgIDogaSA8IDEgPyBbeDAsIGRvbWFpblswXV1cbiAgICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgICAgLnJhbmdlKHJhbmdlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gICAgdmFyIGRvbWFpbiA9IFswLjVdLFxuICAgICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgICAgbiA9IDE7XG5cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoeCA8PSB4KSByZXR1cm4gcmFuZ2VbZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAwLCBuKV07XG4gICAgfVxuXG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICAgIH07XG5cbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhyZXNob2xkKClcbiAgICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgICAucmFuZ2UocmFuZ2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICB2YXIgZHVyYXRpb25TZWNvbmQgPSAxMDAwO1xuICB2YXIgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwO1xuICB2YXIgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MDtcbiAgdmFyIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG4gIHZhciBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDc7XG4gIHZhciBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMDtcbiAgdmFyIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuICBmdW5jdGlvbiBkYXRlKHQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodCk7XG4gIH1cblxuICBmdW5jdGlvbiBudW1iZXIkMSh0KSB7XG4gICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpIHtcbiAgICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXIpLFxuICAgICAgICBpbnZlcnQgPSBzY2FsZS5pbnZlcnQsXG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICAgIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgICAgZm9ybWF0U2Vjb25kID0gZm9ybWF0KFwiOiVTXCIpLFxuICAgICAgICBmb3JtYXRNaW51dGUgPSBmb3JtYXQoXCIlSTolTVwiKSxcbiAgICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgICBmb3JtYXREYXkgPSBmb3JtYXQoXCIlYSAlZFwiKSxcbiAgICAgICAgZm9ybWF0V2VlayA9IGZvcm1hdChcIiViICVkXCIpLFxuICAgICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgICBmb3JtYXRZZWFyID0gZm9ybWF0KFwiJVlcIik7XG5cbiAgICB2YXIgdGlja0ludGVydmFscyA9IFtcbiAgICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICAgIFtzZWNvbmQsICA1LCAgNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICAgIFttaW51dGUsICAxLCAgICAgIGR1cmF0aW9uTWludXRlXSxcbiAgICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICAgIFttaW51dGUsIDMwLCAzMCAqIGR1cmF0aW9uTWludXRlXSxcbiAgICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICAgIFsgIGhvdXIsICA2LCAgNiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICAgIFsgICBkYXksICAyLCAgMiAqIGR1cmF0aW9uRGF5ICAgXSxcbiAgICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICAgIFsgbW9udGgsICAzLCAgMyAqIGR1cmF0aW9uTW9udGggXSxcbiAgICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICAgIF07XG5cbiAgICBmdW5jdGlvbiB0aWNrRm9ybWF0KGRhdGUpIHtcbiAgICAgIHJldHVybiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbGxpc2Vjb25kXG4gICAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgICAgOiBob3VyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbnV0ZVxuICAgICAgICAgIDogZGF5KGRhdGUpIDwgZGF0ZSA/IGZvcm1hdEhvdXJcbiAgICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgICAgOiB5ZWFyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1vbnRoXG4gICAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCkgaW50ZXJ2YWwgPSAxMDtcblxuICAgICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgICAvLyBiYXNlZCBvbiB0aGUgZXh0ZW50IG9mIHRoZSBkb21haW4gYW5kIGEgcm91Z2ggZXN0aW1hdGUgb2YgdGljayBzaXplLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaW50ZXJ2YWwgaXMgYWxyZWFkeSBhIHRpbWUgaW50ZXJ2YWwgYW5kIHVzZSBpdC5cbiAgICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBpbnRlcnZhbCxcbiAgICAgICAgICAgIGkgPSBkM0FycmF5LmJpc2VjdG9yKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGlbMl07IH0pLnJpZ2h0KHRpY2tJbnRlcnZhbHMsIHRhcmdldCk7XG4gICAgICAgIGlmIChpID09PSB0aWNrSW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XG4gICAgICAgICAgaW50ZXJ2YWwgPSB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGkpIHtcbiAgICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgICAgICAgIHN0ZXAgPSBpWzFdO1xuICAgICAgICAgIGludGVydmFsID0gaVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCwgc3RvcCwgaW50ZXJ2YWwpO1xuICAgICAgICAgIGludGVydmFsID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAgPT0gbnVsbCA/IGludGVydmFsIDogaW50ZXJ2YWwuZXZlcnkoc3RlcCk7XG4gICAgfVxuXG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGludmVydCh5KSk7XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZG9tYWluKG1hcCQxLmNhbGwoXywgbnVtYmVyJDEpKSA6IGRvbWFpbigpLm1hcChkYXRlKTtcbiAgICB9O1xuXG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgICB0MCA9IGRbMF0sXG4gICAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgciA9IHQxIDwgdDAsXG4gICAgICAgICAgdDtcbiAgICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICAgIHQgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHQwLCB0MSwgc3RlcCk7XG4gICAgICB0ID0gdCA/IHQucmFuZ2UodDAsIHQxICsgMSkgOiBbXTsgLy8gaW5jbHVzaXZlIHN0b3BcbiAgICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICAgIH07XG5cbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICAgIH07XG5cbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgICByZXR1cm4gKGludGVydmFsID0gdGlja0ludGVydmFsKGludGVydmFsLCBkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIHN0ZXApKVxuICAgICAgICAgID8gZG9tYWluKG5pY2UoZCwgaW50ZXJ2YWwpKVxuICAgICAgICAgIDogc2NhbGU7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lKCkge1xuICAgIHJldHVybiBjYWxlbmRhcihkM1RpbWUudGltZVllYXIsIGQzVGltZS50aW1lTW9udGgsIGQzVGltZS50aW1lV2VlaywgZDNUaW1lLnRpbWVEYXksIGQzVGltZS50aW1lSG91ciwgZDNUaW1lLnRpbWVNaW51dGUsIGQzVGltZS50aW1lU2Vjb25kLCBkM1RpbWUudGltZU1pbGxpc2Vjb25kLCBkM1RpbWVGb3JtYXQudGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0Y1RpbWUoKSB7XG4gICAgcmV0dXJuIGNhbGVuZGFyKGQzVGltZS51dGNZZWFyLCBkM1RpbWUudXRjTW9udGgsIGQzVGltZS51dGNXZWVrLCBkM1RpbWUudXRjRGF5LCBkM1RpbWUudXRjSG91ciwgZDNUaW1lLnV0Y01pbnV0ZSwgZDNUaW1lLnV0Y1NlY29uZCwgZDNUaW1lLnV0Y01pbGxpc2Vjb25kLCBkM1RpbWVGb3JtYXQudXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sb3JzKHMpIHtcbiAgICByZXR1cm4gcy5tYXRjaCgvLns2fS9nKS5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFwiI1wiICsgeDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBjYXRlZ29yeTEwID0gY29sb3JzKFwiMWY3N2I0ZmY3ZjBlMmNhMDJjZDYyNzI4OTQ2N2JkOGM1NjRiZTM3N2MyN2Y3ZjdmYmNiZDIyMTdiZWNmXCIpO1xuXG4gIHZhciBjYXRlZ29yeTIwYiA9IGNvbG9ycyhcIjM5M2I3OTUyNTRhMzZiNmVjZjljOWVkZTYzNzkzOThjYTI1MmI1Y2Y2YmNlZGI5YzhjNmQzMWJkOWUzOWU3YmE1MmU3Y2I5NDg0M2MzOWFkNDk0YWQ2NjE2YmU3OTY5YzdiNDE3M2E1NTE5NGNlNmRiZGRlOWVkNlwiKTtcblxuICB2YXIgY2F0ZWdvcnkyMGMgPSBjb2xvcnMoXCIzMTgyYmQ2YmFlZDY5ZWNhZTFjNmRiZWZlNjU1MGRmZDhkM2NmZGFlNmJmZGQwYTIzMWEzNTQ3NGM0NzZhMWQ5OWJjN2U5YzA3NTZiYjE5ZTlhYzhiY2JkZGNkYWRhZWI2MzYzNjM5Njk2OTZiZGJkYmRkOWQ5ZDlcIik7XG5cbiAgdmFyIGNhdGVnb3J5MjAgPSBjb2xvcnMoXCIxZjc3YjRhZWM3ZThmZjdmMGVmZmJiNzgyY2EwMmM5OGRmOGFkNjI3MjhmZjk4OTY5NDY3YmRjNWIwZDU4YzU2NGJjNDljOTRlMzc3YzJmN2I2ZDI3ZjdmN2ZjN2M3YzdiY2JkMjJkYmRiOGQxN2JlY2Y5ZWRhZTVcIik7XG5cbiAgdmFyIGN1YmVoZWxpeCQxID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoMzAwLCAwLjUsIDAuMCksIGQzQ29sb3IuY3ViZWhlbGl4KC0yNDAsIDAuNSwgMS4wKSk7XG5cbiAgdmFyIHdhcm0gPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyhkM0NvbG9yLmN1YmVoZWxpeCgtMTAwLCAwLjc1LCAwLjM1KSwgZDNDb2xvci5jdWJlaGVsaXgoODAsIDEuNTAsIDAuOCkpO1xuXG4gIHZhciBjb29sID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoMjYwLCAwLjc1LCAwLjM1KSwgZDNDb2xvci5jdWJlaGVsaXgoODAsIDEuNTAsIDAuOCkpO1xuXG4gIHZhciByYWluYm93ID0gZDNDb2xvci5jdWJlaGVsaXgoKTtcblxuICBmdW5jdGlvbiByYWluYm93JDEodCkge1xuICAgIGlmICh0IDwgMCB8fCB0ID4gMSkgdCAtPSBNYXRoLmZsb29yKHQpO1xuICAgIHZhciB0cyA9IE1hdGguYWJzKHQgLSAwLjUpO1xuICAgIHJhaW5ib3cuaCA9IDM2MCAqIHQgLSAxMDA7XG4gICAgcmFpbmJvdy5zID0gMS41IC0gMS41ICogdHM7XG4gICAgcmFpbmJvdy5sID0gMC44IC0gMC45ICogdHM7XG4gICAgcmV0dXJuIHJhaW5ib3cgKyBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFtcChyYW5nZSkge1xuICAgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gcmFuZ2VbTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqIG4pKSldO1xuICAgIH07XG4gIH1cblxuICB2YXIgdmlyaWRpcyA9IHJhbXAoY29sb3JzKFwiNDQwMTU0NDQwMjU2NDUwNDU3NDUwNTU5NDYwNzVhNDYwODVjNDYwYTVkNDYwYjVlNDcwZDYwNDcwZTYxNDcxMDYzNDcxMTY0NDcxMzY1NDgxNDY3NDgxNjY4NDgxNzY5NDgxODZhNDgxYTZjNDgxYjZkNDgxYzZlNDgxZDZmNDgxZjcwNDgyMDcxNDgyMTczNDgyMzc0NDgyNDc1NDgyNTc2NDgyNjc3NDgyODc4NDgyOTc5NDcyYTdhNDcyYzdhNDcyZDdiNDcyZTdjNDcyZjdkNDYzMDdlNDYzMjdlNDYzMzdmNDYzNDgwNDUzNTgxNDUzNzgxNDUzODgyNDQzOTgzNDQzYTgzNDQzYjg0NDMzZDg0NDMzZTg1NDIzZjg1NDI0MDg2NDI0MTg2NDE0Mjg3NDE0NDg3NDA0NTg4NDA0Njg4M2Y0Nzg4M2Y0ODg5M2U0OTg5M2U0YTg5M2U0YzhhM2Q0ZDhhM2Q0ZThhM2M0ZjhhM2M1MDhiM2I1MThiM2I1MjhiM2E1MzhiM2E1NDhjMzk1NThjMzk1NjhjMzg1ODhjMzg1OThjMzc1YThjMzc1YjhkMzY1YzhkMzY1ZDhkMzU1ZThkMzU1ZjhkMzQ2MDhkMzQ2MThkMzM2MjhkMzM2MzhkMzI2NDhlMzI2NThlMzE2NjhlMzE2NzhlMzE2ODhlMzA2OThlMzA2YThlMmY2YjhlMmY2YzhlMmU2ZDhlMmU2ZThlMmU2ZjhlMmQ3MDhlMmQ3MThlMmM3MThlMmM3MjhlMmM3MzhlMmI3NDhlMmI3NThlMmE3NjhlMmE3NzhlMmE3ODhlMjk3OThlMjk3YThlMjk3YjhlMjg3YzhlMjg3ZDhlMjc3ZThlMjc3ZjhlMjc4MDhlMjY4MThlMjY4MjhlMjY4MjhlMjU4MzhlMjU4NDhlMjU4NThlMjQ4NjhlMjQ4NzhlMjM4ODhlMjM4OThlMjM4YThkMjI4YjhkMjI4YzhkMjI4ZDhkMjE4ZThkMjE4ZjhkMjE5MDhkMjE5MThjMjA5MjhjMjA5MjhjMjA5MzhjMWY5NDhjMWY5NThiMWY5NjhiMWY5NzhiMWY5ODhiMWY5OThhMWY5YThhMWU5YjhhMWU5Yzg5MWU5ZDg5MWY5ZTg5MWY5Zjg4MWZhMDg4MWZhMTg4MWZhMTg3MWZhMjg3MjBhMzg2MjBhNDg2MjFhNTg1MjFhNjg1MjJhNzg1MjJhODg0MjNhOTgzMjRhYTgzMjVhYjgyMjVhYzgyMjZhZDgxMjdhZDgxMjhhZTgwMjlhZjdmMmFiMDdmMmNiMTdlMmRiMjdkMmViMzdjMmZiNDdjMzFiNTdiMzJiNjdhMzRiNjc5MzViNzc5MzdiODc4MzhiOTc3M2FiYTc2M2JiYjc1M2RiYzc0M2ZiYzczNDBiZDcyNDJiZTcxNDRiZjcwNDZjMDZmNDhjMTZlNGFjMTZkNGNjMjZjNGVjMzZiNTBjNDZhNTJjNTY5NTRjNTY4NTZjNjY3NThjNzY1NWFjODY0NWNjODYzNWVjOTYyNjBjYTYwNjNjYjVmNjVjYjVlNjdjYzVjNjljZDViNmNjZDVhNmVjZTU4NzBjZjU3NzNkMDU2NzVkMDU0NzdkMTUzN2FkMTUxN2NkMjUwN2ZkMzRlODFkMzRkODRkNDRiODZkNTQ5ODlkNTQ4OGJkNjQ2OGVkNjQ1OTBkNzQzOTNkNzQxOTVkODQwOThkODNlOWJkOTNjOWRkOTNiYTBkYTM5YTJkYTM3YTVkYjM2YThkYjM0YWFkYzMyYWRkYzMwYjBkZDJmYjJkZDJkYjVkZTJiYjhkZTI5YmFkZTI4YmRkZjI2YzBkZjI1YzJkZjIzYzVlMDIxYzhlMDIwY2FlMTFmY2RlMTFkZDBlMTFjZDJlMjFiZDVlMjFhZDhlMjE5ZGFlMzE5ZGRlMzE4ZGZlMzE4ZTJlNDE4ZTVlNDE5ZTdlNDE5ZWFlNTFhZWNlNTFiZWZlNTFjZjFlNTFkZjRlNjFlZjZlNjIwZjhlNjIxZmJlNzIzZmRlNzI1XCIpKTtcblxuICB2YXIgbWFnbWEgPSByYW1wKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwOTAyMDIwYjAyMDIwZDAzMDMwZjAzMDMxMjA0MDQxNDA1MDQxNjA2MDUxODA2MDUxYTA3MDYxYzA4MDcxZTA5MDcyMDBhMDgyMjBiMDkyNDBjMDkyNjBkMGEyOTBlMGIyYjEwMGIyZDExMGMyZjEyMGQzMTEzMGQzNDE0MGUzNjE1MGUzODE2MGYzYjE4MGYzZDE5MTAzZjFhMTA0MjFjMTA0NDFkMTE0NzFlMTE0OTIwMTE0YjIxMTE0ZTIyMTE1MDI0MTI1MzI1MTI1NTI3MTI1ODI5MTE1YTJhMTE1YzJjMTE1ZjJkMTE2MTJmMTE2MzMxMTE2NTMzMTA2NzM0MTA2OTM2MTA2YjM4MTA2YzM5MGY2ZTNiMGY3MDNkMGY3MTNmMGY3MjQwMGY3NDQyMGY3NTQ0MGY3NjQ1MTA3NzQ3MTA3ODQ5MTA3ODRhMTA3OTRjMTE3YTRlMTE3YjRmMTI3YjUxMTI3YzUyMTM3YzU0MTM3ZDU2MTQ3ZDU3MTU3ZTU5MTU3ZTVhMTY3ZTVjMTY3ZjVkMTc3ZjVmMTg3ZjYwMTg4MDYyMTk4MDY0MWE4MDY1MWE4MDY3MWI4MDY4MWM4MTZhMWM4MTZiMWQ4MTZkMWQ4MTZlMWU4MTcwMWY4MTcyMWY4MTczMjA4MTc1MjE4MTc2MjE4MTc4MjI4MTc5MjI4MjdiMjM4MjdjMjM4MjdlMjQ4MjgwMjU4MjgxMjU4MTgzMjY4MTg0MjY4MTg2Mjc4MTg4Mjc4MTg5Mjg4MThiMjk4MThjMjk4MThlMmE4MTkwMmE4MTkxMmI4MTkzMmI4MDk0MmM4MDk2MmM4MDk4MmQ4MDk5MmQ4MDliMmU3ZjljMmU3ZjllMmY3ZmEwMmY3ZmExMzA3ZWEzMzA3ZWE1MzE3ZWE2MzE3ZGE4MzI3ZGFhMzM3ZGFiMzM3Y2FkMzQ3Y2FlMzQ3YmIwMzU3YmIyMzU3YmIzMzY3YWI1MzY3YWI3Mzc3OWI4Mzc3OWJhMzg3OGJjMzk3OGJkMzk3N2JmM2E3N2MwM2E3NmMyM2I3NWM0M2M3NWM1M2M3NGM3M2Q3M2M4M2U3M2NhM2U3MmNjM2Y3MWNkNDA3MWNmNDA3MGQwNDE2ZmQyNDI2ZmQzNDM2ZWQ1NDQ2ZGQ2NDU2Y2Q4NDU2Y2Q5NDY2YmRiNDc2YWRjNDg2OWRlNDk2OGRmNGE2OGUwNGM2N2UyNGQ2NmUzNGU2NWU0NGY2NGU1NTA2NGU3NTI2M2U4NTM2MmU5NTQ2MmVhNTY2MWViNTc2MGVjNTg2MGVkNWE1ZmVlNWI1ZWVmNWQ1ZWYwNWY1ZWYxNjA1ZGYyNjI1ZGYyNjQ1Y2YzNjU1Y2Y0Njc1Y2Y0Njk1Y2Y1NmI1Y2Y2NmM1Y2Y2NmU1Y2Y3NzA1Y2Y3NzI1Y2Y4NzQ1Y2Y4NzY1Y2Y5Nzg1ZGY5Nzk1ZGY5N2I1ZGZhN2Q1ZWZhN2Y1ZWZhODE1ZmZiODM1ZmZiODU2MGZiODc2MWZjODk2MWZjOGE2MmZjOGM2M2ZjOGU2NGZjOTA2NWZkOTI2NmZkOTQ2N2ZkOTY2OGZkOTg2OWZkOWE2YWZkOWI2YmZlOWQ2Y2ZlOWY2ZGZlYTE2ZWZlYTM2ZmZlYTU3MWZlYTc3MmZlYTk3M2ZlYWE3NGZlYWM3NmZlYWU3N2ZlYjA3OGZlYjI3YWZlYjQ3YmZlYjY3Y2ZlYjc3ZWZlYjk3ZmZlYmI4MWZlYmQ4MmZlYmY4NGZlYzE4NWZlYzI4N2ZlYzQ4OGZlYzY4YWZlYzg4Y2ZlY2E4ZGZlY2M4ZmZlY2Q5MGZlY2Y5MmZlZDE5NGZlZDM5NWZlZDU5N2ZlZDc5OWZlZDg5YWZkZGE5Y2ZkZGM5ZWZkZGVhMGZkZTBhMWZkZTJhM2ZkZTNhNWZkZTVhN2ZkZTdhOWZkZTlhYWZkZWJhY2ZjZWNhZWZjZWViMGZjZjBiMmZjZjJiNGZjZjRiNmZjZjZiOGZjZjdiOWZjZjliYmZjZmJiZGZjZmRiZlwiKSk7XG5cbiAgdmFyIGluZmVybm8gPSByYW1wKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwYTAyMDIwYzAyMDIwZTAzMDIxMDA0MDMxMjA0MDMxNDA1MDQxNzA2MDQxOTA3MDUxYjA4MDUxZDA5MDYxZjBhMDcyMjBiMDcyNDBjMDgyNjBkMDgyOTBlMDkyYjEwMDkyZDExMGEzMDEyMGEzMjE0MGIzNDE1MGIzNzE2MGIzOTE4MGMzYzE5MGMzZTFiMGM0MTFjMGM0MzFlMGM0NTFmMGM0ODIxMGM0YTIzMGM0YzI0MGM0ZjI2MGM1MTI4MGI1MzI5MGI1NTJiMGI1NzJkMGI1OTJmMGE1YjMxMGE1YzMyMGE1ZTM0MGE1ZjM2MDk2MTM4MDk2MjM5MDk2MzNiMDk2NDNkMDk2NTNlMDk2NjQwMGE2NzQyMGE2ODQ0MGE2ODQ1MGE2OTQ3MGI2YTQ5MGI2YTRhMGM2YjRjMGM2YjRkMGQ2YzRmMGQ2YzUxMGU2YzUyMGU2ZDU0MGY2ZDU1MGY2ZDU3MTA2ZTU5MTA2ZTVhMTE2ZTVjMTI2ZTVkMTI2ZTVmMTM2ZTYxMTM2ZTYyMTQ2ZTY0MTU2ZTY1MTU2ZTY3MTY2ZTY5MTY2ZTZhMTc2ZTZjMTg2ZTZkMTg2ZTZmMTk2ZTcxMTk2ZTcyMWE2ZTc0MWE2ZTc1MWI2ZTc3MWM2ZDc4MWM2ZDdhMWQ2ZDdjMWQ2ZDdkMWU2ZDdmMWU2YzgwMWY2YzgyMjA2Yzg0MjA2Yjg1MjE2Yjg3MjE2Yjg4MjI2YThhMjI2YThjMjM2OThkMjM2OThmMjQ2OTkwMjU2ODkyMjU2ODkzMjY2Nzk1MjY2Nzk3Mjc2Njk4Mjc2NjlhMjg2NTliMjk2NDlkMjk2NDlmMmE2M2EwMmE2M2EyMmI2MmEzMmM2MWE1MmM2MGE2MmQ2MGE4MmU1ZmE5MmU1ZWFiMmY1ZWFkMzA1ZGFlMzA1Y2IwMzE1YmIxMzI1YWIzMzI1YWI0MzM1OWI2MzQ1OGI3MzU1N2I5MzU1NmJhMzY1NWJjMzc1NGJkMzg1M2JmMzk1MmMwM2E1MWMxM2E1MGMzM2I0ZmM0M2M0ZWM2M2Q0ZGM3M2U0Y2M4M2Y0YmNhNDA0YWNiNDE0OWNjNDI0OGNlNDM0N2NmNDQ0NmQwNDU0NWQyNDY0NGQzNDc0M2Q0NDg0MmQ1NGE0MWQ3NGIzZmQ4NGMzZWQ5NGQzZGRhNGUzY2RiNTAzYmRkNTEzYWRlNTIzOGRmNTMzN2UwNTUzNmUxNTYzNWUyNTczNGUzNTkzM2U0NWEzMWU1NWMzMGU2NWQyZmU3NWUyZWU4NjAyZGU5NjEyYmVhNjMyYWViNjQyOWViNjYyOGVjNjcyNmVkNjkyNWVlNmEyNGVmNmMyM2VmNmUyMWYwNmYyMGYxNzExZmYxNzMxZGYyNzQxY2YzNzYxYmYzNzgxOWY0NzkxOGY1N2IxN2Y1N2QxNWY2N2UxNGY2ODAxM2Y3ODIxMmY3ODQxMGY4ODUwZmY4ODcwZWY4ODkwY2Y5OGIwYmY5OGMwYWY5OGUwOWZhOTAwOGZhOTIwN2ZhOTQwN2ZiOTYwNmZiOTcwNmZiOTkwNmZiOWIwNmZiOWQwN2ZjOWYwN2ZjYTEwOGZjYTMwOWZjYTUwYWZjYTYwY2ZjYTgwZGZjYWEwZmZjYWMxMWZjYWUxMmZjYjAxNGZjYjIxNmZjYjQxOGZiYjYxYWZiYjgxZGZiYmExZmZiYmMyMWZiYmUyM2ZhYzAyNmZhYzIyOGZhYzQyYWZhYzYyZGY5YzcyZmY5YzkzMmY5Y2IzNWY4Y2QzN2Y4Y2YzYWY3ZDEzZGY3ZDM0MGY2ZDU0M2Y2ZDc0NmY1ZDk0OWY1ZGI0Y2Y0ZGQ0ZmY0ZGY1M2Y0ZTE1NmYzZTM1YWYzZTU1ZGYyZTY2MWYyZTg2NWYyZWE2OWYxZWM2ZGYxZWQ3MWYxZWY3NWYxZjE3OWYyZjI3ZGYyZjQ4MmYzZjU4NmYzZjY4YWY0Zjg4ZWY1Zjk5MmY2ZmE5NmY4ZmI5YWY5ZmM5ZGZhZmRhMWZjZmZhNFwiKSk7XG5cbiAgdmFyIHBsYXNtYSA9IHJhbXAoY29sb3JzKFwiMGQwODg3MTAwNzg4MTMwNzg5MTYwNzhhMTkwNjhjMWIwNjhkMWQwNjhlMjAwNjhmMjIwNjkwMjQwNjkxMjYwNTkxMjgwNTkyMmEwNTkzMmMwNTk0MmUwNTk1MmYwNTk2MzEwNTk3MzMwNTk3MzUwNDk4MzcwNDk5MzgwNDlhM2EwNDlhM2MwNDliM2UwNDljM2YwNDljNDEwNDlkNDMwMzllNDQwMzllNDYwMzlmNDgwMzlmNDkwM2EwNGIwM2ExNGMwMmExNGUwMmEyNTAwMmEyNTEwMmEzNTMwMmEzNTUwMmE0NTYwMWE0NTgwMWE0NTkwMWE1NWIwMWE1NWMwMWE2NWUwMWE2NjAwMWE2NjEwMGE3NjMwMGE3NjQwMGE3NjYwMGE3NjcwMGE4NjkwMGE4NmEwMGE4NmMwMGE4NmUwMGE4NmYwMGE4NzEwMGE4NzIwMWE4NzQwMWE4NzUwMWE4NzcwMWE4NzgwMWE4N2EwMmE4N2IwMmE4N2QwM2E4N2UwM2E4ODAwNGE4ODEwNGE3ODMwNWE3ODQwNWE3ODYwNmE2ODcwN2E2ODgwOGE2OGEwOWE1OGIwYWE1OGQwYmE1OGUwY2E0OGYwZGE0OTEwZWEzOTIwZmEzOTQxMGEyOTUxMWExOTYxM2ExOTgxNGEwOTkxNTlmOWExNjlmOWMxNzllOWQxODlkOWUxOTlkYTAxYTljYTExYjliYTIxZDlhYTMxZTlhYTUxZjk5YTYyMDk4YTcyMTk3YTgyMjk2YWEyMzk1YWIyNDk0YWMyNjk0YWQyNzkzYWUyODkyYjAyOTkxYjEyYTkwYjIyYjhmYjMyYzhlYjQyZThkYjUyZjhjYjYzMDhiYjczMThhYjgzMjg5YmEzMzg4YmIzNDg4YmMzNTg3YmQzNzg2YmUzODg1YmYzOTg0YzAzYTgzYzEzYjgyYzIzYzgxYzMzZDgwYzQzZTdmYzU0MDdlYzY0MTdkYzc0MjdjYzg0MzdiYzk0NDdhY2E0NTdhY2I0Njc5Y2M0Nzc4Y2M0OTc3Y2Q0YTc2Y2U0Yjc1Y2Y0Yzc0ZDA0ZDczZDE0ZTcyZDI0ZjcxZDM1MTcxZDQ1MjcwZDU1MzZmZDU1NDZlZDY1NTZkZDc1NjZjZDg1NzZiZDk1ODZhZGE1YTZhZGE1YjY5ZGI1YzY4ZGM1ZDY3ZGQ1ZTY2ZGU1ZjY1ZGU2MTY0ZGY2MjYzZTA2MzYzZTE2NDYyZTI2NTYxZTI2NjYwZTM2ODVmZTQ2OTVlZTU2YTVkZTU2YjVkZTY2YzVjZTc2ZTViZTc2ZjVhZTg3MDU5ZTk3MTU4ZTk3MjU3ZWE3NDU3ZWI3NTU2ZWI3NjU1ZWM3NzU0ZWQ3OTUzZWQ3YTUyZWU3YjUxZWY3YzUxZWY3ZTUwZjA3ZjRmZjA4MDRlZjE4MTRkZjE4MzRjZjI4NDRiZjM4NTRiZjM4NzRhZjQ4ODQ5ZjQ4OTQ4ZjU4YjQ3ZjU4YzQ2ZjY4ZDQ1ZjY4ZjQ0Zjc5MDQ0Zjc5MTQzZjc5MzQyZjg5NDQxZjg5NTQwZjk5NzNmZjk5ODNlZjk5YTNlZmE5YjNkZmE5YzNjZmE5ZTNiZmI5ZjNhZmJhMTM5ZmJhMjM4ZmNhMzM4ZmNhNTM3ZmNhNjM2ZmNhODM1ZmNhOTM0ZmRhYjMzZmRhYzMzZmRhZTMyZmRhZjMxZmRiMTMwZmRiMjJmZmRiNDJmZmRiNTJlZmViNzJkZmViODJjZmViYTJjZmViYjJiZmViZDJhZmViZTJhZmVjMDI5ZmRjMjI5ZmRjMzI4ZmRjNTI3ZmRjNjI3ZmRjODI3ZmRjYTI2ZmRjYjI2ZmNjZDI1ZmNjZTI1ZmNkMDI1ZmNkMjI1ZmJkMzI0ZmJkNTI0ZmJkNzI0ZmFkODI0ZmFkYTI0ZjlkYzI0ZjlkZDI1ZjhkZjI1ZjhlMTI1ZjdlMjI1ZjdlNDI1ZjZlNjI2ZjZlODI2ZjVlOTI2ZjVlYjI3ZjRlZDI3ZjNlZTI3ZjNmMDI3ZjJmMjI3ZjFmNDI2ZjFmNTI1ZjBmNzI0ZjBmOTIxXCIpKTtcblxuICBmdW5jdGlvbiBzZXF1ZW50aWFsKGludGVycG9sYXRvcikge1xuICAgIHZhciB4MCA9IDAsXG4gICAgICAgIHgxID0gMSxcbiAgICAgICAgY2xhbXAgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHZhciB0ID0gKHggLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICByZXR1cm4gaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpIDogdCk7XG4gICAgfVxuXG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgc2NhbGUpIDogW3gwLCB4MV07XG4gICAgfTtcblxuICAgIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICAgIH07XG5cbiAgICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gICAgfTtcblxuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXF1ZW50aWFsKGludGVycG9sYXRvcikuZG9tYWluKFt4MCwgeDFdKS5jbGFtcChjbGFtcCk7XG4gICAgfTtcblxuICAgIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xuICB9XG5cbiAgZXhwb3J0cy5zY2FsZUJhbmQgPSBiYW5kO1xuICBleHBvcnRzLnNjYWxlUG9pbnQgPSBwb2ludDtcbiAgZXhwb3J0cy5zY2FsZUlkZW50aXR5ID0gaWRlbnRpdHk7XG4gIGV4cG9ydHMuc2NhbGVMaW5lYXIgPSBsaW5lYXI7XG4gIGV4cG9ydHMuc2NhbGVMb2cgPSBsb2c7XG4gIGV4cG9ydHMuc2NhbGVPcmRpbmFsID0gb3JkaW5hbDtcbiAgZXhwb3J0cy5zY2FsZUltcGxpY2l0ID0gaW1wbGljaXQ7XG4gIGV4cG9ydHMuc2NhbGVQb3cgPSBwb3c7XG4gIGV4cG9ydHMuc2NhbGVTcXJ0ID0gc3FydDtcbiAgZXhwb3J0cy5zY2FsZVF1YW50aWxlID0gcXVhbnRpbGUkMTtcbiAgZXhwb3J0cy5zY2FsZVF1YW50aXplID0gcXVhbnRpemU7XG4gIGV4cG9ydHMuc2NhbGVUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIGV4cG9ydHMuc2NhbGVUaW1lID0gdGltZTtcbiAgZXhwb3J0cy5zY2FsZVV0YyA9IHV0Y1RpbWU7XG4gIGV4cG9ydHMuc2NoZW1lQ2F0ZWdvcnkxMCA9IGNhdGVnb3J5MTA7XG4gIGV4cG9ydHMuc2NoZW1lQ2F0ZWdvcnkyMGIgPSBjYXRlZ29yeTIwYjtcbiAgZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTIwYyA9IGNhdGVnb3J5MjBjO1xuICBleHBvcnRzLnNjaGVtZUNhdGVnb3J5MjAgPSBjYXRlZ29yeTIwO1xuICBleHBvcnRzLmludGVycG9sYXRlQ3ViZWhlbGl4RGVmYXVsdCA9IGN1YmVoZWxpeCQxO1xuICBleHBvcnRzLmludGVycG9sYXRlUmFpbmJvdyA9IHJhaW5ib3ckMTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZVdhcm0gPSB3YXJtO1xuICBleHBvcnRzLmludGVycG9sYXRlQ29vbCA9IGNvb2w7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVWaXJpZGlzID0gdmlyaWRpcztcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZU1hZ21hID0gbWFnbWE7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVJbmZlcm5vID0gaW5mZXJubztcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZVBsYXNtYSA9IHBsYXNtYTtcbiAgZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWwgPSBzZXF1ZW50aWFsO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTsiLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNlbGVjdGlvbi8gVmVyc2lvbiAxLjAuMi4gQ29weXJpZ2h0IDIwMTYgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbiAgdmFyIG5hbWVzcGFjZXMgPSB7XG4gICAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgeGh0bWw6IHhodG1sLFxuICAgIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxuICB9O1xuXG4gIGZ1bmN0aW9uIG5hbWVzcGFjZShuYW1lKSB7XG4gICAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRvcihuYW1lKSB7XG4gICAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICAgIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xuICB9XG5cbiAgdmFyIG5leHRJZCA9IDA7XG5cbiAgZnVuY3Rpb24gbG9jYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIExvY2FsKCkge1xuICAgIHRoaXMuXyA9IFwiQFwiICsgKCsrbmV4dElkKS50b1N0cmluZygzNik7XG4gIH1cblxuICBMb2NhbC5wcm90b3R5cGUgPSBsb2NhbC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IExvY2FsLFxuICAgIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGlkID0gdGhpcy5fO1xuICAgICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgICByZXR1cm4gbm9kZVtpZF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl8gaW4gbm9kZSAmJiBkZWxldGUgbm9kZVt0aGlzLl9dO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXztcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1hdGNoZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH07XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5tYXRjaGVzKSB7XG4gICAgICB2YXIgdmVuZG9yTWF0Y2hlcyA9IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgfHwgZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvclxuICAgICAgICAgIHx8IGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yO1xuICAgICAgbWF0Y2hlciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdmVuZG9yTWF0Y2hlcy5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIG1hdGNoZXIkMSA9IG1hdGNoZXI7XG5cbiAgdmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG4gIGV4cG9ydHMuZXZlbnQgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgZWxlbWVudCQxID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGlmICghKFwib25tb3VzZWVudGVyXCIgaW4gZWxlbWVudCQxKSkge1xuICAgICAgZmlsdGVyRXZlbnRzID0ge21vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIn07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyQ29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgICBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGhpcyAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcykgJiA4KSkpIHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50MSkge1xuICAgICAgdmFyIGV2ZW50MCA9IGV4cG9ydHMuZXZlbnQ7IC8vIEV2ZW50cyBjYW4gYmUgcmVlbnRyYW50IChlLmcuLCBmb2N1cykuXG4gICAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCB0aGlzLl9fZGF0YV9fLCBpbmRleCwgZ3JvdXApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gICAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICAgIGlmICghb24pIHJldHVybjtcbiAgICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvblsrK2ldID0gbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gb25BZGQodHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gICAgdmFyIHdyYXAgPSBmaWx0ZXJFdmVudHMuaGFzT3duUHJvcGVydHkodHlwZW5hbWUudHlwZSkgPyBmaWx0ZXJDb250ZXh0TGlzdGVuZXIgOiBjb250ZXh0TGlzdGVuZXI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgICB2YXIgb24gPSB0aGlzLl9fb24sIG8sIGxpc3RlbmVyID0gd3JhcCh2YWx1ZSwgaSwgZ3JvdXApO1xuICAgICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5jYXB0dXJlID0gY2FwdHVyZSk7XG4gICAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIGNhcHR1cmU6IGNhcHR1cmV9O1xuICAgICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgICAgZWxzZSBvbi5wdXNoKG8pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gICAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gICAgaWYgKGNhcHR1cmUgPT0gbnVsbCkgY2FwdHVyZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBjdXN0b21FdmVudChldmVudDEsIGxpc3RlbmVyLCB0aGF0LCBhcmdzKSB7XG4gICAgdmFyIGV2ZW50MCA9IGV4cG9ydHMuZXZlbnQ7XG4gICAgZXZlbnQxLnNvdXJjZUV2ZW50ID0gZXhwb3J0cy5ldmVudDtcbiAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc291cmNlRXZlbnQoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBleHBvcnRzLmV2ZW50LCBzb3VyY2U7XG4gICAgd2hpbGUgKHNvdXJjZSA9IGN1cnJlbnQuc291cmNlRXZlbnQpIGN1cnJlbnQgPSBzb3VyY2U7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludChub2RlLCBldmVudCkge1xuICAgIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuXG4gICAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlKG5vZGUpIHtcbiAgICB2YXIgZXZlbnQgPSBzb3VyY2VFdmVudCgpO1xuICAgIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykgZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICByZXR1cm4gcG9pbnQobm9kZSwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9uZSgpIHt9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0KHNlbGVjdCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0QWxsKHNlbGVjdCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cHMucHVzaChzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpO1xuICAgICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZmlsdGVyKG1hdGNoKSB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIkMShtYXRjaCk7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGFyc2UodXBkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheSh1cGRhdGUubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9lbnRlcigpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hbWVzcGFjZVVSSSA9IHBhcmVudC5uYW1lc3BhY2VVUkk7XG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX19kYXRhX18gPSBkYXR1bTtcbiAgfVxuXG4gIEVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICAgIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXG4gICAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuICBmdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gICAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gICAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuICAgIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cbiAgICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgICAga2V5VmFsdWU7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICAgIGlmIChrZXlWYWx1ZSBpbiBub2RlQnlLZXlWYWx1ZSkge1xuICAgICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gICAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0pIHtcbiAgICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZXNbaV1dID09PSBub2RlKSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fZGF0YSh2YWx1ZSwga2V5KSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihkKSB7IGRhdGFbKytqXSA9IGQ7IH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICAgIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcbiAgICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gICAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgICByZXR1cm4gdXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2V4aXQoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX21lcmdlKHNlbGVjdGlvbikge1xuXG4gICAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fb3JkZXIoKSB7XG5cbiAgICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBub2RlLm5leHRTaWJsaW5nKSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fc29ydChjb21wYXJlKSB7XG4gICAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICAgIH1cblxuICAgIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzb3J0Z3JvdXBzLCB0aGlzLl9wYXJlbnRzKS5vcmRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fY2FsbCgpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX25vZGVzKCkge1xuICAgIHZhciBub2RlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGkgPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fbm9kZSgpIHtcblxuICAgIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3NpemUoKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgKytzaXplOyB9KTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9lbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMubm9kZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2VhY2goY2FsbGJhY2spIHtcblxuICAgIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRWaWV3KG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIC8vIG5vZGUgaXMgYSBOb2RlXG4gICAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG4gIH1cblxuICBmdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICB2YXIgbm9kZTtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgICAgOiBkZWZhdWx0Vmlldyhub2RlID0gdGhpcy5ub2RlKCkpXG4gICAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKVxuICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbiAgfVxuXG4gIENsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gICAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25fdGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9odG1sKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG4gIH1cblxuICBmdW5jdGlvbiByYWlzZSgpIHtcbiAgICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX3JhaXNlKCkge1xuICAgIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG93ZXIoKSB7XG4gICAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9sb3dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGxvd2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9hcHBlbmQobmFtZSkge1xuICAgIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2luc2VydChuYW1lLCBiZWZvcmUpIHtcbiAgICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpLFxuICAgICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9yZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uX2RhdHVtKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5ub2RlKCkuX19kYXRhX187XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KG5vZGUsIHR5cGUsIHBhcmFtcykge1xuICAgIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ29uc3RhbnQodHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbl9kaXNwYXRjaCh0eXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICAgIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG4gIH1cblxuICB2YXIgcm9vdCA9IFtudWxsXTtcblxuICBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gICAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICAgIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xuICB9XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gICAgc2VsZWN0QWxsOiBzZWxlY3Rpb25fc2VsZWN0QWxsLFxuICAgIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgICBlbnRlcjogc2VsZWN0aW9uX2VudGVyLFxuICAgIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICAgIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gICAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICAgIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICAgIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICAgIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gICAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gICAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gICAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICAgIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICAgIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICAgIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICAgIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gICAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gICAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICAgIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICAgIG9uOiBzZWxlY3Rpb25fb24sXG4gICAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNlbGVjdChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0QWxsKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoKG5vZGUsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGlkZW50aWZpZXIgPSB0b3VjaGVzLCB0b3VjaGVzID0gc291cmNlRXZlbnQoKS5jaGFuZ2VkVG91Y2hlcztcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBwb2ludChub2RlLCB0b3VjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVzKG5vZGUsIHRvdWNoZXMpIHtcbiAgICBpZiAodG91Y2hlcyA9PSBudWxsKSB0b3VjaGVzID0gc291cmNlRXZlbnQoKS50b3VjaGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCBwb2ludHMgPSBuZXcgQXJyYXkobik7IGkgPCBuOyArK2kpIHtcbiAgICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBleHBvcnRzLmNyZWF0b3IgPSBjcmVhdG9yO1xuICBleHBvcnRzLmxvY2FsID0gbG9jYWw7XG4gIGV4cG9ydHMubWF0Y2hlciA9IG1hdGNoZXIkMTtcbiAgZXhwb3J0cy5tb3VzZSA9IG1vdXNlO1xuICBleHBvcnRzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZXhwb3J0cy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcbiAgZXhwb3J0cy5zZWxlY3QgPSBzZWxlY3Q7XG4gIGV4cG9ydHMuc2VsZWN0QWxsID0gc2VsZWN0QWxsO1xuICBleHBvcnRzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgZXhwb3J0cy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICBleHBvcnRzLnNlbGVjdG9yQWxsID0gc2VsZWN0b3JBbGw7XG4gIGV4cG9ydHMudG91Y2ggPSB0b3VjaDtcbiAgZXhwb3J0cy50b3VjaGVzID0gdG91Y2hlcztcbiAgZXhwb3J0cy53aW5kb3cgPSBkZWZhdWx0VmlldztcbiAgZXhwb3J0cy5jdXN0b21FdmVudCA9IGN1c3RvbUV2ZW50O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTsiLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUtZm9ybWF0LyB2Mi4xLjMgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy10aW1lJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtdGltZSddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzVGltZSkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG59XG5cbmZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG59XG5cbmZ1bmN0aW9uIG5ld1llYXIoeSkge1xuICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gIHZhciBmb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdEhvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0SG91cjEyLFxuICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdE1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0TW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFBlcmlvZCxcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciB1dGNGb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRVVENNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJmXCI6IHBhcnNlTWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBwYXJzZUhvdXIyNCxcbiAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBwYXJzZU1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgIFwicFwiOiBwYXJzZVBlcmlvZCxcbiAgICBcIlFcIjogcGFyc2VVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgXCJ1XCI6IHBhcnNlV2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBwYXJzZVdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IHBhcnNlV2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgXCJYXCI6IHBhcnNlTG9jYWxlVGltZSxcbiAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgIFwiWlwiOiBwYXJzZVpvbmUsXG4gICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXG4gIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xuICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBbXSxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBwYWQsXG4gICAgICAgICAgZm9ybWF0O1xuXG4gICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgIGlmICgocGFkID0gcGFkc1tjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKTtcbiAgICAgICAgICBlbHNlIHBhZCA9IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIjtcbiAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQpO1xuICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIG5ld0RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgZCA9IG5ld1llYXIoMTkwMCksXG4gICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApLFxuICAgICAgICAgIHdlZWssIGRheTtcbiAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBJZiBhIFVOSVggdGltZXN0YW1wIGlzIHNwZWNpZmllZCwgcmV0dXJuIGl0LlxuICAgICAgaWYgKFwiUVwiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLlEpO1xuXG4gICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG5cbiAgICAgIC8vIENvbnZlcnQgZGF5LW9mLXdlZWsgYW5kIHdlZWstb2YteWVhciB0byBkYXktb2YteWVhci5cbiAgICAgIGlmIChcIlZcIiBpbiBkKSB7XG4gICAgICAgIGlmIChkLlYgPCAxIHx8IGQuViA+IDUzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IDE7XG4gICAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgICAgd2VlayA9IHV0Y0RhdGUobmV3WWVhcihkLnkpKSwgZGF5ID0gd2Vlay5nZXRVVENEYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyBkM1RpbWUudXRjTW9uZGF5LmNlaWwod2VlaykgOiBkM1RpbWUudXRjTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSBkM1RpbWUudXRjRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRVVENNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0VVRDRGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWVrID0gbmV3RGF0ZShuZXdZZWFyKGQueSkpLCBkYXkgPSB3ZWVrLmdldERheSgpO1xuICAgICAgICAgIHdlZWsgPSBkYXkgPiA0IHx8IGRheSA9PT0gMCA/IGQzVGltZS50aW1lTW9uZGF5LmNlaWwod2VlaykgOiBkM1RpbWUudGltZU1vbmRheSh3ZWVrKTtcbiAgICAgICAgICB3ZWVrID0gZDNUaW1lLnRpbWVEYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xuICAgICAgICAgIGQueSA9IHdlZWsuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldE1vbnRoKCk7XG4gICAgICAgICAgZC5kID0gd2Vlay5nZXREYXRlKCkgKyAoZC53ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJ1XCIgaW4gZCA/IGQudSAlIDcgOiBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgIGRheSA9IFwiWlwiIGluIGQgPyB1dGNEYXRlKG5ld1llYXIoZC55KSkuZ2V0VVRDRGF5KCkgOiBuZXdEYXRlKG5ld1llYXIoZC55KSkuZ2V0RGF5KCk7XG4gICAgICAgIGQubSA9IDA7XG4gICAgICAgIGQuZCA9IFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXkgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgIC8vIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0aW1lIHpvbmUuXG4gICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgZC5NICs9IGQuWiAlIDEwMDtcbiAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIGZpZWxkcyBhcmUgaW4gbG9jYWwgdGltZS5cbiAgICAgIHJldHVybiBuZXdEYXRlKGQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICBjLFxuICAgICAgICBwYXJzZTtcblxuICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgYyA9IHNwZWNpZmllci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcbiAgICAgICAgcGFyc2UgPSBwYXJzZXNbYyBpbiBwYWRzID8gc3BlY2lmaWVyLmNoYXJBdChpKyspIDogY107XG4gICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQZXJpb2QoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJpb2RSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5wID0gcGVyaW9kTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBzaG9ydE1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDUGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIgKz0gXCJcIiwgbG9jYWxEYXRlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgdXRjRm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCB1dGNGb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgdXRjUGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIsIHV0Y0RhdGUpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGFkcyA9IHtcIi1cIjogXCJcIiwgXCJfXCI6IFwiIFwiLCBcIjBcIjogXCIwXCJ9LFxuICAgIG51bWJlclJlID0gL15cXHMqXFxkKy8sIC8vIG5vdGU6IGlnbm9yZXMgbmV4dCBkaXJlY3RpdmVcbiAgICBwZXJjZW50UmUgPSAvXiUvLFxuICAgIHJlcXVvdGVSZSA9IC9bXFxcXF4kKis/fFtcXF0oKS57fV0vZztcblxuZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlcXVvdGUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJlKG5hbWVzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gIHZhciBtYXAgPSB7fSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbWFwW25hbWVzW2ldLnRvTG93ZXJDYXNlKCldID0gaTtcbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLnUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVySVNPKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuViA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gIHJldHVybiBuID8gKGQueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSArICgrblswXSA+IDY4ID8gMTkwMCA6IDIwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWm9uZShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSAvXihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuWiA9IG5bMV0gPyAwIDogLShuWzJdICsgKG5bM10gfHwgXCIwMFwiKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZlllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pY3Jvc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLkwgPSBNYXRoLmZsb29yKG5bMF0gLyAxMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXAoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICByZXR1cm4gbiA/IChkLlEgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5RID0gKCtuWzBdKSAqIDEwMDAsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudGltZURheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZGF5ID0gZC5nZXREYXkoKTtcbiAgcmV0dXJuIGRheSA9PT0gMCA/IDcgOiBkYXk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS50aW1lU3VuZGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVySVNPKGQsIHApIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIGQgPSAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IGQzVGltZS50aW1lVGh1cnNkYXkoZCkgOiBkM1RpbWUudGltZVRodXJzZGF5LmNlaWwoZCk7XG4gIHJldHVybiBwYWQoZDNUaW1lLnRpbWVUaHVyc2RheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpICsgKGQzVGltZS50aW1lWWVhcihkKS5nZXREYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0RGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS50aW1lTW9uZGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGdWxsWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRab25lKGQpIHtcbiAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXG4gICAgICArIHBhZCh6IC8gNjAgfCAwLCBcIjBcIiwgMilcbiAgICAgICsgcGFkKHogJSA2MCwgXCIwXCIsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZk1vbnRoKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0RhdGUoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIyNChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDSG91cjEyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoMSArIGQzVGltZS51dGNEYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZG93ID0gZC5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIGRvdyA9PT0gMCA/IDcgOiBkb3c7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNTdW5kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlcklTTyhkLCBwKSB7XG4gIHZhciBkYXkgPSBkLmdldFVUQ0RheSgpO1xuICBkID0gKGRheSA+PSA0IHx8IGRheSA9PT0gMCkgPyBkM1RpbWUudXRjVGh1cnNkYXkoZCkgOiBkM1RpbWUudXRjVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjVGh1cnNkYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpICsgKGQzVGltZS51dGNZZWFyKGQpLmdldFVUQ0RheSgpID09PSA0KSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXkoZCkge1xuICByZXR1cm4gZC5nZXRVVENEYXkoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQoZDNUaW1lLnV0Y01vbmRheS5jb3VudChkM1RpbWUudXRjWWVhcihkKSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENGdWxsWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICByZXR1cm4gXCIrMDAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgcmV0dXJuIFwiJVwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVbml4VGltZXN0YW1wKGQpIHtcbiAgcmV0dXJuICtkO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyhkKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKCtkIC8gMTAwMCk7XG59XG5cbnZhciBsb2NhbGU7XG5cbmRlZmF1bHRMb2NhbGUoe1xuICBkYXRlVGltZTogXCIleCwgJVhcIixcbiAgZGF0ZTogXCIlLW0vJS1kLyVZXCIsXG4gIHRpbWU6IFwiJS1JOiVNOiVTICVwXCIsXG4gIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMudGltZUZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMudGltZVBhcnNlID0gbG9jYWxlLnBhcnNlO1xuICBleHBvcnRzLnV0Y0Zvcm1hdCA9IGxvY2FsZS51dGNGb3JtYXQ7XG4gIGV4cG9ydHMudXRjUGFyc2UgPSBsb2NhbGUudXRjUGFyc2U7XG4gIHJldHVybiBsb2NhbGU7XG59XG5cbnZhciBpc29TcGVjaWZpZXIgPSBcIiVZLSVtLSVkVCVIOiVNOiVTLiVMWlwiO1xuXG5mdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufVxuXG52YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmdcbiAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgIDogZXhwb3J0cy51dGNGb3JtYXQoaXNvU3BlY2lmaWVyKTtcblxuZnVuY3Rpb24gcGFyc2VJc29OYXRpdmUoc3RyaW5nKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG59XG5cbnZhciBwYXJzZUlzbyA9ICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKVxuICAgID8gcGFyc2VJc29OYXRpdmVcbiAgICA6IGV4cG9ydHMudXRjUGFyc2UoaXNvU3BlY2lmaWVyKTtcblxuZXhwb3J0cy50aW1lRm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG5leHBvcnRzLnRpbWVGb3JtYXRMb2NhbGUgPSBmb3JtYXRMb2NhbGU7XG5leHBvcnRzLmlzb0Zvcm1hdCA9IGZvcm1hdElzbztcbmV4cG9ydHMuaXNvUGFyc2UgPSBwYXJzZUlzbztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtdGltZS8gdjEuMC4xMCBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHQwID0gbmV3IERhdGUsXG4gICAgdDEgPSBuZXcgRGF0ZTtcblxuZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCwgZmllbGQpIHtcblxuICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgfVxuXG4gIGludGVydmFsLmZsb29yID0gaW50ZXJ2YWw7XG5cbiAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBmbG9vcmkoZGF0ZSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGQwID0gaW50ZXJ2YWwoZGF0ZSksXG4gICAgICAgIGQxID0gaW50ZXJ2YWwuY2VpbChkYXRlKTtcbiAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgfTtcblxuICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICB2YXIgcmFuZ2UgPSBbXSwgcHJldmlvdXM7XG4gICAgc3RhcnQgPSBpbnRlcnZhbC5jZWlsKHN0YXJ0KTtcbiAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgZG8gcmFuZ2UucHVzaChwcmV2aW91cyA9IG5ldyBEYXRlKCtzdGFydCkpLCBvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICB3aGlsZSAocHJldmlvdXMgPCBzdGFydCAmJiBzdGFydCA8IHN0b3ApO1xuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKytzdGVwIDw9IDApIHtcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0aShkYXRlLCAtMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gZWxzZSB3aGlsZSAoLS1zdGVwID49IDApIHtcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0aShkYXRlLCArMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoY291bnQpIHtcbiAgICBpbnRlcnZhbC5jb3VudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHQwLnNldFRpbWUoK3N0YXJ0KSwgdDEuc2V0VGltZSgrZW5kKTtcbiAgICAgIGZsb29yaSh0MCksIGZsb29yaSh0MSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihjb3VudCh0MCwgdDEpKTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZXZlcnkgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgICBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUoc3RlcCkgfHwgIShzdGVwID4gMCkgPyBudWxsXG4gICAgICAgICAgOiAhKHN0ZXAgPiAxKSA/IGludGVydmFsXG4gICAgICAgICAgOiBpbnRlcnZhbC5maWx0ZXIoZmllbGRcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbihkKSB7IHJldHVybiBmaWVsZChkKSAlIHN0ZXAgPT09IDA7IH1cbiAgICAgICAgICAgICAgOiBmdW5jdGlvbihkKSB7IHJldHVybiBpbnRlcnZhbC5jb3VudCgwLCBkKSAlIHN0ZXAgPT09IDA7IH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaW50ZXJ2YWw7XG59XG5cbnZhciBtaWxsaXNlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKCkge1xuICAvLyBub29wXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxubWlsbGlzZWNvbmQuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBpZiAoIWlzRmluaXRlKGspIHx8ICEoayA+IDApKSByZXR1cm4gbnVsbDtcbiAgaWYgKCEoayA+IDEpKSByZXR1cm4gbWlsbGlzZWNvbmQ7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoZGF0ZSAvIGspICogayk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogayk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGs7XG4gIH0pO1xufTtcbnZhciBtaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZC5yYW5nZTtcblxudmFyIGR1cmF0aW9uU2Vjb25kID0gMWUzO1xudmFyIGR1cmF0aW9uTWludXRlID0gNmU0O1xudmFyIGR1cmF0aW9uSG91ciA9IDM2ZTU7XG52YXIgZHVyYXRpb25EYXkgPSA4NjRlNTtcbnZhciBkdXJhdGlvbldlZWsgPSA2MDQ4ZTU7XG5cbnZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvblNlY29uZCkgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25TZWNvbmQ7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbn0pO1xudmFyIHNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cbnZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvbk1pbnV0ZSkgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xudmFyIG1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG5cbnZhciBob3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICB2YXIgb2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGUgJSBkdXJhdGlvbkhvdXI7XG4gIGlmIChvZmZzZXQgPCAwKSBvZmZzZXQgKz0gZHVyYXRpb25Ib3VyO1xuICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcigoK2RhdGUgLSBvZmZzZXQpIC8gZHVyYXRpb25Ib3VyKSAqIGR1cmF0aW9uSG91ciArIG9mZnNldCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcbn0pO1xudmFyIGhvdXJzID0gaG91ci5yYW5nZTtcblxudmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXREYXRlKCkgLSAxO1xufSk7XG52YXIgZGF5cyA9IGRheS5yYW5nZTtcblxuZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25XZWVrO1xuICB9KTtcbn1cblxudmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG52YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbnZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xudmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xudmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxudmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG52YXIgbW9uZGF5cyA9IG1vbmRheS5yYW5nZTtcbnZhciB0dWVzZGF5cyA9IHR1ZXNkYXkucmFuZ2U7XG52YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbnZhciB0aHVyc2RheXMgPSB0aHVyc2RheS5yYW5nZTtcbnZhciBmcmlkYXlzID0gZnJpZGF5LnJhbmdlO1xudmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuXG52YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0RGF0ZSgxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG59KTtcbnZhciBtb250aHMgPSBtb250aC5yYW5nZTtcblxudmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxueWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG52YXIgeWVhcnMgPSB5ZWFyLnJhbmdlO1xuXG52YXIgdXRjTWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ1NlY29uZHMoMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbn0pO1xudmFyIHV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cbnZhciB1dGNIb3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xudmFyIHV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcblxudmFyIHV0Y0RheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25EYXk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKSAtIDE7XG59KTtcbnZhciB1dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuXG5mdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbnZhciB1dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xudmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG52YXIgdXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG52YXIgdXRjV2VkbmVzZGF5ID0gdXRjV2Vla2RheSgzKTtcbnZhciB1dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG52YXIgdXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcbnZhciB1dGNTYXR1cmRheSA9IHV0Y1dlZWtkYXkoNik7XG5cbnZhciB1dGNTdW5kYXlzID0gdXRjU3VuZGF5LnJhbmdlO1xudmFyIHV0Y01vbmRheXMgPSB1dGNNb25kYXkucmFuZ2U7XG52YXIgdXRjVHVlc2RheXMgPSB1dGNUdWVzZGF5LnJhbmdlO1xudmFyIHV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXkucmFuZ2U7XG52YXIgdXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXkucmFuZ2U7XG52YXIgdXRjRnJpZGF5cyA9IHV0Y0ZyaWRheS5yYW5nZTtcbnZhciB1dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheS5yYW5nZTtcblxudmFyIHV0Y01vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0RhdGUoMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDTW9udGgoZGF0ZS5nZXRVVENNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0VVRDTW9udGgoKSAtIHN0YXJ0LmdldFVUQ01vbnRoKCkgKyAoZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNb250aCgpO1xufSk7XG52YXIgdXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cbnZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnV0Y1llYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xudmFyIHV0Y1llYXJzID0gdXRjWWVhci5yYW5nZTtcblxuZXhwb3J0cy50aW1lSW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcbmV4cG9ydHMudGltZU1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG5leHBvcnRzLnRpbWVNaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG5leHBvcnRzLnV0Y01pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG5leHBvcnRzLnV0Y01pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbmV4cG9ydHMudGltZVNlY29uZCA9IHNlY29uZDtcbmV4cG9ydHMudGltZVNlY29uZHMgPSBzZWNvbmRzO1xuZXhwb3J0cy51dGNTZWNvbmQgPSBzZWNvbmQ7XG5leHBvcnRzLnV0Y1NlY29uZHMgPSBzZWNvbmRzO1xuZXhwb3J0cy50aW1lTWludXRlID0gbWludXRlO1xuZXhwb3J0cy50aW1lTWludXRlcyA9IG1pbnV0ZXM7XG5leHBvcnRzLnRpbWVIb3VyID0gaG91cjtcbmV4cG9ydHMudGltZUhvdXJzID0gaG91cnM7XG5leHBvcnRzLnRpbWVEYXkgPSBkYXk7XG5leHBvcnRzLnRpbWVEYXlzID0gZGF5cztcbmV4cG9ydHMudGltZVdlZWsgPSBzdW5kYXk7XG5leHBvcnRzLnRpbWVXZWVrcyA9IHN1bmRheXM7XG5leHBvcnRzLnRpbWVTdW5kYXkgPSBzdW5kYXk7XG5leHBvcnRzLnRpbWVTdW5kYXlzID0gc3VuZGF5cztcbmV4cG9ydHMudGltZU1vbmRheSA9IG1vbmRheTtcbmV4cG9ydHMudGltZU1vbmRheXMgPSBtb25kYXlzO1xuZXhwb3J0cy50aW1lVHVlc2RheSA9IHR1ZXNkYXk7XG5leHBvcnRzLnRpbWVUdWVzZGF5cyA9IHR1ZXNkYXlzO1xuZXhwb3J0cy50aW1lV2VkbmVzZGF5ID0gd2VkbmVzZGF5O1xuZXhwb3J0cy50aW1lV2VkbmVzZGF5cyA9IHdlZG5lc2RheXM7XG5leHBvcnRzLnRpbWVUaHVyc2RheSA9IHRodXJzZGF5O1xuZXhwb3J0cy50aW1lVGh1cnNkYXlzID0gdGh1cnNkYXlzO1xuZXhwb3J0cy50aW1lRnJpZGF5ID0gZnJpZGF5O1xuZXhwb3J0cy50aW1lRnJpZGF5cyA9IGZyaWRheXM7XG5leHBvcnRzLnRpbWVTYXR1cmRheSA9IHNhdHVyZGF5O1xuZXhwb3J0cy50aW1lU2F0dXJkYXlzID0gc2F0dXJkYXlzO1xuZXhwb3J0cy50aW1lTW9udGggPSBtb250aDtcbmV4cG9ydHMudGltZU1vbnRocyA9IG1vbnRocztcbmV4cG9ydHMudGltZVllYXIgPSB5ZWFyO1xuZXhwb3J0cy50aW1lWWVhcnMgPSB5ZWFycztcbmV4cG9ydHMudXRjTWludXRlID0gdXRjTWludXRlO1xuZXhwb3J0cy51dGNNaW51dGVzID0gdXRjTWludXRlcztcbmV4cG9ydHMudXRjSG91ciA9IHV0Y0hvdXI7XG5leHBvcnRzLnV0Y0hvdXJzID0gdXRjSG91cnM7XG5leHBvcnRzLnV0Y0RheSA9IHV0Y0RheTtcbmV4cG9ydHMudXRjRGF5cyA9IHV0Y0RheXM7XG5leHBvcnRzLnV0Y1dlZWsgPSB1dGNTdW5kYXk7XG5leHBvcnRzLnV0Y1dlZWtzID0gdXRjU3VuZGF5cztcbmV4cG9ydHMudXRjU3VuZGF5ID0gdXRjU3VuZGF5O1xuZXhwb3J0cy51dGNTdW5kYXlzID0gdXRjU3VuZGF5cztcbmV4cG9ydHMudXRjTW9uZGF5ID0gdXRjTW9uZGF5O1xuZXhwb3J0cy51dGNNb25kYXlzID0gdXRjTW9uZGF5cztcbmV4cG9ydHMudXRjVHVlc2RheSA9IHV0Y1R1ZXNkYXk7XG5leHBvcnRzLnV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheXM7XG5leHBvcnRzLnV0Y1dlZG5lc2RheSA9IHV0Y1dlZG5lc2RheTtcbmV4cG9ydHMudXRjV2VkbmVzZGF5cyA9IHV0Y1dlZG5lc2RheXM7XG5leHBvcnRzLnV0Y1RodXJzZGF5ID0gdXRjVGh1cnNkYXk7XG5leHBvcnRzLnV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5cztcbmV4cG9ydHMudXRjRnJpZGF5ID0gdXRjRnJpZGF5O1xuZXhwb3J0cy51dGNGcmlkYXlzID0gdXRjRnJpZGF5cztcbmV4cG9ydHMudXRjU2F0dXJkYXkgPSB1dGNTYXR1cmRheTtcbmV4cG9ydHMudXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXlzO1xuZXhwb3J0cy51dGNNb250aCA9IHV0Y01vbnRoO1xuZXhwb3J0cy51dGNNb250aHMgPSB1dGNNb250aHM7XG5leHBvcnRzLnV0Y1llYXIgPSB1dGNZZWFyO1xuZXhwb3J0cy51dGNZZWFycyA9IHV0Y1llYXJzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10aW1lci8gdjEuMC45IENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnJhbWUgPSAwLCAvLyBpcyBhbiBhbmltYXRpb24gZnJhbWUgcGVuZGluZz9cbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XG4gICAgaW50ZXJ2YWwgPSAwLCAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG4gICAgcG9rZURlbGF5ID0gMTAwMCwgLy8gaG93IGZyZXF1ZW50bHkgd2UgY2hlY2sgZm9yIGNsb2NrIHNrZXdcbiAgICB0YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwobnVsbCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aW1lb3V0JDEoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZnVuY3Rpb24oZWxhcHNlZCkge1xuICAgIHQuc3RvcCgpO1xuICAgIGNhbGxiYWNrKGVsYXBzZWQgKyBkZWxheSk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGludGVydmFsJDEoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyLCB0b3RhbCA9IGRlbGF5O1xuICBpZiAoZGVsYXkgPT0gbnVsbCkgcmV0dXJuIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpLCB0O1xuICBkZWxheSA9ICtkZWxheSwgdGltZSA9IHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWU7XG4gIHQucmVzdGFydChmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgIHQucmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydHMubm93ID0gbm93O1xuZXhwb3J0cy50aW1lciA9IHRpbWVyO1xuZXhwb3J0cy50aW1lckZsdXNoID0gdGltZXJGbHVzaDtcbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQkMTtcbmV4cG9ydHMuaW50ZXJ2YWwgPSBpbnRlcnZhbCQxO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10cmFuc2l0aW9uLyB2MS4xLjMgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy10aW1lcicpLCByZXF1aXJlKCdkMy1jb2xvcicpLCByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpLCByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtZWFzZScpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWRpc3BhdGNoJywgJ2QzLXRpbWVyJywgJ2QzLWNvbG9yJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLXNlbGVjdGlvbicsICdkMy1lYXNlJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0Rpc3BhdGNoLGQzVGltZXIsZDNDb2xvcixkM0ludGVycG9sYXRlLGQzU2VsZWN0aW9uLGQzRWFzZSkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9uID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxudmFyIENSRUFURUQgPSAwO1xudmFyIFNDSEVEVUxFRCA9IDE7XG52YXIgU1RBUlRJTkcgPSAyO1xudmFyIFNUQVJURUQgPSAzO1xudmFyIFJVTk5JTkcgPSA0O1xudmFyIEVORElORyA9IDU7XG52YXIgRU5ERUQgPSA2O1xuXG5mdW5jdGlvbiBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaW5kZXgsIGdyb3VwLCB0aW1pbmcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtcbiAgZWxzZSBpZiAoaWQgaW4gc2NoZWR1bGVzKSByZXR1cm47XG4gIGNyZWF0ZShub2RlLCBpZCwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgaW5kZXg6IGluZGV4LCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgb246IGVtcHR5T24sXG4gICAgdHdlZW46IGVtcHR5VHdlZW4sXG4gICAgdGltZTogdGltaW5nLnRpbWUsXG4gICAgZGVsYXk6IHRpbWluZy5kZWxheSxcbiAgICBkdXJhdGlvbjogdGltaW5nLmR1cmF0aW9uLFxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBzZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gZ2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgaWQsIHNlbGYpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgdHdlZW47XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuICBzY2hlZHVsZXNbaWRdID0gc2VsZjtcbiAgc2VsZi50aW1lciA9IGQzVGltZXIudGltZXIoc2NoZWR1bGUsIDAsIHNlbGYudGltZSk7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgIHNlbGYuc3RhdGUgPSBTQ0hFRFVMRUQ7XG4gICAgc2VsZi50aW1lci5yZXN0YXJ0KHN0YXJ0LCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuXG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgZGVsYXkgaXMgbGVzcyB0aGFuIG91ciBmaXJzdCBzbGVlcCwgc3RhcnQgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHNlbGYuZGVsYXkgPD0gZWxhcHNlZCkgc3RhcnQoZWxhcHNlZCAtIHNlbGYuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgIHZhciBpLCBqLCBuLCBvO1xuXG4gICAgLy8gSWYgdGhlIHN0YXRlIGlzIG5vdCBTQ0hFRFVMRUQsIHRoZW4gd2UgcHJldmlvdXNseSBlcnJvcmVkIG9uIHN0YXJ0LlxuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTQ0hFRFVMRUQpIHJldHVybiBzdG9wKCk7XG5cbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBvID0gc2NoZWR1bGVzW2ldO1xuICAgICAgaWYgKG8ubmFtZSAhPT0gc2VsZi5uYW1lKSBjb250aW51ZTtcblxuICAgICAgLy8gV2hpbGUgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgc3RhcnRpbmcgdHJhbnNpdGlvbiBkdXJpbmcgdGhpcyBmcmFtZSxcbiAgICAgIC8vIGRlZmVyIHN0YXJ0aW5nIGFuIGludGVycnVwdGluZyB0cmFuc2l0aW9uIHVudGlsIHRoYXQgdHJhbnNpdGlvbiBoYXMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcbiAgICAgIGlmIChvLnN0YXRlID09PSBTVEFSVEVEKSByZXR1cm4gZDNUaW1lci50aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgLy8gRGlzcGF0Y2ggdGhlIGludGVycnVwdCBldmVudC5cbiAgICAgIGlmIChvLnN0YXRlID09PSBSVU5OSU5HKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGFueSBwcmUtZW1wdGVkIHRyYW5zaXRpb25zLiBObyBpbnRlcnJ1cHQgZXZlbnQgaXMgZGlzcGF0Y2hlZFxuICAgICAgLy8gYmVjYXVzZSB0aGUgY2FuY2VsbGVkIHRyYW5zaXRpb25zIG5ldmVyIHN0YXJ0ZWQuIE5vdGUgdGhhdCB0aGlzIGFsc29cbiAgICAgIC8vIHJlbW92ZXMgdGhpcyB0cmFuc2l0aW9uIGZyb20gdGhlIHBlbmRpbmcgbGlzdCFcbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICBkM1RpbWVyLnRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gUlVOTklORztcbiAgICAgICAgc2VsZi50aW1lci5yZXN0YXJ0KHRpY2ssIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG4gICAgICAgIHRpY2soZWxhcHNlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgc3RhcnQgZXZlbnQuXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIHR3ZWVuIGFyZSBpbml0aWFsaXplZC5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0d2VlbiwgZGVsZXRpbmcgbnVsbCB0d2Vlbi5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGogPSAtMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG8gPSBzZWxmLnR3ZWVuW2ldLnZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCkpIHtcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgdmFyIHQgPSBlbGFwc2VkIDwgc2VsZi5kdXJhdGlvbiA/IHNlbGYuZWFzZS5jYWxsKG51bGwsIGVsYXBzZWQgLyBzZWxmLmR1cmF0aW9uKSA6IChzZWxmLnRpbWVyLnJlc3RhcnQoc3RvcCksIHNlbGYuc3RhdGUgPSBFTkRJTkcsIDEpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgdHdlZW5baV0uY2FsbChudWxsLCB0KTtcbiAgICB9XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuICAgIGlmIChzZWxmLnN0YXRlID09PSBFTkRJTkcpIHtcbiAgICAgIHNlbGYub24uY2FsbChcImVuZFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHNlbGYuc3RhdGUgPSBFTkRFRDtcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVycnVwdChub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlJCQxLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcblxuICBpZiAoIXNjaGVkdWxlcykgcmV0dXJuO1xuXG4gIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG5cbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgIGlmICgoc2NoZWR1bGUkJDEgPSBzY2hlZHVsZXNbaV0pLm5hbWUgIT09IG5hbWUpIHsgZW1wdHkgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBhY3RpdmUgPSBzY2hlZHVsZSQkMS5zdGF0ZSA+IFNUQVJUSU5HICYmIHNjaGVkdWxlJCQxLnN0YXRlIDwgRU5ESU5HO1xuICAgIHNjaGVkdWxlJCQxLnN0YXRlID0gRU5ERUQ7XG4gICAgc2NoZWR1bGUkJDEudGltZXIuc3RvcCgpO1xuICAgIGlmIChhY3RpdmUpIHNjaGVkdWxlJCQxLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2NoZWR1bGUkJDEuaW5kZXgsIHNjaGVkdWxlJCQxLmdyb3VwKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICB9XG5cbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9pbnRlcnJ1cHQobmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSQkMSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUkJDEudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjEgPSB0d2VlbjEuc2xpY2UoKTtcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZWR1bGUkJDEudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHR3ZWVuRnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUkJDEgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlJCQxLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gKHR3ZWVuMCA9IHR3ZWVuKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgdCA9IHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9LCBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xW2ldID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IG4pIHR3ZWVuMS5wdXNoKHQpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlJCQxLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3R3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG5cbiAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSQkMSA9IHNldCh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlJCQxLnZhbHVlIHx8IChzY2hlZHVsZSQkMS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBnZXQobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZU51bWJlclxuICAgICAgOiBiIGluc3RhbmNlb2YgZDNDb2xvci5jb2xvciA/IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBkM0NvbG9yLmNvbG9yKGIpKSA/IChiID0gYywgZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJnYilcbiAgICAgIDogZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlMSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIGludGVycG9sYXRlJCQxLCB2YWx1ZTEpIHtcbiAgdmFyIHZhbHVlMDAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlKSB7XG4gIHZhciB2YWx1ZTAwLFxuICAgICAgdmFsdWUxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgdmFsdWUwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCAmJiB2YWx1ZTEgPT09IHZhbHVlMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEwID0gdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIGludGVycG9sYXRlJCQxLCB2YWx1ZSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIHZhbHVlMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCAmJiB2YWx1ZTEgPT09IHZhbHVlMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEwID0gdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IGQzU2VsZWN0aW9uLm5hbWVzcGFjZShuYW1lKSwgaSA9IGZ1bGxuYW1lID09PSBcInRyYW5zZm9ybVwiID8gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pKGZ1bGxuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdmFsdWUgPT0gbnVsbCA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIGksIHZhbHVlICsgXCJcIikpO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaSh0KSk7XG4gICAgfTtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBpKHQpKTtcbiAgICB9O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IGQzU2VsZWN0aW9uLm5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZGVsYXkodmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZGVsYXk7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2R1cmF0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGR1cmF0aW9uRnVuY3Rpb25cbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZWFzZSh2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZmlsdGVyKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBkM1NlbGVjdGlvbi5tYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fbWVyZ2UodHJhbnNpdGlvbiQkMSkge1xuICBpZiAodHJhbnNpdGlvbiQkMS5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24kJDEuX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuXG5mdW5jdGlvbiBzdGFydChuYW1lKSB7XG4gIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gIXQgfHwgdCA9PT0gXCJzdGFydFwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9uMCwgb24xLCBzaXQgPSBzdGFydChuYW1lKSA/IGluaXQgOiBzZXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUkJDEgPSBzaXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlJCQxLm9uO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlJCQxLm9uID0gb24xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX29uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9yZW1vdmUoKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdChzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBkM1NlbGVjdGlvbi5zZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdEFsbChzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBkM1NlbGVjdGlvbi5zZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG5cbnZhciBTZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSwgaW50ZXJwb2xhdGUkJDEpIHtcbiAgdmFyIHZhbHVlMDAsXG4gICAgICB2YWx1ZTEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMCA9IGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgJiYgdmFsdWUxID09PSB2YWx1ZTEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlRW5kKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlMSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTAgPSBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKTtcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSQkMSwgdmFsdWUpIHtcbiAgdmFyIHZhbHVlMDAsXG4gICAgICB2YWx1ZTEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMCA9IGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCAmJiB2YWx1ZTEgPT09IHZhbHVlMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEwID0gdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGkgPSAobmFtZSArPSBcIlwiKSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVSZW1vdmUobmFtZSwgaSkpXG4gICAgICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgc3R5bGVSZW1vdmVFbmQobmFtZSkpXG4gICAgICA6IHRoaXMuc3R5bGVUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpXG4gICAgICAgICAgOiBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlICsgXCJcIiksIHByaW9yaXR5KTtcbn1cblxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XG4gICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkodCksIHByaW9yaXR5KTtcbiAgICB9O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fdGV4dCh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy50d2VlbihcInRleHRcIiwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gdGV4dEZ1bmN0aW9uKHR3ZWVuVmFsdWUodGhpcywgXCJ0ZXh0XCIsIHZhbHVlKSlcbiAgICAgIDogdGV4dENvbnN0YW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fdHJhbnNpdGlvbigpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQwID0gdGhpcy5faWQsXG4gICAgICBpZDEgPSBuZXdJZCgpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHZhciBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkMCk7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkMSwgaSwgZ3JvdXAsIHtcbiAgICAgICAgICB0aW1lOiBpbmhlcml0LnRpbWUgKyBpbmhlcml0LmRlbGF5ICsgaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQxKTtcbn1cblxudmFyIGlkID0gMDtcblxuZnVuY3Rpb24gVHJhbnNpdGlvbihncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9pZCA9IGlkO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIGQzU2VsZWN0aW9uLnNlbGVjdGlvbigpLnRyYW5zaXRpb24obmFtZSk7XG59XG5cbmZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBkM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiB0cmFuc2l0aW9uX2ZpbHRlcixcbiAgbWVyZ2U6IHRyYW5zaXRpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25fdHJhbnNpdGlvbixcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiB0cmFuc2l0aW9uX29uLFxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXG4gIGF0dHJUd2VlbjogdHJhbnNpdGlvbl9hdHRyVHdlZW4sXG4gIHN0eWxlOiB0cmFuc2l0aW9uX3N0eWxlLFxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXG4gIHRleHQ6IHRyYW5zaXRpb25fdGV4dCxcbiAgcmVtb3ZlOiB0cmFuc2l0aW9uX3JlbW92ZSxcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXG4gIGRlbGF5OiB0cmFuc2l0aW9uX2RlbGF5LFxuICBkdXJhdGlvbjogdHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlXG59O1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGQzRWFzZS5lYXNlQ3ViaWNJbk91dFxufTtcblxuZnVuY3Rpb24gaW5oZXJpdChub2RlLCBpZCkge1xuICB2YXIgdGltaW5nO1xuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xuICAgIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFRpbWluZy50aW1lID0gZDNUaW1lci5ub3coKSwgZGVmYXVsdFRpbWluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3RyYW5zaXRpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IGQzVGltZXIubm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuXG5kM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XG5kM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBzZWxlY3Rpb25fdHJhbnNpdGlvbjtcblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmZ1bmN0aW9uIGFjdGl2ZShub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlJCQxLFxuICAgICAgaTtcblxuICBpZiAoc2NoZWR1bGVzKSB7XG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBpZiAoKHNjaGVkdWxlJCQxID0gc2NoZWR1bGVzW2ldKS5zdGF0ZSA+IFNDSEVEVUxFRCAmJiBzY2hlZHVsZSQkMS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuZXhwb3J0cy5hY3RpdmUgPSBhY3RpdmU7XG5leHBvcnRzLmludGVycnVwdCA9IGludGVycnVwdDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogKipbR2F1c3NpYW4gZXJyb3IgZnVuY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24pKipcbiAqXG4gKiBUaGUgYGVycm9yRnVuY3Rpb24oeC8oc2QgKiBNYXRoLnNxcnQoMikpKWAgaXMgdGhlIHByb2JhYmlsaXR5IHRoYXQgYSB2YWx1ZSBpbiBhXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uIHdpdGggc3RhbmRhcmQgZGV2aWF0aW9uIHNkIGlzIHdpdGhpbiB4IG9mIHRoZSBtZWFuLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG51bWVyaWNhbCBhcHByb3hpbWF0aW9uIHRvIHRoZSBleGFjdCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfSBlcnJvciBlc3RpbWF0aW9uXG4gKiBAZXhhbXBsZVxuICogZXJyb3JGdW5jdGlvbigxKS50b0ZpeGVkKDIpOyAvLyA9PiAnMC44NCdcbiAqL1xuZnVuY3Rpb24gZXJyb3JGdW5jdGlvbih4Lyo6IG51bWJlciAqLykvKjogbnVtYmVyICovIHtcbiAgICB2YXIgdCA9IDEgLyAoMSArIDAuNSAqIE1hdGguYWJzKHgpKTtcbiAgICB2YXIgdGF1ID0gdCAqIE1hdGguZXhwKC1NYXRoLnBvdyh4LCAyKSAtXG4gICAgICAgIDEuMjY1NTEyMjMgK1xuICAgICAgICAxLjAwMDAyMzY4ICogdCArXG4gICAgICAgIDAuMzc0MDkxOTYgKiBNYXRoLnBvdyh0LCAyKSArXG4gICAgICAgIDAuMDk2Nzg0MTggKiBNYXRoLnBvdyh0LCAzKSAtXG4gICAgICAgIDAuMTg2Mjg4MDYgKiBNYXRoLnBvdyh0LCA0KSArXG4gICAgICAgIDAuMjc4ODY4MDcgKiBNYXRoLnBvdyh0LCA1KSAtXG4gICAgICAgIDEuMTM1MjAzOTggKiBNYXRoLnBvdyh0LCA2KSArXG4gICAgICAgIDEuNDg4NTE1ODcgKiBNYXRoLnBvdyh0LCA3KSAtXG4gICAgICAgIDAuODIyMTUyMjMgKiBNYXRoLnBvdyh0LCA4KSArXG4gICAgICAgIDAuMTcwODcyNzcgKiBNYXRoLnBvdyh0LCA5KSk7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgICByZXR1cm4gMSAtIHRhdTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGF1IC0gMTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXJyb3JGdW5jdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogW1NpbXBsZSBsaW5lYXIgcmVncmVzc2lvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfbGluZWFyX3JlZ3Jlc3Npb24pXG4gKiBpcyBhIHNpbXBsZSB3YXkgdG8gZmluZCBhIGZpdHRlZCBsaW5lXG4gKiBiZXR3ZWVuIGEgc2V0IG9mIGNvb3JkaW5hdGVzLiBUaGlzIGFsZ29yaXRobSBmaW5kcyB0aGUgc2xvcGUgYW5kIHktaW50ZXJjZXB0IG9mIGEgcmVncmVzc2lvbiBsaW5lXG4gKiB1c2luZyB0aGUgbGVhc3Qgc3VtIG9mIHNxdWFyZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGF0YSBhbiBhcnJheSBvZiB0d28tZWxlbWVudCBvZiBhcnJheXMsXG4gKiBsaWtlIGBbWzAsIDFdLCBbMiwgM11dYFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgc2xvcGUgYW5kIGludGVyc2VjdCBvZiByZWdyZXNzaW9uIGxpbmVcbiAqIEBleGFtcGxlXG4gKiBsaW5lYXJSZWdyZXNzaW9uKFtbMCwgMF0sIFsxLCAxXV0pOyAvLyA9PiB7IG06IDEsIGI6IDAgfVxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uKGRhdGEvKjogQXJyYXk8QXJyYXk8bnVtYmVyPj4gKi8pLyo6IHsgbTogbnVtYmVyLCBiOiBudW1iZXIgfSAqLyB7XG5cbiAgICB2YXIgbSwgYjtcblxuICAgIC8vIFN0b3JlIGRhdGEgbGVuZ3RoIGluIGEgbG9jYWwgdmFyaWFibGUgdG8gcmVkdWNlXG4gICAgLy8gcmVwZWF0ZWQgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgLy9pZiB0aGVyZSdzIG9ubHkgb25lIHBvaW50LCBhcmJpdHJhcmlseSBjaG9vc2UgYSBzbG9wZSBvZiAwXG4gICAgLy9hbmQgYSB5LWludGVyY2VwdCBvZiB3aGF0ZXZlciB0aGUgeSBvZiB0aGUgaW5pdGlhbCBwb2ludCBpc1xuICAgIGlmIChkYXRhTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBiID0gZGF0YVswXVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbml0aWFsaXplIG91ciBzdW1zIGFuZCBzY29wZSB0aGUgYG1gIGFuZCBgYmBcbiAgICAgICAgLy8gdmFyaWFibGVzIHRoYXQgZGVmaW5lIHRoZSBsaW5lLlxuICAgICAgICB2YXIgc3VtWCA9IDAsIHN1bVkgPSAwLFxuICAgICAgICAgICAgc3VtWFggPSAwLCBzdW1YWSA9IDA7XG5cbiAgICAgICAgLy8gVXNlIGxvY2FsIHZhcmlhYmxlcyB0byBncmFiIHBvaW50IHZhbHVlc1xuICAgICAgICAvLyB3aXRoIG1pbmltYWwgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICAgICAgdmFyIHBvaW50LCB4LCB5O1xuXG4gICAgICAgIC8vIEdhdGhlciB0aGUgc3VtIG9mIGFsbCB4IHZhbHVlcywgdGhlIHN1bSBvZiBhbGxcbiAgICAgICAgLy8geSB2YWx1ZXMsIGFuZCB0aGUgc3VtIG9mIHheMiBhbmQgKHgqeSkgZm9yIGVhY2hcbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIG1hdGggbm90YXRpb24sIHRoZXNlIHdvdWxkIGJlIFNTX3gsIFNTX3ksIFNTX3h4LCBhbmQgU1NfeHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHggPSBwb2ludFswXTtcbiAgICAgICAgICAgIHkgPSBwb2ludFsxXTtcblxuICAgICAgICAgICAgc3VtWCArPSB4O1xuICAgICAgICAgICAgc3VtWSArPSB5O1xuXG4gICAgICAgICAgICBzdW1YWCArPSB4ICogeDtcbiAgICAgICAgICAgIHN1bVhZICs9IHggKiB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYG1gIGlzIHRoZSBzbG9wZSBvZiB0aGUgcmVncmVzc2lvbiBsaW5lXG4gICAgICAgIG0gPSAoKGRhdGFMZW5ndGggKiBzdW1YWSkgLSAoc3VtWCAqIHN1bVkpKSAvXG4gICAgICAgICAgICAoKGRhdGFMZW5ndGggKiBzdW1YWCkgLSAoc3VtWCAqIHN1bVgpKTtcblxuICAgICAgICAvLyBgYmAgaXMgdGhlIHktaW50ZXJjZXB0IG9mIHRoZSBsaW5lLlxuICAgICAgICBiID0gKHN1bVkgLyBkYXRhTGVuZ3RoKSAtICgobSAqIHN1bVgpIC8gZGF0YUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGJvdGggdmFsdWVzIGFzIGFuIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBtOiBtLFxuICAgICAgICBiOiBiXG4gICAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhclJlZ3Jlc3Npb247XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIEdpdmVuIHRoZSBvdXRwdXQgb2YgYGxpbmVhclJlZ3Jlc3Npb25gOiBhbiBvYmplY3RcbiAqIHdpdGggYG1gIGFuZCBgYmAgdmFsdWVzIGluZGljYXRpbmcgc2xvcGUgYW5kIGludGVyY2VwdCxcbiAqIHJlc3BlY3RpdmVseSwgZ2VuZXJhdGUgYSBsaW5lIGZ1bmN0aW9uIHRoYXQgdHJhbnNsYXRlc1xuICogeCB2YWx1ZXMgaW50byB5IHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWIgb2JqZWN0IHdpdGggYG1gIGFuZCBgYmAgbWVtYmVycywgcmVwcmVzZW50aW5nXG4gKiBzbG9wZSBhbmQgaW50ZXJzZWN0IG9mIGRlc2lyZWQgbGluZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBtZXRob2QgdGhhdCBjb21wdXRlcyB5LXZhbHVlIGF0IGFueSBnaXZlblxuICogeC12YWx1ZSBvbiB0aGUgbGluZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbCA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24oW1swLCAwXSwgWzEsIDFdXSkpO1xuICogbCgwKSAvLyA9IDBcbiAqIGwoMikgLy8gPSAyXG4gKiBsaW5lYXJSZWdyZXNzaW9uTGluZSh7IGI6IDAsIG06IDEgfSkoMSk7IC8vID0+IDFcbiAqIGxpbmVhclJlZ3Jlc3Npb25MaW5lKHsgYjogMSwgbTogMSB9KSgxKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uTGluZShtYi8qOiB7IGI6IG51bWJlciwgbTogbnVtYmVyIH0qLykvKjogRnVuY3Rpb24gKi8ge1xuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgYSBgeWAgdmFsdWUgZm9yIGVhY2hcbiAgICAvLyB4IHZhbHVlIGl0IGlzIGdpdmVuLCBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIGBiYCBhbmQgYGFgXG4gICAgLy8gdGhhdCB3ZSBqdXN0IGNvbXB1dGVkLlxuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBtYi5iICsgKG1iLm0gKiB4KTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHN1bSA9IHJlcXVpcmUoJy4vc3VtJyk7XG5cbi8qKlxuICogVGhlIG1lYW4sIF9hbHNvIGtub3duIGFzIGF2ZXJhZ2VfLFxuICogaXMgdGhlIHN1bSBvZiBhbGwgdmFsdWVzIG92ZXIgdGhlIG51bWJlciBvZiB2YWx1ZXMuXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhpcyBydW5zIG9uIGBPKG4pYCwgbGluZWFyIHRpbWUgaW4gcmVzcGVjdCB0byB0aGUgYXJyYXlcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gb25lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWFuXG4gKiBAZXhhbXBsZVxuICogbWVhbihbMCwgMTBdKTsgLy8gPT4gNVxuICovXG5mdW5jdGlvbiBtZWFuKHggLyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIC8vIFRoZSBtZWFuIG9mIG5vIG51bWJlcnMgaXMgbnVsbFxuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtKHgpIC8geC5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVhbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBxdWFudGlsZVNvcnRlZCA9IHJlcXVpcmUoJy4vcXVhbnRpbGVfc29ydGVkJyk7XG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCcuL3F1aWNrc2VsZWN0Jyk7XG5cbi8qKlxuICogVGhlIFtxdWFudGlsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUpOlxuICogdGhpcyBpcyBhIHBvcHVsYXRpb24gcXVhbnRpbGUsIHNpbmNlIHdlIGFzc3VtZSB0byBrbm93IHRoZSBlbnRpcmVcbiAqIGRhdGFzZXQgaW4gdGhpcyBsaWJyYXJ5LiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICogW1F1YW50aWxlcyBvZiBhIFBvcHVsYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUjUXVhbnRpbGVzX29mX2FfcG9wdWxhdGlvbilcbiAqIGFsZ29yaXRobSBmcm9tIHdpa2lwZWRpYS5cbiAqXG4gKiBTYW1wbGUgaXMgYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2YgbnVtYmVycyxcbiAqIGFuZCBwIGlzIGVpdGhlciBhIGRlY2ltYWwgbnVtYmVyIGZyb20gMCB0byAxIG9yIGFuIGFycmF5IG9mIGRlY2ltYWxcbiAqIG51bWJlcnMgZnJvbSAwIHRvIDEuXG4gKiBJbiB0ZXJtcyBvZiBhIGsvcSBxdWFudGlsZSwgcCA9IGsvcSAtIGl0J3MganVzdCBkZWFsaW5nIHdpdGggZnJhY3Rpb25zIG9yIGRlYWxpbmdcbiAqIHdpdGggZGVjaW1hbCB2YWx1ZXMuXG4gKiBXaGVuIHAgaXMgYW4gYXJyYXksIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlzIGFsc28gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYXBwcm9wcmlhdGVcbiAqIHF1YW50aWxlcyBpbiBpbnB1dCBvcmRlclxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHAgdGhlIGRlc2lyZWQgcXVhbnRpbGUsIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge251bWJlcn0gcXVhbnRpbGVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZShbMywgNiwgNywgOCwgOCwgOSwgMTAsIDEzLCAxNSwgMTYsIDIwXSwgMC41KTsgLy8gPT4gOVxuICovXG5mdW5jdGlvbiBxdWFudGlsZSh4IC8qOiBBcnJheTxudW1iZXI+ICovLCBwIC8qOiBBcnJheTxudW1iZXI+IHwgbnVtYmVyICovKSB7XG4gICAgdmFyIGNvcHkgPSB4LnNsaWNlKCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgICAvLyByZWFycmFuZ2UgZWxlbWVudHMgc28gdGhhdCBlYWNoIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIHJlcXVlc3RlZFxuICAgICAgICAvLyBxdWFudGlsZSBpcyBvbiBhIHBsYWNlIGl0IHdvdWxkIGJlIGlmIHRoZSBhcnJheSB3YXMgZnVsbHkgc29ydGVkXG4gICAgICAgIG11bHRpUXVhbnRpbGVTZWxlY3QoY29weSwgcCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0ZWQgcXVhbnRpbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcXVhbnRpbGVTb3J0ZWQoY29weSwgcFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IHF1YW50aWxlSW5kZXgoY29weS5sZW5ndGgsIHApO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChjb3B5LCBpZHgsIDAsIGNvcHkubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBxdWFudGlsZVNvcnRlZChjb3B5LCBwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlU2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoayAlIDEgPT09IDApIHtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgayA9IE1hdGguZmxvb3Ioayk7XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIGsgKyAxLCBrICsgMSwgcmlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbXVsdGlRdWFudGlsZVNlbGVjdChhcnIsIHApIHtcbiAgICB2YXIgaW5kaWNlcyA9IFswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHF1YW50aWxlSW5kZXgoYXJyLmxlbmd0aCwgcFtpXSkpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2goYXJyLmxlbmd0aCAtIDEpO1xuICAgIGluZGljZXMuc29ydChjb21wYXJlKTtcblxuICAgIHZhciBzdGFjayA9IFswLCBpbmRpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgciA9IE1hdGguY2VpbChzdGFjay5wb3AoKSk7XG4gICAgICAgIHZhciBsID0gTWF0aC5mbG9vcihzdGFjay5wb3AoKSk7XG4gICAgICAgIGlmIChyIC0gbCA8PSAxKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IoKGwgKyByKSAvIDIpO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChhcnIsIGluZGljZXNbbV0sIGluZGljZXNbbF0sIGluZGljZXNbcl0pO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobCwgbSwgbSwgcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlSW5kZXgobGVuIC8qOiBudW1iZXIgKi8sIHAgLyo6IG51bWJlciAqLykvKjpudW1iZXIqLyB7XG4gICAgdmFyIGlkeCA9IGxlbiAqIHA7XG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgaW5kZXhcbiAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG4gICAgfSBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMCwgZGlyZWN0bHkgcmV0dXJuIHRoZSBmaXJzdCBpbmRleFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgaW5kZXggaXMgbm90IGludGVnZXIsIHJldHVybiB0aGUgbmV4dCBpbmRleCBpbiBhcnJheVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGlkeCkgLSAxO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHJldHVybiB0aGUgbWlkZGxlIG9mIHR3byBpbmRpY2VzXG4gICAgICAgIC8vIGFyb3VuZCBxdWFudGlsZSB0byBpbmRpY2F0ZSB0aGF0IHdlIG5lZWQgYW4gYXZlcmFnZSB2YWx1ZSBvZiB0aGUgdHdvXG4gICAgICAgIHJldHVybiBpZHggLSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgaW5kZXhcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgaW5kZXhcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVhbnRpbGU7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHF1YW50aWxlczogd2hlbiB5b3Uga25vd1xuICogdGhhdCB0aGUgb3JkZXIgaXMgc29ydGVkLCB5b3UgZG9uJ3QgbmVlZCB0byByZS1zb3J0IGl0LCBhbmQgdGhlIGNvbXB1dGF0aW9uc1xuICogYXJlIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gcCBkZXNpcmVkIHF1YW50aWxlOiBhIG51bWJlciBiZXR3ZWVuIDAgdG8gMSwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBxdWFudGlsZSB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHAgaXggb3V0c2lkZSBvZiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDFcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVTb3J0ZWQoWzMsIDYsIDcsIDgsIDgsIDksIDEwLCAxMywgMTUsIDE2LCAyMF0sIDAuNSk7IC8vID0+IDlcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQoeCAvKjogQXJyYXk8bnVtYmVyPiAqLywgcCAvKjogbnVtYmVyICovKS8qOm51bWJlciovIHtcbiAgICB2YXIgaWR4ID0geC5sZW5ndGggKiBwO1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3F1YW50aWxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50LicpO1xuICAgIH0gZWxzZSBpZiAocCA8IDAgfHwgcCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxdWFudGlsZXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEnKTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFt4Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIDAsIGRpcmVjdGx5IHJldHVybiB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFswXTtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgcCBpcyBub3QgaW50ZWdlciwgcmV0dXJuIHRoZSBuZXh0IGVsZW1lbnQgaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHhbTWF0aC5jZWlsKGlkeCkgLSAxXTtcbiAgICB9IGVsc2UgaWYgKHgubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhpcyBudW1iZXJcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHZhbHVlLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgcmV0dXJuICh4W2lkeCAtIDFdICsgeFtpZHhdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgdmFsdWVcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgeCB2YWx1ZSBhdCB0aGUgaW5kZXguXG4gICAgICAgIHJldHVybiB4W2lkeF07XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YW50aWxlU29ydGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBxdWlja3NlbGVjdDtcblxuLyoqXG4gKiBSZWFycmFuZ2UgaXRlbXMgaW4gYGFycmAgc28gdGhhdCBhbGwgaXRlbXMgaW4gYFtsZWZ0LCBrXWAgcmFuZ2UgYXJlIHRoZSBzbWFsbGVzdC5cbiAqIFRoZSBga2AtdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIGAoayAtIGxlZnQgKyAxKWAtdGggc21hbGxlc3QgdmFsdWUgaW4gYFtsZWZ0LCByaWdodF1gLlxuICpcbiAqIEltcGxlbWVudHMgRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxveWQtUml2ZXN0X2FsZ29yaXRobVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFyciBpbnB1dCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGsgcGl2b3QgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCByaWdodCBpbmRleFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXJyID0gWzY1LCAyOCwgNTksIDMzLCAyMSwgNTYsIDIyLCA5NSwgNTAsIDEyLCA5MCwgNTMsIDI4LCA3NywgMzldO1xuICogcXVpY2tzZWxlY3QoYXJyLCA4KTtcbiAqIC8vID0gWzM5LCAyOCwgMjgsIDMzLCAyMSwgMTIsIDIyLCA1MCwgNTMsIDU2LCA1OSwgNjUsIDkwLCA3NywgOTVdXG4gKi9cbmZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciAvKjogQXJyYXk8bnVtYmVyPiAqLywgayAvKjogbnVtYmVyICovLCBsZWZ0IC8qOiBudW1iZXIgKi8sIHJpZ2h0IC8qOiBudW1iZXIgKi8pIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCAwO1xuICAgIHJpZ2h0ID0gcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKTtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgLy8gNjAwIGFuZCAwLjUgYXJlIGFyYml0cmFyeSBjb25zdGFudHMgY2hvc2VuIGluIHRoZSBvcmlnaW5hbCBwYXBlciB0byBtaW5pbWl6ZSBleGVjdXRpb24gdGltZVxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbik7XG4gICAgICAgICAgICBpZiAobSAtIG4gLyAyIDwgMCkgc2QgKj0gLTE7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChhcnJbcmlnaHRdID4gdCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChhcnJbaV0gPCB0KSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2pdID4gdCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycltsZWZ0XSA9PT0gdCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBzYW1wbGVDb3ZhcmlhbmNlID0gcmVxdWlyZSgnLi9zYW1wbGVfY292YXJpYW5jZScpO1xudmFyIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uID0gcmVxdWlyZSgnLi9zYW1wbGVfc3RhbmRhcmRfZGV2aWF0aW9uJyk7XG5cbi8qKlxuICogVGhlIFtjb3JyZWxhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db3JyZWxhdGlvbl9hbmRfZGVwZW5kZW5jZSkgaXNcbiAqIGEgbWVhc3VyZSBvZiBob3cgY29ycmVsYXRlZCB0d28gZGF0YXNldHMgYXJlLCBiZXR3ZWVuIC0xIGFuZCAxXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGZpcnN0IGlucHV0XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHkgc2Vjb25kIGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzYW1wbGUgY29ycmVsYXRpb25cbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVDb3JyZWxhdGlvbihbMSwgMiwgMywgNCwgNSwgNl0sIFsyLCAyLCAzLCA0LCA1LCA2MF0pLnRvRml4ZWQoMik7XG4gKiAvLyA9PiAnMC42OSdcbiAqL1xuZnVuY3Rpb24gc2FtcGxlQ29ycmVsYXRpb24oeC8qOiBBcnJheTxudW1iZXI+ICovLCB5Lyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIHZhciBjb3YgPSBzYW1wbGVDb3ZhcmlhbmNlKHgsIHkpLFxuICAgICAgICB4c3RkID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeCksXG4gICAgICAgIHlzdGQgPSBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih5KTtcblxuICAgIHJldHVybiBjb3YgLyB4c3RkIC8geXN0ZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVDb3JyZWxhdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBtZWFuID0gcmVxdWlyZSgnLi9tZWFuJyk7XG5cbi8qKlxuICogW1NhbXBsZSBjb3ZhcmlhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYW1wbGVfbWVhbl9hbmRfc2FtcGxlQ292YXJpYW5jZSkgb2YgdHdvIGRhdGFzZXRzOlxuICogaG93IG11Y2ggZG8gdGhlIHR3byBkYXRhc2V0cyBtb3ZlIHRvZ2V0aGVyP1xuICogeCBhbmQgeSBhcmUgdHdvIGRhdGFzZXRzLCByZXByZXNlbnRlZCBhcyBhcnJheXMgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBzYW1wbGUgb2YgdHdvIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geSBhIHNhbXBsZSBvZiB0d28gb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggYW5kIHkgZG8gbm90IGhhdmUgZXF1YWwgbGVuZ3Roc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggb3IgeSBoYXZlIGxlbmd0aCBvZiBvbmUgb3IgbGVzc1xuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIGNvdmFyaWFuY2VcbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVDb3ZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1LCA2XSwgWzYsIDUsIDQsIDMsIDIsIDFdKTsgLy8gPT4gLTMuNVxuICovXG5mdW5jdGlvbiBzYW1wbGVDb3ZhcmlhbmNlKHggLyo6QXJyYXk8bnVtYmVyPiovLCB5IC8qOkFycmF5PG51bWJlcj4qLykvKjpudW1iZXIqLyB7XG5cbiAgICAvLyBUaGUgdHdvIGRhdGFzZXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggd2hpY2ggbXVzdCBiZSBtb3JlIHRoYW4gMVxuICAgIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIHNhbXBsZXMgd2l0aCBlcXVhbCBsZW5ndGhzJyk7XG4gICAgfVxuXG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzIGluIGVhY2ggc2FtcGxlJyk7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBtZWFuIG9mIGVhY2ggZGF0YXNldCBzbyB0aGF0IHdlIGNhbiBqdWRnZSBlYWNoXG4gICAgLy8gdmFsdWUgb2YgdGhlIGRhdGFzZXQgZmFpcmx5IGFzIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIG1lYW4uIHRoaXNcbiAgICAvLyB3YXksIGlmIG9uZSBkYXRhc2V0IGlzIFsxLCAyLCAzXSBhbmQgWzIsIDMsIDRdLCB0aGVpciBjb3ZhcmlhbmNlXG4gICAgLy8gZG9lcyBub3Qgc3VmZmVyIGJlY2F1c2Ugb2YgdGhlIGRpZmZlcmVuY2UgaW4gYWJzb2x1dGUgdmFsdWVzXG4gICAgdmFyIHhtZWFuID0gbWVhbih4KSxcbiAgICAgICAgeW1lYW4gPSBtZWFuKHkpLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBvZiB2YWx1ZXMsIHRoZSBjb3ZhcmlhbmNlIGluY3JlYXNlcyB3aGVuIHRoZWlyXG4gICAgLy8gZGlmZmVyZW5jZSBmcm9tIHRoZSBtZWFuIGlzIGFzc29jaWF0ZWQgLSBpZiBib3RoIGFyZSB3ZWxsIGFib3ZlXG4gICAgLy8gb3IgaWYgYm90aCBhcmUgd2VsbCBiZWxvd1xuICAgIC8vIHRoZSBtZWFuLCB0aGUgY292YXJpYW5jZSBpbmNyZWFzZXMgc2lnbmlmaWNhbnRseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9ICh4W2ldIC0geG1lYW4pICogKHlbaV0gLSB5bWVhbik7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIHRoZSBjb3ZhcmlhbmNlIGlzIHdlaWdodGVkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGRhdGFzZXRzLlxuICAgIHJldHVybiBzdW0gLyBiZXNzZWxzQ29ycmVjdGlvbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVDb3ZhcmlhbmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHNhbXBsZVZhcmlhbmNlID0gcmVxdWlyZSgnLi9zYW1wbGVfdmFyaWFuY2UnKTtcblxuLyoqXG4gKiBUaGUgW3NhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfZGV2aWF0aW9uI1NhbXBsZV9zdGFuZGFyZF9kZXZpYXRpb24pXG4gKiBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHNhbXBsZSB2YXJpYW5jZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXQgYXJyYXlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVTdGFuZGFyZERldmlhdGlvbihbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pLnRvRml4ZWQoMik7XG4gKiAvLyA9PiAnMi4xNCdcbiAqL1xuZnVuY3Rpb24gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeC8qOkFycmF5PG51bWJlcj4qLykvKjpudW1iZXIqLyB7XG4gICAgLy8gVGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBubyBudW1iZXJzIGlzIG51bGxcbiAgICB2YXIgc2FtcGxlVmFyaWFuY2VYID0gc2FtcGxlVmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydChzYW1wbGVWYXJpYW5jZVgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHN1bU50aFBvd2VyRGV2aWF0aW9ucyA9IHJlcXVpcmUoJy4vc3VtX250aF9wb3dlcl9kZXZpYXRpb25zJyk7XG5cbi8qKlxuICogVGhlIFtzYW1wbGUgdmFyaWFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhcmlhbmNlI1NhbXBsZV92YXJpYW5jZSlcbiAqIGlzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW4uIFRoZSBzYW1wbGUgdmFyaWFuY2VcbiAqIGlzIGRpc3Rpbmd1aXNoZWQgZnJvbSB0aGUgdmFyaWFuY2UgYnkgdGhlIHVzYWdlIG9mIFtCZXNzZWwncyBDb3JyZWN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZXNzZWwnc19jb3JyZWN0aW9uKTpcbiAqIGluc3RlYWQgb2YgZGl2aWRpbmcgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgYnkgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQsXG4gKiBpdCBpcyBkaXZpZGVkIGJ5IHRoZSBsZW5ndGggbWludXMgb25lLiBUaGlzIGNvcnJlY3RzIHRoZSBiaWFzIGluIGVzdGltYXRpbmdcbiAqIGEgdmFsdWUgZnJvbSBhIHNldCB0aGF0IHlvdSBkb24ndCBrbm93IGlmIGZ1bGwuXG4gKlxuICogUmVmZXJlbmNlczpcbiAqICogW1dvbGZyYW0gTWF0aFdvcmxkIG9uIFNhbXBsZSBWYXJpYW5jZV0oaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TYW1wbGVWYXJpYW5jZS5odG1sKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiB0d28gb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gMlxuICogQHJldHVybiB7bnVtYmVyfSBzYW1wbGUgdmFyaWFuY2VcbiAqIEBleGFtcGxlXG4gKiBzYW1wbGVWYXJpYW5jZShbMSwgMiwgMywgNCwgNV0pOyAvLyA9PiAyLjVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlVmFyaWFuY2UoeCAvKjogQXJyYXk8bnVtYmVyPiAqLykvKjpudW1iZXIqLyB7XG4gICAgLy8gVGhlIHZhcmlhbmNlIG9mIG5vIG51bWJlcnMgaXMgbnVsbFxuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYW1wbGVWYXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gZGF0YSBwb2ludHMnKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtU3F1YXJlZERldmlhdGlvbnNWYWx1ZSA9IHN1bU50aFBvd2VyRGV2aWF0aW9ucyh4LCAyKTtcblxuICAgIC8vIHRoaXMgaXMgQmVzc2VscycgQ29ycmVjdGlvbjogYW4gYWRqdXN0bWVudCBtYWRlIHRvIHNhbXBsZSBzdGF0aXN0aWNzXG4gICAgLy8gdGhhdCBhbGxvd3MgZm9yIHRoZSByZWR1Y2VkIGRlZ3JlZSBvZiBmcmVlZG9tIGVudGFpbGVkIGluIGNhbGN1bGF0aW5nXG4gICAgLy8gdmFsdWVzIGZyb20gc2FtcGxlcyByYXRoZXIgdGhhbiBjb21wbGV0ZSBwb3B1bGF0aW9ucy5cbiAgICB2YXIgYmVzc2Vsc0NvcnJlY3Rpb24gPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICAvLyBGaW5kIHRoZSBtZWFuIHZhbHVlIG9mIHRoYXQgbGlzdFxuICAgIHJldHVybiBzdW1TcXVhcmVkRGV2aWF0aW9uc1ZhbHVlIC8gYmVzc2Vsc0NvcnJlY3Rpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FtcGxlVmFyaWFuY2U7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG52YXIgdmFyaWFuY2UgPSByZXF1aXJlKCcuL3ZhcmlhbmNlJyk7XG5cbi8qKlxuICogVGhlIFtzdGFuZGFyZCBkZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfZGV2aWF0aW9uKVxuICogaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YXJpYW5jZS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIHRoZSBwb3B1bGF0aW9uXG4gKiBzdGFuZGFyZCBkZXZpYXRpb24uIEl0J3MgdXNlZnVsIGZvciBtZWFzdXJpbmcgdGhlIGFtb3VudFxuICogb2YgdmFyaWF0aW9uIG9yIGRpc3BlcnNpb24gaW4gYSBzZXQgb2YgdmFsdWVzLlxuICpcbiAqIFN0YW5kYXJkIGRldmlhdGlvbiBpcyBvbmx5IGFwcHJvcHJpYXRlIGZvciBmdWxsLXBvcHVsYXRpb24ga25vd2xlZGdlOiBmb3JcbiAqIHNhbXBsZXMgb2YgYSBwb3B1bGF0aW9uLCB7QGxpbmsgc2FtcGxlU3RhbmRhcmREZXZpYXRpb259IGlzXG4gKiBtb3JlIGFwcHJvcHJpYXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc3RhbmRhcmQgZGV2aWF0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyaWFuY2UoWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gNFxuICogc3RhbmRhcmREZXZpYXRpb24oWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBzdGFuZGFyZERldmlhdGlvbih4IC8qOiBBcnJheTxudW1iZXI+ICovKS8qOm51bWJlciovIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciB2ID0gdmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFuZGFyZERldmlhdGlvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbi8qKlxuICogT3VyIGRlZmF1bHQgc3VtIGlzIHRoZSBbS2FoYW4tQmFidXNrYSBhbGdvcml0aG1dKGh0dHBzOi8vcGRmcy5zZW1hbnRpY3NjaG9sYXIub3JnLzE3NjAvN2Q0NjdjZGExZDAyNzdhZDI3MmRlYjIxMTM1MzMxMzFkYzA5LnBkZikuXG4gKiBUaGlzIG1ldGhvZCBpcyBhbiBpbXByb3ZlbWVudCBvdmVyIHRoZSBjbGFzc2ljYWxcbiAqIFtLYWhhbiBzdW1tYXRpb24gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYWhhbl9zdW1tYXRpb25fYWxnb3JpdGhtKS5cbiAqIEl0IGFpbXMgYXQgY29tcHV0aW5nIHRoZSBzdW0gb2YgYSBsaXN0IG9mIG51bWJlcnMgd2hpbGUgY29ycmVjdGluZyBmb3JcbiAqIGZsb2F0aW5nLXBvaW50IGVycm9ycy4gVHJhZGl0aW9uYWxseSwgc3VtcyBhcmUgY2FsY3VsYXRlZCBhcyBtYW55XG4gKiBzdWNjZXNzaXZlIGFkZGl0aW9ucywgZWFjaCBvbmUgd2l0aCBpdHMgb3duIGZsb2F0aW5nLXBvaW50IHJvdW5kb2ZmLiBUaGVzZVxuICogbG9zc2VzIGluIHByZWNpc2lvbiBhZGQgdXAgYXMgdGhlIG51bWJlciBvZiBudW1iZXJzIGluY3JlYXNlcy4gVGhpcyBhbHRlcm5hdGl2ZVxuICogYWxnb3JpdGhtIGlzIG1vcmUgYWNjdXJhdGUgdGhhbiB0aGUgc2ltcGxlIHdheSBvZiBjYWxjdWxhdGluZyBzdW1zIGJ5IHNpbXBsZVxuICogYWRkaXRpb24uXG4gKlxuICogVGhpcyBydW5zIG9uIGBPKG4pYCwgbGluZWFyIHRpbWUgaW4gcmVzcGVjdCB0byB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHN1bSBvZiBhbGwgaW5wdXQgbnVtYmVyc1xuICogQGV4YW1wbGVcbiAqIHN1bShbMSwgMiwgM10pOyAvLyA9PiA2XG4gKi9cbmZ1bmN0aW9uIHN1bSh4Lyo6IEFycmF5PG51bWJlcj4gKi8pLyo6IG51bWJlciAqLyB7XG5cbiAgICAvLyBJZiB0aGUgYXJyYXkgaXMgZW1wdHksIHdlIG5lZWRuJ3QgYm90aGVyIGNvbXB1dGluZyBpdHMgc3VtXG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemluZyB0aGUgc3VtIGFzIHRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIGFycmF5XG4gICAgdmFyIHN1bSA9IHhbMF07XG5cbiAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIHRoZSBmbG9hdGluZy1wb2ludCBlcnJvciBjb3JyZWN0aW9uXG4gICAgdmFyIGNvcnJlY3Rpb24gPSAwO1xuXG4gICAgdmFyIHRyYW5zaXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IHN1bSArIHhbaV07XG5cbiAgICAgICAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY29ycmVjdGlvbiBpbiBhIGRpZmZlcmVudCBmYXNoaW9uXG4gICAgICAgIC8vIGlmIHRoZSBuZXcgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBhYnNvbHV0ZSBzdW1cbiAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPj0gTWF0aC5hYnMoeFtpXSkpIHtcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gKz0gKChzdW0gLSB0cmFuc2l0aW9uKSArIHhbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29ycmVjdGlvbiArPSAoKHhbaV0gLSB0cmFuc2l0aW9uKSArIHN1bSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gPSB0cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIFJldHVybmluZyB0aGUgY29ycmVjdGVkIHN1bVxuICAgIHJldHVybiBzdW0gKyBjb3JyZWN0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1bTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIEBmbG93ICovXG5cbnZhciBtZWFuID0gcmVxdWlyZSgnLi9tZWFuJyk7XG5cbi8qKlxuICogVGhlIHN1bSBvZiBkZXZpYXRpb25zIHRvIHRoZSBOdGggcG93ZXIuXG4gKiBXaGVuIG49MiBpdCdzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zLlxuICogV2hlbiBuPTMgaXQncyB0aGUgc3VtIG9mIGN1YmVkIGRldmlhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4XG4gKiBAcGFyYW0ge251bWJlcn0gbiBwb3dlclxuICogQHJldHVybnMge251bWJlcn0gc3VtIG9mIG50aCBwb3dlciBkZXZpYXRpb25zXG4gKiBAZXhhbXBsZVxuICogdmFyIGlucHV0ID0gWzEsIDIsIDNdO1xuICogLy8gc2luY2UgdGhlIHZhcmlhbmNlIG9mIGEgc2V0IGlzIHRoZSBtZWFuIHNxdWFyZWRcbiAqIC8vIGRldmlhdGlvbnMsIHdlIGNhbiBjYWxjdWxhdGUgdGhhdCB3aXRoIHN1bU50aFBvd2VyRGV2aWF0aW9uczpcbiAqIHZhciB2YXJpYW5jZSA9IHN1bU50aFBvd2VyRGV2aWF0aW9ucyhpbnB1dCkgLyBpbnB1dC5sZW5ndGg7XG4gKi9cbmZ1bmN0aW9uIHN1bU50aFBvd2VyRGV2aWF0aW9ucyh4Lyo6IEFycmF5PG51bWJlcj4gKi8sIG4vKjogbnVtYmVyICovKS8qOm51bWJlciovIHtcbiAgICB2YXIgbWVhblZhbHVlID0gbWVhbih4KSxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgdGVtcFZhbHVlLFxuICAgICAgICBpO1xuXG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb246IHdoZW4gbiBpcyAyICh3ZSdyZSBjb21wdXRpbmcgYSBudW1iZXIgc3F1YXJlZCksXG4gICAgLy8gbXVsdGlwbHlpbmcgdGhlIG51bWJlciBieSBpdHNlbGYgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiB1c2luZ1xuICAgIC8vIHRoZSBNYXRoLnBvdyBtZXRob2QuXG4gICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgICAgICBzdW0gKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4W2ldIC0gbWVhblZhbHVlLCBuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdW07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VtTnRoUG93ZXJEZXZpYXRpb25zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogQGZsb3cgKi9cblxudmFyIHN1bU50aFBvd2VyRGV2aWF0aW9ucyA9IHJlcXVpcmUoJy4vc3VtX250aF9wb3dlcl9kZXZpYXRpb25zJyk7XG5cbi8qKlxuICogVGhlIFt2YXJpYW5jZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYW5jZSlcbiAqIGlzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW4uXG4gKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB2YXJpYW5jZSwgbm90IHNhbXBsZSB2YXJpYW5jZTpcbiAqIHNlZSB0aGUgYHNhbXBsZVZhcmlhbmNlYCBtZXRob2QgaWYgeW91IHdhbnQgYSBzYW1wbGUgbWVhc3VyZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBwb3B1bGF0aW9uIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB2YXJpYW5jZTogYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cbiAqIHplcm8gaW5kaWNhdGVzIHRoYXQgYWxsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHgncyBsZW5ndGggaXMgMFxuICogQGV4YW1wbGVcbiAqIHZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1LCA2XSk7IC8vID0+IDIuOTE2NjY2NjY2NjY2NjY2NVxuICovXG5mdW5jdGlvbiB2YXJpYW5jZSh4Lyo6IEFycmF5PG51bWJlcj4gKi8pLyo6bnVtYmVyKi8ge1xuICAgIC8vIFRoZSB2YXJpYW5jZSBvZiBubyBudW1iZXJzIGlzIG51bGxcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludCcpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIG1lYW4gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGJldHdlZW4gdGhlXG4gICAgLy8gbWVhbiB2YWx1ZSBhbmQgZWFjaCB2YWx1ZS5cbiAgICByZXR1cm4gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgsIDIpIC8geC5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFyaWFuY2U7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBAZmxvdyAqL1xuXG4vKipcbiAqIFRoZSBbWi1TY29yZSwgb3IgU3RhbmRhcmQgU2NvcmVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfc2NvcmUpLlxuICpcbiAqIFRoZSBzdGFuZGFyZCBzY29yZSBpcyB0aGUgbnVtYmVyIG9mIHN0YW5kYXJkIGRldmlhdGlvbnMgYW4gb2JzZXJ2YXRpb25cbiAqIG9yIGRhdHVtIGlzIGFib3ZlIG9yIGJlbG93IHRoZSBtZWFuLiBUaHVzLCBhIHBvc2l0aXZlIHN0YW5kYXJkIHNjb3JlXG4gKiByZXByZXNlbnRzIGEgZGF0dW0gYWJvdmUgdGhlIG1lYW4sIHdoaWxlIGEgbmVnYXRpdmUgc3RhbmRhcmQgc2NvcmVcbiAqIHJlcHJlc2VudHMgYSBkYXR1bSBiZWxvdyB0aGUgbWVhbi4gSXQgaXMgYSBkaW1lbnNpb25sZXNzIHF1YW50aXR5XG4gKiBvYnRhaW5lZCBieSBzdWJ0cmFjdGluZyB0aGUgcG9wdWxhdGlvbiBtZWFuIGZyb20gYW4gaW5kaXZpZHVhbCByYXdcbiAqIHNjb3JlIGFuZCB0aGVuIGRpdmlkaW5nIHRoZSBkaWZmZXJlbmNlIGJ5IHRoZSBwb3B1bGF0aW9uIHN0YW5kYXJkXG4gKiBkZXZpYXRpb24uXG4gKlxuICogVGhlIHotc2NvcmUgaXMgb25seSBkZWZpbmVkIGlmIG9uZSBrbm93cyB0aGUgcG9wdWxhdGlvbiBwYXJhbWV0ZXJzO1xuICogaWYgb25lIG9ubHkgaGFzIGEgc2FtcGxlIHNldCwgdGhlbiB0aGUgYW5hbG9nb3VzIGNvbXB1dGF0aW9uIHdpdGhcbiAqIHNhbXBsZSBtZWFuIGFuZCBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIHlpZWxkcyB0aGVcbiAqIFN0dWRlbnQncyB0LXN0YXRpc3RpYy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFuZGFyZERldmlhdGlvblxuICogQHJldHVybiB7bnVtYmVyfSB6IHNjb3JlXG4gKiBAZXhhbXBsZVxuICogelNjb3JlKDc4LCA4MCwgNSk7IC8vID0+IC0wLjRcbiAqL1xuZnVuY3Rpb24gelNjb3JlKHgvKjpudW1iZXIqLywgbWVhbi8qOm51bWJlciovLCBzdGFuZGFyZERldmlhdGlvbi8qOm51bWJlciovKS8qOm51bWJlciovIHtcbiAgICByZXR1cm4gKHggLSBtZWFuKSAvIHN0YW5kYXJkRGV2aWF0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHpTY29yZTtcbiIsImltcG9ydCB7Q2hhcnRXaXRoQ29sb3JHcm91cHMsIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7TGVnZW5kfSBmcm9tIFwiLi9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBCYXJDaGFydENvbmZpZyBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnIHtcblxuICAgIHN2Z0NsYXNzID0gdGhpcy5jc3NDbGFzc1ByZWZpeCArICdiYXItY2hhcnQnO1xuICAgIHNob3dMZWdlbmQgPSB0cnVlO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTtcbiAgICB4ID0gey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsXG4gICAgICAgIGtleTogMCxcbiAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IFV0aWxzLmlzTnVtYmVyKGQpID8gZCA6IGRba2V5XSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzY2FsZTogXCJvcmRpbmFsXCIsXG4gICAgICAgIG9yaWVudDogXCJib3R0b21cIixcbiAgICAgICAgdGlja3M6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHkgPSB7Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICBrZXk6IDEsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBVdGlscy5pc051bWJlcihkKSA/IGQgOiBkW2tleV0sIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsLFxuICAgICAgICBvcmllbnQ6IFwibGVmdFwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgdHJhbnNpdGlvbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYXJDaGFydCBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzIHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEJhckNoYXJ0Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgQmFyQ2hhcnRDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54ID0ge307XG4gICAgICAgIHRoaXMucGxvdC55ID0ge307XG5cbiAgICAgICAgdGhpcy5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgdGhpcy5zZXR1cFkoKTtcbiAgICAgICAgdGhpcy5zZXR1cFgoKTtcbiAgICAgICAgdGhpcy5zZXR1cEdyb3VwU3RhY2tzKCk7XG4gICAgICAgIHRoaXMuc2V0dXBZRG9tYWluKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBzZXR1cFgoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLng7XG5cbiAgICAgICAgLyogKlxuICAgICAgICAgKiB2YWx1ZSBhY2Nlc3NvciAtIHJldHVybnMgdGhlIHZhbHVlIHRvIGVuY29kZSBmb3IgYSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICAgICAgICogc2NhbGUgLSBtYXBzIHZhbHVlIHRvIGEgdmlzdWFsIGRpc3BsYXkgZW5jb2RpbmcsIHN1Y2ggYXMgYSBwaXhlbCBwb3NpdGlvbi5cbiAgICAgICAgICogbWFwIGZ1bmN0aW9uIC0gbWFwcyBmcm9tIGRhdGEgdmFsdWUgdG8gZGlzcGxheSB2YWx1ZVxuICAgICAgICAgKiBheGlzIC0gc2V0cyB1cCBheGlzXG4gICAgICAgICAqKi9cbiAgICAgICAgeC52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZShkLCBjb25mLmtleSk7XG4gICAgICAgIHguc2NhbGUgPSBkMy5zY2FsZUJhbmQoKS5yYW5nZShbMCwgcGxvdC53aWR0aF0pLnBhZGRpbmdJbm5lciguMDgpO1xuICAgICAgICB4Lm1hcCA9IGQgPT4geC5zY2FsZSh4LnZhbHVlKGQpKTtcblxuICAgICAgICB4LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB4LnNjYWxlKTtcbiAgICAgICAgaWYgKGNvbmYudGlja3MpIHtcbiAgICAgICAgICAgIHguYXhpcy50aWNrcyhjb25mLnRpY2tzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb21haW4gPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5jb25maWcuc2VyaWVzKSB7XG4gICAgICAgICAgICBkb21haW4gPSBkMy5tYXAoZGF0YSwgeC52YWx1ZSkua2V5cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tYWluID0gZDMubWFwKGRhdGFbMF0udmFsdWVzLCB4LnZhbHVlKS5rZXlzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB5LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlKGQsIGNvbmYua2V5KTtcbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFtwbG90LmhlaWdodCwgMF0pO1xuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcblxuICAgIH07XG5cbiAgICBzZXR1cFlEb21haW4oKSB7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICB2YXIgeVN0YWNrTWF4ID0gZDMubWF4KHBsb3QubGF5ZXJzLCBsYXllciA9PiBkMy5tYXgobGF5ZXIucG9pbnRzLCBkID0+IGQueTAgKyBkLnkpKTtcblxuXG4gICAgICAgIC8vIHZhciBtaW4gPSBkMy5taW4oZGF0YSwgcz0+ZDMubWluKHMudmFsdWVzLCBwbG90LnkudmFsdWUpKTtcbiAgICAgICAgdmFyIG1heCA9IHlTdGFja01heDtcbiAgICAgICAgZG9tYWluID0gWzAsIG1heF07XG5cbiAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnIHBsb3QueS5zY2FsZS5kb21haW4nLCBwbG90Lnkuc2NhbGUuZG9tYWluKCkpO1xuICAgIH1cblxuICAgIHNldHVwR3JvdXBTdGFja3MoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5ncm91cERhdGEoKTtcblxuICAgICAgICB2YXIgeTBzID0gW107XG4gICAgICAgIHRoaXMucGxvdC5ncm91cGVkRGF0YS5mb3JFYWNoKHM9PiB7XG4gICAgICAgICAgICBzLnBvaW50cyA9IHMudmFsdWVzLm1hcCh2PT5zZWxmLm1hcFRvUG9pbnQodikpO1xuICAgICAgICAgICAgcy5wb2ludHMuZm9yRWFjaCgocCwgaSk9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZZMCA9IHkwc1tpXTtcbiAgICAgICAgICAgICAgICBpZighcHJldlkwKSBwcmV2WTAgPSAwO1xuICAgICAgICAgICAgICAgIHAueTAgPSBwcmV2WTA7XG4gICAgICAgICAgICAgICAgeTBzW2ldID0gcC55K3ByZXZZMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsb3QubGF5ZXJzID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuXG4gICAgfVxuXG4gICAgbWFwVG9Qb2ludCh2YWx1ZSkge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBsb3QueC52YWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHBsb3QueS52YWx1ZSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGRyYXdBeGlzWCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueDtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy14JykgKyBcIi5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSArIChzZWxmLmNvbmZpZy5ndWlkZXMgPyAnJyA6ICcuJyArIHNlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKTtcblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueC5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChwbG90LndpZHRoIC8gMikgKyBcIixcIiArIChwbG90Lm1hcmdpbi5ib3R0b20pICsgXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNZKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzLXknKSArIFwiLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpICsgKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nICsgc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKTtcblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYXhpc1QgPSBheGlzLnRyYW5zaXRpb24oKS5lYXNlKGQzLmVhc2VTaW5Jbk91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzVC5jYWxsKHBsb3QueS5heGlzKTtcblxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1wbG90Lm1hcmdpbi5sZWZ0ICsgXCIsXCIgKyAocGxvdC5oZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cblxuICAgIGRyYXdCYXJzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsYXllcnMnLCBwbG90LmxheWVycyk7XG5cbiAgICAgICAgdmFyIGxheWVyQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKFwibGF5ZXJcIik7XG5cbiAgICAgICAgdmFyIGJhckNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcImJhclwiKTtcbiAgICAgICAgdmFyIGxheWVyID0gc2VsZi5zdmdHLnNlbGVjdEFsbChcIi5cIiArIGxheWVyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LmxheWVycyk7XG5cbiAgICAgICAgdmFyIGxheWVyTWVyZ2UgPSBsYXllci5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgbGF5ZXJDbGFzcykubWVyZ2UobGF5ZXIpO1xuXG4gICAgICAgIHZhciBiYXIgPSBsYXllck1lcmdlLnNlbGVjdEFsbChcIi5cIiArIGJhckNsYXNzKVxuICAgICAgICAgICAgLmRhdGEoZCA9PiBkLnBvaW50cyk7XG5cbiAgICAgICAgdmFyIGJhckVudGVyID0gYmFyLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBiYXJDbGFzcyk7XG4gICAgICAgIHZhciBiYXJSZWN0RW50ZXIgPSBiYXJFbnRlci5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMSk7XG4gICAgICAgIHZhciBiYXJNZXJnZSA9IGJhckVudGVyLm1lcmdlKGJhcik7XG5cbiAgICAgICAgdmFyIGJhclJlY3QgPSBiYXJNZXJnZS5zZWxlY3QoXCJyZWN0XCIpO1xuXG4gICAgICAgIHZhciBiYXJSZWN0VCA9IGJhclJlY3Q7XG4gICAgICAgIHZhciBiYXJUID0gYmFyTWVyZ2U7XG4gICAgICAgIHZhciBsYXllclQgPSBsYXllck1lcmdlO1xuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBiYXJSZWN0VCA9IGJhclJlY3QudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgYmFyVCA9IGJhck1lcmdlLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGxheWVyVCA9IGxheWVyTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyRW50ZXIuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgcGxvdC54LnNjYWxlKGQueCkgKyBcIixcIiArIChwbG90Lnkuc2NhbGUoZC55MCkpICsgXCIpXCI7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeURvbWFpbiA9IHBsb3QueS5zY2FsZS5kb21haW4oKTtcbiAgICAgICAgYmFyVC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBwbG90Lnguc2NhbGUoZC54KSArIFwiLFwiICsgKHBsb3QueS5zY2FsZShkLnkwICsgZC55KSkgKyBcIilcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhclJlY3RFbnRlclxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAwKTtcbiAgICAgICAgYmFyUmVjdFRcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiBwbG90Lnkuc2NhbGUoZC55MCkgLSBwbG90Lnkuc2NhbGUoZC55MCArIGQueSAtIHlEb21haW5bMF0pKTtcblxuXG4gICAgICAgIGlmICh0aGlzLnBsb3Quc2VyaWVzQ29sb3IpIHtcbiAgICAgICAgICAgIGxheWVyVFxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCB0aGlzLnBsb3Quc2VyaWVzQ29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsb3QudG9vbHRpcCkge1xuICAgICAgICAgICAgYmFyTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChkLnkpO1xuICAgICAgICAgICAgfSkub24oXCJtb3VzZW91dFwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXllci5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGJhci5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWCgpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWSgpO1xuICAgICAgICB0aGlzLmRyYXdCYXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbn1cbiIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBCb3hQbG90QmFzZUNvbmZpZyBleHRlbmRzIENoYXJ0Q29uZmlne1xuXG4gICAgc3ZnQ2xhc3MgPSB0aGlzLmNzc0NsYXNzUHJlZml4ICsgJ2JveC1wbG90JztcbiAgICBzaG93VG9vbHRpcCA9IHRydWU7XG4gICAgeCA9IHsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbFxuICAgICAgICB2YWx1ZTogcyA9PiBzLmtleSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBndWlkZXM6IGZhbHNlLCAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICAgICAgb3JpZW50OiAnYm90dG9tJyxcblxuICAgIH07XG4gICAgeSA9IHsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgdmFsdWU6IGQgPT4gZCwgLy8geSB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgb3JpZW50OiAnbGVmdCcsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4xLFxuICAgICAgICBndWlkZXM6IHRydWUgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgfTtcbiAgICBRMSA9IGQgPT4gZC52YWx1ZXMuUTE7XG4gICAgUTIgPSBkID0+IGQudmFsdWVzLlEyO1xuICAgIFEzID0gZCA9PiBkLnZhbHVlcy5RMztcbiAgICBXbCA9IGQgPT4gZC52YWx1ZXMud2hpc2tlckxvdztcbiAgICBXaCA9IGQgPT4gZC52YWx1ZXMud2hpc2tlckhpZ2g7XG4gICAgb3V0bGllcnM9IGQ9PiBkLnZhbHVlcy5vdXRsaWVycztcbiAgICBvdXRsaWVyVmFsdWUgPSAoZCxpKT0+IGQ7XG4gICAgb3V0bGllckxhYmVsID0gKGQsaSk9PiBkO1xuICAgIG1pbkJveFdpZHRoID0gMzU7XG4gICAgbWF4Qm94V2lkdGggPSAxMDA7XG5cbiAgICB0cmFuc2l0aW9uID0gdHJ1ZTtcbiAgICBjb2xvciA9ICB1bmRlZmluZWQ7Ly8gc3RyaW5nIG9yIGZ1bmN0aW9uIHJldHVybmluZyBjb2xvcidzIHZhbHVlIGZvciBjb2xvciBzY2FsZVxuICAgIGQzQ29sb3JDYXRlZ29yeT0gJ2NhdGVnb3J5MTAnO1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQm94UGxvdEJhc2UgZXh0ZW5kcyBDaGFydHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEJveFBsb3RCYXNlQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBCb3hQbG90QmFzZUNvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpe1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICBzdXBlci5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgdGhpcy5wbG90LnggPSB7fTtcbiAgICAgICAgdGhpcy5wbG90LnkgPSB7fTtcblxuICAgICAgICB0aGlzLnBsb3QuZGF0YSA9IHRoaXMuZ2V0RGF0YVRvUGxvdCgpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuICAgICAgICB0aGlzLnNldHVwWCgpO1xuXG4gICAgICAgIHRoaXMuc2V0dXBDb2xvcigpO1xuXG4gICAgfVxuXG4gICAgZ2V0RGF0YVRvUGxvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBzZXR1cFgoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLng7XG5cbiAgICAgICAgeC52YWx1ZSA9IGNvbmYudmFsdWU7XG4gICAgICAgIHguc2NhbGUgPSBkMy5zY2FsZUJhbmQoKS5yYW5nZShbMCwgcGxvdC53aWR0aF0pO1xuICAgICAgICB4Lm1hcCA9IGQgPT4geC5zY2FsZSh4LnZhbHVlKGQpKTtcblxuICAgICAgICB4LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB4LnNjYWxlKTtcbiAgICAgICAgaWYoY29uZi5ndWlkZXMpe1xuICAgICAgICAgICAgeC5heGlzLnRpY2tTaXplKC1wbG90LmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb21haW4gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IGRhdGEubWFwKHgudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC54LnNjYWxlLmRvbWFpbihkb21haW4pO1xuXG4gICAgfTtcblxuICAgIHNldHVwWSgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHkgPSBwbG90Lnk7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgeS52YWx1ZSA9IGQgPT4gY29uZi52YWx1ZS5jYWxsKHRoaXMuY29uZmlnLCBkKTtcbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFtwbG90LmhlaWdodCwgMF0pO1xuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcbiAgICAgICAgaWYgKGNvbmYudGlja3MpIHtcbiAgICAgICAgICAgIHkuYXhpcy50aWNrcyhjb25mLnRpY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBpZihjb25mLmd1aWRlcyl7XG4gICAgICAgICAgICB5LmF4aXMudGlja1NpemUoLXBsb3Qud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0dXBZRG9tYWluKCk7XG4gICAgfTtcblxuICAgIHNldHVwWURvbWFpbigpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdLCB5TWluLCB5TWF4O1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIGxldCBxMSA9IGMuUTEoZCksIFxuICAgICAgICAgICAgICAgIHEzID0gYy5RMyhkKSwgXG4gICAgICAgICAgICAgICAgd2wgPSBjLldsKGQpLCBcbiAgICAgICAgICAgICAgICB3aCA9IGMuV2goZCksXG4gICAgICAgICAgICAgICAgb3V0bGllcnMgPSBjLm91dGxpZXJzKGQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAob3V0bGllcnMpIHtcbiAgICAgICAgICAgICAgICBvdXRsaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChvLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGMub3V0bGllclZhbHVlKG8sIGkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3bCkgeyB2YWx1ZXMucHVzaCh3bCkgfVxuICAgICAgICAgICAgaWYgKHExKSB7IHZhbHVlcy5wdXNoKHExKSB9XG4gICAgICAgICAgICBpZiAocTMpIHsgdmFsdWVzLnB1c2gocTMpIH1cbiAgICAgICAgICAgIGlmICh3aCkgeyB2YWx1ZXMucHVzaCh3aCkgfVxuICAgICAgICB9KTtcbiAgICAgICAgeU1pbiA9IGQzLm1pbih2YWx1ZXMpO1xuICAgICAgICB5TWF4ID0gZDMubWF4KHZhbHVlcyk7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoeU1heC15TWluKSogdGhpcy5jb25maWcueS5kb21haW5NYXJnaW47XG4gICAgICAgIHlNaW4tPW1hcmdpbjtcbiAgICAgICAgeU1heCs9bWFyZ2luO1xuICAgICAgICB2YXIgZG9tYWluID0gWyB5TWluLCB5TWF4IF0gO1xuXG4gICAgICAgIHBsb3QueS5zY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICB9XG5cbiAgICBkcmF3QXhpc1goKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLng7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteCcpICsgXCIuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzJykgKyAoYXhpc0NvbmYuZ3VpZGVzID8gJycgOiAnLicgKyBzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnguYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAocGxvdC53aWR0aC8yKSArXCIsXCIrIChwbG90Lm1hcmdpbi5ib3R0b20pICtcIilcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCItMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYubGFiZWwpO1xuICAgIH07XG5cbiAgICBkcmF3QXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpICsgXCIuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzJykgKyAoYXhpc0NvbmYuZ3VpZGVzID8gJycgOiAnLicgKyBzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC55LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiICsgc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLXBsb3QubWFyZ2luLmxlZnQgKyBcIixcIiArIChwbG90LmhlaWdodCAvIDIpICsgXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIGRyYXdCb3hQbG90cygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcGxvdCA9IHNlbGYucGxvdCxcbiAgICAgICAgICAgIGNvbmZpZyA9IHNlbGYuY29uZmlnLFxuICAgICAgICAgICAgYm94cGxvdENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImJveHBsb3QtaXRlbVwiKVxuICAgICAgICBcbiAgICAgICAgdmFyIGJveHBsb3RzID0gc2VsZi5zdmdHLnNlbGVjdEFsbCgnLicrYm94cGxvdENsYXNzKS5kYXRhKHBsb3QuZGF0YSk7XG4gICAgICAgIHZhciBib3hwbG90RW50ZXIgPSBib3hwbG90cy5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGJveHBsb3RDbGFzcylcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcblxuICAgICAgICB2YXIgYm94cGxvdHNNZXJnZSA9IGJveHBsb3RFbnRlci5tZXJnZShib3hwbG90cyk7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDEwMDA7XG4gICAgICAgIHZhciBib3hwbG90c1QgPSBib3hwbG90c01lcmdlO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBib3hwbG90c1QgPSBib3hwbG90c01lcmdlLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGJveHBsb3RzVC5kZWxheShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgKiBkdXJhdGlvbiAvIHBsb3QuZGF0YS5sZW5ndGggfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGJveHBsb3RzVFxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgcGxvdC5jb2xvcilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAwLjc1KVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLGkpID0+J3RyYW5zbGF0ZSgnICsgKHBsb3QueC5tYXAoZCxpKSArIHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuMDUpICsgJywgMCknKVxuICAgICAgICBib3hwbG90cy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIGJveFdpZHRoID0gIWNvbmZpZy5tYXhCb3hXaWR0aCA/IHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuOSA6IE1hdGgubWluKGNvbmZpZy5tYXhCb3hXaWR0aCwgTWF0aC5tYXgoY29uZmlnLm1pbkJveFdpZHRoLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjkpKTtcbiAgICAgICAgdmFyIGJveExlZnQgID0gcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC40NSAtIGJveFdpZHRoLzI7XG4gICAgICAgIHZhciBib3hSaWdodCA9IHBsb3QueC5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuNDUgKyBib3hXaWR0aC8yO1xuXG4gICAgICAgIHZhciBib3hDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJib3hcIik7XG5cbiAgICAgICAgYm94cGxvdEVudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBib3hDbGFzcylcbiAgICAgICAgICAgIC8vIHRvb2x0aXAgZXZlbnRzXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gJ1EzOiAnK2NvbmZpZy5RMyhkLGkpKyc8YnIvPlEyOiAnK2NvbmZpZy5RMihkLGkpKyc8YnIvPlExOiAnK2NvbmZpZy5RMShkLGkpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Rvb2x0aXAoaHRtbClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBib3hSZWN0cyA9IGJveHBsb3RzTWVyZ2Uuc2VsZWN0KCdyZWN0LicrYm94Q2xhc3MpO1xuXG4gICAgICAgIHZhciBib3hSZWN0c1QgPSBib3hSZWN0cztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGJveFJlY3RzVCA9IGJveFJlY3RzLnRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJveFJlY3RzVC5hdHRyKCd5JywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGNvbmZpZy5RMyhkKSkpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBib3hXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKCd4JywgYm94TGVmdCApXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsaSkgPT4gTWF0aC5hYnMocGxvdC55LnNjYWxlKGNvbmZpZy5RMyhkKSkgLSBwbG90Lnkuc2NhbGUoY29uZmlnLlExKGQpKSkgfHwgMSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcGxvdC5jb2xvcik7XG5cbiAgICAgICAgLy8gbWVkaWFuIGxpbmVcbiAgICAgICAgdmFyIG1lZGlhbkNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnbWVkaWFuJyk7XG4gICAgICAgIGJveHBsb3RFbnRlci5hcHBlbmQoJ2xpbmUnKS5hdHRyKCdjbGFzcycsIG1lZGlhbkNsYXNzKTtcblxuICAgICAgICB2YXIgbWVkaWFuTGluZSA9IGJveHBsb3RzTWVyZ2Uuc2VsZWN0KCdsaW5lLicrbWVkaWFuQ2xhc3MpO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgbWVkaWFuTGluZSA9IG1lZGlhbkxpbmUudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhbkxpbmVcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGJveExlZnQpXG4gICAgICAgICAgICAuYXR0cigneTEnLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoY29uZmlnLlEyKGQpKSlcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIGJveFJpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGNvbmZpZy5RMihkKSkpO1xuXG5cbiAgICAgICAgLy93aGlza2Vyc1xuXG4gICAgICAgIHZhciB3aGlza2VyQ2xhc3M9IHNlbGYucHJlZml4Q2xhc3MoXCJ3aGlza2VyXCIpLFxuICAgICAgICAgICAgdGlja0NsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImJveHBsb3QtdGlja1wiKTtcblxuICAgICAgICB2YXIgd2hpc2tlcnMgPSBbe2tleTogJ2xvdycsIHZhbHVlOiBjb25maWcuV2x9LCB7a2V5OiAnaGlnaCcsIHZhbHVlOiBjb25maWcuV2h9XTtcblxuICAgICAgICBib3hwbG90RW50ZXIuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgIHdoaXNrZXJzLmZvckVhY2goZj0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZi52YWx1ZShkKSkge1xuICAgICAgICAgICAgICAgICAgICBib3guYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcGxvdC5jb2xvcihkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgd2hpc2tlckNsYXNzKycgJyArIGJveHBsb3RDbGFzcysnLScrZi5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBib3guYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcGxvdC5jb2xvcihkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgdGlja0NsYXNzKycgJyArIGJveHBsb3RDbGFzcysnLScrZi5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB3aGlza2Vycy5mb3JFYWNoKGYgPT4ge1xuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gKGYua2V5ID09PSAnbG93JykgPyBjb25maWcuUTEgOiBjb25maWcuUTM7XG5cbiAgICAgICAgICAgIHZhciB3aGlza2VyID0gYm94cGxvdHNNZXJnZS5zZWxlY3QoJy4nK3doaXNrZXJDbGFzcysnLicrYm94cGxvdENsYXNzKyctJytmLmtleSk7XG4gICAgICAgICAgICB2YXIgdGljayA9IGJveHBsb3RzTWVyZ2Uuc2VsZWN0KCcuJyt0aWNrQ2xhc3MrJy4nK2JveHBsb3RDbGFzcysnLScrZi5rZXkpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB3aGlza2VyID0gd2hpc2tlci50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGljaz10aWNrLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaXNrZXJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBwbG90Lnguc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjQ1IClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoZi52YWx1ZShkKSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC40NSApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsaSkgPT4gcGxvdC55LnNjYWxlKGVuZHBvaW50KGQpKSk7XG5cbiAgICAgICAgICAgIHRpY2tcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBib3hMZWZ0IClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAoZCxpKSA9PiBwbG90Lnkuc2NhbGUoZi52YWx1ZShkKSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgYm94UmlnaHQgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIChkLGkpID0+IHBsb3QueS5zY2FsZShmLnZhbHVlKGQpKSk7XG5cbiAgICAgICAgICAgIGJveHBsb3RFbnRlci5zZWxlY3RBbGwoJy4nK2JveHBsb3RDbGFzcysnLScrZi5rZXkpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChmLnZhbHVlKGQpKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8gb3V0bGllcnNcbiAgICAgICAgdmFyIG91dGxpZXJDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJvdXRsaWVyXCIpO1xuICAgICAgICB2YXIgb3V0bGllcnMgPSBib3hwbG90c01lcmdlLnNlbGVjdEFsbCgnLicrb3V0bGllckNsYXNzKS5kYXRhKChkLGkpID0+IGNvbmZpZy5vdXRsaWVycyhkLGkpIHx8IFtdKTtcblxuICAgICAgICB2YXIgb3V0bGllckVudGVyQ2lyY2xlID0gb3V0bGllcnMuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBvdXRsaWVyQ2xhc3MpXG4gICAgICAgICAgICAuc3R5bGUoJ3otaW5kZXgnLCA5MDAwKTtcblxuICAgICAgICBvdXRsaWVyRW50ZXJDaXJjbGVcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGksIGopIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGNvbmZpZy5vdXRsaWVyTGFiZWwoZCxpKSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQsIGksIGopIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG91dGxpZXJzTWVyZ2UgPSBvdXRsaWVyRW50ZXJDaXJjbGUubWVyZ2Uob3V0bGllcnMpO1xuICAgICAgICB2YXIgb3V0bGllcnNUID0gb3V0bGllcnNNZXJnZTtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIG91dGxpZXJzVCA9IG91dGxpZXJzTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIG91dGxpZXJzVFxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgcGxvdC54LnNjYWxlLmJhbmR3aWR0aCgpICogMC40NSlcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIChkLGkpID0+IHBsb3QueS5zY2FsZShjb25maWcub3V0bGllclZhbHVlKGQsaSkpKVxuICAgICAgICAgICAgLmF0dHIoJ3InLCAnMycpO1xuICAgICAgICBvdXRsaWVycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICB9XG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1goKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1koKTtcbiAgICAgICAgdGhpcy5kcmF3Qm94UGxvdHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHNldHVwQ29sb3IoKSB7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgaWYoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpe1xuICAgICAgICAgICAgdmFyIGNvbG9yU2NoZW1lQ2F0ZWdvcnkgPSAnc2NoZW1lJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkgPSBkMy5zY2FsZU9yZGluYWwoZDNbY29sb3JTY2hlbWVDYXRlZ29yeV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvclZhbHVlID0gY29uZi5jb2xvcjtcbiAgICAgICAgaWYgKGNvbG9yVmFsdWUgJiYgdHlwZW9mIGNvbG9yVmFsdWUgPT09ICdzdHJpbmcnIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpe1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gY29sb3JWYWx1ZTtcbiAgICAgICAgfWVsc2UgaWYodGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkpe1xuICAgICAgICAgICAgc2VsZi5wbG90LmNvbG9yVmFsdWU9Y29sb3JWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IGQgPT4gIHNlbGYucGxvdC5jb2xvckNhdGVnb3J5KHRoaXMucGxvdC54LnZhbHVlKGQpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7Qm94UGxvdEJhc2UsIEJveFBsb3RCYXNlQ29uZmlnfSBmcm9tIFwiLi9ib3gtcGxvdC1iYXNlXCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHtTdGF0aXN0aWNzVXRpbHN9IGZyb20gJy4vc3RhdGlzdGljcy11dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBCb3hQbG90Q29uZmlnIGV4dGVuZHMgQm94UGxvdEJhc2VDb25maWd7XG5cbiAgICBzdmdDbGFzcyA9IHRoaXMuY3NzQ2xhc3NQcmVmaXggKyAnYm94LXBsb3QnO1xuICAgIHNob3dMZWdlbmQgPSB0cnVlO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTtcbiAgICB5ID0gey8vIFkgYXhpcyBjb25maWdcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihkKSB7IHJldHVybiB0aGlzLnkua2V5PT09dW5kZWZpbmVkID8gZCA6IGRbdGhpcy55LmtleV19ICwgLy8geSB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgb3JpZW50OiAnbGVmdCcsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4xLFxuICAgICAgICBndWlkZXM6IHRydWUgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgfTtcbiAgICBzZXJpZXMgPSBmYWxzZTtcbiAgICBncm91cHM9e1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRoaXMuZ3JvdXBzLmtleT09PXVuZGVmaW5lZCA/ICcnIDogZFt0aGlzLmdyb3Vwcy5rZXldfSAgLCAvLyBncm91cGluZyB2YWx1ZSBhY2Nlc3NvcixcbiAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgIGRpc3BsYXlWYWx1ZTogdW5kZWZpbmVkIC8vIG9wdGlvbmFsIGZ1bmN0aW9uIHJldHVybmluZyBkaXNwbGF5IHZhbHVlIChzZXJpZXMgbGFiZWwpIGZvciBnaXZlbiBncm91cCB2YWx1ZSwgb3Igb2JqZWN0L2FycmF5IG1hcHBpbmcgdmFsdWUgdG8gZGlzcGxheSB2YWx1ZVxuICAgIH07XG4gICAgdHVrZXk9IGZhbHNlO1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCb3hQbG90IGV4dGVuZHMgQm94UGxvdEJhc2V7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBCb3hQbG90Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBCb3hQbG90Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGdldERhdGFUb1Bsb3QoKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZiA9IHNlbGYuY29uZmlnO1xuICAgICAgICBzZWxmLnBsb3QuZ3JvdXBpbmdFbmFibGVkID0gdGhpcy5pc0dyb3VwaW5nRW5hYmxlZCgpO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBpZighc2VsZi5wbG90Lmdyb3VwaW5nRW5hYmxlZCApe1xuICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gIFt7XG4gICAgICAgICAgICAgICAga2V5OiAnJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgc2VsZi5wbG90LmRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpZihzZWxmLmNvbmZpZy5zZXJpZXMpe1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cGVkRGF0YSA9ICBkYXRhLm1hcChzPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybntcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcy5sYWJlbCB8fCBzLmtleSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcy52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwVmFsdWUgPSBkID0+IGNvbmYuZ3JvdXBzLnZhbHVlLmNhbGwoY29uZiwgZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gZDMubmVzdCgpLmtleSh0aGlzLnBsb3QuZ3JvdXBWYWx1ZSkuZW50cmllcyhkYXRhKTtcblxuICAgICAgICAgICAgICAgIHZhciBnZXREaXNwbGF5VmFsdWU9IGsgPT4gaztcbiAgICAgICAgICAgICAgICBpZihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoVXRpbHMuaXNGdW5jdGlvbihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXREaXNwbGF5VmFsdWUgPSBrPT5zZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKGspIHx8IGs7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKFV0aWxzLmlzT2JqZWN0KHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldERpc3BsYXlWYWx1ZSA9IGsgPT4gc2VsZi5jb25maWcuZ3JvdXBzLmRpc3BsYXlWYWx1ZVtrXSB8fCBrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cGVkRGF0YS5mb3JFYWNoKGcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnLmtleSA9IGdldERpc3BsYXlWYWx1ZShnLmtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucGxvdC5kYXRhTGVuZ3RoID0gZDMuc3VtKHRoaXMucGxvdC5ncm91cGVkRGF0YSwgcz0+cy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhLmZvckVhY2gocz0+e1xuICAgICAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkocy52YWx1ZXMpKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBzLnZhbHVlcy5tYXAoZD0+cGFyc2VGbG9hdChzZWxmLmNvbmZpZy55LnZhbHVlLmNhbGwoc2VsZi5jb25maWcsIGQpKSk7XG4gICAgICAgICAgICBzLnZhbHVlcy5RMSA9IFN0YXRpc3RpY3NVdGlscy5xdWFudGlsZSh2YWx1ZXMsIDAuMjUpO1xuICAgICAgICAgICAgcy52YWx1ZXMuUTIgPSBTdGF0aXN0aWNzVXRpbHMucXVhbnRpbGUodmFsdWVzLCAwLjUpO1xuICAgICAgICAgICAgcy52YWx1ZXMuUTMgPSBTdGF0aXN0aWNzVXRpbHMucXVhbnRpbGUodmFsdWVzLCAwLjc1KTtcbiAgICAgICAgICAgIHZhciBJUVIgPSAgcy52YWx1ZXMuUTMgLSBzLnZhbHVlcy5RMTtcblxuICAgICAgICAgICAgaWYoIXNlbGYuY29uZmlnLnR1a2V5KXtcbiAgICAgICAgICAgICAgICBzLnZhbHVlcy53aGlza2VyTG93ID0gZDMubWluKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcy52YWx1ZXMud2hpc2tlckhpZ2ggPSBkMy5tYXgodmFsdWVzKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHMudmFsdWVzLndoaXNrZXJMb3cgPSBzLnZhbHVlcy5RMSAtIDEuNSpJUVI7XG4gICAgICAgICAgICAgICAgcy52YWx1ZXMud2hpc2tlckhpZ2ggPSBzLnZhbHVlcy5RMyArIDEuNSpJUVI7XG4gICAgICAgICAgICAgICAgcy52YWx1ZXMub3V0bGllcnMgPSB2YWx1ZXMuZmlsdGVyKGQ9PiBkPHMudmFsdWVzLndoaXNrZXJMb3cgfHwgZD5zLnZhbHVlcy53aGlza2VySGlnaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmLnBsb3QuZ3JvdXBlZERhdGE7XG4gICAgfVxuXG4gICAgaXNHcm91cGluZ0VuYWJsZWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNlcmllcyB8fCAhISh0aGlzLmNvbmZpZy5ncm91cHMgJiYgdGhpcy5jb25maWcuZ3JvdXBzLnZhbHVlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSBcIi4vbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWcgZXh0ZW5kcyBDaGFydENvbmZpZ3tcblxuICAgIHNob3dMZWdlbmQ9dHJ1ZTtcbiAgICBmb3JjZUxlZ2VuZD1mYWxzZTtcbiAgICBsZWdlbmQ9e1xuICAgICAgICB3aWR0aDogODAsXG4gICAgICAgIG1hcmdpbjogMTAsXG4gICAgICAgIHNoYXBlV2lkdGg6IDIwXG4gICAgfTtcbiAgICBncm91cHM9e1xuICAgICAgICBrZXk6IDIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihkKSB7IHJldHVybiBkW3RoaXMuZ3JvdXBzLmtleV19ICAsIC8vIGdyb3VwaW5nIHZhbHVlIGFjY2Vzc29yLFxuICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgZGlzcGxheVZhbHVlOiB1bmRlZmluZWQgLy8gb3B0aW9uYWwgZnVuY3Rpb24gcmV0dXJuaW5nIGRpc3BsYXkgdmFsdWUgKHNlcmllcyBsYWJlbCkgZm9yIGdpdmVuIGdyb3VwIHZhbHVlLCBvciBvYmplY3QvYXJyYXkgbWFwcGluZyB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgfTtcbiAgICBzZXJpZXMgPSBmYWxzZTtcbiAgICBjb2xvciA9ICB1bmRlZmluZWQ7Ly8gc3RyaW5nIG9yIGZ1bmN0aW9uIHJldHVybmluZyBjb2xvcidzIHZhbHVlIGZvciBjb2xvciBzY2FsZVxuICAgIGQzQ29sb3JDYXRlZ29yeT0gJ2NhdGVnb3J5MTAnO1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2hhcnRXaXRoQ29sb3JHcm91cHMgZXh0ZW5kcyBDaGFydHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBDaGFydFdpdGhDb2xvckdyb3Vwc0NvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBpbml0UGxvdCgpe1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuXG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG4gICAgICAgXG4gICAgICAgIHRoaXMucGxvdC5zaG93TGVnZW5kID0gY29uZi5zaG93TGVnZW5kO1xuICAgICAgICB0aGlzLnNldHVwR3JvdXBzKCk7XG4gICAgICAgIHRoaXMucGxvdC5kYXRhID0gdGhpcy5nZXREYXRhVG9QbG90KCk7XG4gICAgICAgIHRoaXMuZ3JvdXBEYXRhKCk7XG5cbiAgICAgICAgaWYodGhpcy5wbG90LnNob3dMZWdlbmQpe1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnk7XG4gICAgICAgICAgICBpZighc2NhbGUuZG9tYWluKCkgfHwgIXRoaXMuY29uZmlnLmZvcmNlTGVnZW5kICYmIHNjYWxlLmRvbWFpbigpLmxlbmd0aDwyKXtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3Quc2hvd0xlZ2VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5yaWdodCA9IGNvbmYubWFyZ2luLnJpZ2h0ICsgY29uZi5sZWdlbmQud2lkdGgrY29uZi5sZWdlbmQubWFyZ2luKjI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaXNHcm91cGluZ0VuYWJsZWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNlcmllcyB8fCAhISh0aGlzLmNvbmZpZy5ncm91cHMgJiYgdGhpcy5jb25maWcuZ3JvdXBzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBjb21wdXRlR3JvdXBDb2xvckRvbWFpbigpe1xuICAgICAgICB2YXIgbWFwID0gZDMuc2V0KHRoaXMuZGF0YSwgZCA9PiB0aGlzLnBsb3QuZ3JvdXBWYWx1ZShkKSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtYXApLm1hcChkPT5tYXBbZF0pO1xuICAgIH1cblxuICAgIHNldHVwR3JvdXBzKCkge1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC5ncm91cGluZ0VuYWJsZWQgPSB0aGlzLmlzR3JvdXBpbmdFbmFibGVkKCk7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgaWYodGhpcy5wbG90Lmdyb3VwaW5nRW5hYmxlZCl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBUb0xhYmVsID0ge307XG4gICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5zZXJpZXMpe1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5ncm91cFZhbHVlID0gcyA9PiBzLmtleTtcbiAgICAgICAgICAgICAgICBkb21haW4gPSB0aGlzLmNvbXB1dGVHcm91cENvbG9yRG9tYWluKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChzPT57XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cFRvTGFiZWxbcy5rZXldID0gcy5sYWJlbHx8cy5rZXk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5ncm91cFZhbHVlID0gZCA9PiBjb25mLmdyb3Vwcy52YWx1ZS5jYWxsKGNvbmYsIGQpO1xuICAgICAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuY29tcHV0ZUdyb3VwQ29sb3JEb21haW4oKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0TGFiZWw9IGsgPT4gaztcbiAgICAgICAgICAgICAgICBpZihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoVXRpbHMuaXNGdW5jdGlvbihzZWxmLmNvbmZpZy5ncm91cHMuZGlzcGxheVZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMYWJlbCA9IGs9PnNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWUoaykgfHwgaztcbiAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoVXRpbHMuaXNPYmplY3Qoc2VsZi5jb25maWcuZ3JvdXBzLmRpc3BsYXlWYWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TGFiZWwgPSBrID0+IHNlbGYuY29uZmlnLmdyb3Vwcy5kaXNwbGF5VmFsdWVba10gfHwgaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb21haW4uZm9yRWFjaChrPT57XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cFRvTGFiZWxba10gPSBnZXRMYWJlbChrKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5wbG90Lmdyb3VwVmFsdWUgPSBkID0+IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbG90Lmdyb3VwQ29sb3JEb21haW4gPSBkb21haW47XG4gICAgICAgIGlmKGNvbmYuZDNDb2xvckNhdGVnb3J5KXtcbiAgICAgICAgICAgIHZhciBjb2xvclNjaGVtZUNhdGVnb3J5ID0gJ3NjaGVtZScrVXRpbHMuY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGNvbmYuZDNDb2xvckNhdGVnb3J5KTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvckNhdGVnb3J5ID0gZDMuc2NhbGVPcmRpbmFsKGQzW2NvbG9yU2NoZW1lQ2F0ZWdvcnldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3JWYWx1ZSA9IGNvbmYuY29sb3I7XG5cbiAgICAgICAgaWYgKGNvbG9yVmFsdWUpe1xuICAgICAgICAgICAgaWYodHlwZW9mIGNvbG9yVmFsdWUgPT09ICdzdHJpbmcnIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpe1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IGNvbG9yVmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LnNlcmllc0NvbG9yID0gdGhpcy5wbG90LmNvbG9yO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gY29sb3JWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3Quc2VyaWVzQ29sb3IgPSB0aGlzLnBsb3QuY29sb3I7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9tYWluLm1hcCh2PT50aGlzLnBsb3Quc2VyaWVzQ29sb3Ioe2tleTogdn0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSA9IGQzLnNjYWxlT3JkaW5hbChyYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKGRvbWFpbik7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9ZWxzZSBpZih0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuY29sb3JWYWx1ZT1jb2xvclZhbHVlO1xuICAgICAgICAgICAgc2VsZi5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKGRvbWFpbik7XG5cbiAgICAgICAgICAgIHRoaXMucGxvdC5zZXJpZXNDb2xvciA9IHMgPT4gIHNlbGYucGxvdC5jb2xvckNhdGVnb3J5KHMua2V5KTtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IGQgPT4gIHNlbGYucGxvdC5jb2xvckNhdGVnb3J5KHRoaXMucGxvdC5ncm91cFZhbHVlKGQpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IHRoaXMucGxvdC5zZXJpZXNDb2xvciA9IHM9PiAnYmxhY2snXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdyb3VwRGF0YSgpe1xuICAgICAgICB2YXIgc2VsZj10aGlzO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICBpZighc2VsZi5wbG90Lmdyb3VwaW5nRW5hYmxlZCApe1xuICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gIFt7XG4gICAgICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgc2VsZi5wbG90LmRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAgIGlmKHNlbGYuY29uZmlnLnNlcmllcyl7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhID0gIGRhdGEubWFwKHM9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJue1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBzLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBzLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuZ3JvdXBlZERhdGEgPSBkMy5uZXN0KCkua2V5KHRoaXMucGxvdC5ncm91cFZhbHVlKS5lbnRyaWVzKGRhdGEpO1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC5ncm91cGVkRGF0YS5mb3JFYWNoKGcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnLmxhYmVsID0gc2VsZi5wbG90Lmdyb3VwVG9MYWJlbFtnLmtleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucGxvdC5kYXRhTGVuZ3RoID0gZDMuc3VtKHRoaXMucGxvdC5ncm91cGVkRGF0YSwgcz0+cy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMucGxvdC5zZXJpZXNDb2xvclxuXG4gICAgfVxuXG4gICAgZ2V0RGF0YVRvUGxvdCgpe1xuICAgICAgICBpZighdGhpcy5wbG90Lmdyb3VwaW5nRW5hYmxlZCB8fCAhdGhpcy5lbmFibGVkR3JvdXBzKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maWx0ZXIoZCA9PiB0aGlzLmVuYWJsZWRHcm91cHMuaW5kZXhPZih0aGlzLnBsb3QuZ3JvdXBWYWx1ZShkKSk+LTEpO1xuICAgIH1cblxuXG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdXBkYXRlTGVnZW5kKCkge1xuXG4gICAgICAgIHZhciBzZWxmID10aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcblxuICAgICAgICB2YXIgc2NhbGUgPSBwbG90LmNvbG9yQ2F0ZWdvcnk7XG5cbiAgICAgICAgaWYoIXNjYWxlLmRvbWFpbigpIHx8ICF0aGlzLmNvbmZpZy5mb3JjZUxlZ2VuZCAmJiBzY2FsZS5kb21haW4oKS5sZW5ndGg8Mil7XG4gICAgICAgICAgICBwbG90LnNob3dMZWdlbmQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFwbG90LnNob3dMZWdlbmQpe1xuICAgICAgICAgICAgaWYocGxvdC5sZWdlbmQgJiYgcGxvdC5sZWdlbmQuY29udGFpbmVyKXtcbiAgICAgICAgICAgICAgICBwbG90LmxlZ2VuZC5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBsZWdlbmRYID0gdGhpcy5wbG90LndpZHRoICsgdGhpcy5jb25maWcubGVnZW5kLm1hcmdpbjtcbiAgICAgICAgdmFyIGxlZ2VuZFkgPSB0aGlzLmNvbmZpZy5sZWdlbmQubWFyZ2luO1xuXG4gICAgICAgIHBsb3QubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLnN2ZywgdGhpcy5zdmdHLCBzY2FsZSwgbGVnZW5kWCwgbGVnZW5kWSk7XG5cbiAgICAgICAgcGxvdC5sZWdlbmRDb2xvciA9IHBsb3QubGVnZW5kLmNvbG9yKClcbiAgICAgICAgICAgIC5zaGFwZVdpZHRoKHRoaXMuY29uZmlnLmxlZ2VuZC5zaGFwZVdpZHRoKVxuICAgICAgICAgICAgLm9yaWVudCgndmVydGljYWwnKVxuICAgICAgICAgICAgLnNjYWxlKHNjYWxlKVxuICAgICAgICAgICAgLmxhYmVsV3JhcCh0aGlzLmNvbmZpZy5sZWdlbmQud2lkdGgpXG4gICAgICAgICAgICAubGFiZWxzKHNjYWxlLmRvbWFpbigpLm1hcCh2PT5wbG90Lmdyb3VwVG9MYWJlbFt2XSkpO1xuXG5cbiAgICAgICAgcGxvdC5sZWdlbmRDb2xvci5vbignY2VsbGNsaWNrJywgYz0+IHNlbGYub25MZWdlbmRDZWxsQ2xpY2soYykpO1xuICAgICAgICBcbiAgICAgICAgcGxvdC5sZWdlbmQuY29udGFpbmVyXG4gICAgICAgICAgICAuY2FsbChwbG90LmxlZ2VuZENvbG9yKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZENlbGxTdGF0dXNlcygpO1xuICAgIH1cblxuICAgIG9uTGVnZW5kQ2VsbENsaWNrKGNlbGxWYWx1ZSl7XG4gICAgICAgIHRoaXMudXBkYXRlRW5hYmxlZEdyb3VwcyhjZWxsVmFsdWUpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgdXBkYXRlTGVnZW5kQ2VsbFN0YXR1c2VzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucGxvdC5sZWdlbmQuY29udGFpbmVyLnNlbGVjdEFsbChcImcuY2VsbFwiKS5lYWNoKGZ1bmN0aW9uKGNlbGwpe1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBzZWxmLmVuYWJsZWRHcm91cHMgJiYgc2VsZi5lbmFibGVkR3JvdXBzLmluZGV4T2YoY2VsbCk8MDtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwib2RjLWRpc2FibGVkXCIsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVFbmFibGVkR3JvdXBzKGNlbGxWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZEdyb3Vwcykge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkR3JvdXBzID0gdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKCkuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVuYWJsZWRHcm91cHMuaW5kZXhPZihjZWxsVmFsdWUpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZEdyb3Vwcy5wdXNoKGNlbGxWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWRHcm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkR3JvdXBzID0gdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkuZG9tYWluKCkuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc2V0RGF0YShkYXRhKXtcbiAgICAgICAgc3VwZXIuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgdGhpcy5lbmFibGVkR3JvdXBzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBDaGFydENvbmZpZyB7XG4gICAgY3NzQ2xhc3NQcmVmaXggPSBcIm9kYy1cIjtcbiAgICBzdmdDbGFzcyA9IHRoaXMuY3NzQ2xhc3NQcmVmaXggKyAnbXctZDMtY2hhcnQnO1xuICAgIHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIGhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICBtYXJnaW4gPSB7XG4gICAgICAgIGxlZnQ6IDUwLFxuICAgICAgICByaWdodDogMzAsXG4gICAgICAgIHRvcDogMzAsXG4gICAgICAgIGJvdHRvbTogNTBcbiAgICB9O1xuICAgIHNob3dUb29sdGlwID0gZmFsc2U7XG4gICAgdHJhbnNpdGlvbiA9IHRydWU7XG5cbiAgICB0aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aXRsZVNpemU9MjA7XG4gICAgdGl0bGVNYXJnaW49e1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdG9wOiAxNSxcbiAgICAgICAgYm90dG9tOiAyMFxuICAgIH07XG5cbiAgICBzdWJ0aXRsZSA9IHVuZGVmaW5lZDtcbiAgICBzdWJ0aXRsZVNpemU9MTQ7XG4gICAgc3VidGl0bGVNYXJnaW49e1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdG9wOiAxMCxcbiAgICAgICAgYm90dG9tOiAyMFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pIHtcbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGNsYXNzIENoYXJ0IHtcbiAgICB1dGlscyA9IFV0aWxzO1xuICAgIGJhc2VDb250YWluZXI7XG4gICAgc3ZnO1xuICAgIGNvbmZpZztcbiAgICBwbG90ID0ge1xuICAgICAgICBtYXJnaW46IHt9XG4gICAgfTtcbiAgICBfYXR0YWNoZWQgPSB7fTtcbiAgICBfbGF5ZXJzID0ge307XG4gICAgX2V2ZW50cyA9IHt9O1xuICAgIF9pc0F0dGFjaGVkO1xuICAgIF9pc0luaXRpYWxpemVkPWZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5faWQgPSBVdGlscy5ndWlkKCk7XG4gICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBiYXNlIGluc3RhbmNlb2YgQ2hhcnQ7XG5cbiAgICAgICAgdGhpcy5iYXNlQ29udGFpbmVyID0gYmFzZTtcblxuICAgICAgICB0aGlzLnNldENvbmZpZyhjb25maWcpO1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMucG9zdEluaXQoKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IG5ldyBDaGFydENvbmZpZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0Q29uZmlnQWNjZXNzb3JzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuaW5pdFBsb3QoKTtcbiAgICAgICAgc2VsZi5pbml0U3ZnKCk7XG5cbiAgICAgICAgaWYoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpe1xuICAgICAgICAgICAgc2VsZi5pbml0VG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZHJhdygpO1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkPXRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlZHJhdygpe1xuICAgICAgICB0aGlzLmluaXRDb25maWdBY2Nlc3NvcnModHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBwb3N0SW5pdCgpe1xuXG4gICAgfVxuXG4gICAgaW5pdFN2ZygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdmFyIG1hcmdpbiA9IHNlbGYucGxvdC5tYXJnaW47XG4gICAgICAgIHZhciB3aWR0aCA9IHNlbGYuc3ZnV2lkdGggPSBzZWxmLnBsb3Qud2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHNlbGYuc3ZnSGVpZ2h0ID0gIHNlbGYucGxvdC5oZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBpZighc2VsZi5faXNBdHRhY2hlZCl7XG4gICAgICAgICAgICBpZighdGhpcy5faXNJbml0aWFsaXplZCl7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGYuYmFzZUNvbnRhaW5lcikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zdmcgPSBkMy5zZWxlY3Qoc2VsZi5iYXNlQ29udGFpbmVyKS5zZWxlY3RPckFwcGVuZChcInN2Z1wiKS5jbGFzc2VkKGNvbmZpZy5zdmdDbGFzcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHNlbGYuc3ZnXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ2aWV3Qm94XCIsIFwiMCAwIFwiICsgXCIgXCIgKyB3aWR0aCArIFwiIFwiICsgaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcInhNaWRZTWlkIG1lZXRcIilcbiAgICAgICAgICAgIHNlbGYuc3ZnRyA9IHNlbGYuc3ZnLnNlbGVjdE9yQXBwZW5kKFwiZy5tYWluLWdyb3VwXCIpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHNlbGYuYmFzZUNvbnRhaW5lcik7XG4gICAgICAgICAgICBzZWxmLnN2ZyA9IHNlbGYuYmFzZUNvbnRhaW5lci5zdmc7XG4gICAgICAgICAgICBzZWxmLnN2Z0cgPSBzZWxmLnN2Zy5zZWxlY3RPckFwcGVuZChcImcubWFpbi1ncm91cC5cIitjb25maWcuc3ZnQ2xhc3MpXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN2Z0cuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIGlmICghY29uZmlnLndpZHRoIHx8IGNvbmZpZy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgICAgICAgICAgLm9uKFwicmVzaXplLlwiK3NlbGYuX2lkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gc2VsZi5jb25maWcudHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcudHJhbnNpdGlvbj1mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpe1xuICAgICAgICBkMy5zZWxlY3QodGhpcy5iYXNlQ29udGFpbmVyKS5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBkMy5zZWxlY3Qod2luZG93KS5vbihcInJlc2l6ZS5cIiArIHRoaXMuX2lkLCBudWxsKTtcbiAgICB9XG5cbiAgICBpbml0VG9vbHRpcCgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5zaG93VG9vbHRpcCkge1xuICAgICAgICAgICAgaWYoIXNlbGYuX2lzQXR0YWNoZWQgKXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QudG9vbHRpcCA9IGQzLnNlbGVjdChcImJvZHlcIikuc2VsZWN0T3JBcHBlbmQoJ2Rpdi4nK3NlbGYuY29uZmlnLmNzc0NsYXNzUHJlZml4Kyd0b29sdGlwJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC50b29sdGlwPSBzZWxmLmJhc2VDb250YWluZXIucGxvdC50b29sdGlwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc2VsZi5wbG90LnRvb2x0aXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNvbmZpZy5tYXJnaW47XG4gICAgICAgIHRoaXMucGxvdCA9IHRoaXMucGxvdCB8fCB7fTtcbiAgICAgICAgdGhpcy5wbG90Lm1hcmdpbiA9IHtcbiAgICAgICAgICAgIHRvcDogbWFyZ2luLnRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQ6IG1hcmdpbi5sZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IG1hcmdpbi5yaWdodFxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIHRpdGxlTWFyZ2luU2l6ZSA9IDA7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnRpdGxlKXtcbiAgICAgICAgICAgIHRpdGxlTWFyZ2luU2l6ZT0gdGhpcy5jb25maWcudGl0bGVTaXplK3RoaXMuY29uZmlnLnRpdGxlTWFyZ2luLnRvcDtcbiAgICAgICAgICAgIGlmKCF0aGlzLmNvbmZpZy5zdWJ0aXRsZSl7XG4gICAgICAgICAgICAgICAgdGl0bGVNYXJnaW5TaXplICs9IHRoaXMuY29uZmlnLnRpdGxlTWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi50b3A9TWF0aC5tYXgodGhpcy5wbG90Lm1hcmdpbi50b3AsdGl0bGVNYXJnaW5TaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnN1YnRpdGxlKXtcblxuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi50b3A9TWF0aC5tYXgodGhpcy5wbG90Lm1hcmdpbi50b3AsIHRpdGxlTWFyZ2luU2l6ZSt0aGlzLmNvbmZpZy5zdWJ0aXRsZU1hcmdpbi50b3ArdGhpcy5jb25maWcuc3VidGl0bGVTaXplK3RoaXMuY29uZmlnLnN1YnRpdGxlTWFyZ2luLmJvdHRvbSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUaXRsZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnRpdGxlKCk7XG5cbiAgICAgICAgdmFyIGxheWVyTmFtZSwgYXR0YWNobWVudERhdGE7XG4gICAgICAgIGZvciAodmFyIGF0dGFjaG1lbnROYW1lIGluIHRoaXMuX2F0dGFjaGVkKSB7XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnREYXRhID0gZGF0YTtcblxuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRbYXR0YWNobWVudE5hbWVdLnVwZGF0ZShhdHRhY2htZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlVGl0bGUoKSB7XG4gICAgICAgIHZhciB0aXRsZUNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcygncGxvdC10aXRsZScpO1xuICAgICAgICBpZighdGhpcy5jb25maWcudGl0bGUpe1xuICAgICAgICAgICAgdGhpcy5zdmcuc2VsZWN0KFwidGV4dC5cIit0aXRsZUNsYXNzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIit0aXRsZUNsYXNzKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrICh0aGlzLnN2Z1dpZHRoLzIpICtcIixcIisgKHRoaXMuY29uZmlnLnRpdGxlTWFyZ2luLnRvcCkgK1wiKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjAuNWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJjZW50cmFsXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgdGhpcy5jb25maWcudGl0bGVTaXplK1wicHhcIilcbiAgICAgICAgICAgIC50ZXh0KHRoaXMuY29uZmlnLnRpdGxlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTdWJ0aXRsZSgpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKCdwbG90LXN1YnRpdGxlJyk7XG4gICAgICAgIGlmKCF0aGlzLmNvbmZpZy5zdWJ0aXRsZSl7XG4gICAgICAgICAgICB0aGlzLnN2Zy5zZWxlY3QoXCJ0ZXh0LlwiK3N1YnRpdGxlQ2xhc3MpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkgPSB0aGlzLmNvbmZpZy5zdWJ0aXRsZU1hcmdpbi50b3A7XG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnRpdGxlKXtcbiAgICAgICAgICAgIHkrPXRoaXMuY29uZmlnLnRpdGxlTWFyZ2luLnRvcCt0aGlzLmNvbmZpZy50aXRsZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2Zy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc3VidGl0bGVDbGFzcylcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAodGhpcy5zdmdXaWR0aC8yKSArXCIsXCIrICh5KSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMC41ZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImNlbnRyYWxcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCB0aGlzLmNvbmZpZy5zdWJ0aXRsZVNpemUrXCJweFwiKVxuICAgICAgICAgICAgLnRleHQodGhpcy5jb25maWcuc3VidGl0bGUpO1xuICAgIH1cblxuICAgIGRyYXcoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZShkYXRhKTtcblxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLy9Cb3Jyb3dlZCBmcm9tIGQzLmNoYXJ0XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgb3IgcmV0cmlldmUgYW4gXCJhdHRhY2htZW50XCIgQ2hhcnQuIFRoZSBcImF0dGFjaG1lbnRcIiBjaGFydCdzIGBkcmF3YFxuICAgICAqIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIGNvbnRhaW5pbmcgY2hhcnQncyBgZHJhd2AgbWV0aG9kIGlzXG4gICAgICogaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBleHRlcm5hbEV4YW1wbGUgY2hhcnQtYXR0YWNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0YWNobWVudE5hbWUgTmFtZSBvZiB0aGUgYXR0YWNobWVudFxuICAgICAqIEBwYXJhbSB7Q2hhcnR9IFtjaGFydF0gQ2hhcnQgdG8gcmVnaXN0ZXIgYXMgYSBtaXggaW4gb2YgdGhpcyBjaGFydC4gV2hlblxuICAgICAqICAgICAgICB1bnNwZWNpZmllZCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIGF0dGFjaG1lbnQgcHJldmlvdXNseVxuICAgICAqICAgICAgICByZWdpc3RlcmVkIHdpdGggdGhlIHNwZWNpZmllZCBgYXR0YWNobWVudE5hbWVgIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NoYXJ0fSBSZWZlcmVuY2UgdG8gdGhpcyBjaGFydCAoY2hhaW5hYmxlKS5cbiAgICAgKi9cbiAgICBhdHRhY2goYXR0YWNobWVudE5hbWUsIGNoYXJ0KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNoZWRbYXR0YWNobWVudE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRbYXR0YWNobWVudE5hbWVdID0gY2hhcnQ7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgXG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhbiBldmVudCB0cmlnZ2VyZWQgb24gdGhlIGNoYXJ0LiBTZWUge0BsaW5rXG4gICAgICAgICogQ2hhcnQjb25jZX0gdG8gc3Vic2NyaWJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYW4gZXZlbnQgZm9yIG9uZSBvY2N1cmVuY2UuXG4gICAgICpcbiAgICAgKiBAZXh0ZXJuYWxFeGFtcGxlIHtydW5uYWJsZX0gY2hhcnQtb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtDaGFydEV2ZW50SGFuZGxlcn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudFxuICAgICAqICAgICAgICBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIFZhbHVlIHRvIHNldCBhcyBgdGhpc2Agd2hlbiBpbnZva2luZyB0aGVcbiAgICAgKiAgICAgICAgYGNhbGxiYWNrYC4gRGVmYXVsdHMgdG8gdGhlIGNoYXJ0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NoYXJ0fSBBIHJlZmVyZW5jZSB0byB0aGlzIGNoYXJ0IChjaGFpbmFibGUpLlxuICAgICAqL1xuICAgIG9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCB8fCB0aGlzLFxuICAgICAgICAgICAgX2NoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFuIGV2ZW50IHRyaWdnZXJlZCBvbiB0aGUgY2hhcnQuIFRoaXNcbiAgICAgKiBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYXQgdGhlIG5leHQgb2NjdXJhbmNlIG9mIHRoZSBldmVudCBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiB1bnN1YnNjcmliZWQuIFNlZSB7QGxpbmsgQ2hhcnQjb259IHRvIHN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFuXG4gICAgICogZXZlbnQgaW5kZWZpbml0ZWx5LlxuICAgICAqXG4gICAgICogQGV4dGVybmFsRXhhbXBsZSB7cnVubmFibGV9IGNoYXJ0LW9uY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtDaGFydEV2ZW50SGFuZGxlcn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudFxuICAgICAqICAgICAgICBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIFZhbHVlIHRvIHNldCBhcyBgdGhpc2Agd2hlbiBpbnZva2luZyB0aGVcbiAgICAgKiAgICAgICAgYGNhbGxiYWNrYC4gRGVmYXVsdHMgdG8gdGhlIGNoYXJ0IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2hhcnR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY2hhcnQgKGNoYWluYWJsZSlcbiAgICAgKi9cbiAgICBvbmNlKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIG9uY2UsIGNvbnRleHQpO1xuICAgIH1cblxuXG4gICAgLy9Cb3Jyb3dlZCBmcm9tIGQzLmNoYXJ0XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgb25lIG9yIG1vcmUgY2FsbGJhY2sgZnVuY3Rpb25zIGZyb20gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIHRoZVxuICAgICAqIGNoYXJ0LiBXaGVuIG5vIGFyZ3VtZW50cyBhcmUgc3BlY2lmaWVkLCAqYWxsKiBoYW5kbGVycyB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cbiAgICAgKiBXaGVuIG9ubHkgYSBgbmFtZWAgaXMgc3BlY2lmaWVkLCBhbGwgaGFuZGxlcnMgc3Vic2NyaWJlZCB0byB0aGF0IGV2ZW50IHdpbGxcbiAgICAgKiBiZSB1bnN1YnNjcmliZWQuIFdoZW4gYSBgbmFtZWAgYW5kIGBjYWxsYmFja2AgYXJlIHNwZWNpZmllZCwgb25seSB0aGF0XG4gICAgICogZnVuY3Rpb24gd2lsbCBiZSB1bnN1YnNjcmliZWQgZnJvbSB0aGF0IGV2ZW50LiBXaGVuIGEgYG5hbWVgIGFuZCBgY29udGV4dGBcbiAgICAgKiBhcmUgc3BlY2lmaWVkIChidXQgYGNhbGxiYWNrYCBpcyBvbWl0dGVkKSwgYWxsIGV2ZW50cyBib3VuZCB0byB0aGUgZ2l2ZW5cbiAgICAgKiBldmVudCB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxuICAgICAqXG4gICAgICogQGV4dGVybmFsRXhhbXBsZSB7cnVubmFibGV9IGNoYXJ0LW9mZlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSB1bnN1YnNjcmliZWRcbiAgICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnRIYW5kbGVyfSBbY2FsbGJhY2tdIEZ1bmN0aW9uIHRvIGJlIHVuc3Vic2NyaWJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dHMgdG8gYmUgdW5zdWJzY3JpYmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDaGFydH0gQSByZWZlcmVuY2UgdG8gdGhpcyBjaGFydCAoY2hhaW5hYmxlKS5cbiAgICAgKi9cblxuICAgIG9mZihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgbmFtZXMsIG4sIGV2ZW50cywgZXZlbnQsIGksIGo7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHNcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBldmVudHMgZm9yIGEgc3BlY2lmaWMgbmFtZVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIHdoYXRldmVyIGNvbWJpbmF0aW9uIG9mIG5hbWUsIGNvbnRleHRcbiAgICAgICAgLy8gYW5kIGNhbGxiYWNrLlxuICAgICAgICBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBPYmplY3Qua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG4gPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuXTtcbiAgICAgICAgICAgIGogPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgPT09IGV2ZW50LmNhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ID09PSBldmVudC5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvL0JvcnJvd2VkIGZyb20gZDMuY2hhcnRcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IG9uIHRoaXMgY2hhcnQgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICAgICAqXG4gICAgICogQGV4dGVybmFsRXhhbXBsZSB7cnVubmFibGV9IGNoYXJ0LXRyaWdnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cyBWYWx1ZXMgd2l0aCB3aGljaCB0byBpbnZva2UgdGhlIHJlZ2lzdGVyZWRcbiAgICAgKiAgICAgICAgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NoYXJ0fSBBIHJlZmVyZW5jZSB0byB0aGlzIGNoYXJ0IChjaGFpbmFibGUpLlxuICAgICAqL1xuICAgIHRyaWdnZXIobmFtZSkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIHZhciBpLCBldjtcblxuICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBldiA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICBldi5jYWxsYmFjay5hcHBseShldi5jb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZ2V0QmFzZUNvbnRhaW5lcigpe1xuICAgICAgICBpZih0aGlzLl9pc0F0dGFjaGVkKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VDb250YWluZXIuc3ZnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkMy5zZWxlY3QodGhpcy5iYXNlQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBnZXRCYXNlQ29udGFpbmVyTm9kZSgpe1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJhc2VDb250YWluZXIoKS5ub2RlKCk7XG4gICAgfVxuXG4gICAgcHJlZml4Q2xhc3MoY2xhenosIGFkZERvdCl7XG4gICAgICAgIHJldHVybiBhZGREb3Q/ICcuJzogJycrdGhpcy5jb25maWcuY3NzQ2xhc3NQcmVmaXgrY2xheno7XG4gICAgfVxuICAgIGNvbXB1dGVQbG90U2l6ZSgpIHtcbiAgICAgICAgdGhpcy5wbG90LndpZHRoID0gVXRpbHMuYXZhaWxhYmxlV2lkdGgodGhpcy5jb25maWcud2lkdGgsIHRoaXMuZ2V0QmFzZUNvbnRhaW5lcigpLCB0aGlzLnBsb3QubWFyZ2luKTtcbiAgICAgICAgdGhpcy5wbG90LmhlaWdodCA9IFV0aWxzLmF2YWlsYWJsZUhlaWdodCh0aGlzLmNvbmZpZy5oZWlnaHQsIHRoaXMuZ2V0QmFzZUNvbnRhaW5lcigpLCB0aGlzLnBsb3QubWFyZ2luKTtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uRW5hYmxlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZCAmJiB0aGlzLmNvbmZpZy50cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIHNob3dUb29sdGlwKGh0bWwpe1xuICAgICAgICBpZighdGhpcy5wbG90LnRvb2x0aXApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxvdC50b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpO1xuICAgICAgICB0aGlzLnBsb3QudG9vbHRpcC5odG1sKGh0bWwpXG4gICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIChkMy5ldmVudC5wYWdlWCArIDUpICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIChkMy5ldmVudC5wYWdlWSAtIDI4KSArIFwicHhcIik7XG4gICAgfVxuXG4gICAgaGlkZVRvb2x0aXAoKXtcbiAgICAgICAgaWYoIXRoaXMucGxvdC50b29sdGlwKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsb3QudG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgIH1cblxuICAgIGluaXRDb25maWdBY2Nlc3NvcnMoY2xlYW4pIHtcbiAgICAgICAgaWYoY2xlYW4pe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcm9wZXJ0eUFjY2Vzc29ycyh0aGlzLHRoaXMsIHRoaXMuY29uZmlnLCBcIiRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0UHJvcGVydHlBY2Nlc3NvcnModGhpcyx0aGlzLCB0aGlzLmNvbmZpZywgXCIkXCIsIHRydWUpO1xuICAgIH1cblxuICAgIHJlbW92ZVByb3BlcnR5QWNjZXNzb3JzKGJpbmRUbyxyZXR1cm5PYmosIHNvdXJjZSwgcHJlZml4KSB7XG4gICAgICAgIHZhciBzZWxmICA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZighc291cmNlLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJpbmRUb1twcmVmaXggKyBpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRQcm9wZXJ0eUFjY2Vzc29ycyhiaW5kVG8scmV0dXJuT2JqLCBzb3VyY2UsIHByZWZpeCwgcmVjdXJzaXZlKSB7XG4gICAgICAgIHZhciBzZWxmICA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZighc291cmNlLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFjY2Vzc29yID0gc2VsZi5pbml0UHJvcGVydHlBY2Nlc3NvcihiaW5kVG8scmV0dXJuT2JqLCBzb3VyY2UsIGksIHByZWZpeCk7XG5cbiAgICAgICAgICAgIGlmKHJlY3Vyc2l2ZSAmJiBVdGlscy5pc09iamVjdE5vdEFycmF5KHNvdXJjZVtpXSkpe1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdFByb3BlcnR5QWNjZXNzb3JzKGFjY2Vzc29yLCBiaW5kVG8sIHNvdXJjZVtpXSwgcHJlZml4LCByZWN1cnNpdmUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0UHJvcGVydHlBY2Nlc3NvcihiaW5kVG8sIHJldHVybk9iaiwgc291cmNlLCBwcm9wZXJ0eUtleSwgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBiaW5kVG9bcHJlZml4ICsgcHJvcGVydHlLZXldID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VbcHJvcGVydHlLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5S2V5XSA9IF87XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuT2JqO1xuICAgICAgICB9O1xuICAgIH1cblxuXG59XG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge1N0YXRpc3RpY3NVdGlsc30gZnJvbSAnLi9zdGF0aXN0aWNzLXV0aWxzJ1xuaW1wb3J0IHtMZWdlbmR9IGZyb20gJy4vbGVnZW5kJ1xuaW1wb3J0IHtTY2F0dGVyUGxvdH0gZnJvbSAnLi9zY2F0dGVycGxvdCdcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBDb3JyZWxhdGlvbk1hdHJpeENvbmZpZyBleHRlbmRzIENoYXJ0Q29uZmlnIHtcblxuICAgIHN2Z0NsYXNzID0gdGhpcy5jc3NDbGFzc1ByZWZpeCsnY29ycmVsYXRpb24tbWF0cml4JztcbiAgICBndWlkZXMgPSBmYWxzZTsgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgc2hvd1Rvb2x0aXAgPSB0cnVlOyAvL3Nob3cgdG9vbHRpcCBvbiBkb3QgaG92ZXJcbiAgICBzaG93TGVnZW5kID0gdHJ1ZTtcbiAgICBoaWdobGlnaHRMYWJlbHMgPSB0cnVlO1xuICAgIHJvdGF0ZUxhYmVsc1ggPSB0cnVlO1xuICAgIHJvdGF0ZUxhYmVsc1kgPSB0cnVlO1xuICAgIHZhcmlhYmxlcyA9IHtcbiAgICAgICAgbGFiZWxzOiB1bmRlZmluZWQsXG4gICAgICAgIGtleXM6IFtdLCAvL29wdGlvbmFsIGFycmF5IG9mIHZhcmlhYmxlIGtleXNcbiAgICAgICAgdmFsdWU6IChkLCB2YXJpYWJsZUtleSkgPT4gcGFyc2VGbG9hdChkW3ZhcmlhYmxlS2V5XSksIC8vIHZhcmlhYmxlIHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIHNjYWxlOiBcIm9yZGluYWxcIlxuICAgIH07XG4gICAgY29ycmVsYXRpb24gPSB7XG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBkb21haW46IFstMSwgLTAuNzUsIC0wLjUsIDAsIDAuNSwgMC43NSwgMV0sXG4gICAgICAgIHJhbmdlOiBbXCJkYXJrYmx1ZVwiLCBcImJsdWVcIiwgXCJsaWdodHNreWJsdWVcIiwgXCJ3aGl0ZVwiLCBcIm9yYW5nZXJlZFwiLCBcImNyaW1zb25cIiwgXCJkYXJrcmVkXCJdLFxuICAgICAgICB2YWx1ZTogKHhWYWx1ZXMsIHlWYWx1ZXMpID0+IFN0YXRpc3RpY3NVdGlscy5zYW1wbGVDb3JyZWxhdGlvbih4VmFsdWVzLCB5VmFsdWVzKVxuXG4gICAgfTtcbiAgICBjZWxsID0ge1xuICAgICAgICBzaGFwZTogXCJlbGxpcHNlXCIsIC8vcG9zc2libGUgdmFsdWVzOiByZWN0LCBjaXJjbGUsIGVsbGlwc2VcbiAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICBzaXplTWluOiAxNSxcbiAgICAgICAgc2l6ZU1heDogMjUwLFxuICAgICAgICBwYWRkaW5nOiAxXG4gICAgfTtcbiAgICBtYXJnaW4gPSB7XG4gICAgICAgIGxlZnQ6IDYwLFxuICAgICAgICByaWdodDogNTAsXG4gICAgICAgIHRvcDogMzAsXG4gICAgICAgIGJvdHRvbTogNjBcbiAgICB9O1xuICAgIGdyb3Vwcz17XG4gICAgICAgIGtleTogbnVsbCxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChjdXN0b20pIHtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvcnJlbGF0aW9uTWF0cml4IGV4dGVuZHMgQ2hhcnQge1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgQ29ycmVsYXRpb25NYXRyaXhDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBDb3JyZWxhdGlvbk1hdHJpeENvbmZpZyhjb25maWcpKTtcblxuICAgIH1cblxuICAgIGluaXRQbG90KCkge1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNvbmZpZy5tYXJnaW47XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgdGhpcy5wbG90LnggPSB7fTtcbiAgICAgICAgdGhpcy5wbG90LmNvcnJlbGF0aW9uID0ge1xuICAgICAgICAgICAgbWF0cml4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZWxsczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sb3I6IHt9LFxuICAgICAgICAgICAgc2hhcGU6IHt9XG4gICAgICAgIH07XG5cblxuICAgICAgICB0aGlzLnNldHVwVmFyaWFibGVzKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGg7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlck5vZGUgPSB0aGlzLmdldEJhc2VDb250YWluZXJOb2RlKCk7XG4gICAgICAgIHRoaXMucGxvdC5wbGFjZWhvbGRlck5vZGUgPSBwbGFjZWhvbGRlck5vZGU7XG5cbiAgICAgICAgdmFyIHBhcmVudFdpZHRoID0gcGxhY2Vob2xkZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBpZiAod2lkdGgpIHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnBsb3QuY2VsbFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFNpemUgPSBNYXRoLm1heChjb25mLmNlbGwuc2l6ZU1pbiwgTWF0aC5taW4oY29uZi5jZWxsLnNpemVNYXgsICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSAvIHRoaXMucGxvdC52YXJpYWJsZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jZWxsU2l6ZSA9IHRoaXMuY29uZmlnLmNlbGwuc2l6ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnBsb3QuY2VsbFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFNpemUgPSBNYXRoLm1heChjb25mLmNlbGwuc2l6ZU1pbiwgTWF0aC5taW4oY29uZi5jZWxsLnNpemVNYXgsIChwYXJlbnRXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSAvIHRoaXMucGxvdC52YXJpYWJsZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5wbG90LmNlbGxTaXplICogdGhpcy5wbG90LnZhcmlhYmxlcy5sZW5ndGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoO1xuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcGxhY2Vob2xkZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxvdC53aWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG4gICAgICAgIHRoaXMucGxvdC5oZWlnaHQgPSB0aGlzLnBsb3Qud2lkdGg7XG5cbiAgICAgICAgdGhpcy5zZXR1cFZhcmlhYmxlc1NjYWxlcygpO1xuICAgICAgICB0aGlzLnNldHVwQ29ycmVsYXRpb25TY2FsZXMoKTtcbiAgICAgICAgdGhpcy5zZXR1cENvcnJlbGF0aW9uTWF0cml4KCk7XG5cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFZhcmlhYmxlc1NjYWxlcygpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcudmFyaWFibGVzO1xuXG4gICAgICAgIC8qICpcbiAgICAgICAgICogdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAgICAgICAqIHNjYWxlIC0gbWFwcyB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzIGEgcGl4ZWwgcG9zaXRpb24uXG4gICAgICAgICAqIG1hcCBmdW5jdGlvbiAtIG1hcHMgZnJvbSBkYXRhIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICogYXhpcyAtIHNldHMgdXAgYXhpc1xuICAgICAgICAgKiovXG4gICAgICAgIHgudmFsdWUgPSBjb25mLnZhbHVlO1xuICAgICAgICB4LnNjYWxlID0gZDMuc2NhbGVCYW5kKCkucmFuZ2UoW3Bsb3Qud2lkdGgsIDBdKTtcbiAgICAgICAgeC5tYXAgPSBkID0+IHguc2NhbGUoeC52YWx1ZShkKSk7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBDb3JyZWxhdGlvblNjYWxlcygpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBjb3JyQ29uZiA9IHRoaXMuY29uZmlnLmNvcnJlbGF0aW9uO1xuXG4gICAgICAgIHBsb3QuY29ycmVsYXRpb24uY29sb3Iuc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb3JyQ29uZi5zY2FsZSkuZG9tYWluKGNvcnJDb25mLmRvbWFpbikucmFuZ2UoY29yckNvbmYucmFuZ2UpO1xuICAgICAgICB2YXIgc2hhcGUgPSBwbG90LmNvcnJlbGF0aW9uLnNoYXBlID0ge307XG5cbiAgICAgICAgdmFyIGNlbGxDb25mID0gdGhpcy5jb25maWcuY2VsbDtcbiAgICAgICAgc2hhcGUudHlwZSA9IGNlbGxDb25mLnNoYXBlO1xuXG4gICAgICAgIHZhciBzaGFwZVNpemUgPSBwbG90LmNlbGxTaXplIC0gY2VsbENvbmYucGFkZGluZyAqIDI7XG4gICAgICAgIGlmIChzaGFwZS50eXBlID09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzTWF4ID0gc2hhcGVTaXplIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1c1NjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbMiwgcmFkaXVzTWF4XSk7XG4gICAgICAgICAgICBzaGFwZS5yYWRpdXMgPSBjPT4gc2hhcGUucmFkaXVzU2NhbGUoTWF0aC5hYnMoYy52YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlLnR5cGUgPT0gJ2VsbGlwc2UnKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzTWF4ID0gc2hhcGVTaXplIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1c1NjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbcmFkaXVzTWF4LCAyXSk7XG4gICAgICAgICAgICBzaGFwZS5yYWRpdXNYID0gYz0+IHNoYXBlLnJhZGl1c1NjYWxlKE1hdGguYWJzKGMudmFsdWUpKTtcbiAgICAgICAgICAgIHNoYXBlLnJhZGl1c1kgPSByYWRpdXNNYXg7XG5cbiAgICAgICAgICAgIHNoYXBlLnJvdGF0ZVZhbCA9IHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2ID09IDApIHJldHVybiBcIjBcIjtcbiAgICAgICAgICAgICAgICBpZiAodiA8IDApIHJldHVybiBcIi00NVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjQ1XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZS50eXBlID09ICdyZWN0Jykge1xuICAgICAgICAgICAgc2hhcGUuc2l6ZSA9IHNoYXBlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICBzZXR1cFZhcmlhYmxlcygpIHtcblxuICAgICAgICB2YXIgdmFyaWFibGVzQ29uZiA9IHRoaXMuY29uZmlnLnZhcmlhYmxlcztcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHBsb3QuZG9tYWluQnlWYXJpYWJsZSA9IHt9O1xuICAgICAgICBwbG90LnZhcmlhYmxlcyA9IHZhcmlhYmxlc0NvbmYua2V5cztcbiAgICAgICAgaWYgKCFwbG90LnZhcmlhYmxlcyB8fCAhcGxvdC52YXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbG90LnZhcmlhYmxlcyA9IFV0aWxzLmluZmVyVmFyaWFibGVzKGRhdGEsIHRoaXMuY29uZmlnLmdyb3Vwcy5rZXksIHRoaXMuY29uZmlnLmluY2x1ZGVJblBsb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC5sYWJlbHMgPSBbXTtcbiAgICAgICAgcGxvdC5sYWJlbEJ5VmFyaWFibGUgPSB7fTtcbiAgICAgICAgcGxvdC52YXJpYWJsZXMuZm9yRWFjaCgodmFyaWFibGVLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBwbG90LmRvbWFpbkJ5VmFyaWFibGVbdmFyaWFibGVLZXldID0gZDMuZXh0ZW50KGRhdGEsIChkKSA9PiB2YXJpYWJsZXNDb25mLnZhbHVlKGQsIHZhcmlhYmxlS2V5KSk7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB2YXJpYWJsZUtleTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZXNDb25mLmxhYmVscyAmJiB2YXJpYWJsZXNDb25mLmxhYmVscy5sZW5ndGggPiBpbmRleCkge1xuXG4gICAgICAgICAgICAgICAgbGFiZWwgPSB2YXJpYWJsZXNDb25mLmxhYmVsc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbG90LmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIHBsb3QubGFiZWxCeVZhcmlhYmxlW3ZhcmlhYmxlS2V5XSA9IGxhYmVsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhwbG90LmxhYmVsQnlWYXJpYWJsZSk7XG5cbiAgICB9O1xuXG5cbiAgICBzZXR1cENvcnJlbGF0aW9uTWF0cml4KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5wbG90LmNvcnJlbGF0aW9uLm1hdHJpeCA9IFtdO1xuICAgICAgICB2YXIgbWF0cml4Q2VsbHMgPSB0aGlzLnBsb3QuY29ycmVsYXRpb24ubWF0cml4LmNlbGxzID0gW107XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuXG4gICAgICAgIHZhciB2YXJpYWJsZVRvVmFsdWVzID0ge307XG4gICAgICAgIHBsb3QudmFyaWFibGVzLmZvckVhY2goKHYsIGkpID0+IHtcblxuICAgICAgICAgICAgdmFyaWFibGVUb1ZhbHVlc1t2XSA9IGRhdGEubWFwKGQ9PnBsb3QueC52YWx1ZShkLCB2KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3QudmFyaWFibGVzLmZvckVhY2goKHYxLCBpKSA9PiB7XG4gICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICBtYXRyaXgucHVzaChyb3cpO1xuXG4gICAgICAgICAgICBwbG90LnZhcmlhYmxlcy5mb3JFYWNoKCh2MiwgaikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyID0gMTtcbiAgICAgICAgICAgICAgICBpZiAodjEgIT0gdjIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29yciA9IHNlbGYuY29uZmlnLmNvcnJlbGF0aW9uLnZhbHVlKHZhcmlhYmxlVG9WYWx1ZXNbdjFdLCB2YXJpYWJsZVRvVmFsdWVzW3YyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICByb3dWYXI6IHYxLFxuICAgICAgICAgICAgICAgICAgICBjb2xWYXI6IHYyLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGksXG4gICAgICAgICAgICAgICAgICAgIGNvbDogaixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvcnJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGNlbGwpO1xuXG4gICAgICAgICAgICAgICAgbWF0cml4Q2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgdXBkYXRlKG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICAvLyB0aGlzLnVwZGF0ZVxuICAgICAgICB0aGlzLnVwZGF0ZUNlbGxzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFyaWFibGVMYWJlbHMoKTtcblxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5zaG93TGVnZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHVwZGF0ZVZhcmlhYmxlTGFiZWxzKCkge1xuICAgICAgICB0aGlzLnBsb3QubGFiZWxDbGFzcyA9IHRoaXMucHJlZml4Q2xhc3MoXCJsYWJlbFwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVBeGlzWCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNZKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXhpc1goKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBsYWJlbENsYXNzID0gcGxvdC5sYWJlbENsYXNzO1xuICAgICAgICB2YXIgbGFiZWxYQ2xhc3MgPSBsYWJlbENsYXNzICsgXCIteFwiO1xuXG4gICAgICAgIHZhciBsYWJlbHMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIGxhYmVsWENsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGxvdC52YXJpYWJsZXMsIChkLCBpKT0+aSk7XG5cbiAgICAgICAgdmFyIGxhYmVsc01lcmdlID0gbGFiZWxzLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGxhYmVsQ2xhc3MgKyBcIiBcIiArIGxhYmVsWENsYXNzICsgXCIgXCIgKyBsYWJlbFhDbGFzcyArIFwiLVwiICsgaSkubWVyZ2UobGFiZWxzKTtcblxuICAgICAgICBsYWJlbHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiBpICogcGxvdC5jZWxsU2l6ZSArIHBsb3QuY2VsbFNpemUgLyAyKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHBsb3QuaGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAtMilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgNSlcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcblxuICAgICAgICAgICAgLy8gLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImhhbmdpbmdcIilcbiAgICAgICAgICAgIC50ZXh0KHY9PnBsb3QubGFiZWxCeVZhcmlhYmxlW3ZdKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcucm90YXRlTGFiZWxzWCkge1xuICAgICAgICAgICAgbGFiZWxzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJyb3RhdGUoLTQ1LCBcIiArIChpICogcGxvdC5jZWxsU2l6ZSArIHBsb3QuY2VsbFNpemUgLyAyICApICsgXCIsIFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXhXaWR0aCA9IHNlbGYuY29tcHV0ZVhBeGlzTGFiZWxzV2lkdGgoKTtcbiAgICAgICAgbGFiZWxzTWVyZ2UuZWFjaChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIFV0aWxzLnBsYWNlVGV4dFdpdGhFbGxpcHNpc0FuZFRvb2x0aXAoZDMuc2VsZWN0KHRoaXMpLCBsYWJlbCwgbWF4V2lkdGgsIHNlbGYuY29uZmlnLnNob3dUb29sdGlwID8gc2VsZi5wbG90LnRvb2x0aXAgOiBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxhYmVscy5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBsYWJlbENsYXNzID0gcGxvdC5sYWJlbENsYXNzO1xuICAgICAgICB2YXIgbGFiZWxZQ2xhc3MgPSBwbG90LmxhYmVsQ2xhc3MgKyBcIi15XCI7XG4gICAgICAgIHZhciBsYWJlbHMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIGxhYmVsWUNsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGxvdC52YXJpYWJsZXMpO1xuXG4gICAgICAgIHZhciBsYWJlbHNNZXJnZSA9IGxhYmVscy5lbnRlcigpLmFwcGVuZChcInRleHRcIikubWVyZ2UobGFiZWxzKTtcblxuICAgICAgICBsYWJlbHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgKGQsIGkpID0+IGkgKiBwbG90LmNlbGxTaXplICsgcGxvdC5jZWxsU2l6ZSAvIDIpXG4gICAgICAgICAgICAuYXR0cihcImR4XCIsIC0yKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gbGFiZWxDbGFzcyArIFwiIFwiICsgbGFiZWxZQ2xhc3MgKyBcIiBcIiArIGxhYmVsWUNsYXNzICsgXCItXCIgKyBpKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImhhbmdpbmdcIilcbiAgICAgICAgICAgIC50ZXh0KHY9PnBsb3QubGFiZWxCeVZhcmlhYmxlW3ZdKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcucm90YXRlTGFiZWxzWSkge1xuICAgICAgICAgICAgbGFiZWxzTWVyZ2VcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJyb3RhdGUoLTQ1LCBcIiArIDAgKyBcIiwgXCIgKyAoaSAqIHBsb3QuY2VsbFNpemUgKyBwbG90LmNlbGxTaXplIC8gMikgKyBcIilcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFdpZHRoID0gc2VsZi5jb21wdXRlWUF4aXNMYWJlbHNXaWR0aCgpO1xuICAgICAgICBsYWJlbHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgVXRpbHMucGxhY2VUZXh0V2l0aEVsbGlwc2lzQW5kVG9vbHRpcChkMy5zZWxlY3QodGhpcyksIGxhYmVsLCBtYXhXaWR0aCwgc2VsZi5jb25maWcuc2hvd1Rvb2x0aXAgPyBzZWxmLnBsb3QudG9vbHRpcCA6IGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGFiZWxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBjb21wdXRlWUF4aXNMYWJlbHNXaWR0aCgpIHtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5wbG90Lm1hcmdpbi5sZWZ0O1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnJvdGF0ZUxhYmVsc1kpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heFdpZHRoICo9IFV0aWxzLlNRUlRfMjtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gMTE7IC8vdG9kbyBjaGVjayBhY3R1YWwgZm9udCBzaXplXG4gICAgICAgIG1heFdpZHRoIC09IGZvbnRTaXplIC8gMjtcblxuICAgICAgICByZXR1cm4gbWF4V2lkdGg7XG4gICAgfVxuXG4gICAgY29tcHV0ZVhBeGlzTGFiZWxzV2lkdGgob2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcucm90YXRlTGFiZWxzWCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdC5jZWxsU2l6ZSAtIDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnBsb3QubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgc2l6ZSAqPSBVdGlscy5TUVJUXzI7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IDExOyAvL3RvZG8gY2hlY2sgYWN0dWFsIGZvbnQgc2l6ZVxuICAgICAgICBzaXplIC09IGZvbnRTaXplIC8gMjtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgdXBkYXRlQ2VsbHMoKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGNlbGxDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJjZWxsXCIpO1xuICAgICAgICB2YXIgY2VsbFNoYXBlID0gcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS50eXBlO1xuXG4gICAgICAgIHZhciBjZWxscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJnLlwiICsgY2VsbENsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGxvdC5jb3JyZWxhdGlvbi5tYXRyaXguY2VsbHMpO1xuXG4gICAgICAgIHZhciBjZWxsc0VudGVyID0gY2VsbHMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChjZWxsQ2xhc3MsIHRydWUpO1xuICAgICAgICB2YXIgY2VsbHNNZXJnZSA9IGNlbGxzRW50ZXIubWVyZ2UoY2VsbHMpO1xuICAgICAgICBjZWxsc01lcmdlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYz0+IFwidHJhbnNsYXRlKFwiICsgKHBsb3QuY2VsbFNpemUgKiBjLmNvbCArIHBsb3QuY2VsbFNpemUgLyAyKSArIFwiLFwiICsgKHBsb3QuY2VsbFNpemUgKiBjLnJvdyArIHBsb3QuY2VsbFNpemUgLyAyKSArIFwiKVwiKTtcblxuICAgICAgICBjZWxsc01lcmdlLmNsYXNzZWQoc2VsZi5jb25maWcuY3NzQ2xhc3NQcmVmaXggKyBcInNlbGVjdGFibGVcIiwgISFzZWxmLnNjYXR0ZXJQbG90KTtcblxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBcIio6bm90KC5jZWxsLXNoYXBlLVwiICsgY2VsbFNoYXBlICsgXCIpXCI7XG5cbiAgICAgICAgdmFyIHdyb25nU2hhcGVzID0gY2VsbHMuc2VsZWN0QWxsKHNlbGVjdG9yKTtcbiAgICAgICAgd3JvbmdTaGFwZXMucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IGNlbGxzTWVyZ2Uuc2VsZWN0T3JBcHBlbmQoY2VsbFNoYXBlICsgXCIuY2VsbC1zaGFwZS1cIiArIGNlbGxTaGFwZSk7XG5cbiAgICAgICAgaWYgKHBsb3QuY29ycmVsYXRpb24uc2hhcGUudHlwZSA9PSAnY2lyY2xlJykge1xuXG4gICAgICAgICAgICBzaGFwZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5yYWRpdXMpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxvdC5jb3JyZWxhdGlvbi5zaGFwZS50eXBlID09ICdlbGxpcHNlJykge1xuICAgICAgICAgICAgLy8gY2VsbHMuYXR0cihcInRyYW5zZm9ybVwiLCBjPT4gXCJ0cmFuc2xhdGUoMzAwLDE1MCkgcm90YXRlKFwiK3Bsb3QuY29ycmVsYXRpb24uc2hhcGUucm90YXRlVmFsKGMudmFsdWUpK1wiKVwiKTtcbiAgICAgICAgICAgIHNoYXBlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5yYWRpdXNYKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwicnlcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5yYWRpdXNZKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgMClcbiAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIDApXG5cbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBjPT4gXCJyb3RhdGUoXCIgKyBwbG90LmNvcnJlbGF0aW9uLnNoYXBlLnJvdGF0ZVZhbChjLnZhbHVlKSArIFwiKVwiKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHBsb3QuY29ycmVsYXRpb24uc2hhcGUudHlwZSA9PSAncmVjdCcpIHtcbiAgICAgICAgICAgIHNoYXBlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGxvdC5jb3JyZWxhdGlvbi5zaGFwZS5zaXplKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBsb3QuY29ycmVsYXRpb24uc2hhcGUuc2l6ZSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgLXBsb3QuY2VsbFNpemUgLyAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtcGxvdC5jZWxsU2l6ZSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlcy5zdHlsZShcImZpbGxcIiwgYz0+IHBsb3QuY29ycmVsYXRpb24uY29sb3Iuc2NhbGUoYy52YWx1ZSkpO1xuXG4gICAgICAgIHZhciBtb3VzZW92ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIG1vdXNlb3V0Q2FsbGJhY2tzID0gW107XG5cbiAgICAgICAgaWYgKHBsb3QudG9vbHRpcCkge1xuXG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MucHVzaChjPT4ge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goYz0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5jb25maWcuaGlnaGxpZ2h0TGFiZWxzKSB7XG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0Q2xhc3MgPSBzZWxmLmNvbmZpZy5jc3NDbGFzc1ByZWZpeCArIFwiaGlnaGxpZ2h0XCI7XG4gICAgICAgICAgICB2YXIgeExhYmVsQ2xhc3MgPSBjPT5wbG90LmxhYmVsQ2xhc3MgKyBcIi14LVwiICsgYy5jb2w7XG4gICAgICAgICAgICB2YXIgeUxhYmVsQ2xhc3MgPSBjPT5wbG90LmxhYmVsQ2xhc3MgKyBcIi15LVwiICsgYy5yb3c7XG5cblxuICAgICAgICAgICAgbW91c2VvdmVyQ2FsbGJhY2tzLnB1c2goYz0+IHtcblxuICAgICAgICAgICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgeExhYmVsQ2xhc3MoYykpLmNsYXNzZWQoaGlnaGxpZ2h0Q2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgeUxhYmVsQ2xhc3MoYykpLmNsYXNzZWQoaGlnaGxpZ2h0Q2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb3VzZW91dENhbGxiYWNrcy5wdXNoKGM9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB4TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgeUxhYmVsQ2xhc3MoYykpLmNsYXNzZWQoaGlnaGxpZ2h0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBjZWxsc01lcmdlLm9uKFwibW91c2VvdmVyXCIsIGMgPT4ge1xuICAgICAgICAgICAgbW91c2VvdmVyQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2s9PmNhbGxiYWNrKGMpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGMgPT4ge1xuICAgICAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2s9PmNhbGxiYWNrKGMpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNlbGxzTWVyZ2Uub24oXCJjbGlja1wiLCBjPT4ge1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKFwiY2VsbC1zZWxlY3RlZFwiLCBjKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBjZWxscy5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxuXG5cbiAgICB1cGRhdGVMZWdlbmQoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciBsZWdlbmRYID0gdGhpcy5wbG90LndpZHRoICsgMTA7XG4gICAgICAgIHZhciBsZWdlbmRZID0gMDtcbiAgICAgICAgdmFyIGJhcldpZHRoID0gMTA7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSB0aGlzLnBsb3QuaGVpZ2h0IC0gMjtcbiAgICAgICAgdmFyIHNjYWxlID0gcGxvdC5jb3JyZWxhdGlvbi5jb2xvci5zY2FsZTtcblxuICAgICAgICBwbG90LmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5zdmcsIHRoaXMuc3ZnRywgc2NhbGUsIGxlZ2VuZFgsIGxlZ2VuZFkpLmxpbmVhckdyYWRpZW50QmFyKGJhcldpZHRoLCBiYXJIZWlnaHQpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBhdHRhY2hTY2F0dGVyUGxvdChjb250YWluZXJTZWxlY3RvciwgY29uZmlnKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cblxuICAgICAgICB2YXIgc2NhdHRlclBsb3RDb25maWcgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IHNlbGYucGxvdC5oZWlnaHQgKyBzZWxmLmNvbmZpZy5tYXJnaW4udG9wICsgc2VsZi5jb25maWcubWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgIHdpZHRoOiBzZWxmLnBsb3QuaGVpZ2h0ICsgc2VsZi5jb25maWcubWFyZ2luLnRvcCArIHNlbGYuY29uZmlnLm1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICBncm91cHM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IHNlbGYuY29uZmlnLmdyb3Vwcy5rZXksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHNlbGYuY29uZmlnLmdyb3Vwcy5sYWJlbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGd1aWRlczogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5zY2F0dGVyUGxvdCA9IHRydWU7XG5cbiAgICAgICAgc2NhdHRlclBsb3RDb25maWcgPSBVdGlscy5kZWVwRXh0ZW5kKHNjYXR0ZXJQbG90Q29uZmlnLCBjb25maWcpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMub24oXCJjZWxsLXNlbGVjdGVkXCIsIGM9PiB7XG5cblxuICAgICAgICAgICAgc2NhdHRlclBsb3RDb25maWcueCA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IGMucm93VmFyLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBzZWxmLnBsb3QubGFiZWxCeVZhcmlhYmxlW2Mucm93VmFyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjYXR0ZXJQbG90Q29uZmlnLnkgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBjLmNvbFZhcixcbiAgICAgICAgICAgICAgICBsYWJlbDogc2VsZi5wbG90LmxhYmVsQnlWYXJpYWJsZVtjLmNvbFZhcl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc2VsZi5zY2F0dGVyUGxvdCAmJiBzZWxmLnNjYXR0ZXJQbG90ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY2F0dGVyUGxvdC5zZXRDb25maWcoc2NhdHRlclBsb3RDb25maWcpLmluaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY2F0dGVyUGxvdCA9IG5ldyBTY2F0dGVyUGxvdChjb250YWluZXJTZWxlY3Rvciwgc2VsZi5kYXRhLCBzY2F0dGVyUGxvdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2goXCJTY2F0dGVyUGxvdFwiLCBzZWxmLnNjYXR0ZXJQbG90KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0pO1xuXG5cbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgRDNFeHRlbnNpb25zIHtcblxuICAgIHN0YXRpYyBleHRlbmQoKSB7XG5cbiAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5lbnRlci5wcm90b3R5cGUuaW5zZXJ0U2VsZWN0b3IgPVxuICAgICAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5pbnNlcnRTZWxlY3Rvcih0aGlzLCBzZWxlY3RvciwgYmVmb3JlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5lbnRlci5wcm90b3R5cGUuYXBwZW5kU2VsZWN0b3IgPVxuICAgICAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5hcHBlbmRTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuYXBwZW5kU2VsZWN0b3IodGhpcywgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLmVudGVyLnByb3RvdHlwZS5zZWxlY3RPckFwcGVuZCA9XG4gICAgICAgICAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdE9yQXBwZW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEQzRXh0ZW5zaW9ucy5zZWxlY3RPckFwcGVuZCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUuZW50ZXIucHJvdG90eXBlLnNlbGVjdE9ySW5zZXJ0ID1cbiAgICAgICAgICAgIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0T3JJbnNlcnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuc2VsZWN0T3JJbnNlcnQodGhpcywgc2VsZWN0b3IsIGJlZm9yZSk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICB9XG5cbiAgICBzdGF0aWMgaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBvcGVyYXRpb24sIGJlZm9yZSkge1xuXG4gICAgICAgIHZhciBzZWxlY3RvclBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoLyhbXFwuXFwjXSkvKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBwYXJlbnRbb3BlcmF0aW9uXShzZWxlY3RvclBhcnRzLnNoaWZ0KCksIGJlZm9yZSk7Ly9cIjpmaXJzdC1jaGlsZFwiXG5cbiAgICAgICAgd2hpbGUgKHNlbGVjdG9yUGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yTW9kaWZpZXIgPSBzZWxlY3RvclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JJdGVtID0gc2VsZWN0b3JQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yTW9kaWZpZXIgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuY2xhc3NlZChzZWxlY3Rvckl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvck1vZGlmaWVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmF0dHIoJ2lkJywgc2VsZWN0b3JJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5zZXJ0U2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBcImluc2VydFwiLCBiZWZvcmUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuaW5zZXJ0T3JBcHBlbmRTZWxlY3RvcihwYXJlbnQsIHNlbGVjdG9yLCBcImFwcGVuZFwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0T3JBcHBlbmQocGFyZW50LCBzZWxlY3RvciwgZWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gcGFyZW50LnNlbGVjdChzZWxlY3Rvcik7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uZW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEM0V4dGVuc2lvbnMuYXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG5cbiAgICBzdGF0aWMgc2VsZWN0T3JJbnNlcnQocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBwYXJlbnQuc2VsZWN0KHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gRDNFeHRlbnNpb25zLmluc2VydFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IsIGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnZDMtZGlzcGF0Y2gnO1xuZXhwb3J0ICogZnJvbSAnZDMtc2NhbGUnO1xuZXhwb3J0ICogZnJvbSAnZDMtc2VsZWN0aW9uJztcbmV4cG9ydCAqIGZyb20gJ2QzLXNoYXBlJ1xuZXhwb3J0ICogZnJvbSAnZDMtZHJhZyc7XG5leHBvcnQgKiBmcm9tICdkMy1icnVzaCdcbmV4cG9ydCAqIGZyb20gJ2QzLWFycmF5J1xuZXhwb3J0ICogZnJvbSAnZDMtaGllcmFyY2h5J1xuZXhwb3J0ICogZnJvbSAnZDMtdGltZS1mb3JtYXQnXG5leHBvcnQgKiBmcm9tICdkMy1jb2xsZWN0aW9uJ1xuZXhwb3J0ICogZnJvbSAnZDMtZWFzZSdcbmV4cG9ydCAqIGZyb20gJ2QzLWF4aXMnXG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSBcIi4vbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgRGl2ZXJnaW5nU3RhY2tlZEJhckNoYXJ0Q29uZmlnIGV4dGVuZHMgQ2hhcnRDb25maWd7XG5cbiAgICBzdmdDbGFzcyA9IHRoaXMuY3NzQ2xhc3NQcmVmaXggKyAnZGl2ZXJnaW5nLXN0YWNrZWQtYmFyLWNoYXJ0JztcbiAgICBzaG93VG9vbHRpcCA9IHRydWU7XG4gICAgc2hvd0xlZ2VuZD10cnVlO1xuICAgIGZvcmNlTGVnZW5kPWZhbHNlO1xuICAgIGxlZ2VuZD17XG4gICAgICAgIHdpZHRoOiA4MCxcbiAgICAgICAgbWFyZ2luOiAxMCxcbiAgICAgICAgc2hhcGVXaWR0aDogMjBcbiAgICB9O1xuICAgIHggPSB7Ly8gWCBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgbGFiZWxcbiAgICAgICAgdmFsdWU6IGQgPT4gZC52YWx1ZXMsIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgZ3VpZGVzOiB0cnVlLCAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICAgICAgb3JpZW50OiAndG9wJyxcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4wMixcbiAgICB9O1xuICAgIHkgPSB7Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIHZhbHVlOiBkID0+IGQua2V5LCAvLyB5IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIHNjYWxlOiBcIm9yZGluYWxcIixcbiAgICAgICAgb3JpZW50OiAnbGVmdCcsXG4gICAgICAgIGd1aWRlczogdHJ1ZSAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICB9O1xuXG4gICAgdHJhbnNpdGlvbiA9IHRydWU7XG4gICAgY29sb3IgPSAgdW5kZWZpbmVkOy8vIHN0cmluZyBvciBmdW5jdGlvbiByZXR1cm5pbmcgY29sb3IncyB2YWx1ZSBmb3IgY29sb3Igc2NhbGVcbiAgICBkM0NvbG9yQ2F0ZWdvcnk9ICdjYXRlZ29yeTEwJztcbiAgICBzaG93QmFyVmFsdWVzID0gdHJ1ZTtcblxuXG4gICAgY29sb3JSYW5nZSA9IHVuZGVmaW5lZDtcblxuICAgIGNhdGVnb3J5TmFtZXMgPSB1bmRlZmluZWQ7XG4gICAgbWlkZGxlVmFsdWUgPSAwO1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYoY3VzdG9tKXtcbiAgICAgICAgICAgIFV0aWxzLmRlZXBFeHRlbmQodGhpcywgY3VzdG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpdmVyZ2luZ1N0YWNrZWRCYXJDaGFydCBleHRlbmRzIENoYXJ0e1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgRGl2ZXJnaW5nU3RhY2tlZEJhckNoYXJ0Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpe1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBEaXZlcmdpbmdTdGFja2VkQmFyQ2hhcnRDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKXtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdGhpcy5wbG90LnNob3dMZWdlbmQgPSB0aGlzLmNvbmZpZy5zaG93TGVnZW5kO1xuICAgICAgICBpZih0aGlzLnBsb3Quc2hvd0xlZ2VuZCl7XG4gICAgICAgICAgICB0aGlzLnBsb3QubWFyZ2luLnJpZ2h0ID0gdGhpcy5jb25maWcubWFyZ2luLnJpZ2h0ICsgdGhpcy5jb25maWcubGVnZW5kLndpZHRoK3RoaXMuY29uZmlnLmxlZ2VuZC5tYXJnaW4qMjtcblxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnBsb3QueCA9IHt9O1xuICAgICAgICB0aGlzLnBsb3QueSA9IHt9O1xuXG4gICAgICAgIHRoaXMucGxvdC5kYXRhID0gdGhpcy5nZXREYXRhVG9QbG90KCk7XG5cbiAgICAgICAgdGhpcy5zZXR1cFkoKTtcbiAgICAgICAgdGhpcy5zZXR1cFgoKTtcblxuICAgICAgICB0aGlzLnNldHVwQ29sb3IoKTtcblxuICAgIH1cblxuICAgIGdldERhdGFUb1Bsb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuXG4gICAgc2V0dXBYKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy54O1xuXG4gICAgICAgIHgudmFsdWUgPSBkID0+IGNvbmYudmFsdWUuY2FsbCh0aGlzLmNvbmZpZywgZCk7XG4gICAgICAgIHguc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnNjYWxlKS5yYW5nZVJvdW5kKFswLCBwbG90LndpZHRoXSk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuXG4gICAgICAgIHguYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHguc2NhbGUpO1xuICAgICAgICBpZihjb25mLmd1aWRlcyl7XG4gICAgICAgICAgICB4LmF4aXMudGlja1NpemUoLXBsb3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90LmRhdGE7XG5cblxuICAgICAgICBwbG90LmNhdGVnb3J5TmFtZXMgPSB0aGlzLmNvbmZpZy5jYXRlZ29yeU5hbWVzO1xuXG4gICAgICAgIHBsb3QubmV1dHJhbEluZGV4ID0gTWF0aC5mbG9vcihwbG90LmNhdGVnb3J5TmFtZXMubGVuZ3RoLzIpO1xuXG4gICAgICAgIHBsb3Qucm93cyA9IGRhdGEubWFwKGQ9PiB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxWYWx1ZXMgPSB4LnZhbHVlKGQpO1xuICAgICAgICAgICAgbGV0IHgwID0gdGhpcy5jb25maWcubWlkZGxlVmFsdWUgLSBkMy5zdW0ob3JpZ2luYWxWYWx1ZXMubWFwKCh2LGkpID0+ICBpIDwgcGxvdC5uZXV0cmFsSW5kZXggPyB2IDogMCApKTtcbiAgICAgICAgICAgIGlmIChwbG90LmNhdGVnb3J5TmFtZXMubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB4MCArPSAtMSAqIG9yaWdpbmFsVmFsdWVzW3Bsb3QubmV1dHJhbEluZGV4XS8yO1xuXG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gb3JpZ2luYWxWYWx1ZXMubWFwKCh2LCBpKSA9PiBpPHBsb3QubmV1dHJhbEluZGV4ID8gdGhpcy5jb25maWcubWlkZGxlVmFsdWUgLSB2IDogdGhpcy5jb25maWcubWlkZGxlVmFsdWUgKyB2KTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGQzLnN1bShvcmlnaW5hbFZhbHVlcyk7XG4gICAgICAgICAgICBsZXQgY2F0ZWdvcmllcyA9IHBsb3QuY2F0ZWdvcnlOYW1lcztcbiAgICAgICAgICAgIGlmKGQuY2F0ZWdvcmllcyl7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllcyA9IGQuY2F0ZWdvcmllcy5tYXAoKGNhdEluZGV4LCBpKT0+cGxvdC5jYXRlZ29yeU5hbWVzW2NhdEluZGV4XSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXR1bTogZCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFZhbHVlczogb3JpZ2luYWxWYWx1ZXMsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllczogW10sXG4gICAgICAgICAgICAgICAgbWluOiB4MCxcbiAgICAgICAgICAgICAgICBtYXg6IHgwK3RvdGFsLFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICAgICAgICAgICAgICBib3hlczogdmFsdWVzLm1hcCgodiwgaSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNhdGVnb3JpZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4MDogeDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogeDArPW9yaWdpbmFsVmFsdWVzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZTogb3JpZ2luYWxWYWx1ZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tYWluID0gZDMuZXh0ZW50KFtdLmNvbmNhdCguLi5wbG90LnJvd3MubWFwKGI9PltiLm1pbiwgYi5tYXhdKSkpO1xuICAgICAgICAgICAgbGV0IG1hcmdpbiA9ICgoZG9tYWluWzFdLWRvbWFpblswXSkqIGNvbmYuZG9tYWluTWFyZ2luKSB8fCBjb25mLmRvbWFpbk1hcmdpbipkb21haW5bMF07XG5cbiAgICAgICAgICAgIGRvbWFpblswXS09bWFyZ2luO1xuICAgICAgICAgICAgZG9tYWluWzFdKz1tYXJnaW47XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgICB9O1xuXG5cbiAgICBzZXR1cFkoKSB7XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB5ID0gcGxvdC55O1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHkudmFsdWUgPSBkID0+IGNvbmYudmFsdWUuY2FsbCh0aGlzLmNvbmZpZywgZCk7XG4gICAgICAgIHkuc2NhbGUgPSBkMy5zY2FsZUJhbmQoKS5yYW5nZShbMCwgcGxvdC5oZWlnaHRdKS5wYWRkaW5nKC4zKTtcbiAgICAgICAgeS5tYXAgPSBkID0+IHkuc2NhbGUoeS52YWx1ZShkKSk7XG5cbiAgICAgICAgeS5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeS5zY2FsZSk7XG4gICAgICAgIGlmIChjb25mLnRpY2tzKSB7XG4gICAgICAgICAgICB5LmF4aXMudGlja3MoY29uZi50aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY29uZi5ndWlkZXMpe1xuICAgICAgICAgICAgeS5heGlzLnRpY2tTaXplKC1wbG90LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldHVwWURvbWFpbigpO1xuICAgIH07XG5cbiAgICBzZXR1cFlEb21haW4oKSB7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHZhciBkb21haW4gPSBkYXRhLm1hcChwbG90LnkudmFsdWUpIDtcblxuICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgfVxuXG4gICAgZHJhd0F4aXNYKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy54O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzLXgnKSArIFwiLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpICsgKGF4aXNDb25mLmd1aWRlcyA/ICcnIDogJy4nICsgc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKVxuXG4gICAgICAgIGlmKGF4aXNDb25mLm9yaWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC54LmF4aXMpO1xuXG4gICAgICAgIHZhciB0aXRsZVkgPSBheGlzQ29uZi5vcmllbnQgPT09ICdib3R0b20nID8gcGxvdC5tYXJnaW4uYm90dG9tIDogMDtcbiAgICAgICAgdmFyIHRpdGxlRFkgPSBheGlzQ29uZi5vcmllbnQgPT09ICdib3R0b20nID8gXCItMWVtXCIgOiBcIi0xLjVlbVwiO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiK3NlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgKHBsb3Qud2lkdGgvMikgK1wiLFwiKyAodGl0bGVZKSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIHRpdGxlRFkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICBkcmF3QXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpICsgXCIuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdheGlzJykgKyAoYXhpc0NvbmYuZ3VpZGVzID8gJycgOiAnLicgKyBzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpO1xuXG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnkuYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAtcGxvdC5tYXJnaW4ubGVmdCArIFwiLFwiICsgKHBsb3QuaGVpZ2h0IC8gMikgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgZHJhd0JhcnMoKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHBsb3QgPSBzZWxmLnBsb3QsXG4gICAgICAgICAgICBjb25maWcgPSBzZWxmLmNvbmZpZztcblxuICAgICAgICBsZXQgcm93Q2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwicm93XCIpO1xuICAgICAgICBsZXQgcm93cyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCIuXCIrIHJvd0NsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGxvdC5yb3dzKTtcblxuICAgICAgICBsZXQgcm93RW50ZXIgPSByb3dzLmVudGVyKCkuYXBwZW5kU2VsZWN0b3IoXCJnLlwiK3Jvd0NsYXNzKTtcblxuICAgICAgICBsZXQgcm93TWVyZ2UgPSByb3dFbnRlci5tZXJnZShyb3dzKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZSgwLFwiICsgcGxvdC55Lm1hcChkLmRhdHVtKSArIFwiKVwiKTtcblxuICAgICAgICByb3dzLmV4aXQoKS5yZW1vdmUoKTtcblxuXG4gICAgICAgIGxldCBiYXJDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJiYXJcIik7XG5cbiAgICAgICAgbGV0IGJhcnMgPSByb3dNZXJnZS5zZWxlY3RBbGwoXCJnLlwiKyBiYXJDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuYm94ZXM7IH0pO1xuICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgYmFyc0VudGVyID0gYmFycy5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBiYXJDbGFzcyk7XG5cbiAgICAgICAgYmFyc0VudGVyLmFwcGVuZChcInJlY3RcIik7XG4gICAgICAgIGlmKGNvbmZpZy5zaG93QmFyVmFsdWVzKXtcbiAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgYmFyc00gPSAgYmFyc0VudGVyLm1lcmdlKGJhcnMpO1xuXG4gICAgICAgIGJhcnNNLnNlbGVjdChcInJlY3RcIikuYXR0cihcImhlaWdodFwiLCBwbG90Lnkuc2NhbGUuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PnBsb3QueC5zY2FsZShkLngwKSlcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiBwbG90Lnguc2NhbGUoZC54MSkgLSBwbG90Lnguc2NhbGUoZC54MCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiBwbG90LmNvbG9yKGQubmFtZSwgaSkpO1xuXG5cbiAgICAgICAgbGV0IHRleHRNID0gYmFyc00uc2VsZWN0KFwidGV4dFwiKTtcbiAgICAgICAgaWYoY29uZmlnLnNob3dCYXJWYWx1ZXMpe1xuICAgICAgICAgICAgdGV4dE0uYXR0cihcInhcIiwgZCA9PiBwbG90Lnguc2NhbGUoZC54MCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHBsb3QueS5zY2FsZS5iYW5kd2lkdGgoKS8yKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIwLjVlbVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgZD0+KHBsb3QueC5zY2FsZShkLngxKS1wbG90Lnguc2NhbGUoZC54MCkpLzIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgICAgICAudGV4dChkID0+IGQub3JpZ2luYWxWYWx1ZSAhPT0gMCAmJiAoZC54MS1kLngwKT4wLjA0ID8gZC5vcmlnaW5hbFZhbHVlIDogXCJcIik7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGV4dE0ucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwibGluZS5cIitzZWxmLnByZWZpeENsYXNzKFwibWlkZGxlLWxpbmVcIikpXG4gICAgICAgICAgICAuYXR0cihcIngxXCIsIHBsb3QueC5zY2FsZShzZWxmLmNvbmZpZy5taWRkbGVWYWx1ZSkpXG4gICAgICAgICAgICAuYXR0cihcInkxXCIsIDApXG4gICAgICAgICAgICAuYXR0cihcIngyXCIsIHBsb3QueC5zY2FsZShzZWxmLmNvbmZpZy5taWRkbGVWYWx1ZSkpXG4gICAgICAgICAgICAuYXR0cihcInkyXCIsIHBsb3QuaGVpZ2h0KTtcblxuICAgIH1cblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWCgpO1xuICAgICAgICB0aGlzLmRyYXdBeGlzWSgpO1xuICAgICAgICB0aGlzLmRyYXdCYXJzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuICAgIHNldHVwQ29sb3IoKSB7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgaWYoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpe1xuICAgICAgICAgICAgdmFyIGNvbG9yU2NoZW1lQ2F0ZWdvcnkgPSAnc2NoZW1lJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoY29uZi5kM0NvbG9yQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnkgPSBkMy5zY2FsZU9yZGluYWwoZDNbY29sb3JTY2hlbWVDYXRlZ29yeV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbG9yVmFsdWUgPSBjb25mLmNvbG9yO1xuICAgICAgICBpZiAoY29sb3JWYWx1ZSAmJiB0eXBlb2YgY29sb3JWYWx1ZSA9PT0gJ3N0cmluZycgfHwgY29sb3JWYWx1ZSBpbnN0YW5jZW9mIFN0cmluZyl7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY29sb3IgPSBjb2xvclZhbHVlO1xuICAgICAgICB9ZWxzZSBpZiAoY29uZi5jb2xvclJhbmdlKXtcbiAgICAgICAgICAgIHRoaXMucGxvdC5jb2xvciA9IFV0aWxzLmNyZWF0ZVNjYWxlKFwib3JkaW5hbFwiKS5kb21haW4odGhpcy5wbG90LmNhdGVnb3J5TmFtZXMpLnJhbmdlKGNvbmYuY29sb3JSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLnBsb3QuY29sb3JDYXRlZ29yeSl7XG4gICAgICAgICAgICBzZWxmLnBsb3QuY29sb3JWYWx1ZT1jb2xvclZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wbG90LmNvbG9yID0gdGhpcy5wbG90LmNvbG9yQ2F0ZWdvcnlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUxlZ2VuZCgpIHtcblxuICAgICAgICB2YXIgc2VsZiA9dGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gcGxvdC5jb2xvcjtcblxuICAgICAgICBpZighc2NhbGUuZG9tYWluKCkgfHwgIXRoaXMuY29uZmlnLmZvcmNlTGVnZW5kICYmIHNjYWxlLmRvbWFpbigpLmxlbmd0aDwyKXtcbiAgICAgICAgICAgIHBsb3Quc2hvd0xlZ2VuZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXBsb3Quc2hvd0xlZ2VuZCl7XG4gICAgICAgICAgICBpZihwbG90LmxlZ2VuZCAmJiBwbG90LmxlZ2VuZC5jb250YWluZXIpe1xuICAgICAgICAgICAgICAgIHBsb3QubGVnZW5kLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGxlZ2VuZFggPSB0aGlzLnBsb3Qud2lkdGggKyB0aGlzLmNvbmZpZy5sZWdlbmQubWFyZ2luO1xuICAgICAgICB2YXIgbGVnZW5kWSA9IHRoaXMuY29uZmlnLmxlZ2VuZC5tYXJnaW47XG5cbiAgICAgICAgcGxvdC5sZWdlbmQgPSBuZXcgTGVnZW5kKHRoaXMuc3ZnLCB0aGlzLnN2Z0csIHNjYWxlLCBsZWdlbmRYLCBsZWdlbmRZKTtcblxuICAgICAgICBwbG90LmxlZ2VuZENvbG9yID0gcGxvdC5sZWdlbmQuY29sb3IoKVxuICAgICAgICAgICAgLnNoYXBlV2lkdGgodGhpcy5jb25maWcubGVnZW5kLnNoYXBlV2lkdGgpXG4gICAgICAgICAgICAub3JpZW50KCd2ZXJ0aWNhbCcpXG4gICAgICAgICAgICAuc2NhbGUoc2NhbGUpXG4gICAgICAgICAgICAubGFiZWxXcmFwKHRoaXMuY29uZmlnLmxlZ2VuZC53aWR0aClcbiAgICAgICAgICAgIC8vIC5sYWJlbHMoc2NhbGUuZG9tYWluKCkubWFwKHY9PnBsb3QuZ3JvdXBUb0xhYmVsW3ZdKSk7XG5cbiAgICAgICAgcGxvdC5sZWdlbmQuY29udGFpbmVyXG4gICAgICAgICAgICAuY2FsbChwbG90LmxlZ2VuZENvbG9yKTtcbiAgICB9XG59XG4iLCJpbXBvcnQge0NoYXJ0LCBDaGFydENvbmZpZ30gZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCB7SGVhdG1hcCwgSGVhdG1hcENvbmZpZ30gZnJvbSBcIi4vaGVhdG1hcFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7U3RhdGlzdGljc1V0aWxzfSBmcm9tICcuL3N0YXRpc3RpY3MtdXRpbHMnXG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgSGVhdG1hcFRpbWVTZXJpZXNDb25maWcgZXh0ZW5kcyBIZWF0bWFwQ29uZmlnIHtcbiAgICB4ID0ge1xuICAgICAgICBmaWxsTWlzc2luZzogZmFsc2UsIC8vIGZpbGwgbWlzc2luZyB2YWx1ZXMgdXNpbmcgaW50ZXJ2YWwgYW5kIGludGVydmFsU3RlcFxuICAgICAgICBpbnRlcnZhbDogdW5kZWZpbmVkLCAvL3VzZWQgaW4gZmlsbGluZyBtaXNzaW5nIHRpY2tzXG4gICAgICAgIGludGVydmFsU3RlcDogMSxcbiAgICAgICAgZm9ybWF0OiB1bmRlZmluZWQsIC8vaW5wdXQgZGF0YSBkMyB0aW1lIGZvcm1hdFxuICAgICAgICBkaXNwbGF5Rm9ybWF0OiB1bmRlZmluZWQsLy9kMyB0aW1lIGZvcm1hdCBmb3IgZGlzcGxheVxuICAgICAgICBpbnRlcnZhbFRvRm9ybWF0czogWyAvL3VzZWQgdG8gZ3Vlc3MgaW50ZXJ2YWwgYW5kIGZvcm1hdFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICBmb3JtYXRzOiBbXCIlWVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbW9udGgnLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcIiVZLSVtXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdkYXknLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcIiVZLSVtLSVkXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdob3VyJyxcbiAgICAgICAgICAgICAgICBmb3JtYXRzOiBbJyVIJywgJyVZLSVtLSVkICVIJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgZm9ybWF0czogWyclSDolTScsICclWS0lbS0lZCAlSDolTSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzZWNvbmQnLFxuICAgICAgICAgICAgICAgIGZvcm1hdHM6IFsnJUg6JU06JVMnLCAnJVktJW0tJWQgJUg6JU06JVMnXVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuXG4gICAgICAgIHNvcnRDb21wYXJhdG9yOiBmdW5jdGlvbiBzb3J0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNTdHJpbmcoYSkgPyAgYS5sb2NhbGVDb21wYXJlKGIpIDogIGEgLSBiO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgeiA9IHtcbiAgICAgICAgZmlsbE1pc3Npbmc6IHRydWUgLy8gZmlpbGwgbWlzc2luZyB2YWx1ZXMgd2l0aCBuZWFyZXN0IHByZXZpb3VzIHZhbHVlXG4gICAgfTtcblxuICAgIGxlZ2VuZCA9IHtcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodiAvIDEwMDAwMDAgPj0gMSkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IFwiIE1cIjtcbiAgICAgICAgICAgICAgICB2ID0gTnVtYmVyKHYgLyAxMDAwMDAwKS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5mID0gSW50bC5OdW1iZXJGb3JtYXQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZi5mb3JtYXQodikgKyBzdWZmaXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgSGVhdG1hcFRpbWVTZXJpZXMgZXh0ZW5kcyBIZWF0bWFwIHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEhlYXRtYXBUaW1lU2VyaWVzQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgSGVhdG1hcFRpbWVTZXJpZXNDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG5cbiAgICBzZXR1cFZhbHVlc0JlZm9yZUdyb3Vwc1NvcnQoKSB7XG5cbiAgICAgICAgdGhpcy5wbG90LngudGltZUZvcm1hdCA9IHRoaXMuY29uZmlnLnguZm9ybWF0O1xuICAgICAgICBpZih0aGlzLmNvbmZpZy54LmRpc3BsYXlGb3JtYXQgJiYgIXRoaXMucGxvdC54LnRpbWVGb3JtYXQpe1xuICAgICAgICAgICAgdGhpcy5ndWVzc1RpbWVGb3JtYXQoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc3VwZXIuc2V0dXBWYWx1ZXNCZWZvcmVHcm91cHNTb3J0KCk7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcueC5maWxsTWlzc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuaW5pdFRpbWVGb3JtYXRBbmRJbnRlcnZhbCgpO1xuXG4gICAgICAgIHRoaXMucGxvdC54LmludGVydmFsU3RlcCA9IHRoaXMuY29uZmlnLnguaW50ZXJ2YWxTdGVwIHx8IDE7XG5cbiAgICAgICAgdGhpcy5wbG90LngudGltZVBhcnNlciA9IHRoaXMuZ2V0VGltZVBhcnNlcigpO1xuXG5cblxuICAgICAgICB0aGlzLnBsb3QueC51bmlxdWVWYWx1ZXMuc29ydCh0aGlzLmNvbmZpZy54LnNvcnRDb21wYXJhdG9yKTtcblxuICAgICAgICB2YXIgcHJldiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wbG90LngudW5pcXVlVmFsdWVzLmZvckVhY2goKHgsIGkpPT4ge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnBhcnNlVGltZSh4KTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHNlbGYubmV4dFRpbWVUaWNrVmFsdWUocHJldik7XG4gICAgICAgICAgICB2YXIgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZi5jb21wYXJlVGltZVZhbHVlcyhuZXh0LCBjdXJyZW50KTw9MCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb24gPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVTdHJpbmcgPSBzZWxmLmZvcm1hdFRpbWUobmV4dCk7XG4gICAgICAgICAgICAgICAgZFt0aGlzLmNvbmZpZy54LmtleV0gPSB0aW1lU3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVHcm91cHMoZCwgdGltZVN0cmluZywgc2VsZi5wbG90LnguZ3JvdXBzLCBzZWxmLmNvbmZpZy54Lmdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIG5leHQgPSBzZWxmLm5leHRUaW1lVGlja1ZhbHVlKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgcGFyc2VUaW1lKHgpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXMuZ2V0VGltZVBhcnNlcigpO1xuICAgICAgICByZXR1cm4gcGFyc2VyKHgpO1xuICAgIH1cblxuICAgIGZvcm1hdFRpbWUoZGF0ZSl7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmdldFRpbWVGb3JtYXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcihkYXRlKTtcbiAgICB9XG5cbiAgICBmb3JtYXRWYWx1ZVgodmFsdWUpIHsgLy91c2VkIG9ubHkgZm9yIGRpc3BsYXlcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnguZm9ybWF0dGVyKSByZXR1cm4gdGhpcy5jb25maWcueC5mb3JtYXR0ZXIuY2FsbCh0aGlzLmNvbmZpZywgdmFsdWUpO1xuXG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnguZGlzcGxheUZvcm1hdCl7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMucGFyc2VUaW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBkMy50aW1lRm9ybWF0KHRoaXMuY29uZmlnLnguZGlzcGxheUZvcm1hdCkoZGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5wbG90LngudGltZUZvcm1hdCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIGlmKFV0aWxzLmlzRGF0ZSh2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VGltZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29tcGFyZVRpbWVWYWx1ZXMoYSwgYil7XG4gICAgICAgIHJldHVybiBhLWI7XG4gICAgfVxuXG4gICAgdGltZVZhbHVlc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXMucGxvdC54LnRpbWVQYXJzZXI7XG4gICAgICAgIHJldHVybiBwYXJzZXIoYSkgPT09IHBhcnNlcihiKTtcbiAgICB9XG5cbiAgICBuZXh0VGltZVRpY2tWYWx1ZSh0KSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9ICd0aW1lJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIodGhpcy5wbG90LnguaW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiBkM1tpbnRlcnZhbF0ub2Zmc2V0KHQsIHRoaXMucGxvdC54LmludGVydmFsU3RlcCk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKSB7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnouZmlsbE1pc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5tYXRyaXguZm9yRWFjaCgocm93LCByb3dJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Um93VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcm93LmZvckVhY2goKGNlbGwsIGNvbEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnZhbHVlID09PSB1bmRlZmluZWQgJiYgcHJldlJvd1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudmFsdWUgPSBwcmV2Um93VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLm1pc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZSb3dWYWx1ZSA9IGNlbGwudmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICB9XG5cbiAgICB1cGRhdGUobmV3RGF0YSkge1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG5cbiAgICB9O1xuXG5cbiAgICBpbml0VGltZUZvcm1hdEFuZEludGVydmFsKCkge1xuXG4gICAgICAgIHRoaXMucGxvdC54LmludGVydmFsID0gdGhpcy5jb25maWcueC5pbnRlcnZhbDtcblxuICAgICAgICBpZighdGhpcy5wbG90LngudGltZUZvcm1hdCl7XG4gICAgICAgICAgICB0aGlzLmd1ZXNzVGltZUZvcm1hdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMucGxvdC54LmludGVydmFsICYmIHRoaXMucGxvdC54LnRpbWVGb3JtYXQpe1xuICAgICAgICAgICAgdGhpcy5ndWVzc0ludGVydmFsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBndWVzc1RpbWVGb3JtYXQoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBzZWxmLmNvbmZpZy54LmludGVydmFsVG9Gb3JtYXRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBpbnRlcnZhbEZvcm1hdCA9IHNlbGYuY29uZmlnLnguaW50ZXJ2YWxUb0Zvcm1hdHNbaV07XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBmb3JtYXRNYXRjaCA9IGludGVydmFsRm9ybWF0LmZvcm1hdHMuc29tZShmPT57XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZjtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gZDMudGltZVBhcnNlKGYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBsb3QueC51bmlxdWVWYWx1ZXMuZXZlcnkoeD0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyKHgpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKGZvcm1hdE1hdGNoKXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QueC50aW1lRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHdWVzc2VkIHRpbWVGb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGlmKCFzZWxmLnBsb3QueC5pbnRlcnZhbCl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxvdC54LmludGVydmFsID0gaW50ZXJ2YWxGb3JtYXQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0d1ZXNzZWQgaW50ZXJ2YWwnLCBzZWxmLnBsb3QueC5pbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGd1ZXNzSW50ZXJ2YWwoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBzZWxmLmNvbmZpZy54LmludGVydmFsVG9Gb3JtYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW50ZXJ2YWxGb3JtYXQgPSBzZWxmLmNvbmZpZy54LmludGVydmFsVG9Gb3JtYXRzW2ldO1xuXG4gICAgICAgICAgICBpZihpbnRlcnZhbEZvcm1hdC5mb3JtYXRzLmluZGV4T2Yoc2VsZi5wbG90LngudGltZUZvcm1hdCkgPj0gMCl7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90LnguaW50ZXJ2YWwgPSBpbnRlcnZhbEZvcm1hdC5uYW1lO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHdWVzc2VkIGludGVydmFsJywgc2VsZi5wbG90LnguaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZXRUaW1lRm9ybWF0dGVyKCkge1xuICAgICAgICBpZighdGhpcy5wbG90LngudGltZUZvcm1hdHRlcil7XG4gICAgICAgICAgICB0aGlzLnBsb3QueC50aW1lRm9ybWF0dGVyID0gZDMudGltZUZvcm1hdCh0aGlzLnBsb3QueC50aW1lRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wbG90LngudGltZUZvcm1hdHRlcjtcbiAgICB9XG4gICAgZ2V0VGltZVBhcnNlcigpIHtcbiAgICAgICAgaWYoIXRoaXMucGxvdC54LnRpbWVQYXJzZXIpe1xuICAgICAgICAgICAgdGhpcy5wbG90LngudGltZVBhcnNlciA9IGQzLnRpbWVQYXJzZSh0aGlzLnBsb3QueC50aW1lRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wbG90LngudGltZVBhcnNlcjtcbiAgICB9XG59XG5cbiIsImltcG9ydCB7Q2hhcnQsIENoYXJ0Q29uZmlnfSBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCB7TGVnZW5kfSBmcm9tICcuL2xlZ2VuZCdcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBIZWF0bWFwQ29uZmlnIGV4dGVuZHMgQ2hhcnRDb25maWcge1xuXG4gICAgc3ZnQ2xhc3MgPSAnb2RjLWhlYXRtYXAnO1xuICAgIHNob3dUb29sdGlwID0gdHJ1ZTsgLy9zaG93IHRvb2x0aXAgb24gZG90IGhvdmVyXG4gICAgdG9vbHRpcCA9IHtcbiAgICAgICAgbm9EYXRhVGV4dDogXCJOL0FcIlxuICAgIH07XG4gICAgc2hvd0xlZ2VuZCA9IHRydWU7XG4gICAgbGVnZW5kID0ge1xuICAgICAgICB3aWR0aDogMzAsXG4gICAgICAgIHJvdGF0ZUxhYmVsczogZmFsc2UsXG4gICAgICAgIGRlY2ltYWxQbGFjZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybWF0dGVyOiB2ID0+IHRoaXMubGVnZW5kLmRlY2ltYWxQbGFjZXMgPT09IHVuZGVmaW5lZCA/IHYgOiBOdW1iZXIodikudG9GaXhlZCh0aGlzLmxlZ2VuZC5kZWNpbWFsUGxhY2VzKVxuICAgIH1cbiAgICBoaWdobGlnaHRMYWJlbHMgPSB0cnVlO1xuICAgIHggPSB7Ly8gWCBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgdGl0bGVcbiAgICAgICAga2V5OiAwLFxuICAgICAgICB2YWx1ZTogKGQpID0+IGRbdGhpcy54LmtleV0sIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgcm90YXRlTGFiZWxzOiB0cnVlLFxuICAgICAgICBzb3J0TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgc29ydENvbXBhcmF0b3I6IChhLCBiKT0+IFV0aWxzLmlzTnVtYmVyKGEpID8gYSAtIGIgOiBhLmxvY2FsZUNvbXBhcmUoYiksXG4gICAgICAgIGdyb3Vwczoge1xuICAgICAgICAgICAga2V5czogW10sXG4gICAgICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IGRba2V5XSxcbiAgICAgICAgICAgIG92ZXJsYXA6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDIwLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogMjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQgLy8gdmFsdWUgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cbiAgICB9O1xuICAgIHkgPSB7Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICB0aXRsZTogJycsIC8vIGF4aXMgdGl0bGUsXG4gICAgICAgIHJvdGF0ZUxhYmVsczogdHJ1ZSxcbiAgICAgICAga2V5OiAxLFxuICAgICAgICB2YWx1ZTogKGQpID0+IGRbdGhpcy55LmtleV0sIC8vIHkgdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgc29ydExhYmVsczogZmFsc2UsXG4gICAgICAgIHNvcnRDb21wYXJhdG9yOiAoYSwgYik9PiBVdGlscy5pc051bWJlcihiKSA/IGIgLSBhIDogYi5sb2NhbGVDb21wYXJlKGEpLFxuICAgICAgICBncm91cHM6IHtcbiAgICAgICAgICAgIGtleXM6IFtdLFxuICAgICAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBkW2tleV0sXG4gICAgICAgICAgICBvdmVybGFwOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogMjAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDIwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLy8gdmFsdWUgZm9ybWF0dGVyIGZ1bmN0aW9uXG4gICAgfTtcbiAgICB6ID0ge1xuICAgICAgICBrZXk6IDIsXG4gICAgICAgIHZhbHVlOiAoZCkgPT4gZFt0aGlzLnoua2V5XSxcbiAgICAgICAgbm90QXZhaWxhYmxlVmFsdWU6ICh2KSA9PiB2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCxcblxuICAgICAgICBkZWNpbWFsUGxhY2VzOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1hdHRlcjogdiA9PiB0aGlzLnouZGVjaW1hbFBsYWNlcyA9PT0gdW5kZWZpbmVkID8gdiA6IE51bWJlcih2KS50b0ZpeGVkKHRoaXMuei5kZWNpbWFsUGxhY2VzKS8vIHZhbHVlIGZvcm1hdHRlciBmdW5jdGlvblxuXG4gICAgfTtcbiAgICBjb2xvciA9IHtcbiAgICAgICAgbm9EYXRhQ29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIHJldmVyc2VTY2FsZTogZmFsc2UsXG4gICAgICAgIHJhbmdlOiBbXCJkYXJrYmx1ZVwiLCBcImxpZ2h0c2t5Ymx1ZVwiLCBcIm9yYW5nZVwiLCBcImNyaW1zb25cIiwgXCJkYXJrcmVkXCJdXG4gICAgfTtcbiAgICBjZWxsID0ge1xuICAgICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZU1pbjogMTUsXG4gICAgICAgIHNpemVNYXg6IDI1MCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG4gICAgbWFyZ2luID0ge1xuICAgICAgICBsZWZ0OiA2MCxcbiAgICAgICAgcmlnaHQ6IDUwLFxuICAgICAgICB0b3A6IDMwLFxuICAgICAgICBib3R0b206IDgwXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoY3VzdG9tKSB7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vVE9ETyByZWZhY3RvclxuZXhwb3J0IGNsYXNzIEhlYXRtYXAgZXh0ZW5kcyBDaGFydCB7XG5cbiAgICBzdGF0aWMgbWF4R3JvdXBHYXBTaXplID0gMjQ7XG4gICAgc3RhdGljIGdyb3VwVGl0bGVSZWN0SGVpZ2h0ID0gNjtcblxuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgSGVhdG1hcENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IEhlYXRtYXBDb25maWcoY29uZmlnKSk7XG5cbiAgICB9XG5cbiAgICBpbml0UGxvdCgpIHtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbWFyZ2luID0gdGhpcy5jb25maWcubWFyZ2luO1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54ID0ge307XG4gICAgICAgIHRoaXMucGxvdC55ID0ge307XG4gICAgICAgIHRoaXMucGxvdC56ID0ge1xuICAgICAgICAgICAgbWF0cml4ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlbGxzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2xvcjoge30sXG4gICAgICAgICAgICBzaGFwZToge31cbiAgICAgICAgfTtcblxuXG4gICAgICAgIHRoaXMuc2V0dXBWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy5idWlsZENlbGxzKCk7XG5cbiAgICAgICAgdmFyIHRpdGxlUmVjdFdpZHRoID0gNjtcbiAgICAgICAgdGhpcy5wbG90Lngub3ZlcmxhcCA9IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSBzZWxmLmNvbmZpZy54Lmdyb3Vwcy5rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBhbGxUaXRsZXNXaWR0aCA9IGRlcHRoICogKHRpdGxlUmVjdFdpZHRoKTtcblxuICAgICAgICAgICAgdGhpcy5wbG90Lngub3ZlcmxhcC5ib3R0b20gPSBzZWxmLmNvbmZpZy54Lmdyb3Vwcy5vdmVybGFwLmJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMucGxvdC54Lm92ZXJsYXAudG9wID0gc2VsZi5jb25maWcueC5ncm91cHMub3ZlcmxhcC50b3AgKyBhbGxUaXRsZXNXaWR0aDtcbiAgICAgICAgICAgIHRoaXMucGxvdC5tYXJnaW4udG9wID0gdGhpcy5wbG90Lm1hcmdpbi50b3AgKyBjb25mLnguZ3JvdXBzLm92ZXJsYXAudG9wO1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5ib3R0b20gPSB0aGlzLnBsb3QubWFyZ2luLmJvdHRvbSArIGNvbmYueC5ncm91cHMub3ZlcmxhcC5ib3R0b207XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMucGxvdC55Lm92ZXJsYXAgPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgfTtcblxuXG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLmtleXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFsbFRpdGxlc1dpZHRoID0gZGVwdGggKiAodGl0bGVSZWN0V2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5wbG90Lnkub3ZlcmxhcC5yaWdodCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLm92ZXJsYXAubGVmdCArIGFsbFRpdGxlc1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5wbG90Lnkub3ZlcmxhcC5sZWZ0ID0gc2VsZi5jb25maWcueS5ncm91cHMub3ZlcmxhcC5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5sZWZ0ID0gdGhpcy5wbG90Lm1hcmdpbi5sZWZ0ICsgdGhpcy5wbG90Lnkub3ZlcmxhcC5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5wbG90Lm1hcmdpbi5yaWdodCA9IHRoaXMucGxvdC5tYXJnaW4ucmlnaHQgKyB0aGlzLnBsb3QueS5vdmVybGFwLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxvdC5zaG93TGVnZW5kID0gY29uZi5zaG93TGVnZW5kO1xuICAgICAgICBpZiAodGhpcy5wbG90LnNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5tYXJnaW4ucmlnaHQgKz0gY29uZi5sZWdlbmQud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgdGhpcy5zZXR1cFpTY2FsZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwVmFsdWVzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb25maWcgPSBzZWxmLmNvbmZpZztcbiAgICAgICAgdmFyIHggPSBzZWxmLnBsb3QueDtcbiAgICAgICAgdmFyIHkgPSBzZWxmLnBsb3QueTtcbiAgICAgICAgdmFyIHogPSBzZWxmLnBsb3QuejtcblxuXG4gICAgICAgIHgudmFsdWUgPSBkID0+IGNvbmZpZy54LnZhbHVlLmNhbGwoY29uZmlnLCBkKTtcbiAgICAgICAgeS52YWx1ZSA9IGQgPT4gY29uZmlnLnkudmFsdWUuY2FsbChjb25maWcsIGQpO1xuICAgICAgICB6LnZhbHVlID0gZCA9PiBjb25maWcuei52YWx1ZS5jYWxsKGNvbmZpZywgZCk7XG5cbiAgICAgICAgeC51bmlxdWVWYWx1ZXMgPSBbXTtcbiAgICAgICAgeS51bmlxdWVWYWx1ZXMgPSBbXTtcblxuXG4gICAgICAgIHNlbGYucGxvdC5ncm91cEJ5WSA9ICEhY29uZmlnLnkuZ3JvdXBzLmtleXMubGVuZ3RoO1xuICAgICAgICBzZWxmLnBsb3QuZ3JvdXBCeVggPSAhIWNvbmZpZy54Lmdyb3Vwcy5rZXlzLmxlbmd0aDtcblxuICAgICAgICB5Lmdyb3VwcyA9IHtcbiAgICAgICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIGxhc3RJbmRleDogMFxuICAgICAgICB9O1xuICAgICAgICB4Lmdyb3VwcyA9IHtcbiAgICAgICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIGxhc3RJbmRleDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB2YWx1ZU1hcCA9IHt9O1xuICAgICAgICB2YXIgbWluWiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG1heFogPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGQ9PiB7XG5cbiAgICAgICAgICAgIHZhciB4VmFsID0geC52YWx1ZShkKTtcbiAgICAgICAgICAgIHZhciB5VmFsID0geS52YWx1ZShkKTtcbiAgICAgICAgICAgIHZhciB6VmFsUmF3ID0gei52YWx1ZShkKTtcbiAgICAgICAgICAgIHZhciB6VmFsID0gY29uZmlnLnoubm90QXZhaWxhYmxlVmFsdWUoelZhbFJhdykgPyB1bmRlZmluZWQgOiBwYXJzZUZsb2F0KHpWYWxSYXcpO1xuXG5cbiAgICAgICAgICAgIGlmICh4LnVuaXF1ZVZhbHVlcy5pbmRleE9mKHhWYWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHgudW5pcXVlVmFsdWVzLnB1c2goeFZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5LnVuaXF1ZVZhbHVlcy5pbmRleE9mKHlWYWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHkudW5pcXVlVmFsdWVzLnB1c2goeVZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncm91cFkgPSB5Lmdyb3VwcztcbiAgICAgICAgICAgIGlmIChzZWxmLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgICAgICBncm91cFkgPSB0aGlzLnVwZGF0ZUdyb3VwcyhkLCB5VmFsLCB5Lmdyb3VwcywgY29uZmlnLnkuZ3JvdXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncm91cFggPSB4Lmdyb3VwcztcbiAgICAgICAgICAgIGlmIChzZWxmLnBsb3QuZ3JvdXBCeVgpIHtcblxuICAgICAgICAgICAgICAgIGdyb3VwWCA9IHRoaXMudXBkYXRlR3JvdXBzKGQsIHhWYWwsIHguZ3JvdXBzLCBjb25maWcueC5ncm91cHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlTWFwW2dyb3VwWS5pbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZU1hcFtncm91cFkuaW5kZXhdID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlTWFwW2dyb3VwWS5pbmRleF1bZ3JvdXBYLmluZGV4XVt5VmFsXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTWFwW2dyb3VwWS5pbmRleF1bZ3JvdXBYLmluZGV4XVt5VmFsXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVNYXBbZ3JvdXBZLmluZGV4XVtncm91cFguaW5kZXhdW3lWYWxdW3hWYWxdID0gelZhbDtcblxuXG4gICAgICAgICAgICBpZiAobWluWiA9PT0gdW5kZWZpbmVkIHx8IHpWYWwgPCBtaW5aKSB7XG4gICAgICAgICAgICAgICAgbWluWiA9IHpWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4WiA9PT0gdW5kZWZpbmVkIHx8IHpWYWwgPiBtYXhaKSB7XG4gICAgICAgICAgICAgICAgbWF4WiA9IHpWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnBsb3QudmFsdWVNYXAgPSB2YWx1ZU1hcDtcblxuXG4gICAgICAgIGlmICghc2VsZi5wbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICB4Lmdyb3Vwcy52YWx1ZXMgPSB4LnVuaXF1ZVZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZi5wbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICB5Lmdyb3Vwcy52YWx1ZXMgPSB5LnVuaXF1ZVZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dXBWYWx1ZXNCZWZvcmVHcm91cHNTb3J0KCk7XG5cbiAgICAgICAgeC5nYXBzID0gW107XG4gICAgICAgIHgudG90YWxWYWx1ZXNDb3VudCA9IDA7XG4gICAgICAgIHguYWxsVmFsdWVzTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnNvcnRHcm91cHMoeCwgeC5ncm91cHMsIGNvbmZpZy54KTtcblxuICAgICAgICB5LmdhcHMgPSBbXTtcbiAgICAgICAgeS50b3RhbFZhbHVlc0NvdW50ID0gMDtcbiAgICAgICAgeS5hbGxWYWx1ZXNMaXN0ID0gW107XG4gICAgICAgIHRoaXMuc29ydEdyb3Vwcyh5LCB5Lmdyb3VwcywgY29uZmlnLnkpO1xuXG4gICAgICAgIHoubWluID0gbWluWjtcbiAgICAgICAgei5tYXggPSBtYXhaO1xuXG4gICAgfVxuXG4gICAgc2V0dXBWYWx1ZXNCZWZvcmVHcm91cHNTb3J0KCkge1xuICAgIH1cblxuICAgIGJ1aWxkQ2VsbHMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBzZWxmLnBsb3QueDtcbiAgICAgICAgdmFyIHkgPSBzZWxmLnBsb3QueTtcbiAgICAgICAgdmFyIHogPSBzZWxmLnBsb3QuejtcbiAgICAgICAgdmFyIHZhbHVlTWFwID0gc2VsZi5wbG90LnZhbHVlTWFwO1xuXG4gICAgICAgIHZhciBtYXRyaXhDZWxscyA9IHNlbGYucGxvdC5jZWxscyA9IFtdO1xuICAgICAgICB2YXIgbWF0cml4ID0gc2VsZi5wbG90Lm1hdHJpeCA9IFtdO1xuXG4gICAgICAgIHkuYWxsVmFsdWVzTGlzdC5mb3JFYWNoKCh2MSwgaSk9PiB7XG4gICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICBtYXRyaXgucHVzaChyb3cpO1xuXG4gICAgICAgICAgICB4LmFsbFZhbHVlc0xpc3QuZm9yRWFjaCgodjIsIGopID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgelZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB6VmFsID0gdmFsdWVNYXBbdjEuZ3JvdXAuaW5kZXhdW3YyLmdyb3VwLmluZGV4XVt2MS52YWxdW3YyLnZhbF1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1ZhcjogdjEsXG4gICAgICAgICAgICAgICAgICAgIGNvbFZhcjogdjIsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogaSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiBqLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogelZhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcm93LnB1c2goY2VsbCk7XG5cbiAgICAgICAgICAgICAgICBtYXRyaXhDZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgdXBkYXRlR3JvdXBzKGQsIGF4aXNWYWwsIHJvb3RHcm91cCwgYXhpc0dyb3Vwc0NvbmZpZykge1xuXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IHJvb3RHcm91cDtcbiAgICAgICAgYXhpc0dyb3Vwc0NvbmZpZy5rZXlzLmZvckVhY2goKGdyb3VwS2V5LCBncm91cEtleUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAua2V5ID0gZ3JvdXBLZXk7XG5cbiAgICAgICAgICAgIGlmICghY3VycmVudEdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLmNoaWxkcmVuID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncm91cGluZ1ZhbHVlID0gYXhpc0dyb3Vwc0NvbmZpZy52YWx1ZS5jYWxsKGNvbmZpZywgZCwgZ3JvdXBLZXkpO1xuXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRHcm91cC5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShncm91cGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJvb3RHcm91cC5sYXN0SW5kZXgrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuY2hpbGRyZW5bZ3JvdXBpbmdWYWx1ZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBncm91cGluZ1ZhbHVlOiBncm91cGluZ1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudEdyb3VwLmxldmVsICsgMSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJvb3RHcm91cC5sYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZ3JvdXBLZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IGN1cnJlbnRHcm91cC5jaGlsZHJlbltncm91cGluZ1ZhbHVlXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRHcm91cC52YWx1ZXMuaW5kZXhPZihheGlzVmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC52YWx1ZXMucHVzaChheGlzVmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50R3JvdXA7XG4gICAgfVxuXG4gICAgc29ydEdyb3VwcyhheGlzLCBncm91cCwgYXhpc0NvbmZpZywgZ2Fwcykge1xuICAgICAgICBpZiAoYXhpc0NvbmZpZy5ncm91cHMubGFiZWxzICYmIGF4aXNDb25maWcuZ3JvdXBzLmxhYmVscy5sZW5ndGggPiBncm91cC5sZXZlbCkge1xuICAgICAgICAgICAgZ3JvdXAubGFiZWwgPSBheGlzQ29uZmlnLmdyb3Vwcy5sYWJlbHNbZ3JvdXAubGV2ZWxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXAubGFiZWwgPSBncm91cC5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdhcHMpIHtcbiAgICAgICAgICAgIGdhcHMgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdhcHMubGVuZ3RoIDw9IGdyb3VwLmxldmVsKSB7XG4gICAgICAgICAgICBnYXBzLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cC5hbGxWYWx1ZXNDb3VudCA9IGdyb3VwLmFsbFZhbHVlc0NvdW50IHx8IDA7XG4gICAgICAgIGdyb3VwLmFsbFZhbHVlc0JlZm9yZUNvdW50ID0gZ3JvdXAuYWxsVmFsdWVzQmVmb3JlQ291bnQgfHwgMDtcblxuICAgICAgICBncm91cC5nYXBzID0gZ2Fwcy5zbGljZSgpO1xuICAgICAgICBncm91cC5nYXBzQmVmb3JlID0gZ2Fwcy5zbGljZSgpO1xuXG5cbiAgICAgICAgZ3JvdXAuZ2Fwc1NpemUgPSBIZWF0bWFwLmNvbXB1dGVHYXBzU2l6ZShncm91cC5nYXBzKTtcbiAgICAgICAgZ3JvdXAuZ2Fwc0JlZm9yZVNpemUgPSBncm91cC5nYXBzU2l6ZTtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGF4aXNDb25maWcuc29ydExhYmVscykge1xuICAgICAgICAgICAgICAgIGdyb3VwLnZhbHVlcy5zb3J0KGF4aXNDb25maWcuc29ydENvbXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JvdXAudmFsdWVzLmZvckVhY2godj0+YXhpcy5hbGxWYWx1ZXNMaXN0LnB1c2goe3ZhbDogdiwgZ3JvdXA6IGdyb3VwfSkpO1xuICAgICAgICAgICAgZ3JvdXAuYWxsVmFsdWVzQmVmb3JlQ291bnQgPSBheGlzLnRvdGFsVmFsdWVzQ291bnQ7XG4gICAgICAgICAgICBheGlzLnRvdGFsVmFsdWVzQ291bnQgKz0gZ3JvdXAudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGdyb3VwLmFsbFZhbHVlc0NvdW50ICs9IGdyb3VwLnZhbHVlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cC5jaGlsZHJlbkxpc3QgPSBbXTtcbiAgICAgICAgaWYgKGdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5Db3VudCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNoaWxkUHJvcCBpbiBncm91cC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChncm91cC5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShjaGlsZFByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuW2NoaWxkUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmNoaWxkcmVuTGlzdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5Db3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydEdyb3VwcyhheGlzLCBjaGlsZCwgYXhpc0NvbmZpZywgZ2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFsbFZhbHVlc0NvdW50ICs9IGNoaWxkLmFsbFZhbHVlc0NvdW50O1xuICAgICAgICAgICAgICAgICAgICBnYXBzW2dyb3VwLmxldmVsXSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdhcHMgJiYgY2hpbGRyZW5Db3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICBnYXBzW2dyb3VwLmxldmVsXSAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5nYXBzSW5zaWRlID0gW107XG4gICAgICAgICAgICBnYXBzLmZvckVhY2goKGQsIGkpPT4ge1xuICAgICAgICAgICAgICAgIGdyb3VwLmdhcHNJbnNpZGUucHVzaChkIC0gKGdyb3VwLmdhcHNCZWZvcmVbaV0gfHwgMCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cC5nYXBzSW5zaWRlU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcHNTaXplKGdyb3VwLmdhcHNJbnNpZGUpO1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5nYXBzLmxlbmd0aCA8IGdhcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXhpcy5nYXBzID0gZ2FwcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29tcHV0ZVlBeGlzTGFiZWxzV2lkdGgob2Zmc2V0KSB7XG4gICAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMucGxvdC5tYXJnaW4ubGVmdDtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnkudGl0bGUpIHtcbiAgICAgICAgICAgIG1heFdpZHRoIC09IDE1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgJiYgb2Zmc2V0LngpIHtcbiAgICAgICAgICAgIG1heFdpZHRoICs9IG9mZnNldC54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnkucm90YXRlTGFiZWxzKSB7XG4gICAgICAgICAgICBtYXhXaWR0aCAqPSBVdGlscy5TUVJUXzI7XG4gICAgICAgICAgICB2YXIgZm9udFNpemUgPSAxMTsgLy90b2RvIGNoZWNrIGFjdHVhbCBmb250IHNpemVcbiAgICAgICAgICAgIG1heFdpZHRoIC09Zm9udFNpemUvMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9XG5cbiAgICBjb21wdXRlWEF4aXNMYWJlbHNXaWR0aChvZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy54LnJvdGF0ZUxhYmVscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdC5jZWxsV2lkdGggLSAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5wbG90Lm1hcmdpbi5ib3R0b207XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy54LnRpdGxlKSB7XG4gICAgICAgICAgICBzaXplIC09IDE1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgJiYgb2Zmc2V0LnkpIHtcbiAgICAgICAgICAgIHNpemUgLT0gb2Zmc2V0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBzaXplICo9IFV0aWxzLlNRUlRfMjtcblxuICAgICAgICB2YXIgZm9udFNpemUgPSAxMTsgLy90b2RvIGNoZWNrIGFjdHVhbCBmb250IHNpemVcbiAgICAgICAgc2l6ZSAtPWZvbnRTaXplLzI7XG5cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbXB1dGVHYXBTaXplKGdhcExldmVsKSB7XG4gICAgICAgIHJldHVybiBIZWF0bWFwLm1heEdyb3VwR2FwU2l6ZSAvIChnYXBMZXZlbCArIDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb21wdXRlR2Fwc1NpemUoZ2Fwcykge1xuICAgICAgICB2YXIgZ2Fwc1NpemUgPSAwO1xuICAgICAgICBnYXBzLmZvckVhY2goKGdhcHNOdW1iZXIsIGdhcHNMZXZlbCk9PiBnYXBzU2l6ZSArPSBnYXBzTnVtYmVyICogSGVhdG1hcC5jb21wdXRlR2FwU2l6ZShnYXBzTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGdhcHNTaXplO1xuICAgIH1cblxuICAgIGNvbXB1dGVQbG90U2l6ZSgpIHtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIG1hcmdpbiA9IHBsb3QubWFyZ2luO1xuICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBVdGlscy5hdmFpbGFibGVXaWR0aCh0aGlzLmNvbmZpZy53aWR0aCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIHRoaXMucGxvdC5tYXJnaW4pO1xuICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gVXRpbHMuYXZhaWxhYmxlSGVpZ2h0KHRoaXMuY29uZmlnLmhlaWdodCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIHRoaXMucGxvdC5tYXJnaW4pO1xuICAgICAgICB2YXIgd2lkdGggPSBhdmFpbGFibGVXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGF2YWlsYWJsZUhlaWdodDtcblxuICAgICAgICB2YXIgeEdhcHNTaXplID0gSGVhdG1hcC5jb21wdXRlR2Fwc1NpemUocGxvdC54LmdhcHMpO1xuXG5cbiAgICAgICAgdmFyIGNvbXB1dGVkQ2VsbFdpZHRoID0gTWF0aC5tYXgoY29uZi5jZWxsLnNpemVNaW4sIE1hdGgubWluKGNvbmYuY2VsbC5zaXplTWF4LCAoYXZhaWxhYmxlV2lkdGggLSB4R2Fwc1NpemUpIC8gdGhpcy5wbG90LngudG90YWxWYWx1ZXNDb3VudCkpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcud2lkdGgpIHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5jZWxsLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxXaWR0aCA9IGNvbXB1dGVkQ2VsbFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY2VsbFdpZHRoID0gdGhpcy5jb25maWcuY2VsbC53aWR0aDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnBsb3QuY2VsbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxXaWR0aCA9IGNvbXB1dGVkQ2VsbFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggPSB0aGlzLnBsb3QuY2VsbFdpZHRoICogdGhpcy5wbG90LngudG90YWxWYWx1ZXNDb3VudCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0ICsgeEdhcHNTaXplO1xuXG4gICAgICAgIHZhciB5R2Fwc1NpemUgPSBIZWF0bWFwLmNvbXB1dGVHYXBzU2l6ZShwbG90LnkuZ2Fwcyk7XG4gICAgICAgIHZhciBjb21wdXRlZENlbGxIZWlnaHQgPSBNYXRoLm1heChjb25mLmNlbGwuc2l6ZU1pbiwgTWF0aC5taW4oY29uZi5jZWxsLnNpemVNYXgsIChhdmFpbGFibGVIZWlnaHQgLSB5R2Fwc1NpemUpIC8gdGhpcy5wbG90LnkudG90YWxWYWx1ZXNDb3VudCkpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNlbGwuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxIZWlnaHQgPSBjb21wdXRlZENlbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBsb3QuY2VsbEhlaWdodCA9IHRoaXMuY29uZmlnLmNlbGwuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucGxvdC5jZWxsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LmNlbGxIZWlnaHQgPSBjb21wdXRlZENlbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGhlaWdodCA9IHRoaXMucGxvdC5jZWxsSGVpZ2h0ICogdGhpcy5wbG90LnkudG90YWxWYWx1ZXNDb3VudCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgeUdhcHNTaXplO1xuXG5cbiAgICAgICAgdGhpcy5wbG90LndpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgdGhpcy5wbG90LmhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgIH1cblxuXG4gICAgc2V0dXBaU2NhbGUoKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnID0gc2VsZi5jb25maWc7XG4gICAgICAgIHZhciB6ID0gc2VsZi5wbG90Lno7XG4gICAgICAgIHZhciByYW5nZSA9IGNvbmZpZy5jb2xvci5yYW5nZTtcbiAgICAgICAgdmFyIGV4dGVudCA9IHoubWF4IC0gei5taW47XG4gICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgei5kb21haW4gPSBbXTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb2xvci5zY2FsZSA9PSBcInBvd1wiKSB7XG4gICAgICAgICAgICB2YXIgZXhwb25lbnQgPSAxMDtcbiAgICAgICAgICAgIHJhbmdlLmZvckVhY2goKGMsIGkpPT4ge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gei5tYXggLSAoZXh0ZW50IC8gTWF0aC5wb3coMTAsIGkpKTtcbiAgICAgICAgICAgICAgICB6LmRvbWFpbi5wdXNoKHYpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjYWxlID0gZDMuc2NhbGVQb3coKS5leHBvbmVudChleHBvbmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmNvbG9yLnNjYWxlID09IFwibG9nXCIpIHtcblxuICAgICAgICAgICAgcmFuZ2UuZm9yRWFjaCgoYywgaSk9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB6Lm1pbiArIChleHRlbnQgLyBNYXRoLnBvdygxMCwgaSkpO1xuICAgICAgICAgICAgICAgIHouZG9tYWluLnVuc2hpZnQodilcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNjYWxlID0gZDMuc2NhbGVMb2coKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UuZm9yRWFjaCgoYywgaSk9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB6Lm1pbiArIChleHRlbnQgKiAoaSAvIChyYW5nZS5sZW5ndGggLSAxKSkpO1xuICAgICAgICAgICAgICAgIHouZG9tYWluLnB1c2godilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25maWcuY29sb3Iuc2NhbGUpO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIHouZG9tYWluWzBdID0gei5taW47IC8vcmVtb3ZpbmcgdW5uZWNlc3NhcnkgZmxvYXRpbmcgcG9pbnRzXG4gICAgICAgIHouZG9tYWluW3ouZG9tYWluLmxlbmd0aCAtIDFdID0gei5tYXg7IC8vcmVtb3ZpbmcgdW5uZWNlc3NhcnkgZmxvYXRpbmcgcG9pbnRzXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHouZG9tYWluKTtcblxuICAgICAgICBpZiAoY29uZmlnLmNvbG9yLnJldmVyc2VTY2FsZSkge1xuICAgICAgICAgICAgei5kb21haW4ucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2cocmFuZ2UpO1xuXG4gICAgICAgIHBsb3Quei5jb2xvci5zY2FsZSA9IHNjYWxlLmRvbWFpbih6LmRvbWFpbikucmFuZ2UocmFuZ2UpO1xuICAgICAgICB2YXIgc2hhcGUgPSBwbG90Lnouc2hhcGUgPSB7fTtcblxuICAgICAgICB2YXIgY2VsbENvbmYgPSB0aGlzLmNvbmZpZy5jZWxsO1xuICAgICAgICBzaGFwZS50eXBlID0gXCJyZWN0XCI7XG5cbiAgICAgICAgcGxvdC56LnNoYXBlLndpZHRoID0gcGxvdC5jZWxsV2lkdGggLSBjZWxsQ29uZi5wYWRkaW5nICogMjtcbiAgICAgICAgcGxvdC56LnNoYXBlLmhlaWdodCA9IHBsb3QuY2VsbEhlaWdodCAtIGNlbGxDb25mLnBhZGRpbmcgKiAyO1xuICAgIH1cblxuXG4gICAgdXBkYXRlKG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICBpZiAodGhpcy5wbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHcm91cHNZKHRoaXMucGxvdC55Lmdyb3VwcywgdGhpcy5zdmdHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdHcm91cHNYKHRoaXMucGxvdC54Lmdyb3VwcywgdGhpcy5zdmdHKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlQ2VsbHMoKTtcblxuICAgICAgICAvLyB0aGlzLnVwZGF0ZVZhcmlhYmxlTGFiZWxzKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVBeGlzWCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNZKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGVnZW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUF4aXNUaXRsZXMoKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlQXhpc1RpdGxlcygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcblxuXG4gICAgfVxuXG5cbiAgICB1cGRhdGVBeGlzWCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGxhYmVsQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwibGFiZWxcIik7XG4gICAgICAgIHZhciBsYWJlbFhDbGFzcyA9IGxhYmVsQ2xhc3MgKyBcIi14XCI7XG4gICAgICAgIHZhciBsYWJlbFlDbGFzcyA9IGxhYmVsQ2xhc3MgKyBcIi15XCI7XG4gICAgICAgIHBsb3QubGFiZWxDbGFzcyA9IGxhYmVsQ2xhc3M7XG5cbiAgICAgICAgdmFyIG9mZnNldFggPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgIGlmIChwbG90Lmdyb3VwQnlYKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxhcCA9IHNlbGYuY29uZmlnLnguZ3JvdXBzLm92ZXJsYXA7XG5cbiAgICAgICAgICAgIG9mZnNldFgueCA9IGdhcFNpemUgLyAyO1xuICAgICAgICAgICAgb2Zmc2V0WC55ID0gb3ZlcmxhcC5ib3R0b20gKyBnYXBTaXplIC8gMiArIDY7XG4gICAgICAgIH0gZWxzZSBpZiAocGxvdC5ncm91cEJ5WSkge1xuICAgICAgICAgICAgb2Zmc2V0WC55ID0gZ2FwU2l6ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgbGFiZWxYQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnguYWxsVmFsdWVzTGlzdCwgKGQsIGkpPT5pKTtcblxuICAgICAgICB2YXIgbGFiZWxzTWVyZ2UgPSBsYWJlbHMuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gbGFiZWxDbGFzcyArIFwiIFwiICsgbGFiZWxYQ2xhc3MgKyBcIiBcIiArIGxhYmVsWENsYXNzICsgXCItXCIgKyBpKS5tZXJnZShsYWJlbHMpO1xuXG4gICAgICAgIGxhYmVsc01lcmdlXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IChpICogcGxvdC5jZWxsV2lkdGggKyBwbG90LmNlbGxXaWR0aCAvIDIpICsgKGQuZ3JvdXAuZ2Fwc1NpemUpICsgb2Zmc2V0WC54KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHBsb3QuaGVpZ2h0ICsgb2Zmc2V0WC55KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMClcblxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoZD0+c2VsZi5mb3JtYXRWYWx1ZVgoZC52YWwpKTtcblxuXG5cbiAgICAgICAgdmFyIG1heFdpZHRoID0gc2VsZi5jb21wdXRlWEF4aXNMYWJlbHNXaWR0aChvZmZzZXRYKTtcblxuICAgICAgICBsYWJlbHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGV4dCA9IHNlbGYuZm9ybWF0VmFsdWVYKGxhYmVsLnZhbCk7XG4gICAgICAgICAgICBVdGlscy5wbGFjZVRleHRXaXRoRWxsaXBzaXNBbmRUb29sdGlwKGVsZW0sIHRleHQsIG1heFdpZHRoLCBzZWxmLmNvbmZpZy5zaG93VG9vbHRpcCA/IHNlbGYucGxvdC50b29sdGlwIDogZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5jb25maWcueC5yb3RhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGxhYmVsc01lcmdlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IFwicm90YXRlKC00NSwgXCIgKyAoKGkgKiBwbG90LmNlbGxXaWR0aCArIHBsb3QuY2VsbFdpZHRoIC8gMikgKyBkLmdyb3VwLmdhcHNTaXplICsgb2Zmc2V0WC54ICkgKyBcIiwgXCIgKyAoIHBsb3QuaGVpZ2h0ICsgb2Zmc2V0WC55KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgLTIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCA4KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxhYmVscy5leGl0KCkucmVtb3ZlKCk7XG5cblxuICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5wcmVmaXhDbGFzcygnYXhpcy14JykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChwbG90LndpZHRoIC8gMikgKyBcIixcIiArIChwbG90LmhlaWdodCArIHBsb3QubWFyZ2luLmJvdHRvbSkgKyBcIilcIilcbiAgICAgICAgICAgIC5zZWxlY3RPckFwcGVuZChcInRleHQuXCIgKyBzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTAuNWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoc2VsZi5jb25maWcueC50aXRsZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXhpc1koKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBsYWJlbENsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImxhYmVsXCIpO1xuICAgICAgICB2YXIgbGFiZWxZQ2xhc3MgPSBsYWJlbENsYXNzICsgXCIteVwiO1xuICAgICAgICBwbG90LmxhYmVsQ2xhc3MgPSBsYWJlbENsYXNzO1xuXG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCJ0ZXh0LlwiICsgbGFiZWxZQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnkuYWxsVmFsdWVzTGlzdCk7XG5cbiAgICAgICAgdmFyIGxhYmVsc0VudGVyID0gbGFiZWxzLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKTtcbiAgICAgICAgdmFyIGxhYmVsc01lcmdlID0gbGFiZWxzRW50ZXIubWVyZ2UobGFiZWxzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0WSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxhcCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLm92ZXJsYXA7XG4gICAgICAgICAgICBsZXQgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgICAgICBvZmZzZXRZLnggPSAtb3ZlcmxhcC5sZWZ0O1xuXG4gICAgICAgICAgICBvZmZzZXRZLnkgPSBnYXBTaXplIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbHNNZXJnZVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIG9mZnNldFkueClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAoZCwgaSkgPT4gKGkgKiBwbG90LmNlbGxIZWlnaHQgKyBwbG90LmNlbGxIZWlnaHQgLyAyKSArIGQuZ3JvdXAuZ2Fwc1NpemUgKyBvZmZzZXRZLnkpXG4gICAgICAgICAgICAuYXR0cihcImR4XCIsIC0yKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gbGFiZWxDbGFzcyArIFwiIFwiICsgbGFiZWxZQ2xhc3MgKyBcIiBcIiArIGxhYmVsWUNsYXNzICsgXCItXCIgKyBpKVxuXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSBzZWxmLmZvcm1hdFZhbHVlWShkLnZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1heFdpZHRoID0gc2VsZi5jb21wdXRlWUF4aXNMYWJlbHNXaWR0aChvZmZzZXRZKTtcblxuICAgICAgICBsYWJlbHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGV4dCA9IHNlbGYuZm9ybWF0VmFsdWVZKGxhYmVsLnZhbCk7XG4gICAgICAgICAgICBVdGlscy5wbGFjZVRleHRXaXRoRWxsaXBzaXNBbmRUb29sdGlwKGVsZW0sIHRleHQsIG1heFdpZHRoLCBzZWxmLmNvbmZpZy5zaG93VG9vbHRpcCA/IHNlbGYucGxvdC50b29sdGlwIDogZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5jb25maWcueS5yb3RhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGxhYmVsc01lcmdlXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IFwicm90YXRlKC00NSwgXCIgKyAob2Zmc2V0WS54ICApICsgXCIsIFwiICsgKGQuZ3JvdXAuZ2Fwc1NpemUgKyAoaSAqIHBsb3QuY2VsbEhlaWdodCArIHBsb3QuY2VsbEhlaWdodCAvIDIpICsgb2Zmc2V0WS55KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG4gICAgICAgICAgICAvLyAuYXR0cihcImR4XCIsIC03KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsc01lcmdlLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKVxuICAgICAgICB9XG5cblxuICAgICAgICBsYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xuXG5cbiAgICAgICAgc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpKVxuICAgICAgICAgICAgLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIiArIHNlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1wbG90Lm1hcmdpbi5sZWZ0ICsgXCIsXCIgKyAocGxvdC5oZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoc2VsZi5jb25maWcueS50aXRsZSk7XG5cbiAgICB9XG5cblxuICAgIGRyYXdHcm91cHNZKHBhcmVudEdyb3VwLCBjb250YWluZXIsIGF2YWlsYWJsZVdpZHRoKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcblxuICAgICAgICB2YXIgZ3JvdXBDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJncm91cFwiKTtcbiAgICAgICAgdmFyIGdyb3VwWUNsYXNzID0gZ3JvdXBDbGFzcyArIFwiLXlcIjtcbiAgICAgICAgdmFyIGdyb3VwcyA9IGNvbnRhaW5lci5zZWxlY3RBbGwoXCJnLlwiICsgZ3JvdXBDbGFzcyArIFwiLlwiICsgZ3JvdXBZQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwYXJlbnRHcm91cC5jaGlsZHJlbkxpc3QpO1xuXG4gICAgICAgIHZhciB2YWx1ZXNCZWZvcmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBnYXBzQmVmb3JlU2l6ZSA9IDA7XG5cbiAgICAgICAgdmFyIGdyb3Vwc0VudGVyID0gZ3JvdXBzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgZ3JvdXBzRW50ZXJcbiAgICAgICAgICAgIC5jbGFzc2VkKGdyb3VwQ2xhc3MsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZChncm91cFlDbGFzcywgdHJ1ZSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpLmNsYXNzZWQoXCJncm91cC1yZWN0XCIsIHRydWUpO1xuXG4gICAgICAgIHZhciB0aXRsZUdyb3VwRW50ZXIgPSBncm91cHNFbnRlci5hcHBlbmRTZWxlY3RvcihcImcudGl0bGVcIik7XG4gICAgICAgIHRpdGxlR3JvdXBFbnRlci5hcHBlbmQoXCJyZWN0XCIpO1xuICAgICAgICB0aXRsZUdyb3VwRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuICAgICAgICB2YXIgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUocGFyZW50R3JvdXAubGV2ZWwpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IGdhcFNpemUgLyA0O1xuXG4gICAgICAgIHZhciB0aXRsZVJlY3RXaWR0aCA9IEhlYXRtYXAuZ3JvdXBUaXRsZVJlY3RIZWlnaHQ7XG4gICAgICAgIHZhciBkZXB0aCA9IHNlbGYuY29uZmlnLnkuZ3JvdXBzLmtleXMubGVuZ3RoIC0gcGFyZW50R3JvdXAubGV2ZWw7XG4gICAgICAgIHZhciBvdmVybGFwID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFhdmFpbGFibGVXaWR0aCkge1xuICAgICAgICAgICAgb3ZlcmxhcC5yaWdodCA9IHBsb3QueS5vdmVybGFwLmxlZnQ7XG4gICAgICAgICAgICBvdmVybGFwLmxlZnQgPSBwbG90Lnkub3ZlcmxhcC5sZWZ0O1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBwbG90LndpZHRoICsgZ2FwU2l6ZSArIG92ZXJsYXAubGVmdCArIG92ZXJsYXAucmlnaHQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBncm91cHNNZXJnZSA9IGdyb3Vwc0VudGVyLm1lcmdlKGdyb3Vwcyk7XG5cbiAgICAgICAgZ3JvdXBzTWVyZ2VcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiICsgKHBhZGRpbmcgLSBvdmVybGFwLmxlZnQpICsgXCIsXCIgKyAoKHBsb3QuY2VsbEhlaWdodCAqIHZhbHVlc0JlZm9yZUNvdW50KSArIGkgKiBnYXBTaXplICsgZ2Fwc0JlZm9yZVNpemUgKyBwYWRkaW5nKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIGdhcHNCZWZvcmVTaXplICs9IChkLmdhcHNJbnNpZGVTaXplIHx8IDApO1xuICAgICAgICAgICAgICAgIHZhbHVlc0JlZm9yZUNvdW50ICs9IGQuYWxsVmFsdWVzQ291bnQgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIHZhciBncm91cFdpZHRoID0gYXZhaWxhYmxlV2lkdGggLSBwYWRkaW5nICogMjtcblxuICAgICAgICB2YXIgdGl0bGVHcm91cHMgPSBncm91cHNNZXJnZS5zZWxlY3RBbGwoXCJnLnRpdGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJ0cmFuc2xhdGUoXCIgKyAoZ3JvdXBXaWR0aCAtIHRpdGxlUmVjdFdpZHRoKSArIFwiLCAwKVwiKTtcblxuICAgICAgICB2YXIgdGlsZVJlY3RzID0gdGl0bGVHcm91cHMuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB0aXRsZVJlY3RXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQ9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkLmdhcHNJbnNpZGVTaXplIHx8IDApICsgcGxvdC5jZWxsSGVpZ2h0ICogZC5hbGxWYWx1ZXNDb3VudCArIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgICAgICAgIC8vIC5hdHRyKFwiZmlsbFwiLCBcImxpZ2h0Z3JleVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMCk7XG5cbiAgICAgICAgdGhpcy5zZXRHcm91cE1vdXNlQ2FsbGJhY2tzKHBhcmVudEdyb3VwLCB0aWxlUmVjdHMpO1xuXG5cbiAgICAgICAgZ3JvdXBzTWVyZ2Uuc2VsZWN0QWxsKFwicmVjdC5ncm91cC1yZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQ9PiBcImdyb3VwLXJlY3QgZ3JvdXAtcmVjdC1cIiArIGQuaW5kZXgpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGdyb3VwV2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZC5nYXBzSW5zaWRlU2l6ZSB8fCAwKSArIHBsb3QuY2VsbEhlaWdodCAqIGQuYWxsVmFsdWVzQ291bnQgKyBwYWRkaW5nICogMlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJ3aGl0ZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDAuNSlcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcblxuXG4gICAgICAgIGdyb3Vwc01lcmdlLmVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG5cbiAgICAgICAgICAgIHNlbGYuZHJhd0dyb3Vwc1kuY2FsbChzZWxmLCBncm91cCwgZDMuc2VsZWN0KHRoaXMpLCBncm91cFdpZHRoIC0gdGl0bGVSZWN0V2lkdGgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGRyYXdHcm91cHNYKHBhcmVudEdyb3VwLCBjb250YWluZXIsIGF2YWlsYWJsZUhlaWdodCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG5cbiAgICAgICAgdmFyIGdyb3VwQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiZ3JvdXBcIik7XG4gICAgICAgIHZhciBncm91cFhDbGFzcyA9IGdyb3VwQ2xhc3MgKyBcIi14XCI7XG4gICAgICAgIHZhciBncm91cHMgPSBjb250YWluZXIuc2VsZWN0QWxsKFwiZy5cIiArIGdyb3VwQ2xhc3MgKyBcIi5cIiArIGdyb3VwWENsYXNzKVxuICAgICAgICAgICAgLmRhdGEocGFyZW50R3JvdXAuY2hpbGRyZW5MaXN0KTtcblxuICAgICAgICB2YXIgdmFsdWVzQmVmb3JlQ291bnQgPSAwO1xuICAgICAgICB2YXIgZ2Fwc0JlZm9yZVNpemUgPSAwO1xuXG4gICAgICAgIHZhciBncm91cHNFbnRlciA9IGdyb3Vwcy5lbnRlcigpLmFwcGVuZChcImdcIik7XG4gICAgICAgIGdyb3Vwc0VudGVyXG4gICAgICAgICAgICAuY2xhc3NlZChncm91cENsYXNzLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoZ3JvdXBYQ2xhc3MsIHRydWUpXG4gICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKS5jbGFzc2VkKFwiZ3JvdXAtcmVjdFwiLCB0cnVlKTtcblxuICAgICAgICB2YXIgdGl0bGVHcm91cEVudGVyID0gZ3JvdXBzRW50ZXIuYXBwZW5kU2VsZWN0b3IoXCJnLnRpdGxlXCIpO1xuICAgICAgICB0aXRsZUdyb3VwRW50ZXIuYXBwZW5kKFwicmVjdFwiKTtcbiAgICAgICAgdGl0bGVHcm91cEVudGVyLmFwcGVuZChcInRleHRcIik7XG5cbiAgICAgICAgdmFyIGdhcFNpemUgPSBIZWF0bWFwLmNvbXB1dGVHYXBTaXplKHBhcmVudEdyb3VwLmxldmVsKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBnYXBTaXplIC8gNDtcbiAgICAgICAgdmFyIHRpdGxlUmVjdEhlaWdodCA9IEhlYXRtYXAuZ3JvdXBUaXRsZVJlY3RIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGRlcHRoID0gc2VsZi5jb25maWcueC5ncm91cHMua2V5cy5sZW5ndGggLSBwYXJlbnRHcm91cC5sZXZlbDtcblxuICAgICAgICB2YXIgb3ZlcmxhcCA9IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICBvdmVybGFwLmJvdHRvbSA9IHBsb3QueC5vdmVybGFwLmJvdHRvbTtcbiAgICAgICAgICAgIG92ZXJsYXAudG9wID0gcGxvdC54Lm92ZXJsYXAudG9wO1xuICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gcGxvdC5oZWlnaHQgKyBnYXBTaXplICsgb3ZlcmxhcC50b3AgKyBvdmVybGFwLmJvdHRvbTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcmxhcC50b3AgPSAtdGl0bGVSZWN0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJlbnRHcm91cCcscGFyZW50R3JvdXAsICdnYXBTaXplJywgZ2FwU2l6ZSwgcGxvdC54Lm92ZXJsYXApO1xuXG4gICAgICAgIHZhciBncm91cHNNZXJnZSA9IGdyb3Vwc0VudGVyLm1lcmdlKGdyb3Vwcyk7XG5cbiAgICAgICAgZ3JvdXBzTWVyZ2VcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiICsgKChwbG90LmNlbGxXaWR0aCAqIHZhbHVlc0JlZm9yZUNvdW50KSArIGkgKiBnYXBTaXplICsgZ2Fwc0JlZm9yZVNpemUgKyBwYWRkaW5nKSArIFwiLCBcIiArIChwYWRkaW5nIC0gb3ZlcmxhcC50b3ApICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgZ2Fwc0JlZm9yZVNpemUgKz0gKGQuZ2Fwc0luc2lkZVNpemUgfHwgMCk7XG4gICAgICAgICAgICAgICAgdmFsdWVzQmVmb3JlQ291bnQgKz0gZC5hbGxWYWx1ZXNDb3VudCB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBncm91cEhlaWdodCA9IGF2YWlsYWJsZUhlaWdodCAtIHBhZGRpbmcgKiAyO1xuXG4gICAgICAgIHZhciB0aXRsZUdyb3VwcyA9IGdyb3Vwc01lcmdlLnNlbGVjdEFsbChcImcudGl0bGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInRyYW5zbGF0ZSgwLCBcIiArICgwKSArIFwiKVwiKTtcblxuXG4gICAgICAgIHZhciB0aWxlUmVjdHMgPSB0aXRsZUdyb3Vwcy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB0aXRsZVJlY3RIZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGQ9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkLmdhcHNJbnNpZGVTaXplIHx8IDApICsgcGxvdC5jZWxsV2lkdGggKiBkLmFsbFZhbHVlc0NvdW50ICsgcGFkZGluZyAqIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJmaWxsXCIsIFwibGlnaHRncmV5XCIpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAwKTtcblxuICAgICAgICB0aGlzLnNldEdyb3VwTW91c2VDYWxsYmFja3MocGFyZW50R3JvdXAsIHRpbGVSZWN0cyk7XG5cblxuICAgICAgICBncm91cHNNZXJnZS5zZWxlY3RBbGwoXCJyZWN0Lmdyb3VwLXJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZD0+IFwiZ3JvdXAtcmVjdCBncm91cC1yZWN0LVwiICsgZC5pbmRleClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGdyb3VwSGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBkPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZC5nYXBzSW5zaWRlU2l6ZSB8fCAwKSArIHBsb3QuY2VsbFdpZHRoICogZC5hbGxWYWx1ZXNDb3VudCArIHBhZGRpbmcgKiAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIndoaXRlXCIpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMC41KVxuICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcblxuICAgICAgICBncm91cHNNZXJnZS5lYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgc2VsZi5kcmF3R3JvdXBzWC5jYWxsKHNlbGYsIGdyb3VwLCBkMy5zZWxlY3QodGhpcyksIGdyb3VwSGVpZ2h0IC0gdGl0bGVSZWN0SGVpZ2h0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIH1cblxuICAgIHNldEdyb3VwTW91c2VDYWxsYmFja3MocGFyZW50R3JvdXAsIHRpbGVSZWN0cykge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbW91c2VvdmVyQ2FsbGJhY2tzID0gW107XG4gICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwicmVjdC5ncm91cC1yZWN0LVwiICsgZC5pbmRleCkuY2xhc3NlZCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1vdXNlb3V0Q2FsbGJhY2tzID0gW107XG4gICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSkuc2VsZWN0QWxsKFwicmVjdC5ncm91cC1yZWN0LVwiICsgZC5pbmRleCkuY2xhc3NlZCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG5cbiAgICAgICAgICAgIG1vdXNlb3ZlckNhbGxiYWNrcy5wdXNoKGQ9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBwYXJlbnRHcm91cC5sYWJlbCArIFwiOiBcIiArIGQuZ3JvdXBpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goZD0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH1cbiAgICAgICAgdGlsZVJlY3RzLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYsIGQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRpbGVSZWN0cy5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBtb3VzZW91dENhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZiwgZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVDZWxscygpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgY2VsbENvbnRhaW5lckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImNlbGxzXCIpO1xuICAgICAgICB2YXIgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgIHZhciBwYWRkaW5nWCA9IHBsb3QueC5ncm91cHMuY2hpbGRyZW5MaXN0Lmxlbmd0aCA/IGdhcFNpemUgLyAyIDogMDtcbiAgICAgICAgdmFyIHBhZGRpbmdZID0gcGxvdC55Lmdyb3Vwcy5jaGlsZHJlbkxpc3QubGVuZ3RoID8gZ2FwU2l6ZSAvIDIgOiAwO1xuICAgICAgICB2YXIgY2VsbENvbnRhaW5lciA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIgKyBjZWxsQ29udGFpbmVyQ2xhc3MpO1xuICAgICAgICBjZWxsQ29udGFpbmVyLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBwYWRkaW5nWCArIFwiLCBcIiArIHBhZGRpbmdZICsgXCIpXCIpO1xuXG4gICAgICAgIHZhciBjZWxsQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiY2VsbFwiKTtcbiAgICAgICAgdmFyIGNlbGxTaGFwZSA9IHBsb3Quei5zaGFwZS50eXBlO1xuXG4gICAgICAgIHZhciBjZWxscyA9IGNlbGxDb250YWluZXIuc2VsZWN0QWxsKFwiZy5cIiArIGNlbGxDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHNlbGYucGxvdC5jZWxscyk7XG5cbiAgICAgICAgdmFyIGNlbGxFbnRlciA9IGNlbGxzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmNsYXNzZWQoY2VsbENsYXNzLCB0cnVlKTtcblxuICAgICAgICB2YXIgY2VsbHNNZXJnZSA9IGNlbGxFbnRlci5tZXJnZShjZWxscyk7XG4gICAgICAgIGNlbGxzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCBjPT4gXCJ0cmFuc2xhdGUoXCIgKyAoKHBsb3QuY2VsbFdpZHRoICogYy5jb2wgKyBwbG90LmNlbGxXaWR0aCAvIDIpICsgYy5jb2xWYXIuZ3JvdXAuZ2Fwc1NpemUpICsgXCIsXCIgKyAoKHBsb3QuY2VsbEhlaWdodCAqIGMucm93ICsgcGxvdC5jZWxsSGVpZ2h0IC8gMikgKyBjLnJvd1Zhci5ncm91cC5nYXBzU2l6ZSkgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IGNlbGxzTWVyZ2Uuc2VsZWN0T3JBcHBlbmQoY2VsbFNoYXBlICsgXCIuY2VsbC1zaGFwZS1cIiArIGNlbGxTaGFwZSk7XG5cbiAgICAgICAgc2hhcGVzXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHBsb3Quei5zaGFwZS53aWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBsb3Quei5zaGFwZS5oZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgLXBsb3QuY2VsbFdpZHRoIC8gMilcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtcGxvdC5jZWxsSGVpZ2h0IC8gMik7XG5cbiAgICAgICAgc2hhcGVzLnN0eWxlKFwiZmlsbFwiLCBjPT4gYy52YWx1ZSA9PT0gdW5kZWZpbmVkID8gc2VsZi5jb25maWcuY29sb3Iubm9EYXRhQ29sb3IgOiBwbG90LnouY29sb3Iuc2NhbGUoYy52YWx1ZSkpO1xuICAgICAgICBzaGFwZXMuYXR0cihcImZpbGwtb3BhY2l0eVwiLCBkPT4gZC52YWx1ZSA9PT0gdW5kZWZpbmVkID8gMCA6IDEpO1xuXG4gICAgICAgIHZhciBtb3VzZW92ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIG1vdXNlb3V0Q2FsbGJhY2tzID0gW107XG5cbiAgICAgICAgaWYgKHBsb3QudG9vbHRpcCkge1xuXG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MucHVzaChjPT4ge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gYy52YWx1ZSA9PT0gdW5kZWZpbmVkID8gc2VsZi5jb25maWcudG9vbHRpcC5ub0RhdGFUZXh0IDogc2VsZi5mb3JtYXRWYWx1ZVooYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChodG1sKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goYz0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5oaWdobGlnaHRMYWJlbHMpIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHRDbGFzcyA9IHNlbGYuY29uZmlnLmNzc0NsYXNzUHJlZml4ICsgXCJoaWdobGlnaHRcIjtcbiAgICAgICAgICAgIHZhciB4TGFiZWxDbGFzcyA9IGM9PnBsb3QubGFiZWxDbGFzcyArIFwiLXgtXCIgKyBjLmNvbDtcbiAgICAgICAgICAgIHZhciB5TGFiZWxDbGFzcyA9IGM9PnBsb3QubGFiZWxDbGFzcyArIFwiLXktXCIgKyBjLnJvdztcblxuXG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MucHVzaChjPT4ge1xuXG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB4TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB5TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vdXNlb3V0Q2FsbGJhY2tzLnB1c2goYz0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwidGV4dC5cIiArIHhMYWJlbENsYXNzKGMpKS5jbGFzc2VkKGhpZ2hsaWdodENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcInRleHQuXCIgKyB5TGFiZWxDbGFzcyhjKSkuY2xhc3NlZChoaWdobGlnaHRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNlbGxzTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgYyA9PiB7XG4gICAgICAgICAgICBtb3VzZW92ZXJDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjaz0+Y2FsbGJhY2soYykpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgYyA9PiB7XG4gICAgICAgICAgICAgICAgbW91c2VvdXRDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjaz0+Y2FsbGJhY2soYykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY2VsbHNNZXJnZS5vbihcImNsaWNrXCIsIGM9PiB7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJjZWxsLXNlbGVjdGVkXCIsIGMpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmb3JtYXRWYWx1ZVgodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy54LmZvcm1hdHRlcikgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy54LmZvcm1hdHRlci5jYWxsKHRoaXMuY29uZmlnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0VmFsdWVZKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcueS5mb3JtYXR0ZXIpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcueS5mb3JtYXR0ZXIuY2FsbCh0aGlzLmNvbmZpZywgdmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdFZhbHVlWih2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnouZm9ybWF0dGVyKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnouZm9ybWF0dGVyLmNhbGwodGhpcy5jb25maWcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXRMZWdlbmRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmxlZ2VuZC5mb3JtYXR0ZXIpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubGVnZW5kLmZvcm1hdHRlci5jYWxsKHRoaXMuY29uZmlnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlTGVnZW5kKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgbGVnZW5kWCA9IHRoaXMucGxvdC53aWR0aCArIDEwO1xuICAgICAgICB2YXIgZ2FwU2l6ZSA9IEhlYXRtYXAuY29tcHV0ZUdhcFNpemUoMCk7XG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVkpIHtcbiAgICAgICAgICAgIGxlZ2VuZFggKz0gZ2FwU2l6ZSAvIDIgKyBwbG90Lnkub3ZlcmxhcC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVgpIHtcbiAgICAgICAgICAgIGxlZ2VuZFggKz0gZ2FwU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVnZW5kWSA9IDA7XG4gICAgICAgIGlmICh0aGlzLnBsb3QuZ3JvdXBCeVggfHwgdGhpcy5wbG90Lmdyb3VwQnlZKSB7XG4gICAgICAgICAgICBsZWdlbmRZICs9IGdhcFNpemUgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhcldpZHRoID0gMTA7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSB0aGlzLnBsb3QuaGVpZ2h0IC0gMjtcbiAgICAgICAgdmFyIHNjYWxlID0gcGxvdC56LmNvbG9yLnNjYWxlO1xuXG4gICAgICAgIHBsb3QubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLnN2ZywgdGhpcy5zdmdHLCBzY2FsZSwgbGVnZW5kWCwgbGVnZW5kWSwgdiA9PiBzZWxmLmZvcm1hdExlZ2VuZFZhbHVlKHYpKS5zZXRSb3RhdGVMYWJlbHMoc2VsZi5jb25maWcubGVnZW5kLnJvdGF0ZUxhYmVscykubGluZWFyR3JhZGllbnRCYXIoYmFyV2lkdGgsIGJhckhlaWdodCk7XG4gICAgfVxuXG5cbn1cbiIsImltcG9ydCB7Q2hhcnRXaXRoQ29sb3JHcm91cHMsIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBIaXN0b2dyYW1Db25maWcgZXh0ZW5kcyBDaGFydFdpdGhDb2xvckdyb3Vwc0NvbmZpZ3tcblxuICAgIHN2Z0NsYXNzPSB0aGlzLmNzc0NsYXNzUHJlZml4KydoaXN0b2dyYW0nO1xuICAgIHNob3dMZWdlbmQ9dHJ1ZTtcbiAgICBzaG93VG9vbHRpcCA9dHJ1ZTtcbiAgICB4PXsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbFxuICAgICAgICBrZXk6IDAsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBVdGlscy5pc051bWJlcihkKSA/IGQgOiBwYXJzZUZsb2F0KGRba2V5XSksIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIG9yaWVudDogXCJib3R0b21cIixcbiAgICAgICAgdGlja3M6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHk9ey8vIFkgYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsLFxuICAgICAgICBvcmllbnQ6IFwibGVmdFwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgZnJlcXVlbmN5PXRydWU7XG4gICAgZ3JvdXBzPXtcbiAgICAgICAga2V5OiAxXG4gICAgfTtcbiAgICB0cmFuc2l0aW9uPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IoY3VzdG9tKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBpZihjdXN0b20pe1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIaXN0b2dyYW0gZXh0ZW5kcyBDaGFydFdpdGhDb2xvckdyb3Vwc3tcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IEhpc3RvZ3JhbUNvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKXtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgSGlzdG9ncmFtQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGluaXRQbG90KCl7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG5cbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB0aGlzLnBsb3QueD17fTtcbiAgICAgICAgdGhpcy5wbG90Lnk9e307XG4gICAgICAgIHRoaXMucGxvdC5iYXI9e1xuICAgICAgICAgICAgY29sb3I6IG51bGwvL2NvbG9yIHNjYWxlIG1hcHBpbmcgZnVuY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY29tcHV0ZVBsb3RTaXplKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldHVwWCgpO1xuICAgICAgICB0aGlzLnNldHVwSGlzdG9ncmFtKCk7XG4gICAgICAgIHRoaXMuc2V0dXBHcm91cFN0YWNrcygpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFgoKXtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueDtcblxuICAgICAgICAvKiAqXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICoqL1xuICAgICAgICB4LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlKGQsIGNvbmYua2V5KTtcbiAgICAgICAgeC5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFswLCBwbG90LndpZHRoXSk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuXG4gICAgICAgIHguYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHguc2NhbGUpO1xuXG4gICAgICAgIGlmKGNvbmYudGlja3Mpe1xuICAgICAgICAgICAgeC5heGlzLnRpY2tzKGNvbmYudGlja3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuICAgICAgICBwbG90Lnguc2NhbGUuZG9tYWluKFtkMy5taW4oZGF0YSwgcz0+ZDMubWluKHMudmFsdWVzLCBwbG90LngudmFsdWUpKSwgZDMubWF4KGRhdGEsIHM9PmQzLm1heChzLnZhbHVlcywgcGxvdC54LnZhbHVlKSldKTtcbiAgICAgICAgXG4gICAgfTtcblxuICAgIHNldHVwWSAoKXtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHkgPSBwbG90Lnk7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgeS5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFtwbG90LmhlaWdodCwgMF0pO1xuXG4gICAgICAgIHkuYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHkuc2NhbGUpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGxvdC5kYXRhO1xuICAgICAgICB2YXIgeVN0YWNrTWF4ID0gZDMubWF4KHBsb3Quc3RhY2tlZEhpc3RvZ3JhbXMsIGxheWVyID0+IGQzLm1heChsYXllci5oaXN0b2dyYW1CaW5zLCBkID0+IGQueTAgKyBkLnkpKTtcbiAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihbMCwgeVN0YWNrTWF4XSk7XG5cbiAgICB9O1xuXG5cbiAgICBzZXR1cEhpc3RvZ3JhbSgpIHtcbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3Q7XG4gICAgICAgIHZhciB4ID0gcGxvdC54O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5jb25maWcueC50aWNrcyA/IHguc2NhbGUudGlja3ModGhpcy5jb25maWcueC50aWNrcykgOiB4LnNjYWxlLnRpY2tzKCk7XG5cbiAgICAgICAgcGxvdC5oaXN0b2dyYW0gPSBkMy5oaXN0b2dyYW0oKVxuICAgICAgICAgICAgLmRvbWFpbih4LnNjYWxlLmRvbWFpbigpKVxuICAgICAgICAgICAgLnZhbHVlKHgudmFsdWUpXG4gICAgICAgICAgICAudGhyZXNob2xkcyh0aWNrcyk7XG4gICAgfVxuXG4gICAgc2V0dXBHcm91cFN0YWNrcygpIHtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcbiAgICAgICAgdmFyIHkwcyA9IFtdO1xuICAgICAgICB0aGlzLnBsb3QuZ3JvdXBlZERhdGEuZm9yRWFjaChkPT57XG4gICAgICAgICAgICBkLmhpc3RvZ3JhbUJpbnMgPSB0aGlzLnBsb3QuaGlzdG9ncmFtKGQudmFsdWVzKTtcblxuICAgICAgICAgICAgICAgIGQuaGlzdG9ncmFtQmlucy5mb3JFYWNoKChiLGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYi54ID1iLngwO1xuICAgICAgICAgICAgICAgICAgICBiLmR4ID0gYi54MS1iLngwO1xuICAgICAgICAgICAgICAgICAgICBiLnkgPSBiLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZZMCA9IHkwc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIXByZXZZMCkgcHJldlkwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYi55MCA9IHByZXZZMDtcblxuICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5jb25maWcuZnJlcXVlbmN5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIueS89dGhpcy5wbG90LmRhdGFMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5MHNbaV0gPSBiLnkrcHJldlkwO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhLm1hcChkPT5kLmtleSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGxvdC5ncm91cGVkRGF0YSk7XG5cbiAgICAgICAgdGhpcy5wbG90LnN0YWNrID0gZDMuc3RhY2soKS5rZXlzKGtleXMpLnZhbHVlKGQ9PmQuaGlzdG9ncmFtQmlucyk7XG4gICAgICAgIHRoaXMucGxvdC5zdGFja2VkSGlzdG9ncmFtcyA9IHRoaXMucGxvdC5ncm91cGVkRGF0YTtcbiAgICB9XG5cbiAgICBkcmF3QXhpc1goKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueDtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMteCcpK1wiLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSsoc2VsZi5jb25maWcuZ3VpZGVzID8gJycgOiAnLicrc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIHBsb3QuaGVpZ2h0ICsgXCIpXCIpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC54LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiK3NlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgKHBsb3Qud2lkdGgvMikgK1wiLFwiKyAocGxvdC5tYXJnaW4uYm90dG9tKSArXCIpXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLTFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNZKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLnk7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzLXknKStcIi5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzJykrKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nK3NlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSk7XG5cbiAgICAgICAgdmFyIGF4aXNUID0gYXhpcztcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnkuYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAtcGxvdC5tYXJnaW4ubGVmdCArXCIsXCIrKHBsb3QuaGVpZ2h0LzIpK1wiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cblxuICAgIGRyYXdIaXN0b2dyYW0oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGF5ZXJDbGFzcyA9IHRoaXMucHJlZml4Q2xhc3MoXCJsYXllclwiKTtcblxuICAgICAgICB2YXIgYmFyQ2xhc3MgPSB0aGlzLnByZWZpeENsYXNzKFwiYmFyXCIpO1xuICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiK2xheWVyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShwbG90LnN0YWNrZWRIaXN0b2dyYW1zKTtcblxuICAgICAgICB2YXIgbGF5ZXJNZXJnZSA9IGxheWVyLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBsYXllckNsYXNzKS5tZXJnZShsYXllcik7XG5cblxuICAgICAgICB2YXIgYmFyID0gbGF5ZXJNZXJnZS5zZWxlY3RBbGwoXCIuXCIrYmFyQ2xhc3MpXG4gICAgICAgICAgICAuZGF0YShkID0+IGQuaGlzdG9ncmFtQmlucyk7XG5cbiAgICAgICAgdmFyIGJhckVudGVyID0gYmFyLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgYmFyRW50ZXJcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgYmFyQ2xhc3MpXG4gICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDEpO1xuXG4gICAgICAgIHZhciBiYXJNZXJnZSA9IGJhckVudGVyLm1lcmdlKGJhcik7XG4gICAgICAgIHZhciBiYXJSZWN0ID0gYmFyTWVyZ2Uuc2VsZWN0KFwicmVjdFwiKTtcblxuICAgICAgICB2YXIgYmFyUmVjdFQgPSBiYXJSZWN0O1xuICAgICAgICB2YXIgYmFyVCA9IGJhck1lcmdlO1xuICAgICAgICB2YXIgbGF5ZXJUID0gbGF5ZXJNZXJnZTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgYmFyUmVjdFQgPSBiYXJSZWN0LnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGJhclQgPSBiYXJNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICBsYXllclQ9IGxheWVyTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyVC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgcGxvdC54LnNjYWxlKGQueCkgKyBcIixcIiArIChwbG90Lnkuc2NhbGUoZC55MCArZC55KSkgKyBcIilcIjsgfSk7XG4gICAgICAgIHZhciByZWN0V2lkdGggPSBwbG90LnN0YWNrZWRIaXN0b2dyYW1zLmxlbmd0aCA/IChwbG90LnN0YWNrZWRIaXN0b2dyYW1zWzBdLmhpc3RvZ3JhbUJpbnMubGVuZ3RoID8gIHBsb3QueC5zY2FsZShwbG90LnN0YWNrZWRIaXN0b2dyYW1zWzBdLmhpc3RvZ3JhbUJpbnNbMF0ueDEpLXBsb3QueC5zY2FsZShwbG90LnN0YWNrZWRIaXN0b2dyYW1zWzBdLmhpc3RvZ3JhbUJpbnNbMF0ueDApLTEgOiAwKSA6IDA7XG5cblxuICAgICAgICBiYXJSZWN0VFxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAgZD0+ICBNYXRoLm1heCgwLCBwbG90Lnguc2NhbGUoZC54MSktcGxvdC54LnNjYWxlKGQueDApLTEpIClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQgPT4gICBwbG90LmhlaWdodCAtIHBsb3QueS5zY2FsZShkLnkpKTtcblxuICAgICAgICBpZih0aGlzLnBsb3QuY29sb3Ipe1xuICAgICAgICAgICAgbGF5ZXJUXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIHRoaXMucGxvdC5zZXJpZXNDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICBiYXJNZXJnZS5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGQueSk7XG4gICAgICAgICAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgYmFyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1goKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1koKTtcblxuICAgICAgICB0aGlzLmRyYXdIaXN0b2dyYW0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7RDNFeHRlbnNpb25zfSBmcm9tICcuL2QzLWV4dGVuc2lvbnMnXG5EM0V4dGVuc2lvbnMuZXh0ZW5kKCk7XG5cbmV4cG9ydCB7U2NhdHRlclBsb3QsIFNjYXR0ZXJQbG90Q29uZmlnfSBmcm9tIFwiLi9zY2F0dGVycGxvdFwiO1xuZXhwb3J0IHtTY2F0dGVyUGxvdE1hdHJpeCwgU2NhdHRlclBsb3RNYXRyaXhDb25maWd9IGZyb20gXCIuL3NjYXR0ZXJwbG90LW1hdHJpeFwiO1xuZXhwb3J0IHtSZWdyZXNzaW9uLCBSZWdyZXNzaW9uQ29uZmlnfSBmcm9tICcuL3JlZ3Jlc3Npb24nXG5leHBvcnQge0NvcnJlbGF0aW9uTWF0cml4LCBDb3JyZWxhdGlvbk1hdHJpeENvbmZpZ30gZnJvbSAnLi9jb3JyZWxhdGlvbi1tYXRyaXgnXG5leHBvcnQge0hlYXRtYXAsIEhlYXRtYXBDb25maWd9IGZyb20gJy4vaGVhdG1hcCdcbmV4cG9ydCB7SGVhdG1hcFRpbWVTZXJpZXMsIEhlYXRtYXBUaW1lU2VyaWVzQ29uZmlnfSBmcm9tICcuL2hlYXRtYXAtdGltZXNlcmllcydcbmV4cG9ydCB7SGlzdG9ncmFtLCBIaXN0b2dyYW1Db25maWd9IGZyb20gJy4vaGlzdG9ncmFtJ1xuZXhwb3J0IHtCYXJDaGFydCwgQmFyQ2hhcnRDb25maWd9IGZyb20gJy4vYmFyLWNoYXJ0J1xuZXhwb3J0IHtCb3hQbG90QmFzZSwgQm94UGxvdEJhc2VDb25maWd9IGZyb20gJy4vYm94LXBsb3QtYmFzZSdcbmV4cG9ydCB7Qm94UGxvdCwgQm94UGxvdENvbmZpZ30gZnJvbSAnLi9ib3gtcGxvdCdcbmV4cG9ydCB7RGl2ZXJnaW5nU3RhY2tlZEJhckNoYXJ0LCBEaXZlcmdpbmdTdGFja2VkQmFyQ2hhcnRDb25maWd9IGZyb20gJy4vZGl2ZXJnaW5nLXN0YWNrZWQtYmFyLWNoYXJ0J1xuZXhwb3J0IHtMaW5lQ2hhcnQsIExpbmVDaGFydENvbmZpZ30gZnJvbSAnLi9saW5lLWNoYXJ0J1xuZXhwb3J0IHtTdGF0aXN0aWNzVXRpbHN9IGZyb20gJy4vc3RhdGlzdGljcy11dGlscydcbmV4cG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5leHBvcnQge0xlZ2VuZH0gZnJvbSAnLi9sZWdlbmQnXG5cblxuXG5cblxuIiwiaW1wb3J0IHtVdGlsc30gZnJvbSBcIi4vdXRpbHNcIjtcblxuaW1wb3J0IHtsZWdlbmRDb2xvciwgbGVnZW5kU2l6ZSwgbGVnZW5kU3ltYm9sfSBmcm9tICdkMy1zdmctbGVnZW5kJ1xuXG5cbi8qdmFyIGQzID0gcmVxdWlyZSgnLi4vYm93ZXJfY29tcG9uZW50cy9kMycpO1xuKi9cbi8vIHZhciBsZWdlbmQgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2QzLWxlZ2VuZC9uby1leHRlbmQnKTtcbi8vXG4vLyBtb2R1bGUuZXhwb3J0cy5sZWdlbmQgPSBsZWdlbmQ7XG5cbmV4cG9ydCBjbGFzcyBMZWdlbmQge1xuXG4gICAgY3NzQ2xhc3NQcmVmaXg9XCJvZGMtXCI7XG4gICAgbGVnZW5kQ2xhc3M9dGhpcy5jc3NDbGFzc1ByZWZpeCtcImxlZ2VuZFwiO1xuICAgIGNvbnRhaW5lcjtcbiAgICBzY2FsZTtcbiAgICBjb2xvcj0gbGVnZW5kQ29sb3I7XG4gICAgc2l6ZSA9IGxlZ2VuZFNpemU7XG4gICAgc3ltYm9sPSBsZWdlbmRTeW1ib2w7XG4gICAgZ3VpZDtcblxuICAgIGxhYmVsRm9ybWF0ID0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3RydWN0b3Ioc3ZnLCBsZWdlbmRQYXJlbnQsIHNjYWxlLCBsZWdlbmRYLCBsZWdlbmRZLCBsYWJlbEZvcm1hdCl7XG4gICAgICAgIHRoaXMuc2NhbGU9c2NhbGU7XG4gICAgICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgICAgICB0aGlzLmd1aWQgPSBVdGlscy5ndWlkKCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gIFV0aWxzLnNlbGVjdE9yQXBwZW5kKGxlZ2VuZFBhcmVudCwgXCJnLlwiK3RoaXMubGVnZW5kQ2xhc3MsIFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrbGVnZW5kWCtcIixcIitsZWdlbmRZK1wiKVwiKVxuICAgICAgICAgICAgLmNsYXNzZWQodGhpcy5sZWdlbmRDbGFzcywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdCA9IGxhYmVsRm9ybWF0O1xuICAgIH1cblxuXG5cbiAgICBsaW5lYXJHcmFkaWVudEJhcihiYXJXaWR0aCwgYmFySGVpZ2h0LCB0aXRsZSl7XG4gICAgICAgIHZhciBncmFkaWVudElkID0gdGhpcy5jc3NDbGFzc1ByZWZpeCtcImxpbmVhci1ncmFkaWVudFwiK1wiLVwiK3RoaXMuZ3VpZDtcbiAgICAgICAgdmFyIHNjYWxlPSB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5saW5lYXJHcmFkaWVudCA9IFV0aWxzLmxpbmVhckdyYWRpZW50KHRoaXMuc3ZnLCBncmFkaWVudElkLCB0aGlzLnNjYWxlLnJhbmdlKCksIDAsIDEwMCwgMCwgMCk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuc2VsZWN0T3JBcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGJhcldpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgYmFySGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCJ1cmwoI1wiK2dyYWRpZW50SWQrXCIpXCIpO1xuXG5cbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5jb250YWluZXIuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgLmRhdGEoIHNjYWxlLmRvbWFpbigpICk7XG4gICAgICAgIHZhciB0aWNrc051bWJlciA9c2NhbGUuZG9tYWluKCkubGVuZ3RoLTE7XG4gICAgICAgIHZhciB0aWNrc01lcmdlID0gdGlja3MuZW50ZXIoKS5hcHBlbmQoXCJ0ZXh0XCIpLm1lcmdlKHRpY2tzKTtcblxuICAgICAgICB0aWNrc01lcmdlLmF0dHIoXCJ4XCIsIGJhcldpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsICAoZCwgaSkgPT4gIGJhckhlaWdodCAtKGkqYmFySGVpZ2h0L3RpY2tzTnVtYmVyKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMylcbiAgICAgICAgICAgIC8vIC5hdHRyKFwiZHlcIiwgMSlcbiAgICAgICAgICAgIC5hdHRyKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChkPT4gc2VsZi5sYWJlbEZvcm1hdCA/IHNlbGYubGFiZWxGb3JtYXQoZCkgOiBkKTtcbiAgICAgICAgdGlja3NNZXJnZS5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgaWYodGhpcy5yb3RhdGVMYWJlbHMpe1xuICAgICAgICAgICAgdGlja3NNZXJnZVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInJvdGF0ZSgtNDUsIFwiICsgYmFyV2lkdGggKyBcIiwgXCIgKyAoYmFySGVpZ2h0IC0oaSpiYXJIZWlnaHQvdGlja3NOdW1iZXIpKSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIDUpO1xuXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aWNrcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0Um90YXRlTGFiZWxzKHJvdGF0ZUxhYmVscykge1xuICAgICAgICB0aGlzLnJvdGF0ZUxhYmVscyA9IHJvdGF0ZUxhYmVscztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgXG59IiwiaW1wb3J0IHtDaGFydFdpdGhDb2xvckdyb3VwcywgQ2hhcnRXaXRoQ29sb3JHcm91cHNDb25maWd9IGZyb20gXCIuL2NoYXJ0LXdpdGgtY29sb3ItZ3JvdXBzXCI7XG5pbXBvcnQge1V0aWxzfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIExpbmVDaGFydENvbmZpZyBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlne1xuXG4gICAgc3ZnQ2xhc3M9IHRoaXMuY3NzQ2xhc3NQcmVmaXgrJ2xpbmUtY2hhcnQnO1xuICAgIGd1aWRlcz0gZmFsc2U7IC8vc2hvdyBheGlzIGd1aWRlc1xuICAgIHNob3dUb29sdGlwPSB0cnVlOyAvL3Nob3cgdG9vbHRpcCBvbiBkb3QgaG92ZXJcblxuICAgIHg9ey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsXG4gICAgICAgIGtleTogMCxcbiAgICAgICAgdmFsdWU6IChkLCBrZXkpID0+IGRba2V5XSwgLy8geCB2YWx1ZSBhY2Nlc3NvclxuICAgICAgICBvcmllbnQ6IFwiYm90dG9tXCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBkb21haW5NYXJnaW46IDAuMDVcbiAgICB9O1xuICAgIHk9ey8vIFkgYXhpcyBjb25maWdcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBheGlzIGxhYmVsLFxuICAgICAgICBrZXk6IDEsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBkW2tleV0sIC8vIHkgdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgb3JpZW50OiBcImxlZnRcIixcbiAgICAgICAgc2NhbGU6IFwibGluZWFyXCIsXG4gICAgICAgIGRvbWFpbk1hcmdpbjogMC4wNVxuICAgIH07XG4gICAgZ3JvdXBzPXtcbiAgICAgICAga2V5OiAyXG4gICAgfTtcblxuICAgIGRvdFJhZGl1cyA9IDI7XG4gICAgZG90SWQgPSAoZCwgaSk9PiB1bmRlZmluZWQ7XG4gICAgdHJhbnNpdGlvbj0gdHJ1ZTtcbiAgICBvbkRvdEhvdmVyID0gKGQsIGkpID0+IHt9O1xuICAgIG9uRG90SG92ZXJPdXQgPSAoZCwgaSkgPT4ge307XG4gICAgbGluZUlkID0gKGQsIGkpPT4gdW5kZWZpbmVkO1xuICAgIHRyYW5zaXRpb249IHRydWU7XG4gICAgb25MaW5lSG92ZXIgPSAoZCwgaSkgPT4ge307XG4gICAgb25MaW5lSG92ZXJPdXQgPSAoZCwgaSkgPT4ge307XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuXG5cblxuICAgICAgICBpZihjdXN0b20pe1xuICAgICAgICAgICAgVXRpbHMuZGVlcEV4dGVuZCh0aGlzLCBjdXN0b20pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMaW5lQ2hhcnQgZXh0ZW5kcyBDaGFydFdpdGhDb2xvckdyb3Vwc3tcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IExpbmVDaGFydENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKXtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgTGluZUNoYXJ0Q29uZmlnKGNvbmZpZykpO1xuICAgIH1cblxuICAgIGluaXRQbG90KCl7XG4gICAgICAgIHN1cGVyLmluaXRQbG90KCk7XG4gICAgICAgIHZhciBzZWxmPXRoaXM7XG5cbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB0aGlzLnBsb3QueD17fTtcbiAgICAgICAgdGhpcy5wbG90Lnk9e307XG5cbiAgICAgICAgdGhpcy5jb21wdXRlUGxvdFNpemUoKTtcbiAgICAgICAgdGhpcy5zZXR1cFgoKTtcbiAgICAgICAgdGhpcy5zZXR1cFkoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFgoKXtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHggPSBwbG90Lng7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueDtcblxuICAgICAgICAvKiAqXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICoqL1xuICAgICAgICB4LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlKGQsIGNvbmYua2V5KTtcbiAgICAgICAgXG4gICAgICAgIHguc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnNjYWxlKS5yYW5nZShbMCwgcGxvdC53aWR0aF0pO1xuICAgICAgICB4Lm1hcCA9IGQgPT4geC5zY2FsZSh4LnZhbHVlKGQpKTtcbiAgICAgICAgXG4gICAgICAgIHguYXhpcyA9IFV0aWxzLmNyZWF0ZUF4aXMoY29uZi5vcmllbnQsIHguc2NhbGUpO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuXG4gICAgICAgIHZhciBkb21haW4gPSBbcGFyc2VGbG9hdChkMy5taW4oZGF0YSwgcz0+ZDMubWluKHMudmFsdWVzLCBwbG90LngudmFsdWUpKSksIHBhcnNlRmxvYXQoZDMubWF4KGRhdGEsIHM9PmQzLm1heChzLnZhbHVlcywgcGxvdC54LnZhbHVlKSkpXTtcbiAgICAgICAgdmFyIGV4dGVudCA9IChkb21haW5bMV0tZG9tYWluWzBdKSB8fCAxO1xuICAgICAgICB2YXIgbWFyZ2luID0gKGV4dGVudCkqIGNvbmYuZG9tYWluTWFyZ2luO1xuICAgICAgICBkb21haW5bMF0tPW1hcmdpbjtcbiAgICAgICAgZG9tYWluWzFdKz1tYXJnaW47XG4gICAgICAgIHBsb3QueC5zY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICAgICAgaWYodGhpcy5jb25maWcuZ3VpZGVzKSB7XG4gICAgICAgICAgICB4LmF4aXMudGlja1NpemUoLXBsb3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHNldHVwWSAoKXtcblxuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgdmFyIHkgPSBwbG90Lnk7XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWcueTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiB2YWx1ZSBhY2Nlc3NvciAtIHJldHVybnMgdGhlIHZhbHVlIHRvIGVuY29kZSBmb3IgYSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICAgICAgICogc2NhbGUgLSBtYXBzIHZhbHVlIHRvIGEgdmlzdWFsIGRpc3BsYXkgZW5jb2RpbmcsIHN1Y2ggYXMgYSBwaXhlbCBwb3NpdGlvbi5cbiAgICAgICAgICogbWFwIGZ1bmN0aW9uIC0gbWFwcyBmcm9tIGRhdGEgdmFsdWUgdG8gZGlzcGxheSB2YWx1ZVxuICAgICAgICAgKiBheGlzIC0gc2V0cyB1cCBheGlzXG4gICAgICAgICAqL1xuICAgICAgICB5LnZhbHVlID0gZCA9PiBjb25mLnZhbHVlKGQsIGNvbmYua2V5KTtcblxuICAgICAgICB5LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi5zY2FsZSkucmFuZ2UoW3Bsb3QuaGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgeS5tYXAgPSBkID0+IHkuc2NhbGUoeS52YWx1ZShkKSk7XG5cbiAgICAgICAgeS5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeS5zY2FsZSk7XG5cbiAgICAgICAgaWYodGhpcy5jb25maWcuZ3VpZGVzKXtcbiAgICAgICAgICAgIHkuYXhpcy50aWNrU2l6ZSgtcGxvdC53aWR0aCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuXG4gICAgICAgIHZhciBkb21haW4gPSBbcGFyc2VGbG9hdChkMy5taW4oZGF0YSwgcz0+ZDMubWluKHMudmFsdWVzLCBwbG90LnkudmFsdWUpKSksIHBhcnNlRmxvYXQoZDMubWF4KGRhdGEsIHM9PmQzLm1heChzLnZhbHVlcywgcGxvdC55LnZhbHVlKSkpXTtcbiAgICAgICAgdmFyIGV4dGVudCA9IChkb21haW5bMV0tZG9tYWluWzBdKSB8fCAxO1xuICAgICAgICB2YXIgbWFyZ2luID0gKGV4dGVudCkqIGNvbmYuZG9tYWluTWFyZ2luO1xuXG4gICAgICAgIGRvbWFpblswXS09bWFyZ2luO1xuICAgICAgICBkb21haW5bMV0rPW1hcmdpbjtcbiAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBwbG90Lnkuc2NhbGUuZG9tYWluKFtkMy5taW4oZGF0YSwgcGxvdC55LnZhbHVlKS0xLCBkMy5tYXgoZGF0YSwgcGxvdC55LnZhbHVlKSsxXSk7XG4gICAgfTtcblxuICAgIGRyYXdBeGlzWCgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy54O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcy14JykrXCIuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpKyhzZWxmLmNvbmZpZy5ndWlkZXMgPyAnJyA6ICcuJytzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgcGxvdC5oZWlnaHQgKyBcIilcIik7XG4gICAgICAgIFxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC54LmF4aXMpO1xuICAgICAgICBcbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAocGxvdC53aWR0aC8yKSArXCIsXCIrIChwbG90Lm1hcmdpbi5ib3R0b20pICtcIilcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCItMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICBkcmF3QXhpc1koKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGF4aXNDb25mID0gdGhpcy5jb25maWcueTtcbiAgICAgICAgdmFyIGF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMteScpK1wiLlwiK3NlbGYucHJlZml4Q2xhc3MoJ2F4aXMnKSsoc2VsZi5jb25maWcuZ3VpZGVzID8gJycgOiAnLicrc2VsZi5wcmVmaXhDbGFzcygnbm8tZ3VpZGVzJykpKTtcblxuICAgICAgICB2YXIgYXhpc1QgPSBheGlzO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBheGlzVCA9IGF4aXMudHJhbnNpdGlvbigpLmVhc2UoZDMuZWFzZVNpbkluT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNULmNhbGwocGxvdC55LmF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0T3JBcHBlbmQoXCJ0ZXh0LlwiK3NlbGYucHJlZml4Q2xhc3MoJ2xhYmVsJykpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIisgLXBsb3QubWFyZ2luLmxlZnQgK1wiLFwiKyhwbG90LmhlaWdodC8yKStcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGF4aXNDb25mLnRpdGxlKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlKG5ld0RhdGEpe1xuICAgICAgICBzdXBlci51cGRhdGUobmV3RGF0YSk7XG4gICAgICAgIHRoaXMuZHJhd0F4aXNYKCk7XG4gICAgICAgIHRoaXMuZHJhd0F4aXNZKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGluZXMoKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlTGluZXMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBkYXRhID0gcGxvdC5kYXRhO1xuICAgICAgICB2YXIgbGF5ZXJDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2xheWVyJyk7XG4gICAgICAgIHZhciBsaW5lQ2xhc3MgPSB0aGlzLmxpbmVDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2xpbmUnKTtcbiAgICAgICAgc2VsZi5saW5lc0NvbnRhaW5lckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnbGluZXMtY29udGFpbmVyJyk7XG5cbiAgICAgICAgdmFyIGxpbmVzQ29udGFpbmVyID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIiArIHNlbGYubGluZXNDb250YWluZXJDbGFzcyk7XG5cbiAgICAgICAgdmFyIGxheWVyID0gbGluZXNDb250YWluZXIuc2VsZWN0QWxsKFwiZy5cIitsYXllckNsYXNzKS5kYXRhKHBsb3QuZ3JvdXBlZERhdGEpO1xuXG4gICAgICAgIHZhciBsYXllckVudGVyID0gbGF5ZXIuZW50ZXIoKS5hcHBlbmRTZWxlY3RvcihcImcuXCIrbGF5ZXJDbGFzcyk7XG4gICAgICAgIHZhciBsaW5lUGF0aEVudGVyID0gbGF5ZXJFbnRlci5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGxpbmVDbGFzcyk7XG5cbiAgICAgICAgdmFyIGxheWVyTWVyZ2UgPSBsYXllckVudGVyLm1lcmdlKGxheWVyKTtcblxuICAgICAgICB2YXIgbGluZVBhdGggPSBsYXllck1lcmdlLnNlbGVjdCgnLicgKyBsaW5lQ2xhc3MpXG4gICAgICAgICAgICAuZGF0dW0oZD0+ZC52YWx1ZXMpO1xuXG4gICAgICAgIHZhciBsaW5lUGF0aE1lcmdlID0gbGluZVBhdGhFbnRlci5tZXJnZShsaW5lUGF0aCk7XG5cbiAgICAgICAgdmFyIGxpbmVQYXRoVCA9IGxpbmVQYXRoTWVyZ2U7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGxpbmVQYXRoVCA9IGxpbmVQYXRoTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmUgPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KHBsb3QueC5tYXApXG4gICAgICAgICAgICAueShwbG90LnkubWFwKTtcblxuICAgICAgICBsaW5lUGF0aFRcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIC8vIC5hdHRyKFwic3Ryb2tlXCIsIFwic3RlZWxibHVlXCIpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZS1saW5lY2FwXCIsIFwicm91bmRcIilcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgdGhpcy5jb25maWcubGluZUlkKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmUpO1xuXG5cbiAgICAgICAgLy9UT0RPIGFkZCB0b29sdGlwXG5cbiAgICAgICAgbGluZVBhdGhNZXJnZS5vbihcIm1vdXNlb3Zlci5vbkxpbmVIb3ZlclwiLCB0aGlzLmNvbmZpZy5vbkxpbmVIb3Zlcik7XG4gICAgICAgIGxpbmVQYXRoTWVyZ2Uub24oXCJtb3VzZW91dC5vbkxpbmVIb3Zlck91dFwiLCB0aGlzLmNvbmZpZy5vbkxpbmVIb3Zlck91dCk7XG5cbiAgICAgICAgaWYgKHBsb3Quc2VyaWVzQ29sb3IpIHtcbiAgICAgICAgICAgIGxheWVyTWVyZ2Uuc3R5bGUoXCJzdHJva2VcIiwgcGxvdC5zZXJpZXNDb2xvcilcbiAgICAgICAgfWVsc2UgaWYocGxvdC5jb2xvcil7XG4gICAgICAgICAgICBsaW5lUGF0aE1lcmdlLnN0eWxlKFwic3Ryb2tlXCIsIHBsb3QuY29sb3IpXG4gICAgICAgIH1cblxuICAgICAgICBsaW5lUGF0aC5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIHZhciBkb3RDbGFzcyA9IHRoaXMuZG90Q2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKCdkb3QnKTtcblxuICAgICAgICB2YXIgZG90cyA9IGxheWVyTWVyZ2Uuc2VsZWN0QWxsKCcuJyArIGRvdENsYXNzKVxuICAgICAgICAgICAgLmRhdGEoZD0+ZC52YWx1ZXMpO1xuXG4gICAgICAgIHZhciBkb3RzRW50ZXIgPSBkb3RzLmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGRvdENsYXNzKTtcblxuICAgICAgICB2YXIgZG90c01lcmdlID0gZG90c0VudGVyLm1lcmdlKGRvdHMpO1xuXG4gICAgICAgIHZhciBkb3RzVCA9IGRvdHNNZXJnZTtcbiAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgZG90c1QgPSBkb3RzTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG90c1QuYXR0cihcInJcIiwgc2VsZi5jb25maWcuZG90UmFkaXVzKVxuICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCBwbG90LngubWFwKVxuICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBwbG90LnkubWFwKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCB0aGlzLmNvbmZpZy5kb3RJZCk7XG5cbiAgICAgICAgaWYgKHBsb3QudG9vbHRpcCkge1xuICAgICAgICAgICAgZG90c01lcmdlLm9uKFwibW91c2VvdmVyXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gXCIoXCIgKyBwbG90LngudmFsdWUoZCkgKyBcIiwgXCIgKyBwbG90LnkudmFsdWUoZCkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBzZWxmLmNvbmZpZy5ncm91cHMgPyAgc2VsZi5jb25maWcuZ3JvdXBzLnZhbHVlLmNhbGwoc2VsZi5jb25maWcsZCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChncm91cCB8fCBncm91cCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cCA9IHBsb3QuZ3JvdXBUb0xhYmVsW2dyb3VwXTtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBcIjxici8+XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHNlbGYuY29uZmlnLmdyb3Vwcy5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGxhYmVsICsgXCI6IFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gZ3JvdXBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChodG1sKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvdHNNZXJnZS5vbihcIm1vdXNlb3Zlci5vbkRvdEhvdmVyXCIsIHRoaXMuY29uZmlnLm9uRG90SG92ZXIpO1xuICAgICAgICBkb3RzTWVyZ2Uub24oXCJtb3VzZW91dC5vbkRvdEhvdmVyT3V0XCIsIHRoaXMuY29uZmlnLm9uRG90SG92ZXJPdXQpO1xuXG4gICAgICAgIGlmIChwbG90LnNlcmllc0NvbG9yKSB7XG4gICAgICAgICAgICBsYXllck1lcmdlLnN0eWxlKFwiZmlsbFwiLCBwbG90LnNlcmllc0NvbG9yKVxuICAgICAgICB9ZWxzZSBpZihwbG90LmNvbG9yKXtcbiAgICAgICAgICAgIGRvdHNNZXJnZS5zdHlsZShcImZpbGxcIiwgcGxvdC5jb2xvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGRvdHMuZXhpdCgpLnJlbW92ZSgpO1xuXG5cblxuICAgICAgICBsYXllci5leGl0KCkucmVtb3ZlKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtDaGFydCwgQ2hhcnRDb25maWd9IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQge1NjYXR0ZXJQbG90LCBTY2F0dGVyUGxvdENvbmZpZ30gZnJvbSBcIi4vc2NhdHRlcnBsb3RcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge1N0YXRpc3RpY3NVdGlsc30gZnJvbSAnLi9zdGF0aXN0aWNzLXV0aWxzJ1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnLi9kMydcblxuZXhwb3J0IGNsYXNzIFJlZ3Jlc3Npb25Db25maWcgZXh0ZW5kcyBTY2F0dGVyUGxvdENvbmZpZ3tcblxuICAgIG1haW5SZWdyZXNzaW9uID0gdHJ1ZTtcbiAgICBncm91cFJlZ3Jlc3Npb24gPSB0cnVlO1xuICAgIGNvbmZpZGVuY2U9e1xuICAgICAgICBsZXZlbDogMC45NSxcbiAgICAgICAgY3JpdGljYWxWYWx1ZTogKGRlZ3JlZXNPZkZyZWVkb20sIGNyaXRpY2FsUHJvYmFiaWxpdHkpID0+IFN0YXRpc3RpY3NVdGlscy50VmFsdWUoZGVncmVlc09mRnJlZWRvbSwgY3JpdGljYWxQcm9iYWJpbGl0eSksXG4gICAgICAgIG1hcmdpbk9mRXJyb3I6IHVuZGVmaW5lZCwgLy9jdXN0b20gIG1hcmdpbiBPZiBFcnJvciBmdW5jdGlvbiAoeCwgcG9pbnRzKVxuICAgICAgICBhcmVhQ3VydmU6IGQzLmN1cnZlTmF0dXJhbFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlZ3Jlc3Npb24gZXh0ZW5kcyBTY2F0dGVyUGxvdHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgbmV3IFJlZ3Jlc3Npb25Db25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZyl7XG4gICAgICAgIHJldHVybiBzdXBlci5zZXRDb25maWcobmV3IFJlZ3Jlc3Npb25Db25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKXtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdGhpcy5pbml0UmVncmVzc2lvbkxpbmVzKCk7XG4gICAgfVxuXG4gICAgaW5pdFJlZ3Jlc3Npb25MaW5lcygpe1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdyb3Vwc0F2YWlsYWJsZSA9IHNlbGYucGxvdC5ncm91cGluZ0VuYWJsZWQ7XG5cbiAgICAgICAgc2VsZi5wbG90LnJlZ3Jlc3Npb25zPSBbXTtcblxuXG4gICAgICAgIGlmKGdyb3Vwc0F2YWlsYWJsZSAmJiBzZWxmLmNvbmZpZy5tYWluUmVncmVzc2lvbil7XG4gICAgICAgICAgICB2YXIgcmVncmVzc2lvbiA9IHRoaXMuaW5pdFJlZ3Jlc3Npb24odGhpcy5wbG90LmRhdGEsIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYucGxvdC5yZWdyZXNzaW9ucy5wdXNoKHJlZ3Jlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2VsZi5jb25maWcuZ3JvdXBSZWdyZXNzaW9uKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEdyb3VwUmVncmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpbml0R3JvdXBSZWdyZXNzaW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgc2VsZi5wbG90Lmdyb3VwZWREYXRhLmZvckVhY2goZ3JvdXA9PntcbiAgICAgICAgICAgIGlmKGdyb3VwLnZhbHVlcy5sZW5ndGg8Mil7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVncmVzc2lvbiA9IHRoaXMuaW5pdFJlZ3Jlc3Npb24oZ3JvdXAudmFsdWVzLCBncm91cC5rZXkpO1xuICAgICAgICAgICAgc2VsZi5wbG90LnJlZ3Jlc3Npb25zLnB1c2gocmVncmVzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaXRSZWdyZXNzaW9uKHZhbHVlcywgZ3JvdXBWYWwpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHZhbHVlcy5tYXAoZD0+e1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJzZUZsb2F0KHNlbGYucGxvdC54LnZhbHVlKGQpKSwgcGFyc2VGbG9hdChzZWxmLnBsb3QueS52YWx1ZShkKSldO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBwb2ludHMuc29ydCgoYSxiKSA9PiBhWzBdLWJbMF0pO1xuXG4gICAgICAgIHZhciBsaW5lYXJSZWdyZXNzaW9uID0gIFN0YXRpc3RpY3NVdGlscy5saW5lYXJSZWdyZXNzaW9uKHBvaW50cyk7XG4gICAgICAgIHZhciBsaW5lYXJSZWdyZXNzaW9uTGluZSA9IFN0YXRpc3RpY3NVdGlscy5saW5lYXJSZWdyZXNzaW9uTGluZShsaW5lYXJSZWdyZXNzaW9uKTtcblxuXG4gICAgICAgIHZhciBleHRlbnRYID0gZDMuZXh0ZW50KHBvaW50cywgZD0+ZFswXSk7XG5cblxuICAgICAgICB2YXIgbGluZVBvaW50cyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiBleHRlbnRYWzBdLFxuICAgICAgICAgICAgICAgIHk6IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGV4dGVudFhbMF0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6IGV4dGVudFhbMV0sXG4gICAgICAgICAgICAgICAgeTogbGluZWFyUmVncmVzc2lvbkxpbmUoZXh0ZW50WFsxXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgbGluZSA9IGQzLmxpbmUoKVxuICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpXG4gICAgICAgICAgICAueChkID0+IHNlbGYucGxvdC54LnNjYWxlKGQueCkpXG4gICAgICAgICAgICAueShkID0+IHNlbGYucGxvdC55LnNjYWxlKGQueSkpO1xuXG4gICAgICAgIHZhciBjb2xvciA9IHNlbGYucGxvdC5jb2xvcjtcblxuICAgICAgICB2YXIgZGVmYXVsdENvbG9yID0gXCJibGFja1wiO1xuICAgICAgICBpZihVdGlscy5pc0Z1bmN0aW9uKGNvbG9yKSl7XG4gICAgICAgICAgICBpZih2YWx1ZXMubGVuZ3RoICYmIGdyb3VwVmFsIT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIGlmKHNlbGYuY29uZmlnLnNlcmllcyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID1zZWxmLnBsb3QuY29sb3JDYXRlZ29yeShncm91cFZhbCk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3IodmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZSBpZighY29sb3IgJiYgZ3JvdXBWYWw9PT1mYWxzZSl7XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGNvbmZpZGVuY2UgPSB0aGlzLmNvbXB1dGVDb25maWRlbmNlKHBvaW50cywgZXh0ZW50WCwgIGxpbmVhclJlZ3Jlc3Npb24sbGluZWFyUmVncmVzc2lvbkxpbmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXA6IGdyb3VwVmFsIHx8IGZhbHNlLFxuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGxpbmVQb2ludHM6IGxpbmVQb2ludHMsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBjb25maWRlbmNlOiBjb25maWRlbmNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcHV0ZUNvbmZpZGVuY2UocG9pbnRzLCBleHRlbnRYLCBsaW5lYXJSZWdyZXNzaW9uLGxpbmVhclJlZ3Jlc3Npb25MaW5lKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2xvcGUgPSBsaW5lYXJSZWdyZXNzaW9uLm07XG4gICAgICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlZ3JlZXNPZkZyZWVkb20gPSBNYXRoLm1heCgwLCBuLTIpO1xuXG4gICAgICAgIHZhciBhbHBoYSA9IDEgLSBzZWxmLmNvbmZpZy5jb25maWRlbmNlLmxldmVsO1xuICAgICAgICB2YXIgY3JpdGljYWxQcm9iYWJpbGl0eSAgPSAxIC0gYWxwaGEvMjtcbiAgICAgICAgdmFyIGNyaXRpY2FsVmFsdWUgPSBzZWxmLmNvbmZpZy5jb25maWRlbmNlLmNyaXRpY2FsVmFsdWUoZGVncmVlc09mRnJlZWRvbSxjcml0aWNhbFByb2JhYmlsaXR5KTtcblxuICAgICAgICB2YXIgeFZhbHVlcyA9IHBvaW50cy5tYXAoZD0+ZFswXSk7XG4gICAgICAgIHZhciBtZWFuWCA9IFN0YXRpc3RpY3NVdGlscy5tZWFuKHhWYWx1ZXMpO1xuICAgICAgICB2YXIgeE15U3VtPTA7XG4gICAgICAgIHZhciB4U3VtPTA7XG4gICAgICAgIHZhciB4UG93U3VtPTA7XG4gICAgICAgIHZhciB5U3VtPTA7XG4gICAgICAgIHZhciB5UG93U3VtPTA7XG4gICAgICAgIHBvaW50cy5mb3JFYWNoKHA9PntcbiAgICAgICAgICAgIHZhciB4ID0gcFswXTtcbiAgICAgICAgICAgIHZhciB5ID0gcFsxXTtcblxuICAgICAgICAgICAgeE15U3VtICs9IHgqeTtcbiAgICAgICAgICAgIHhTdW0rPXg7XG4gICAgICAgICAgICB5U3VtKz15O1xuICAgICAgICAgICAgeFBvd1N1bSs9IHgqeDtcbiAgICAgICAgICAgIHlQb3dTdW0rPSB5Knk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYSA9IGxpbmVhclJlZ3Jlc3Npb24ubTtcbiAgICAgICAgdmFyIGIgPSBsaW5lYXJSZWdyZXNzaW9uLmI7XG5cbiAgICAgICAgdmFyIFNhMiA9IG4vKG4rMikgKiAoKHlQb3dTdW0tYSp4TXlTdW0tYip5U3VtKS8obip4UG93U3VtLSh4U3VtKnhTdW0pKSk7IC8vV2FyaWFuY2phIHdzcMOzxYJjenlubmlrYSBraWVydW5rb3dlZ28gcmVncmVzamkgbGluaW93ZWogYVxuICAgICAgICB2YXIgU3kyID0gKHlQb3dTdW0gLSBhKnhNeVN1bS1iKnlTdW0pLyhuKihuLTIpKTsgLy9TYTIgLy9NZWFuIHkgdmFsdWUgdmFyaWFuY2VcblxuICAgICAgICB2YXIgZXJyb3JGbiA9IHg9PiBNYXRoLnNxcnQoU3kyICsgTWF0aC5wb3coeC1tZWFuWCwyKSpTYTIpOyAvL3BpZXJ3aWFzdGVrIGt3YWRyYXRvd3kgeiB3YXJpYW5jamkgZG93b2xuZWdvIHB1bmt0dSBwcm9zdGVqXG4gICAgICAgIHZhciBtYXJnaW5PZkVycm9yID0gIHg9PiBjcml0aWNhbFZhbHVlKiBlcnJvckZuKHgpO1xuXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ24nLCBuLCAnZGVncmVlc09mRnJlZWRvbScsIGRlZ3JlZXNPZkZyZWVkb20sICdjcml0aWNhbFByb2JhYmlsaXR5Jyxjcml0aWNhbFByb2JhYmlsaXR5KTtcbiAgICAgICAgLy8gdmFyIGNvbmZpZGVuY2VEb3duID0geCA9PiBsaW5lYXJSZWdyZXNzaW9uTGluZSh4KSAtICBtYXJnaW5PZkVycm9yKHgpO1xuICAgICAgICAvLyB2YXIgY29uZmlkZW5jZVVwID0geCA9PiBsaW5lYXJSZWdyZXNzaW9uTGluZSh4KSArICBtYXJnaW5PZkVycm9yKHgpO1xuXG5cbiAgICAgICAgdmFyIGNvbXB1dGVDb25maWRlbmNlQXJlYVBvaW50ID0geD0+e1xuICAgICAgICAgICAgdmFyIGxpbmVhclJlZ3Jlc3Npb24gPSBsaW5lYXJSZWdyZXNzaW9uTGluZSh4KTtcbiAgICAgICAgICAgIHZhciBtb2UgPSBtYXJnaW5PZkVycm9yKHgpO1xuICAgICAgICAgICAgdmFyIGNvbmZEb3duID0gbGluZWFyUmVncmVzc2lvbiAtIG1vZTtcbiAgICAgICAgICAgIHZhciBjb25mVXAgPSBsaW5lYXJSZWdyZXNzaW9uICsgbW9lO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHkwOiBjb25mRG93bixcbiAgICAgICAgICAgICAgICB5MTogY29uZlVwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2VudGVyWCA9IChleHRlbnRYWzFdK2V4dGVudFhbMF0pLzI7XG5cbiAgICAgICAgLy8gdmFyIGNvbmZpZGVuY2VBcmVhUG9pbnRzID0gW2V4dGVudFhbMF0sIGNlbnRlclgsICBleHRlbnRYWzFdXS5tYXAoY29tcHV0ZUNvbmZpZGVuY2VBcmVhUG9pbnQpO1xuICAgICAgICB2YXIgY29uZmlkZW5jZUFyZWFQb2ludHMgPSBbZXh0ZW50WFswXSwgY2VudGVyWCwgIGV4dGVudFhbMV1dLm1hcChjb21wdXRlQ29uZmlkZW5jZUFyZWFQb2ludCk7XG5cbiAgICAgICAgdmFyIGZpdEluUGxvdCA9IHkgPT4geTtcblxuICAgICAgICB2YXIgY29uZmlkZW5jZUFyZWEgPSAgZDMuYXJlYSgpXG4gICAgICAgIC5jdXJ2ZShzZWxmLmNvbmZpZy5jb25maWRlbmNlLmFyZWFDdXJ2ZSlcbiAgICAgICAgICAgIC54KGQgPT4gc2VsZi5wbG90Lnguc2NhbGUoZC54KSlcbiAgICAgICAgICAgIC55MChkID0+IGZpdEluUGxvdChzZWxmLnBsb3QueS5zY2FsZShkLnkwKSkpXG4gICAgICAgICAgICAueTEoZCA9PiBmaXRJblBsb3Qoc2VsZi5wbG90Lnkuc2NhbGUoZC55MSkpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJlYTpjb25maWRlbmNlQXJlYSxcbiAgICAgICAgICAgIHBvaW50czpjb25maWRlbmNlQXJlYVBvaW50c1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHVwZGF0ZShuZXdEYXRhKXtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlZ3Jlc3Npb25MaW5lcygpO1xuXG4gICAgfTtcblxuICAgIHVwZGF0ZVJlZ3Jlc3Npb25MaW5lcygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmVncmVzc2lvbkNvbnRhaW5lckNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcInJlZ3Jlc3Npb24tY29udGFpbmVyXCIpO1xuICAgICAgICB2YXIgcmVncmVzc2lvbkNvbnRhaW5lclNlbGVjdG9yID0gXCJnLlwiK3JlZ3Jlc3Npb25Db250YWluZXJDbGFzcztcblxuICAgICAgICB2YXIgY2xpcFBhdGhJZCA9IHNlbGYucHJlZml4Q2xhc3MoXCJjbGlwXCIpO1xuXG4gICAgICAgIHZhciByZWdyZXNzaW9uQ29udGFpbmVyID0gc2VsZi5zdmdHLnNlbGVjdE9ySW5zZXJ0KHJlZ3Jlc3Npb25Db250YWluZXJTZWxlY3RvciwgXCIuXCIrc2VsZi5kb3RzQ29udGFpbmVyQ2xhc3MpO1xuICAgICAgICB2YXIgcmVncmVzc2lvbkNvbnRhaW5lckNsaXAgPSByZWdyZXNzaW9uQ29udGFpbmVyLnNlbGVjdE9yQXBwZW5kKFwiY2xpcFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgY2xpcFBhdGhJZCk7XG5cblxuICAgICAgICByZWdyZXNzaW9uQ29udGFpbmVyQ2xpcC5zZWxlY3RPckFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzZWxmLnBsb3Qud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc2VsZi5wbG90LmhlaWdodClcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMCk7XG5cbiAgICAgICAgcmVncmVzc2lvbkNvbnRhaW5lci5hdHRyKFwiY2xpcC1wYXRoXCIsIChkLGkpID0+IFwidXJsKCNcIitjbGlwUGF0aElkK1wiKVwiKTtcblxuICAgICAgICB2YXIgcmVncmVzc2lvbkNsYXNzID0gdGhpcy5wcmVmaXhDbGFzcyhcInJlZ3Jlc3Npb25cIik7XG4gICAgICAgIHZhciBjb25maWRlbmNlQXJlYUNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcImNvbmZpZGVuY2VcIik7XG4gICAgICAgIHZhciByZWdyZXNzaW9uU2VsZWN0b3IgPSBcImcuXCIrcmVncmVzc2lvbkNsYXNzO1xuICAgICAgICB2YXIgcmVncmVzc2lvbiA9IHJlZ3Jlc3Npb25Db250YWluZXIuc2VsZWN0QWxsKHJlZ3Jlc3Npb25TZWxlY3RvcilcbiAgICAgICAgICAgIC5kYXRhKHNlbGYucGxvdC5yZWdyZXNzaW9ucywgKGQsaSk9PiBkLmdyb3VwKTtcblxuXG4gICAgICAgIHZhciByZWdyZXNzaW9uRW50ZXIgPSByZWdyZXNzaW9uLmVudGVyKCkuYXBwZW5kU2VsZWN0b3IocmVncmVzc2lvblNlbGVjdG9yKTtcbiAgICAgICAgdmFyIHJlZ3Jlc3Npb25NZXJnZSA9IHJlZ3Jlc3Npb25FbnRlci5tZXJnZShyZWdyZXNzaW9uKTtcbiAgICAgICAgdmFyIGxpbmVDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoXCJsaW5lXCIpO1xuICAgICAgICByZWdyZXNzaW9uRW50ZXJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGxpbmVDbGFzcylcbiAgICAgICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwib3B0aW1pemVRdWFsaXR5XCIpO1xuXG4gICAgICAgIHZhciBsaW5lID0gcmVncmVzc2lvbk1lcmdlLnNlbGVjdChcInBhdGguXCIrbGluZUNsYXNzKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIHIgPT4gci5jb2xvcik7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGluZVQgPSBsaW5lO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBsaW5lVCA9IGxpbmUudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZVQuYXR0cihcImRcIiwgciA9PiByLmxpbmUoci5saW5lUG9pbnRzKSlcblxuXG4gICAgICAgIHJlZ3Jlc3Npb25FbnRlclxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgY29uZmlkZW5jZUFyZWFDbGFzcylcbiAgICAgICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwib3B0aW1pemVRdWFsaXR5XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMC40XCIpO1xuXG5cblxuICAgICAgICB2YXIgYXJlYSA9IHJlZ3Jlc3Npb25NZXJnZS5zZWxlY3QoXCJwYXRoLlwiK2NvbmZpZGVuY2VBcmVhQ2xhc3MpO1xuXG4gICAgICAgIHZhciBhcmVhVCA9IGFyZWE7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGFyZWFUID0gYXJlYS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXJlYVQuYXR0cihcImRcIiwgciA9PiByLmNvbmZpZGVuY2UuYXJlYShyLmNvbmZpZGVuY2UucG9pbnRzKSk7XG4gICAgICAgIGFyZWFULnN0eWxlKFwiZmlsbFwiLCByID0+IHIuY29sb3IpXG4gICAgICAgIHJlZ3Jlc3Npb24uZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgfVxuXG5cblxufVxuXG4iLCJpbXBvcnQge0NoYXJ0V2l0aENvbG9yR3JvdXBzfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtTY2F0dGVyUGxvdENvbmZpZ30gZnJvbSBcIi4vc2NhdHRlcnBsb3RcIjtcbmltcG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSBcIi4vbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICcuL2QzJ1xuXG5leHBvcnQgY2xhc3MgU2NhdHRlclBsb3RNYXRyaXhDb25maWcgZXh0ZW5kcyBTY2F0dGVyUGxvdENvbmZpZ3tcblxuICAgIHN2Z0NsYXNzPSB0aGlzLmNzc0NsYXNzUHJlZml4KydzY2F0dGVycGxvdC1tYXRyaXgnO1xuICAgIHNpemU9IHVuZGVmaW5lZDsgLy9zY2F0dGVyIHBsb3QgY2VsbCBzaXplXG4gICAgbWluQ2VsbFNpemUgPSA1MDtcbiAgICBtYXhDZWxsU2l6ZSA9IDEwMDA7XG4gICAgcGFkZGluZz0gMjA7IC8vc2NhdHRlciBwbG90IGNlbGwgcGFkZGluZ1xuICAgIGJydXNoPSB0cnVlO1xuICAgIGd1aWRlcz0gdHJ1ZTsgLy9zaG93IGF4aXMgZ3VpZGVzXG4gICAgc2hvd1Rvb2x0aXA9IHRydWU7IC8vc2hvdyB0b29sdGlwIG9uIGRvdCBob3ZlclxuICAgIHRpY2tzPSB1bmRlZmluZWQ7IC8vdGlja3MgbnVtYmVyLCAoZGVmYXVsdDogY29tcHV0ZWQgdXNpbmcgY2VsbCBzaXplKVxuICAgIHg9ey8vIFggYXhpcyBjb25maWdcbiAgICAgICAgb3JpZW50OiBcImJvdHRvbVwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgeT17Ly8gWSBheGlzIGNvbmZpZ1xuICAgICAgICBvcmllbnQ6IFwibGVmdFwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIlxuICAgIH07XG4gICAgZ3JvdXBzPXtcbiAgICAgICAga2V5OiB1bmRlZmluZWQsIC8vb2JqZWN0IHByb3BlcnR5IG5hbWUgb3IgYXJyYXkgaW5kZXggd2l0aCBncm91cGluZyB2YXJpYWJsZVxuICAgICAgICBpbmNsdWRlSW5QbG90OiBmYWxzZSwgLy9pbmNsdWRlIGdyb3VwIGFzIHZhcmlhYmxlIGluIHBsb3QsIGJvb2xlYW4gKGRlZmF1bHQ6IGZhbHNlKVxuICAgIH07XG4gICAgdmFyaWFibGVzPSB7XG4gICAgICAgIGxhYmVsczogW10sIC8vb3B0aW9uYWwgYXJyYXkgb2YgdmFyaWFibGUgbGFiZWxzIChmb3IgdGhlIGRpYWdvbmFsIG9mIHRoZSBwbG90KS5cbiAgICAgICAga2V5czogW10sIC8vb3B0aW9uYWwgYXJyYXkgb2YgdmFyaWFibGUga2V5c1xuICAgICAgICB2YWx1ZTogKGQsIHZhcmlhYmxlS2V5KSA9PiBkW3ZhcmlhYmxlS2V5XSAvLyB2YXJpYWJsZSB2YWx1ZSBhY2Nlc3NvclxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihjdXN0b20pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGNsYXNzIFNjYXR0ZXJQbG90TWF0cml4IGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHMge1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihwbGFjZWhvbGRlclNlbGVjdG9yLCBkYXRhLCBuZXcgU2NhdHRlclBsb3RNYXRyaXhDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0Q29uZmlnKG5ldyBTY2F0dGVyUGxvdE1hdHJpeENvbmZpZyhjb25maWcpKTtcblxuICAgIH1cblxuICAgIGluaXRQbG90KCkge1xuICAgICAgICBzdXBlci5pbml0UGxvdCgpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMucGxvdC5tYXJnaW47XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25maWc7XG4gICAgICAgIHRoaXMucGxvdC54PXt9O1xuICAgICAgICB0aGlzLnBsb3QueT17fTtcbiAgICAgICAgdGhpcy5wbG90LmRvdD17XG4gICAgICAgICAgICBjb2xvcjogbnVsbC8vY29sb3Igc2NhbGUgbWFwcGluZyBmdW5jdGlvblxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXR1cFZhcmlhYmxlcygpO1xuXG4gICAgICAgIHRoaXMucGxvdC5zaXplID0gY29uZi5zaXplO1xuXG5cbiAgICAgICAgdmFyIHdpZHRoID0gY29uZi53aWR0aDtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gVXRpbHMuYXZhaWxhYmxlV2lkdGgodGhpcy5jb25maWcud2lkdGgsIHRoaXMuZ2V0QmFzZUNvbnRhaW5lcigpLCBtYXJnaW4pO1xuICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gVXRpbHMuYXZhaWxhYmxlSGVpZ2h0KHRoaXMuY29uZmlnLmhlaWdodCwgdGhpcy5nZXRCYXNlQ29udGFpbmVyKCksIG1hcmdpbik7XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnBsb3Quc2l6ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5wbG90LnNpemUgPSAgTWF0aC5taW4oY29uZi5tYXhDZWxsU2l6ZSwgTWF0aC5tYXgoY29uZi5taW5DZWxsU2l6ZSwgYXZhaWxhYmxlV2lkdGgvdGhpcy5wbG90LnZhcmlhYmxlcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRoID0gbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQgKyB0aGlzLnBsb3QudmFyaWFibGVzLmxlbmd0aCp0aGlzLnBsb3Quc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZighdGhpcy5wbG90LnNpemUpe1xuICAgICAgICAgICAgdGhpcy5wbG90LnNpemUgPSAod2lkdGggLSAobWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpKSAvIHRoaXMucGxvdC52YXJpYWJsZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoO1xuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbG90LndpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgdGhpcy5wbG90LmhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5cbiAgICAgICAgdGhpcy5wbG90LnRpY2tzID0gY29uZi50aWNrcztcblxuICAgICAgICBpZih0aGlzLnBsb3QudGlja3M9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy5wbG90LnRpY2tzID0gdGhpcy5wbG90LnNpemUgLyA0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dXBYKCk7XG4gICAgICAgIHRoaXMuc2V0dXBZKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBWYXJpYWJsZXMoKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZXNDb25mID0gdGhpcy5jb25maWcudmFyaWFibGVzO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wbG90Lmdyb3VwZWREYXRhO1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICAgICAgcGxvdC5kb21haW5CeVZhcmlhYmxlID0ge307XG4gICAgICAgIHBsb3QudmFyaWFibGVzID0gdmFyaWFibGVzQ29uZi5rZXlzO1xuICAgICAgICBpZighcGxvdC52YXJpYWJsZXMgfHwgIXBsb3QudmFyaWFibGVzLmxlbmd0aCl7XG5cbiAgICAgICAgICAgIHBsb3QudmFyaWFibGVzID0gZGF0YS5sZW5ndGggPyBVdGlscy5pbmZlclZhcmlhYmxlcyhkYXRhWzBdLnZhbHVlcywgdGhpcy5jb25maWcuZ3JvdXBzLmtleSwgdGhpcy5jb25maWcuaW5jbHVkZUluUGxvdCkgOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QubGFiZWxzID0gW107XG4gICAgICAgIHBsb3QubGFiZWxCeVZhcmlhYmxlID0ge307XG4gICAgICAgIHBsb3QudmFyaWFibGVzLmZvckVhY2goKHZhcmlhYmxlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIG1pbiA9IGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIGQ9PnZhcmlhYmxlc0NvbmYudmFsdWUoZCwgdmFyaWFibGVLZXkpKSk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gZDMubWF4KGRhdGEsIHM9PmQzLm1heChzLnZhbHVlcywgZD0+dmFyaWFibGVzQ29uZi52YWx1ZShkLCB2YXJpYWJsZUtleSkpKTtcbiAgICAgICAgICAgIHBsb3QuZG9tYWluQnlWYXJpYWJsZVt2YXJpYWJsZUtleV0gPSBbbWluLG1heF07XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB2YXJpYWJsZUtleTtcbiAgICAgICAgICAgIGlmKHZhcmlhYmxlc0NvbmYubGFiZWxzICYmIHZhcmlhYmxlc0NvbmYubGFiZWxzLmxlbmd0aD5pbmRleCl7XG5cbiAgICAgICAgICAgICAgICBsYWJlbCA9IHZhcmlhYmxlc0NvbmYubGFiZWxzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsb3QubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgcGxvdC5sYWJlbEJ5VmFyaWFibGVbdmFyaWFibGVLZXldID0gbGFiZWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3Quc3VicGxvdHMgPSBbXTtcbiAgICB9O1xuXG4gICAgc2V0dXBYKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBcbiAgICAgICAgeC52YWx1ZSA9IGNvbmYudmFyaWFibGVzLnZhbHVlO1xuICAgICAgICB4LnNjYWxlID0gVXRpbHMuY3JlYXRlU2NhbGUoY29uZi54LnNjYWxlKS5yYW5nZShbY29uZi5wYWRkaW5nIC8gMiwgcGxvdC5zaXplIC0gY29uZi5wYWRkaW5nIC8gMl0pO1xuICAgICAgICB4Lm1hcCA9IChkLCB2YXJpYWJsZSkgPT4geC5zY2FsZSh4LnZhbHVlKGQsIHZhcmlhYmxlKSk7XG5cbiAgICAgICAgeC5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLngub3JpZW50LCB4LnNjYWxlKS50aWNrcyhwbG90LnRpY2tzKTtcbiAgICAgICAgeC5heGlzLnRpY2tTaXplKHBsb3Quc2l6ZSAqIHBsb3QudmFyaWFibGVzLmxlbmd0aCk7XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZKCkge1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICB5LnZhbHVlID0gY29uZi52YXJpYWJsZXMudmFsdWU7XG4gICAgICAgIHkuc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnkuc2NhbGUpLnJhbmdlKFsgcGxvdC5zaXplIC0gY29uZi5wYWRkaW5nIC8gMiwgY29uZi5wYWRkaW5nIC8gMl0pO1xuXG4gICAgICAgIHkubWFwID0gKGQsIHZhcmlhYmxlKSA9PiB5LnNjYWxlKHkudmFsdWUoZCwgdmFyaWFibGUpKTtcbiAgICAgICAgeS5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLnkub3JpZW50LCB5LnNjYWxlKS50aWNrcyhwbG90LnRpY2tzKTtcbiAgICAgICAgeS5heGlzLnRpY2tTaXplKC1wbG90LnNpemUgKiBwbG90LnZhcmlhYmxlcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB1cGRhdGUoIG5ld0RhdGEpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKG5ld0RhdGEpO1xuXG4gICAgICAgIHZhciBzZWxmID10aGlzO1xuICAgICAgICB2YXIgbiA9IHNlbGYucGxvdC52YXJpYWJsZXMubGVuZ3RoO1xuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHZhciBheGlzQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKFwiYXhpc1wiKTtcbiAgICAgICAgdmFyIGF4aXNYQ2xhc3MgPSBheGlzQ2xhc3MrXCIteFwiO1xuICAgICAgICB2YXIgYXhpc1lDbGFzcyA9IGF4aXNDbGFzcytcIi15XCI7XG5cbiAgICAgICAgdmFyIHhBeGlzU2VsZWN0b3IgPSBcImcuXCIrYXhpc1hDbGFzcytcIi5cIitheGlzQ2xhc3M7XG4gICAgICAgIHZhciB5QXhpc1NlbGVjdG9yID0gXCJnLlwiK2F4aXNZQ2xhc3MrXCIuXCIrYXhpc0NsYXNzO1xuXG4gICAgICAgIHZhciBub0d1aWRlc0NsYXNzID0gc2VsZi5wcmVmaXhDbGFzcyhcIm5vLWd1aWRlc1wiKTtcbiAgICAgICAgdmFyIHhBeGlzID0gc2VsZi5zdmdHLnNlbGVjdEFsbCh4QXhpc1NlbGVjdG9yKVxuICAgICAgICAgICAgLmRhdGEoc2VsZi5wbG90LnZhcmlhYmxlcyk7XG5cbiAgICAgICAgdmFyIHhBeGlzTWVyZ2UgPSB4QXhpcy5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKHhBeGlzU2VsZWN0b3IpXG4gICAgICAgICAgICAuY2xhc3NlZChub0d1aWRlc0NsYXNzLCAhY29uZi5ndWlkZXMpLm1lcmdlKHhBeGlzKTtcblxuXG4gICAgICAgIHhBeGlzTWVyZ2UuYXR0cihcInRyYW5zZm9ybVwiLCAoZCwgaSkgPT4gXCJ0cmFuc2xhdGUoXCIgKyAobiAtIGkgLSAxKSAqIHNlbGYucGxvdC5zaXplICsgXCIsMClcIilcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QueC5zY2FsZS5kb21haW4oc2VsZi5wbG90LmRvbWFpbkJ5VmFyaWFibGVbZF0pO1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcyA9IGF4aXMudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBheGlzLmNhbGwoc2VsZi5wbG90LnguYXhpcyk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHhBeGlzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgeUF4aXMgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKHlBeGlzU2VsZWN0b3IpXG4gICAgICAgICAgICAuZGF0YShzZWxmLnBsb3QudmFyaWFibGVzKTtcbiAgICAgICAgdmFyIHlBeGlzTWVyZ2UgPSB5QXhpcy5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKHlBeGlzU2VsZWN0b3IpLm1lcmdlKHlBeGlzKTtcbiAgICAgICAgeUF4aXNNZXJnZS5jbGFzc2VkKG5vR3VpZGVzQ2xhc3MsICFjb25mLmd1aWRlcylcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIChkLCBpKSA9PiBcInRyYW5zbGF0ZSgwLFwiICsgaSAqIHNlbGYucGxvdC5zaXplICsgXCIpXCIpO1xuICAgICAgICB5QXhpc01lcmdlLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgc2VsZi5wbG90Lnkuc2NhbGUuZG9tYWluKHNlbGYucGxvdC5kb21haW5CeVZhcmlhYmxlW2RdKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKHNlbGYudHJhbnNpdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIGF4aXMgPSBheGlzLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF4aXMuY2FsbChzZWxmLnBsb3QueS5heGlzKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICB5QXhpcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIGNlbGxDbGFzcyA9ICBzZWxmLnByZWZpeENsYXNzKFwiY2VsbFwiKTtcbiAgICAgICAgdmFyIGNlbGwgPSBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiK2NlbGxDbGFzcylcbiAgICAgICAgICAgIC5kYXRhKHNlbGYudXRpbHMuY3Jvc3Moc2VsZi5wbG90LnZhcmlhYmxlcywgc2VsZi5wbG90LnZhcmlhYmxlcykpO1xuXG4gICAgICAgIHZhciBjZWxsRW50ZXIgPSAgY2VsbC5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKFwiZy5cIitjZWxsQ2xhc3MpO1xuICAgICAgICBjZWxsRW50ZXIuZmlsdGVyKGQgPT4gZC5pID09PSBkLmopLmFwcGVuZChcInRleHRcIik7XG5cbiAgICAgICAgdmFyIGNlbGxNZXJnZSA9IGNlbGxFbnRlci5tZXJnZShjZWxsKTtcbiAgICAgICAgY2VsbE1lcmdlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIChuIC0gZC5pIC0gMSkgKiBzZWxmLnBsb3Quc2l6ZSArIFwiLFwiICsgZC5qICogc2VsZi5wbG90LnNpemUgKyBcIilcIik7XG5cbiAgICAgICAgaWYoY29uZi5icnVzaCl7XG4gICAgICAgICAgICB0aGlzLmRyYXdCcnVzaChjZWxsTWVyZ2UpO1xuICAgICAgICB9XG5cblxuICAgICAgICBjZWxsTWVyZ2UuZWFjaChwbG90U3VicGxvdCk7XG5cbiAgICAgICAgLy9MYWJlbHNcbiAgICAgICAgY2VsbE1lcmdlLnNlbGVjdChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBjb25mLnBhZGRpbmcpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgY29uZi5wYWRkaW5nKVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi43MWVtXCIpXG4gICAgICAgICAgICAudGV4dCggZCA9PiBzZWxmLnBsb3QubGFiZWxCeVZhcmlhYmxlW2QueF0pO1xuXG4gICAgICAgIGNlbGwuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBsb3RTdWJwbG90KHApIHtcbiAgICAgICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICAgICAgcGxvdC5zdWJwbG90cy5wdXNoKHApO1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgIHBsb3QueC5zY2FsZS5kb21haW4ocGxvdC5kb21haW5CeVZhcmlhYmxlW3AueF0pO1xuICAgICAgICAgICAgcGxvdC55LnNjYWxlLmRvbWFpbihwbG90LmRvbWFpbkJ5VmFyaWFibGVbcC55XSk7XG5cbiAgICAgICAgICAgIHZhciBmcmFtZUNsYXNzID0gIHNlbGYucHJlZml4Q2xhc3MoXCJmcmFtZVwiKTtcbiAgICAgICAgICAgIGNlbGwuc2VsZWN0T3JBcHBlbmQoXCJyZWN0LlwiK2ZyYW1lQ2xhc3MpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmcmFtZUNsYXNzKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBjb25mLnBhZGRpbmcgLyAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBjb25mLnBhZGRpbmcgLyAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcGxvdC5zaXplIC0gY29uZi5wYWRkaW5nKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBsb3Quc2l6ZSAtIGNvbmYucGFkZGluZyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHAudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VicGxvdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyQ2xhc3MgPSBzZWxmLnByZWZpeENsYXNzKCdsYXllcicpO1xuXG5cbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBjZWxsLnNlbGVjdEFsbChcImcuXCIrbGF5ZXJDbGFzcykuZGF0YShzZWxmLnBsb3QuZ3JvdXBlZERhdGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyTWVyZ2UgPSBsYXllci5lbnRlcigpLmFwcGVuZFNlbGVjdG9yKFwiZy5cIitsYXllckNsYXNzKS5tZXJnZShsYXllcik7XG5cbiAgICAgICAgICAgICAgICB2YXIgZG90cyA9IGxheWVyTWVyZ2Uuc2VsZWN0QWxsKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGQ9PmQudmFsdWVzKTtcblxuICAgICAgICAgICAgICAgIHZhciBkb3RzTWVyZ2UgPSBkb3RzLmVudGVyKCkuYXBwZW5kKFwiY2lyY2xlXCIpLm1lcmdlKGRvdHMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRvdHNUID0gZG90c01lcmdlO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG90c1QgPSBkb3RzTWVyZ2UudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvdHNULmF0dHIoXCJjeFwiLCAoZCkgPT4gcGxvdC54Lm1hcChkLCBzdWJwbG90LngpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIChkKSA9PiBwbG90LnkubWFwKGQsIHN1YnBsb3QueSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCBzZWxmLmNvbmZpZy5kb3RSYWRpdXMpO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAocGxvdC5zZXJpZXNDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllck1lcmdlLnN0eWxlKFwiZmlsbFwiLCBwbG90LnNlcmllc0NvbG9yKVxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHBsb3QuY29sb3Ipe1xuICAgICAgICAgICAgICAgICAgICBkb3RzTWVyZ2Uuc3R5bGUoXCJmaWxsXCIsIHBsb3QuY29sb3IpXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvdHNNZXJnZS5vbihcIm1vdXNlb3ZlclwiLCAoZCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IFwiKFwiICsgcGxvdC54LnZhbHVlKGQsIHN1YnBsb3QueCkgKyBcIiwgXCIgKyBwbG90LnkudmFsdWUoZCwgc3VicGxvdC55KSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gc2VsZi5jb25maWcuZ3JvdXBzID8gc2VsZi5jb25maWcuZ3JvdXBzLnZhbHVlLmNhbGwoc2VsZi5jb25maWcsIGQpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cCB8fCBncm91cCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcGxvdC5ncm91cFRvTGFiZWxbZ3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gXCI8YnIvPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHNlbGYuY29uZmlnLmdyb3Vwcy5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBsYWJlbCArIFwiOiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93VG9vbHRpcChodG1sKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkKT0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb3RzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBsYXllci5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcC51cGRhdGUoKTtcblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRyYXdCcnVzaChjZWxsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGhpZGRlbkNsYXNzID0gc2VsZi5wbG90LmhpZGRlbkNsYXNzID0gIHNlbGYucHJlZml4Q2xhc3MoXCJoaWRkZW5cIik7XG4gICAgICAgIHZhciBicnVzaCA9IGQzLmJydXNoKClcbiAgICAgICAgICAgIC8vIC54KHNlbGYucGxvdC54LnNjYWxlKVxuICAgICAgICAgICAgLy8gLnkoc2VsZi5wbG90Lnkuc2NhbGUpXG4gICAgICAgICAgICAub24oXCJzdGFydFwiLCBicnVzaHN0YXJ0KVxuICAgICAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2htb3ZlKVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGJydXNoZW5kKTtcblxuICAgICAgICBicnVzaC5leHRlbnQoW1swLCAwXSwgW3NlbGYucGxvdC5zaXplLCBzZWxmLnBsb3Quc2l6ZV1dKTtcbiAgICAgICAgY2VsbC5zZWxlY3RPckFwcGVuZChcImcuYnJ1c2gtY29udGFpbmVyXCIpLmNhbGwoYnJ1c2gpO1xuXG4gICAgICAgIHNlbGYuY2xlYXJCcnVzaCgpO1xuXG4gICAgICAgIC8vIENsZWFyIHRoZSBwcmV2aW91c2x5LWFjdGl2ZSBicnVzaCwgaWYgYW55LlxuICAgICAgICBmdW5jdGlvbiBicnVzaHN0YXJ0KHApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnBsb3QuYnJ1c2hDZWxsICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhckJydXNoKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbG90Lnguc2NhbGUuZG9tYWluKHNlbGYucGxvdC5kb21haW5CeVZhcmlhYmxlW3AueF0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxvdC55LnNjYWxlLmRvbWFpbihzZWxmLnBsb3QuZG9tYWluQnlWYXJpYWJsZVtwLnldKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuYnJ1c2hDZWxsID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLnBsb3QuYnJ1c2ggPSBicnVzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZ2hsaWdodCB0aGUgc2VsZWN0ZWQgY2lyY2xlcy5cbiAgICAgICAgZnVuY3Rpb24gYnJ1c2htb3ZlKHApIHtcbiAgICAgICAgICAgIHZhciBzID0gZDMuZXZlbnQuc2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYoIXMpcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGUgPSBzLm1hcChfPT4gW3NlbGYucGxvdC54LnNjYWxlLmludmVydChfWzBdKSwgc2VsZi5wbG90Lnkuc2NhbGUuaW52ZXJ0KF9bMV0pXSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlKTtcblxuICAgICAgICAgICAgc2VsZi5zdmdHLnNlbGVjdEFsbChcImNpcmNsZVwiKS5jbGFzc2VkKGhpZGRlbkNsYXNzLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChkW3AueF0pLFxuICAgICAgICAgICAgICAgICAgICB5ID0gcGFyc2VGbG9hdChkW3AueV0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVbMF1bMF0gPiB4IHx8IHggPiBlWzFdWzBdXG4gICAgICAgICAgICAgICAgICAgIHx8IGVbMV1bMV0gPiB5IHx8IHkgPiBlWzBdWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGJydXNoIGlzIGVtcHR5LCBzZWxlY3QgYWxsIGNpcmNsZXMuXG4gICAgICAgIGZ1bmN0aW9uIGJydXNoZW5kKCkge1xuICAgICAgICAgICAgaWYgKCFkMy5ldmVudC5zZWxlY3Rpb24pIHNlbGYuc3ZnRy5zZWxlY3RBbGwoXCIuXCIraGlkZGVuQ2xhc3MpLmNsYXNzZWQoaGlkZGVuQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjbGVhckJydXNoKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYoIXNlbGYucGxvdC5icnVzaENlbGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZWxmLnBsb3QuYnJ1c2gubW92ZShkMy5zZWxlY3Qoc2VsZi5wbG90LmJydXNoQ2VsbCksIG51bGwpO1xuICAgICAgICBzZWxmLnN2Z0cuc2VsZWN0QWxsKFwiLlwiK3NlbGYucGxvdC5oaWRkZW5DbGFzcykuY2xhc3NlZChzZWxmLnBsb3QuaGlkZGVuQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgc2VsZi5wbG90LmJydXNoQ2VsbD1udWxsO1xuXG4gICAgfVxufSIsImltcG9ydCB7Q2hhcnRXaXRoQ29sb3JHcm91cHMsIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlnfSBmcm9tIFwiLi9jaGFydC13aXRoLWNvbG9yLWdyb3Vwc1wiO1xuaW1wb3J0IHtVdGlsc30gZnJvbSAnLi91dGlscydcbmltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBTY2F0dGVyUGxvdENvbmZpZyBleHRlbmRzIENoYXJ0V2l0aENvbG9yR3JvdXBzQ29uZmlne1xuXG4gICAgc3ZnQ2xhc3M9IHRoaXMuY3NzQ2xhc3NQcmVmaXgrJ3NjYXR0ZXJwbG90JztcbiAgICBndWlkZXM9IGZhbHNlOyAvL3Nob3cgYXhpcyBndWlkZXNcbiAgICBzaG93VG9vbHRpcD0gdHJ1ZTsgLy9zaG93IHRvb2x0aXAgb24gZG90IGhvdmVyXG5cbiAgICB4PXsvLyBYIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbFxuICAgICAgICBrZXk6IDAsXG4gICAgICAgIHZhbHVlOiAoZCwga2V5KSA9PiBkW2tleV0sIC8vIHggdmFsdWUgYWNjZXNzb3JcbiAgICAgICAgb3JpZW50OiBcImJvdHRvbVwiLFxuICAgICAgICBzY2FsZTogXCJsaW5lYXJcIixcbiAgICAgICAgZG9tYWluTWFyZ2luOiAwLjA1XG4gICAgfTtcbiAgICB5PXsvLyBZIGF4aXMgY29uZmlnXG4gICAgICAgIHRpdGxlOiAnJywgLy8gYXhpcyBsYWJlbCxcbiAgICAgICAga2V5OiAxLFxuICAgICAgICB2YWx1ZTogKGQsIGtleSkgPT4gZFtrZXldLCAvLyB5IHZhbHVlIGFjY2Vzc29yXG4gICAgICAgIG9yaWVudDogXCJsZWZ0XCIsXG4gICAgICAgIHNjYWxlOiBcImxpbmVhclwiLFxuICAgICAgICBkb21haW5NYXJnaW46IDAuMDVcbiAgICB9O1xuICAgIGdyb3Vwcz17XG4gICAgICAgIGtleTogMlxuICAgIH07XG4gICAgZG90UmFkaXVzID0gMjtcbiAgICBkb3RJZCA9IChkLCBpKT0+IHVuZGVmaW5lZDtcbiAgICB0cmFuc2l0aW9uPSB0cnVlO1xuICAgIG9uRG90SG92ZXIgPSAoZCwgaSkgPT4ge307XG4gICAgb25Eb3RIb3Zlck91dCA9IChkLCBpKSA9PiB7fTtcblxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbSl7XG4gICAgICAgIHN1cGVyKCk7XG5cblxuXG4gICAgICAgIGlmKGN1c3RvbSl7XG4gICAgICAgICAgICBVdGlscy5kZWVwRXh0ZW5kKHRoaXMsIGN1c3RvbSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNjYXR0ZXJQbG90IGV4dGVuZHMgQ2hhcnRXaXRoQ29sb3JHcm91cHN7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZWxlY3RvciwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHBsYWNlaG9sZGVyU2VsZWN0b3IsIGRhdGEsIG5ldyBTY2F0dGVyUGxvdENvbmZpZyhjb25maWcpKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlnKXtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldENvbmZpZyhuZXcgU2NhdHRlclBsb3RDb25maWcoY29uZmlnKSk7XG4gICAgfVxuXG4gICAgaW5pdFBsb3QoKXtcbiAgICAgICAgc3VwZXIuaW5pdFBsb3QoKTtcbiAgICAgICAgdmFyIHNlbGY9dGhpcztcblxuICAgICAgICB2YXIgY29uZiA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIHRoaXMucGxvdC54PXt9O1xuICAgICAgICB0aGlzLnBsb3QueT17fTtcblxuICAgICAgICB0aGlzLmNvbXB1dGVQbG90U2l6ZSgpO1xuICAgICAgICB0aGlzLnNldHVwWCgpO1xuICAgICAgICB0aGlzLnNldHVwWSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWCgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeCA9IHBsb3QueDtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy54O1xuXG4gICAgICAgIC8qICpcbiAgICAgICAgICogdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAgICAgICAqIHNjYWxlIC0gbWFwcyB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzIGEgcGl4ZWwgcG9zaXRpb24uXG4gICAgICAgICAqIG1hcCBmdW5jdGlvbiAtIG1hcHMgZnJvbSBkYXRhIHZhbHVlIHRvIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgICogYXhpcyAtIHNldHMgdXAgYXhpc1xuICAgICAgICAgKiovXG4gICAgICAgIHgudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuICAgICAgICBcbiAgICAgICAgeC5zY2FsZSA9IFV0aWxzLmNyZWF0ZVNjYWxlKGNvbmYuc2NhbGUpLnJhbmdlKFswLCBwbG90LndpZHRoXSk7XG4gICAgICAgIHgubWFwID0gZCA9PiB4LnNjYWxlKHgudmFsdWUoZCkpO1xuICAgICAgICBcbiAgICAgICAgeC5heGlzID0gVXRpbHMuY3JlYXRlQXhpcyhjb25mLm9yaWVudCwgeC5zY2FsZSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG5cbiAgICAgICAgdmFyIGRvbWFpbiA9IFtwYXJzZUZsb2F0KGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueC52YWx1ZSkpKSwgcGFyc2VGbG9hdChkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBwbG90LngudmFsdWUpKSldO1xuICAgICAgICB2YXIgZXh0ZW50ID0gKGRvbWFpblsxXS1kb21haW5bMF0pIHx8IDE7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoZXh0ZW50KSogY29uZi5kb21haW5NYXJnaW47XG4gICAgICAgIGRvbWFpblswXS09bWFyZ2luO1xuICAgICAgICBkb21haW5bMV0rPW1hcmdpbjtcbiAgICAgICAgcGxvdC54LnNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgICAgICBpZih0aGlzLmNvbmZpZy5ndWlkZXMpIHtcbiAgICAgICAgICAgIHguYXhpcy50aWNrU2l6ZSgtcGxvdC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgc2V0dXBZICgpe1xuXG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90O1xuICAgICAgICB2YXIgeSA9IHBsb3QueTtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmZpZy55O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIHkudmFsdWUgPSBkID0+IGNvbmYudmFsdWUoZCwgY29uZi5rZXkpO1xuXG4gICAgICAgIHkuc2NhbGUgPSBVdGlscy5jcmVhdGVTY2FsZShjb25mLnNjYWxlKS5yYW5nZShbcGxvdC5oZWlnaHQsIDBdKTtcblxuICAgICAgICB5Lm1hcCA9IGQgPT4geS5zY2FsZSh5LnZhbHVlKGQpKTtcblxuICAgICAgICB5LmF4aXMgPSBVdGlscy5jcmVhdGVBeGlzKGNvbmYub3JpZW50LCB5LnNjYWxlKTtcblxuICAgICAgICBpZih0aGlzLmNvbmZpZy5ndWlkZXMpe1xuICAgICAgICAgICAgeS5heGlzLnRpY2tTaXplKC1wbG90LndpZHRoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBsb3QuZ3JvdXBlZERhdGE7XG5cbiAgICAgICAgdmFyIGRvbWFpbiA9IFtwYXJzZUZsb2F0KGQzLm1pbihkYXRhLCBzPT5kMy5taW4ocy52YWx1ZXMsIHBsb3QueS52YWx1ZSkpKSwgcGFyc2VGbG9hdChkMy5tYXgoZGF0YSwgcz0+ZDMubWF4KHMudmFsdWVzLCBwbG90LnkudmFsdWUpKSldO1xuICAgICAgICB2YXIgZXh0ZW50ID0gKGRvbWFpblsxXS1kb21haW5bMF0pIHx8IDE7XG4gICAgICAgIHZhciBtYXJnaW4gPSAoZXh0ZW50KSogY29uZi5kb21haW5NYXJnaW47XG5cbiAgICAgICAgZG9tYWluWzBdLT1tYXJnaW47XG4gICAgICAgIGRvbWFpblsxXSs9bWFyZ2luO1xuICAgICAgICBwbG90Lnkuc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIHBsb3QueS5zY2FsZS5kb21haW4oW2QzLm1pbihkYXRhLCBwbG90LnkudmFsdWUpLTEsIGQzLm1heChkYXRhLCBwbG90LnkudmFsdWUpKzFdKTtcbiAgICB9O1xuXG4gICAgZHJhd0F4aXNYKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBsb3QgPSBzZWxmLnBsb3Q7XG4gICAgICAgIHZhciBheGlzQ29uZiA9IHRoaXMuY29uZmlnLng7XG4gICAgICAgIHZhciBheGlzID0gc2VsZi5zdmdHLnNlbGVjdE9yQXBwZW5kKFwiZy5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzLXgnKStcIi5cIitzZWxmLnByZWZpeENsYXNzKCdheGlzJykrKHNlbGYuY29uZmlnLmd1aWRlcyA/ICcnIDogJy4nK3NlbGYucHJlZml4Q2xhc3MoJ25vLWd1aWRlcycpKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBwbG90LmhlaWdodCArIFwiKVwiKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnguYXhpcyk7XG4gICAgICAgIFxuICAgICAgICBheGlzLnNlbGVjdE9yQXBwZW5kKFwidGV4dC5cIitzZWxmLnByZWZpeENsYXNzKCdsYWJlbCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrIChwbG90LndpZHRoLzIpICtcIixcIisgKHBsb3QubWFyZ2luLmJvdHRvbSkgK1wiKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi0xZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChheGlzQ29uZi50aXRsZSk7XG4gICAgfTtcblxuICAgIGRyYXdBeGlzWSgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwbG90ID0gc2VsZi5wbG90O1xuICAgICAgICB2YXIgYXhpc0NvbmYgPSB0aGlzLmNvbmZpZy55O1xuICAgICAgICB2YXIgYXhpcyA9IHNlbGYuc3ZnRy5zZWxlY3RPckFwcGVuZChcImcuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcy15JykrXCIuXCIrc2VsZi5wcmVmaXhDbGFzcygnYXhpcycpKyhzZWxmLmNvbmZpZy5ndWlkZXMgPyAnJyA6ICcuJytzZWxmLnByZWZpeENsYXNzKCduby1ndWlkZXMnKSkpO1xuXG4gICAgICAgIHZhciBheGlzVCA9IGF4aXM7XG4gICAgICAgIGlmIChzZWxmLnRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGF4aXNUID0gYXhpcy50cmFuc2l0aW9uKCkuZWFzZShkMy5lYXNlU2luSW5PdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1QuY2FsbChwbG90LnkuYXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3RPckFwcGVuZChcInRleHQuXCIrc2VsZi5wcmVmaXhDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiKyAtcGxvdC5tYXJnaW4ubGVmdCArXCIsXCIrKHBsb3QuaGVpZ2h0LzIpK1wiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYXhpc0NvbmYudGl0bGUpO1xuICAgIH07XG5cbiAgICB1cGRhdGUobmV3RGF0YSl7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShuZXdEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1goKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1koKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZURvdHMoKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlRG90cygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGxvdCA9IHNlbGYucGxvdDtcbiAgICAgICAgdmFyIGRhdGEgPSBwbG90LmRhdGE7XG4gICAgICAgIHZhciBsYXllckNsYXNzID0gc2VsZi5wcmVmaXhDbGFzcygnbGF5ZXInKTtcbiAgICAgICAgdmFyIGRvdENsYXNzID0gdGhpcy5kb3RDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2RvdCcpO1xuICAgICAgICBzZWxmLmRvdHNDb250YWluZXJDbGFzcyA9IHNlbGYucHJlZml4Q2xhc3MoJ2RvdHMtY29udGFpbmVyJyk7XG5cbiAgICAgICAgdmFyIGRvdHNDb250YWluZXIgPSBzZWxmLnN2Z0cuc2VsZWN0T3JBcHBlbmQoXCJnLlwiICsgc2VsZi5kb3RzQ29udGFpbmVyQ2xhc3MpO1xuXG4gICAgICAgIHZhciBsYXllciA9IGRvdHNDb250YWluZXIuc2VsZWN0QWxsKFwiZy5cIitsYXllckNsYXNzKS5kYXRhKHBsb3QuZ3JvdXBlZERhdGEpO1xuXG4gICAgICAgIHZhciBsYXllckVudGVyID0gbGF5ZXIuZW50ZXIoKS5hcHBlbmRTZWxlY3RvcihcImcuXCIrbGF5ZXJDbGFzcyk7XG5cbiAgICAgICAgdmFyIGxheWVyTWVyZ2UgPSBsYXllckVudGVyLm1lcmdlKGxheWVyKTtcblxuICAgICAgICB2YXIgZG90cyA9IGxheWVyTWVyZ2Uuc2VsZWN0QWxsKCcuJyArIGRvdENsYXNzKVxuICAgICAgICAgICAgLmRhdGEoZD0+ZC52YWx1ZXMpXG5cbiAgICAgICAgdmFyIGRvdHNFbnRlciA9IGRvdHMuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZG90Q2xhc3MpO1xuXG4gICAgICAgIHZhciBkb3RzTWVyZ2UgPSBkb3RzRW50ZXIubWVyZ2UoZG90cyk7XG5cbiAgICAgICAgdmFyIGRvdHNUID0gZG90c01lcmdlO1xuICAgICAgICBpZiAoc2VsZi50cmFuc2l0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBkb3RzVCA9IGRvdHNNZXJnZS50cmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3RzVC5hdHRyKFwiclwiLCBzZWxmLmNvbmZpZy5kb3RSYWRpdXMpXG4gICAgICAgICAgICAuYXR0cihcImN4XCIsIHBsb3QueC5tYXApXG4gICAgICAgICAgICAuYXR0cihcImN5XCIsIHBsb3QueS5tYXApXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIHRoaXMuY29uZmlnLmRvdElkKTtcblxuICAgICAgICBpZiAocGxvdC50b29sdGlwKSB7XG4gICAgICAgICAgICBkb3RzTWVyZ2Uub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBcIihcIiArIHBsb3QueC52YWx1ZShkKSArIFwiLCBcIiArIHBsb3QueS52YWx1ZShkKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHNlbGYuY29uZmlnLmdyb3VwcyA/ICBzZWxmLmNvbmZpZy5ncm91cHMudmFsdWUuY2FsbChzZWxmLmNvbmZpZyxkKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwIHx8IGdyb3VwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcGxvdC5ncm91cFRvTGFiZWxbZ3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IFwiPGJyLz5cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gc2VsZi5jb25maWcuZ3JvdXBzLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gbGFiZWwgKyBcIjogXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBncm91cFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNob3dUb29sdGlwKGh0bWwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZG90c01lcmdlLm9uKFwibW91c2VvdmVyLm9uRG90SG92ZXJcIiwgdGhpcy5jb25maWcub25Eb3RIb3Zlcik7XG4gICAgICAgIGRvdHNNZXJnZS5vbihcIm1vdXNlb3V0Lm9uRG90SG92ZXJPdXRcIiwgdGhpcy5jb25maWcub25Eb3RIb3Zlck91dCk7XG5cbiAgICAgICAgaWYgKHBsb3Quc2VyaWVzQ29sb3IpIHtcbiAgICAgICAgICAgIGxheWVyTWVyZ2Uuc3R5bGUoXCJmaWxsXCIsIHBsb3Quc2VyaWVzQ29sb3IpXG4gICAgICAgIH1lbHNlIGlmKHBsb3QuY29sb3Ipe1xuICAgICAgICAgICAgZG90c01lcmdlLnN0eWxlKFwiZmlsbFwiLCBwbG90LmNvbG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgZG90cy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGxheWVyLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG59XG4iLCIvKlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmVucmFzbXVzZW4vMTI2MTk3N1xuICogTkFNRVxuICogXG4gKiBzdGF0aXN0aWNzLWRpc3RyaWJ1dGlvbnMuanMgLSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGNhbGN1bGF0aW5nXG4gKiAgIGNyaXRpY2FsIHZhbHVlcyBhbmQgdXBwZXIgcHJvYmFiaWxpdGllcyBvZiBjb21tb24gc3RhdGlzdGljYWxcbiAqICAgZGlzdHJpYnV0aW9uc1xuICogXG4gKiBTWU5PUFNJU1xuICogXG4gKiBcbiAqICAgLy8gQ2hpLXNxdWFyZWQtY3JpdCAoMiBkZWdyZWVzIG9mIGZyZWVkb20sIDk1dGggcGVyY2VudGlsZSA9IDAuMDUgbGV2ZWxcbiAqICAgY2hpc3FyZGlzdHIoMiwgLjA1KVxuICogICBcbiAqICAgLy8gdS1jcml0ICg5NXRoIHBlcmNlbnRpbGUgPSAwLjA1IGxldmVsKVxuICogICB1ZGlzdHIoLjA1KTtcbiAqICAgXG4gKiAgIC8vIHQtY3JpdCAoMSBkZWdyZWUgb2YgZnJlZWRvbSwgOTkuNXRoIHBlcmNlbnRpbGUgPSAwLjAwNSBsZXZlbCkgXG4gKiAgIHRkaXN0cigxLC4wMDUpO1xuICogICBcbiAqICAgLy8gRi1jcml0ICgxIGRlZ3JlZSBvZiBmcmVlZG9tIGluIG51bWVyYXRvciwgMyBkZWdyZWVzIG9mIGZyZWVkb20gXG4gKiAgIC8vICAgICAgICAgaW4gZGVub21pbmF0b3IsIDk5dGggcGVyY2VudGlsZSA9IDAuMDEgbGV2ZWwpXG4gKiAgIGZkaXN0cigxLDMsLjAxKTtcbiAqICAgXG4gKiAgIC8vIHVwcGVyIHByb2JhYmlsaXR5IG9mIHRoZSB1IGRpc3RyaWJ1dGlvbiAodSA9IC0wLjg1KTogUSh1KSA9IDEtRyh1KVxuICogICB1cHJvYigtMC44NSk7XG4gKiAgIFxuICogICAvLyB1cHBlciBwcm9iYWJpbGl0eSBvZiB0aGUgY2hpLXNxdWFyZSBkaXN0cmlidXRpb25cbiAqICAgLy8gKDMgZGVncmVlcyBvZiBmcmVlZG9tLCBjaGktc3F1YXJlZCA9IDYuMjUpOiBRID0gMS1HXG4gKiAgIGNoaXNxcnByb2IoMyw2LjI1KTtcbiAqICAgXG4gKiAgIC8vIHVwcGVyIHByb2JhYmlsaXR5IG9mIHRoZSB0IGRpc3RyaWJ1dGlvblxuICogICAvLyAoMyBkZWdyZWVzIG9mIGZyZWVkb20sIHQgPSA2LjI1MSk6IFEgPSAxLUdcbiAqICAgdHByb2IoMyw2LjI1MSk7XG4gKiAgIFxuICogICAvLyB1cHBlciBwcm9iYWJpbGl0eSBvZiB0aGUgRiBkaXN0cmlidXRpb25cbiAqICAgLy8gKDMgZGVncmVlcyBvZiBmcmVlZG9tIGluIG51bWVyYXRvciwgNSBkZWdyZWVzIG9mIGZyZWVkb20gaW5cbiAqICAgLy8gIGRlbm9taW5hdG9yLCBGID0gNi4yNSk6IFEgPSAxLUdcbiAqICAgZnByb2IoMyw1LC42MjUpO1xuICogXG4gKiBcbiAqICBERVNDUklQVElPTlxuICogXG4gKiBUaGlzIGxpYnJhcnkgY2FsY3VsYXRlcyBwZXJjZW50YWdlIHBvaW50cyAoNSBzaWduaWZpY2FudCBkaWdpdHMpIG9mIHRoZSB1XG4gKiAoc3RhbmRhcmQgbm9ybWFsKSBkaXN0cmlidXRpb24sIHRoZSBzdHVkZW50J3MgdCBkaXN0cmlidXRpb24sIHRoZVxuICogY2hpLXNxdWFyZSBkaXN0cmlidXRpb24gYW5kIHRoZSBGIGRpc3RyaWJ1dGlvbi4gSXQgY2FuIGFsc28gY2FsY3VsYXRlIHRoZVxuICogdXBwZXIgcHJvYmFiaWxpdHkgKDUgc2lnbmlmaWNhbnQgZGlnaXRzKSBvZiB0aGUgdSAoc3RhbmRhcmQgbm9ybWFsKSwgdGhlXG4gKiBjaGktc3F1YXJlLCB0aGUgdCBhbmQgdGhlIEYgZGlzdHJpYnV0aW9uLlxuICogXG4gKiBUaGVzZSBjcml0aWNhbCB2YWx1ZXMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIHN0YXRpc3RpY2FsIHRlc3RzLCBsaWtlIHRoZSB1XG4gKiB0ZXN0LCB0aGUgdCB0ZXN0LCB0aGUgRiB0ZXN0IGFuZCB0aGUgY2hpLXNxdWFyZWQgdGVzdCwgYW5kIHRvIGNhbGN1bGF0ZVxuICogY29uZmlkZW5jZSBpbnRlcnZhbHMuXG4gKiBcbiAqIElmIHlvdSBhcmUgaW50ZXJlc3RlZCBpbiBtb3JlIHByZWNpc2UgYWxnb3JpdGhtcyB5b3UgY291bGQgbG9vayBhdDpcbiAqICAgU3RhdExpYjogaHR0cDovL2xpYi5zdGF0LmNtdS5lZHUvYXBzdGF0LyA7IFxuICogICBBcHBsaWVkIFN0YXRpc3RpY3MgQWxnb3JpdGhtcyBieSBHcmlmZml0aHMsIFAuIGFuZCBIaWxsLCBJLkQuXG4gKiAgICwgRWxsaXMgSG9yd29vZDogQ2hpY2hlc3RlciAoMTk4NSlcbiAqIFxuICogQlVHUyBcbiAqIFxuICogVGhpcyBwb3J0IHdhcyBwcm9kdWNlZCBmcm9tIHRoZSBQZXJsIG1vZHVsZSBTdGF0aXN0aWNzOjpEaXN0cmlidXRpb25zXG4gKiB0aGF0IGhhcyBoYWQgbm8gYnVnIHJlcG9ydHMgaW4gc2V2ZXJhbCB5ZWFycy4gIElmIHlvdSBmaW5kIGEgYnVnIHRoZW5cbiAqIHBsZWFzZSBkb3VibGUtY2hlY2sgdGhhdCBKYXZhU2NyaXB0IGRvZXMgbm90IHRoaW5nIHRoZSBudW1iZXJzIHlvdSBhcmVcbiAqIHBhc3NpbmcgaW4gYXJlIHN0cmluZ3MuICAoWW91IGNhbiBzdWJ0cmFjdCAwIGZyb20gdGhlbSBhcyB5b3UgcGFzcyB0aGVtXG4gKiBpbiBzbyB0aGF0IFwiNVwiIGlzIHByb3Blcmx5IHVuZGVyc3Rvb2QgdG8gYmUgNS4pICBJZiB5b3UgaGF2ZSBwYXNzZWQgaW4gYVxuICogbnVtYmVyIHRoZW4gcGxlYXNlIGNvbnRhY3QgdGhlIGF1dGhvclxuICogXG4gKiBBVVRIT1JcbiAqIFxuICogQmVuIFRpbGx5IDxidGlsbHlAZ21haWwuY29tPlxuICogXG4gKiBPcmlnaW5sIFBlcmwgdmVyc2lvbiBieSBNaWNoYWVsIEtvc3BhY2ggPG1pa2UucGVybEBnbXguYXQ+XG4gKiBcbiAqIE5pY2UgZm9ybWF0aW5nLCBzaW1wbGlmaWNhdGlvbiBhbmQgYnVnIHJlcGFpciBieSBNYXR0aGlhcyBUcmF1dG5lciBLcm9tYW5uXG4gKiA8bXRrQGlkLmNicy5kaz5cbiAqIFxuICogQ09QWVJJR0hUIFxuICogXG4gKiBDb3B5cmlnaHQgMjAwOCBCZW4gVGlsbHkuXG4gKiBcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgc2FtZSB0ZXJtcyBhcyBQZXJsIGl0c2VsZi4gIFRoaXMgbWVhbnMgdW5kZXIgZWl0aGVyIHRoZSBQZXJsXG4gKiBBcnRpc3RpYyBMaWNlbnNlIG9yIHRoZSBHUEwgdjEgb3IgbGF0ZXIuXG4gKi9cblxudmFyIFNJR05JRklDQU5UID0gNTsgLy8gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyB0byBiZSByZXR1cm5lZFxuXG5mdW5jdGlvbiBjaGlzcXJkaXN0ciAoJG4sICRwKSB7XG5cdGlmICgkbiA8PSAwIHx8IE1hdGguYWJzKCRuKSAtIE1hdGguYWJzKGludGVnZXIoJG4pKSAhPSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpOyAvKiBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdGlmICgkcCA8PSAwIHx8ICRwID4gMSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBwOiAkcFxcblwiKTsgXG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YmNoaXNxcigkbi0wLCAkcC0wKSk7XG59XG5cbmZ1bmN0aW9uIHVkaXN0ciAoJHApIHtcblx0aWYgKCRwID4gMSB8fCAkcCA8PSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIHA6ICRwXFxuXCIpO1xuXHR9XG5cdHJldHVybiBwcmVjaXNpb25fc3RyaW5nKF9zdWJ1KCRwLTApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRkaXN0ciAoJG4sICRwKSB7XG5cdGlmICgkbiA8PSAwIHx8IE1hdGguYWJzKCRuKSAtIE1hdGguYWJzKGludGVnZXIoJG4pKSAhPSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpO1xuXHR9XG5cdGlmICgkcCA8PSAwIHx8ICRwID49IDEpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YnQoJG4tMCwgJHAtMCkpO1xufVxuXG5mdW5jdGlvbiBmZGlzdHIgKCRuLCAkbSwgJHApIHtcblx0aWYgKCgkbjw9MCkgfHwgKChNYXRoLmFicygkbiktKE1hdGguYWJzKGludGVnZXIoJG4pKSkpIT0wKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBuOiAkblxcblwiKTsgLyogZmlyc3QgZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRpZiAoKCRtPD0wKSB8fCAoKE1hdGguYWJzKCRtKS0oTWF0aC5hYnMoaW50ZWdlcigkbSkpKSkhPTApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG06ICRtXFxuXCIpOyAvKiBzZWNvbmQgZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRpZiAoKCRwPD0wKSB8fCAoJHA+MSkpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YmYoJG4tMCwgJG0tMCwgJHAtMCkpO1xufVxuXG5mdW5jdGlvbiB1cHJvYiAoJHgpIHtcblx0cmV0dXJuIHByZWNpc2lvbl9zdHJpbmcoX3N1YnVwcm9iKCR4LTApKTtcbn1cblxuZnVuY3Rpb24gY2hpc3FycHJvYiAoJG4sJHgpIHtcblx0aWYgKCgkbiA8PSAwKSB8fCAoKE1hdGguYWJzKCRuKSAtIChNYXRoLmFicyhpbnRlZ2VyKCRuKSkpKSAhPSAwKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBuOiAkblxcblwiKTsgLyogZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3ViY2hpc3FycHJvYigkbi0wLCAkeC0wKSk7XG59XG5cbmZ1bmN0aW9uIHRwcm9iICgkbiwgJHgpIHtcblx0aWYgKCgkbiA8PSAwKSB8fCAoKE1hdGguYWJzKCRuKSAtIE1hdGguYWJzKGludGVnZXIoJG4pKSkgIT0wKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBuOiAkblxcblwiKTsgLyogZGVncmVlIG9mIGZyZWVkb20gKi9cblx0fVxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3VidHByb2IoJG4tMCwgJHgtMCkpO1xufVxuXG5mdW5jdGlvbiBmcHJvYiAoJG4sICRtLCAkeCkge1xuXHRpZiAoKCRuPD0wKSB8fCAoKE1hdGguYWJzKCRuKS0oTWF0aC5hYnMoaW50ZWdlcigkbikpKSkhPTApKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIG46ICRuXFxuXCIpOyAvKiBmaXJzdCBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9XG5cdGlmICgoJG08PTApIHx8ICgoTWF0aC5hYnMoJG0pLShNYXRoLmFicyhpbnRlZ2VyKCRtKSkpKSE9MCkpIHtcblx0XHR0aHJvdyhcIkludmFsaWQgbTogJG1cXG5cIik7IC8qIHNlY29uZCBkZWdyZWUgb2YgZnJlZWRvbSAqL1xuXHR9IFxuXHRyZXR1cm4gcHJlY2lzaW9uX3N0cmluZyhfc3ViZnByb2IoJG4tMCwgJG0tMCwgJHgtMCkpO1xufVxuXG5cbmZ1bmN0aW9uIF9zdWJmcHJvYiAoJG4sICRtLCAkeCkge1xuXHR2YXIgJHA7XG5cblx0aWYgKCR4PD0wKSB7XG5cdFx0JHA9MTtcblx0fSBlbHNlIGlmICgkbSAlIDIgPT0gMCkge1xuXHRcdHZhciAkeiA9ICRtIC8gKCRtICsgJG4gKiAkeCk7XG5cdFx0dmFyICRhID0gMTtcblx0XHRmb3IgKHZhciAkaSA9ICRtIC0gMjsgJGkgPj0gMjsgJGkgLT0gMikge1xuXHRcdFx0JGEgPSAxICsgKCRuICsgJGkgLSAyKSAvICRpICogJHogKiAkYTtcblx0XHR9XG5cdFx0JHAgPSAxIC0gTWF0aC5wb3coKDEgLSAkeiksICgkbiAvIDIpICogJGEpO1xuXHR9IGVsc2UgaWYgKCRuICUgMiA9PSAwKSB7XG5cdFx0dmFyICR6ID0gJG4gKiAkeCAvICgkbSArICRuICogJHgpO1xuXHRcdHZhciAkYSA9IDE7XG5cdFx0Zm9yICh2YXIgJGkgPSAkbiAtIDI7ICRpID49IDI7ICRpIC09IDIpIHtcblx0XHRcdCRhID0gMSArICgkbSArICRpIC0gMikgLyAkaSAqICR6ICogJGE7XG5cdFx0fVxuXHRcdCRwID0gTWF0aC5wb3coKDEgLSAkeiksICgkbSAvIDIpKSAqICRhO1xuXHR9IGVsc2Uge1xuXHRcdHZhciAkeSA9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KCRuICogJHggLyAkbSksIDEpO1xuXHRcdHZhciAkeiA9IE1hdGgucG93KE1hdGguc2luKCR5KSwgMik7XG5cdFx0dmFyICRhID0gKCRuID09IDEpID8gMCA6IDE7XG5cdFx0Zm9yICh2YXIgJGkgPSAkbiAtIDI7ICRpID49IDM7ICRpIC09IDIpIHtcblx0XHRcdCRhID0gMSArICgkbSArICRpIC0gMikgLyAkaSAqICR6ICogJGE7XG5cdFx0fSBcblx0XHR2YXIgJGIgPSBNYXRoLlBJO1xuXHRcdGZvciAodmFyICRpID0gMjsgJGkgPD0gJG0gLSAxOyAkaSArPSAyKSB7XG5cdFx0XHQkYiAqPSAoJGkgLSAxKSAvICRpO1xuXHRcdH1cblx0XHR2YXIgJHAxID0gMiAvICRiICogTWF0aC5zaW4oJHkpICogTWF0aC5wb3coTWF0aC5jb3MoJHkpLCAkbSkgKiAkYTtcblxuXHRcdCR6ID0gTWF0aC5wb3coTWF0aC5jb3MoJHkpLCAyKTtcblx0XHQkYSA9ICgkbSA9PSAxKSA/IDAgOiAxO1xuXHRcdGZvciAodmFyICRpID0gJG0tMjsgJGkgPj0gMzsgJGkgLT0gMikge1xuXHRcdFx0JGEgPSAxICsgKCRpIC0gMSkgLyAkaSAqICR6ICogJGE7XG5cdFx0fVxuXHRcdCRwID0gbWF4KDAsICRwMSArIDEgLSAyICogJHkgLyBNYXRoLlBJXG5cdFx0XHQtIDIgLyBNYXRoLlBJICogTWF0aC5zaW4oJHkpICogTWF0aC5jb3MoJHkpICogJGEpO1xuXHR9XG5cdHJldHVybiAkcDtcbn1cblxuXG5mdW5jdGlvbiBfc3ViY2hpc3FycHJvYiAoJG4sJHgpIHtcblx0dmFyICRwO1xuXG5cdGlmICgkeCA8PSAwKSB7XG5cdFx0JHAgPSAxO1xuXHR9IGVsc2UgaWYgKCRuID4gMTAwKSB7XG5cdFx0JHAgPSBfc3VidXByb2IoKE1hdGgucG93KCgkeCAvICRuKSwgMS8zKVxuXHRcdFx0XHQtICgxIC0gMi85LyRuKSkgLyBNYXRoLnNxcnQoMi85LyRuKSk7XG5cdH0gZWxzZSBpZiAoJHggPiA0MDApIHtcblx0XHQkcCA9IDA7XG5cdH0gZWxzZSB7ICAgXG5cdFx0dmFyICRhO1xuICAgICAgICAgICAgICAgIHZhciAkaTtcbiAgICAgICAgICAgICAgICB2YXIgJGkxO1xuXHRcdGlmICgoJG4gJSAyKSAhPSAwKSB7XG5cdFx0XHQkcCA9IDIgKiBfc3VidXByb2IoTWF0aC5zcXJ0KCR4KSk7XG5cdFx0XHQkYSA9IE1hdGguc3FydCgyL01hdGguUEkpICogTWF0aC5leHAoLSR4LzIpIC8gTWF0aC5zcXJ0KCR4KTtcblx0XHRcdCRpMSA9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRwID0gJGEgPSBNYXRoLmV4cCgtJHgvMik7XG5cdFx0XHQkaTEgPSAyO1xuXHRcdH1cblxuXHRcdGZvciAoJGkgPSAkaTE7ICRpIDw9ICgkbi0yKTsgJGkgKz0gMikge1xuXHRcdFx0JGEgKj0gJHggLyAkaTtcblx0XHRcdCRwICs9ICRhO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJHA7XG59XG5cbmZ1bmN0aW9uIF9zdWJ1ICgkcCkge1xuXHR2YXIgJHkgPSAtTWF0aC5sb2coNCAqICRwICogKDEgLSAkcCkpO1xuXHR2YXIgJHggPSBNYXRoLnNxcnQoXG5cdFx0JHkgKiAoMS41NzA3OTYyODhcblx0XHQgICsgJHkgKiAoLjAzNzA2OTg3OTA2XG5cdFx0ICBcdCsgJHkgKiAoLS44MzY0MzUzNTg5RS0zXG5cdFx0XHQgICsgJHkgKigtLjIyNTA5NDcxNzZFLTNcblx0XHRcdCAgXHQrICR5ICogKC42ODQxMjE4Mjk5RS01XG5cdFx0XHRcdCAgKyAkeSAqICgwLjU4MjQyMzg1MTVFLTVcblx0XHRcdFx0XHQrICR5ICogKC0uMTA0NTI3NDk3RS01XG5cdFx0XHRcdFx0ICArICR5ICogKC44MzYwOTM3MDE3RS03XG5cdFx0XHRcdFx0XHQrICR5ICogKC0uMzIzMTA4MTI3N0UtOFxuXHRcdFx0XHRcdFx0ICArICR5ICogKC4zNjU3NzYzMDM2RS0xMFxuXHRcdFx0XHRcdFx0XHQrICR5ICouNjkzNjIzMzk4MkUtMTIpKSkpKSkpKSkpKTtcblx0aWYgKCRwPi41KVxuICAgICAgICAgICAgICAgICR4ID0gLSR4O1xuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJ1cHJvYiAoJHgpIHtcblx0dmFyICRwID0gMDsgLyogaWYgKCRhYnN4ID4gMTAwKSAqL1xuXHR2YXIgJGFic3ggPSBNYXRoLmFicygkeCk7XG5cblx0aWYgKCRhYnN4IDwgMS45KSB7XG5cdFx0JHAgPSBNYXRoLnBvdygoMSArXG5cdFx0XHQkYWJzeCAqICguMDQ5ODY3MzQ3XG5cdFx0XHQgICsgJGFic3ggKiAoLjAyMTE0MTAwNjFcblx0XHRcdCAgXHQrICRhYnN4ICogKC4wMDMyNzc2MjYzXG5cdFx0XHRcdCAgKyAkYWJzeCAqICguMDAwMDM4MDAzNlxuXHRcdFx0XHRcdCsgJGFic3ggKiAoLjAwMDA0ODg5MDZcblx0XHRcdFx0XHQgICsgJGFic3ggKiAuMDAwMDA1MzgzKSkpKSkpLCAtMTYpLzI7XG5cdH0gZWxzZSBpZiAoJGFic3ggPD0gMTAwKSB7XG5cdFx0Zm9yICh2YXIgJGkgPSAxODsgJGkgPj0gMTsgJGktLSkge1xuXHRcdFx0JHAgPSAkaSAvICgkYWJzeCArICRwKTtcblx0XHR9XG5cdFx0JHAgPSBNYXRoLmV4cCgtLjUgKiAkYWJzeCAqICRhYnN4KSBcblx0XHRcdC8gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKSAvICgkYWJzeCArICRwKTtcblx0fVxuXG5cdGlmICgkeDwwKVxuICAgICAgICBcdCRwID0gMSAtICRwO1xuXHRyZXR1cm4gJHA7XG59XG5cbiAgIFxuZnVuY3Rpb24gX3N1YnQgKCRuLCAkcCkge1xuXG5cdGlmICgkcCA+PSAxIHx8ICRwIDw9IDApIHtcblx0XHR0aHJvdyhcIkludmFsaWQgcDogJHBcXG5cIik7XG5cdH1cblxuXHRpZiAoJHAgPT0gMC41KSB7XG5cdFx0cmV0dXJuIDA7XG5cdH0gZWxzZSBpZiAoJHAgPCAwLjUpIHtcblx0XHRyZXR1cm4gLSBfc3VidCgkbiwgMSAtICRwKTtcblx0fVxuXG5cdHZhciAkdSA9IF9zdWJ1KCRwKTtcblx0dmFyICR1MiA9IE1hdGgucG93KCR1LCAyKTtcblxuXHR2YXIgJGEgPSAoJHUyICsgMSkgLyA0O1xuXHR2YXIgJGIgPSAoKDUgKiAkdTIgKyAxNikgKiAkdTIgKyAzKSAvIDk2O1xuXHR2YXIgJGMgPSAoKCgzICogJHUyICsgMTkpICogJHUyICsgMTcpICogJHUyIC0gMTUpIC8gMzg0O1xuXHR2YXIgJGQgPSAoKCgoNzkgKiAkdTIgKyA3NzYpICogJHUyICsgMTQ4MikgKiAkdTIgLSAxOTIwKSAqICR1MiAtIDk0NSkgXG5cdFx0XHRcdC8gOTIxNjA7XG5cdHZhciAkZSA9ICgoKCgoMjcgKiAkdTIgKyAzMzkpICogJHUyICsgOTMwKSAqICR1MiAtIDE3ODIpICogJHUyIC0gNzY1KSAqICR1MlxuXHRcdFx0KyAxNzk1NSkgLyAzNjg2NDA7XG5cblx0dmFyICR4ID0gJHUgKiAoMSArICgkYSArICgkYiArICgkYyArICgkZCArICRlIC8gJG4pIC8gJG4pIC8gJG4pIC8gJG4pIC8gJG4pO1xuXG5cdGlmICgkbiA8PSBNYXRoLnBvdyhsb2cxMCgkcCksIDIpICsgMykge1xuXHRcdHZhciAkcm91bmQ7XG5cdFx0ZG8geyBcblx0XHRcdHZhciAkcDEgPSBfc3VidHByb2IoJG4sICR4KTtcblx0XHRcdHZhciAkbjEgPSAkbiArIDE7XG5cdFx0XHR2YXIgJGRlbHRhID0gKCRwMSAtICRwKSBcblx0XHRcdFx0LyBNYXRoLmV4cCgoJG4xICogTWF0aC5sb2coJG4xIC8gKCRuICsgJHggKiAkeCkpIFxuXHRcdFx0XHRcdCsgTWF0aC5sb2coJG4vJG4xLzIvTWF0aC5QSSkgLSAxIFxuXHRcdFx0XHRcdCsgKDEvJG4xIC0gMS8kbikgLyA2KSAvIDIpO1xuXHRcdFx0JHggKz0gJGRlbHRhO1xuXHRcdFx0JHJvdW5kID0gcm91bmRfdG9fcHJlY2lzaW9uKCRkZWx0YSwgTWF0aC5hYnMoaW50ZWdlcihsb2cxMChNYXRoLmFicygkeCkpLTQpKSk7XG5cdFx0fSB3aGlsZSAoKCR4KSAmJiAoJHJvdW5kICE9IDApKTtcblx0fVxuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJ0cHJvYiAoJG4sICR4KSB7XG5cblx0dmFyICRhO1xuICAgICAgICB2YXIgJGI7XG5cdHZhciAkdyA9IE1hdGguYXRhbjIoJHggLyBNYXRoLnNxcnQoJG4pLCAxKTtcblx0dmFyICR6ID0gTWF0aC5wb3coTWF0aC5jb3MoJHcpLCAyKTtcblx0dmFyICR5ID0gMTtcblxuXHRmb3IgKHZhciAkaSA9ICRuLTI7ICRpID49IDI7ICRpIC09IDIpIHtcblx0XHQkeSA9IDEgKyAoJGktMSkgLyAkaSAqICR6ICogJHk7XG5cdH0gXG5cblx0aWYgKCRuICUgMiA9PSAwKSB7XG5cdFx0JGEgPSBNYXRoLnNpbigkdykvMjtcblx0XHQkYiA9IC41O1xuXHR9IGVsc2Uge1xuXHRcdCRhID0gKCRuID09IDEpID8gMCA6IE1hdGguc2luKCR3KSpNYXRoLmNvcygkdykvTWF0aC5QSTtcblx0XHQkYj0gLjUgKyAkdy9NYXRoLlBJO1xuXHR9XG5cdHJldHVybiBtYXgoMCwgMSAtICRiIC0gJGEgKiAkeSk7XG59XG5cbmZ1bmN0aW9uIF9zdWJmICgkbiwgJG0sICRwKSB7XG5cdHZhciAkeDtcblxuXHRpZiAoJHAgPj0gMSB8fCAkcCA8PSAwKSB7XG5cdFx0dGhyb3coXCJJbnZhbGlkIHA6ICRwXFxuXCIpO1xuXHR9XG5cblx0aWYgKCRwID09IDEpIHtcblx0XHQkeCA9IDA7XG5cdH0gZWxzZSBpZiAoJG0gPT0gMSkge1xuXHRcdCR4ID0gMSAvIE1hdGgucG93KF9zdWJ0KCRuLCAwLjUgLSAkcCAvIDIpLCAyKTtcblx0fSBlbHNlIGlmICgkbiA9PSAxKSB7XG5cdFx0JHggPSBNYXRoLnBvdyhfc3VidCgkbSwgJHAvMiksIDIpO1xuXHR9IGVsc2UgaWYgKCRtID09IDIpIHtcblx0XHR2YXIgJHUgPSBfc3ViY2hpc3FyKCRtLCAxIC0gJHApO1xuXHRcdHZhciAkYSA9ICRtIC0gMjtcblx0XHQkeCA9IDEgLyAoJHUgLyAkbSAqICgxICtcblx0XHRcdCgoJHUgLSAkYSkgLyAyICtcblx0XHRcdFx0KCgoNCAqICR1IC0gMTEgKiAkYSkgKiAkdSArICRhICogKDcgKiAkbSAtIDEwKSkgLyAyNCArXG5cdFx0XHRcdFx0KCgoMiAqICR1IC0gMTAgKiAkYSkgKiAkdSArICRhICogKDE3ICogJG0gLSAyNikpICogJHVcblx0XHRcdFx0XHRcdC0gJGEgKiAkYSAqICg5ICogJG0gLSA2KVxuXHRcdFx0XHRcdCkvNDgvJG5cblx0XHRcdFx0KS8kblxuXHRcdFx0KS8kbikpO1xuXHR9IGVsc2UgaWYgKCRuID4gJG0pIHtcblx0XHQkeCA9IDEgLyBfc3ViZjIoJG0sICRuLCAxIC0gJHApXG5cdH0gZWxzZSB7XG5cdFx0JHggPSBfc3ViZjIoJG4sICRtLCAkcClcblx0fVxuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJmMiAoJG4sICRtLCAkcCkge1xuXHR2YXIgJHUgPSBfc3ViY2hpc3FyKCRuLCAkcCk7XG5cdHZhciAkbjIgPSAkbiAtIDI7XG5cdHZhciAkeCA9ICR1IC8gJG4gKiBcblx0XHQoMSArIFxuXHRcdFx0KCgkdSAtICRuMikgLyAyICsgXG5cdFx0XHRcdCgoKDQgKiAkdSAtIDExICogJG4yKSAqICR1ICsgJG4yICogKDcgKiAkbiAtIDEwKSkgLyAyNCArIFxuXHRcdFx0XHRcdCgoKDIgKiAkdSAtIDEwICogJG4yKSAqICR1ICsgJG4yICogKDE3ICogJG4gLSAyNikpICogJHUgXG5cdFx0XHRcdFx0XHQtICRuMiAqICRuMiAqICg5ICogJG4gLSA2KSkgLyA0OCAvICRtKSAvICRtKSAvICRtKTtcblx0dmFyICRkZWx0YTtcblx0ZG8ge1xuXHRcdHZhciAkeiA9IE1hdGguZXhwKFxuXHRcdFx0KCgkbiskbSkgKiBNYXRoLmxvZygoJG4rJG0pIC8gKCRuICogJHggKyAkbSkpIFxuXHRcdFx0XHQrICgkbiAtIDIpICogTWF0aC5sb2coJHgpXG5cdFx0XHRcdCsgTWF0aC5sb2coJG4gKiAkbSAvICgkbiskbSkpXG5cdFx0XHRcdC0gTWF0aC5sb2coNCAqIE1hdGguUEkpXG5cdFx0XHRcdC0gKDEvJG4gICsgMS8kbSAtIDEvKCRuKyRtKSkvNlxuXHRcdFx0KS8yKTtcblx0XHQkZGVsdGEgPSAoX3N1YmZwcm9iKCRuLCAkbSwgJHgpIC0gJHApIC8gJHo7XG5cdFx0JHggKz0gJGRlbHRhO1xuXHR9IHdoaWxlIChNYXRoLmFicygkZGVsdGEpPjNlLTQpO1xuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIF9zdWJjaGlzcXIgKCRuLCAkcCkge1xuXHR2YXIgJHg7XG5cblx0aWYgKCgkcCA+IDEpIHx8ICgkcCA8PSAwKSkge1xuXHRcdHRocm93KFwiSW52YWxpZCBwOiAkcFxcblwiKTtcblx0fSBlbHNlIGlmICgkcCA9PSAxKXtcblx0XHQkeCA9IDA7XG5cdH0gZWxzZSBpZiAoJG4gPT0gMSkge1xuXHRcdCR4ID0gTWF0aC5wb3coX3N1YnUoJHAgLyAyKSwgMik7XG5cdH0gZWxzZSBpZiAoJG4gPT0gMikge1xuXHRcdCR4ID0gLTIgKiBNYXRoLmxvZygkcCk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyICR1ID0gX3N1YnUoJHApO1xuXHRcdHZhciAkdTIgPSAkdSAqICR1O1xuXG5cdFx0JHggPSBtYXgoMCwgJG4gKyBNYXRoLnNxcnQoMiAqICRuKSAqICR1IFxuXHRcdFx0KyAyLzMgKiAoJHUyIC0gMSlcblx0XHRcdCsgJHUgKiAoJHUyIC0gNykgLyA5IC8gTWF0aC5zcXJ0KDIgKiAkbilcblx0XHRcdC0gMi80MDUgLyAkbiAqICgkdTIgKiAoMyAqJHUyICsgNykgLSAxNikpO1xuXG5cdFx0aWYgKCRuIDw9IDEwMCkge1xuXHRcdFx0dmFyICR4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkcDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHo7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdCR4MCA9ICR4O1xuXHRcdFx0XHRpZiAoJHggPCAwKSB7XG5cdFx0XHRcdFx0JHAxID0gMTtcblx0XHRcdFx0fSBlbHNlIGlmICgkbj4xMDApIHtcblx0XHRcdFx0XHQkcDEgPSBfc3VidXByb2IoKE1hdGgucG93KCgkeCAvICRuKSwgKDEvMykpIC0gKDEgLSAyLzkvJG4pKVxuXHRcdFx0XHRcdFx0LyBNYXRoLnNxcnQoMi85LyRuKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJHg+NDAwKSB7XG5cdFx0XHRcdFx0JHAxID0gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgJGkwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRhO1xuXHRcdFx0XHRcdGlmICgoJG4gJSAyKSAhPSAwKSB7XG5cdFx0XHRcdFx0XHQkcDEgPSAyICogX3N1YnVwcm9iKE1hdGguc3FydCgkeCkpO1xuXHRcdFx0XHRcdFx0JGEgPSBNYXRoLnNxcnQoMi9NYXRoLlBJKSAqIE1hdGguZXhwKC0keC8yKSAvIE1hdGguc3FydCgkeCk7XG5cdFx0XHRcdFx0XHQkaTAgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQkcDEgPSAkYSA9IE1hdGguZXhwKC0keC8yKTtcblx0XHRcdFx0XHRcdCRpMCA9IDI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICh2YXIgJGkgPSAkaTA7ICRpIDw9ICRuLTI7ICRpICs9IDIpIHtcblx0XHRcdFx0XHRcdCRhICo9ICR4IC8gJGk7XG5cdFx0XHRcdFx0XHQkcDEgKz0gJGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCR6ID0gTWF0aC5leHAoKCgkbi0xKSAqIE1hdGgubG9nKCR4LyRuKSAtIE1hdGgubG9nKDQqTWF0aC5QSSokeCkgXG5cdFx0XHRcdFx0KyAkbiAtICR4IC0gMS8kbi82KSAvIDIpO1xuXHRcdFx0XHQkeCArPSAoJHAxIC0gJHApIC8gJHo7XG5cdFx0XHRcdCR4ID0gcm91bmRfdG9fcHJlY2lzaW9uKCR4LCA1KTtcblx0XHRcdH0gd2hpbGUgKCgkbiA8IDMxKSAmJiAoTWF0aC5hYnMoJHgwIC0gJHgpID4gMWUtNCkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gJHg7XG59XG5cbmZ1bmN0aW9uIGxvZzEwICgkbikge1xuXHRyZXR1cm4gTWF0aC5sb2coJG4pIC8gTWF0aC5sb2coMTApO1xufVxuIFxuZnVuY3Rpb24gbWF4ICgpIHtcblx0dmFyICRtYXggPSBhcmd1bWVudHNbMF07XG5cdGZvciAodmFyICRpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgkbWF4IDwgYXJndW1lbnRzWyRpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICRtYXggPSBhcmd1bWVudHNbJGldO1xuXHR9XHRcblx0cmV0dXJuICRtYXg7XG59XG5cbmZ1bmN0aW9uIG1pbiAoKSB7XG5cdHZhciAkbWluID0gYXJndW1lbnRzWzBdO1xuXHRmb3IgKHZhciAkaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoJG1pbiA+IGFyZ3VtZW50c1skaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAkbWluID0gYXJndW1lbnRzWyRpXTtcblx0fVxuXHRyZXR1cm4gJG1pbjtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uICgkeCkge1xuXHRyZXR1cm4gTWF0aC5hYnMoaW50ZWdlcihsb2cxMChNYXRoLmFicygkeCkpIC0gU0lHTklGSUNBTlQpKTtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uX3N0cmluZyAoJHgpIHtcblx0aWYgKCR4KSB7XG5cdFx0cmV0dXJuIHJvdW5kX3RvX3ByZWNpc2lvbigkeCwgcHJlY2lzaW9uKCR4KSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFwiMFwiO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJvdW5kX3RvX3ByZWNpc2lvbiAoJHgsICRwKSB7XG4gICAgICAgICR4ID0gJHggKiBNYXRoLnBvdygxMCwgJHApO1xuICAgICAgICAkeCA9IE1hdGgucm91bmQoJHgpO1xuICAgICAgICByZXR1cm4gJHggLyBNYXRoLnBvdygxMCwgJHApO1xufVxuXG5mdW5jdGlvbiBpbnRlZ2VyICgkaSkge1xuICAgICAgICBpZiAoJGkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCRpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoJGkpO1xufSIsImltcG9ydCB7dGRpc3RyfSBmcm9tIFwiLi9zdGF0aXN0aWNzLWRpc3RyaWJ1dGlvbnNcIlxuXG52YXIgc3UgPSBtb2R1bGUuZXhwb3J0cy5TdGF0aXN0aWNzVXRpbHMgPXt9O1xuc3Uuc2FtcGxlQ29ycmVsYXRpb24gPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvc2FtcGxlX2NvcnJlbGF0aW9uJyk7XG5zdS5saW5lYXJSZWdyZXNzaW9uID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2xpbmVhcl9yZWdyZXNzaW9uJyk7XG5zdS5saW5lYXJSZWdyZXNzaW9uTGluZSA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9saW5lYXJfcmVncmVzc2lvbl9saW5lJyk7XG5zdS5lcnJvckZ1bmN0aW9uID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL2Vycm9yX2Z1bmN0aW9uJyk7XG5zdS5zdGFuZGFyZERldmlhdGlvbiA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy9zdGFuZGFyZF9kZXZpYXRpb24nKTtcbnN1LnNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3NhbXBsZV9zdGFuZGFyZF9kZXZpYXRpb24nKTtcbnN1LnZhcmlhbmNlID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL3ZhcmlhbmNlJyk7XG5zdS5tZWFuID0gcmVxdWlyZSgnc2ltcGxlLXN0YXRpc3RpY3Mvc3JjL21lYW4nKTtcbnN1LnpTY29yZSA9IHJlcXVpcmUoJ3NpbXBsZS1zdGF0aXN0aWNzL3NyYy96X3Njb3JlJyk7XG5zdS5zdGFuZGFyZEVycm9yPSBhcnIgPT4gTWF0aC5zcXJ0KHN1LnZhcmlhbmNlKGFycikvKGFyci5sZW5ndGgtMSkpO1xuc3UucXVhbnRpbGUgPSByZXF1aXJlKCdzaW1wbGUtc3RhdGlzdGljcy9zcmMvcXVhbnRpbGUnKTtcblxuc3UudFZhbHVlPSAoZGVncmVlc09mRnJlZWRvbSwgY3JpdGljYWxQcm9iYWJpbGl0eSkgPT4geyAvL2FzIGluIGh0dHA6Ly9zdGF0dHJlay5jb20vb25saW5lLWNhbGN1bGF0b3IvdC1kaXN0cmlidXRpb24uYXNweFxuICAgIHJldHVybiB0ZGlzdHIoZGVncmVlc09mRnJlZWRvbSwgY3JpdGljYWxQcm9iYWJpbGl0eSk7XG59OyIsImltcG9ydCAqIGFzIGQzIGZyb20gJy4vZDMnXG5cbmV4cG9ydCBjbGFzcyBVdGlscyB7XG4gICAgc3RhdGljIFNRUlRfMiA9IDEuNDE0MjEzNTYyMzc7XG4gICAgLy8gdXNhZ2UgZXhhbXBsZSBkZWVwRXh0ZW5kKHt9LCBvYmpBLCBvYmpCKTsgPT4gc2hvdWxkIHdvcmsgc2ltaWxhciB0byAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqQSwgb2JqQik7XG4gICAgc3RhdGljIGRlZXBFeHRlbmQob3V0KSB7XG5cbiAgICAgICAgdmFyIHV0aWxzID0gdGhpcztcbiAgICAgICAgdmFyIGVtcHR5T3V0ID0ge307XG5cblxuICAgICAgICBpZiAoIW91dCAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG91dFtrZXldKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNPYmplY3QgPSB1dGlscy5pc09iamVjdChvdXRba2V5XSk7XG4gICAgICAgICAgICAgICAgdmFyIHNyY09iaiA9IHV0aWxzLmlzT2JqZWN0KHNvdXJjZVtrZXldKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAhaXNBcnJheSAmJiBzcmNPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMuZGVlcEV4dGVuZChvdXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgc3RhdGljIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0Tm90QXJyYXkodGFyZ2V0KSAmJiBVdGlscy5pc09iamVjdE5vdEFycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdE5vdEFycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7W2tleV06IHNvdXJjZVtrZXldfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gVXRpbHMubWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHtba2V5XTogc291cmNlW2tleV19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcm9zcyhhLCBiKSB7XG4gICAgICAgIHZhciBjID0gW10sIG4gPSBhLmxlbmd0aCwgbSA9IGIubGVuZ3RoLCBpLCBqO1xuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjspIGZvciAoaiA9IC0xOyArK2ogPCBtOykgYy5wdXNoKHt4OiBhW2ldLCBpOiBpLCB5OiBiW2pdLCBqOiBqfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaW5mZXJWYXJpYWJsZXMoZGF0YSwgZ3JvdXBLZXksIGluY2x1ZGVHcm91cCkge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGlmKCFkYXRhKXtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBkID0gZGF0YVswXTtcbiAgICAgICAgICAgIGlmIChkIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBkLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGQgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwS2V5ICE9PSBudWxsICYmIGdyb3VwS2V5ICE9PSB1bmRlZmluZWQgJiYgIWluY2x1ZGVHcm91cCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVzLmluZGV4T2YoZ3JvdXBLZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIHN0YXRpYyBpc09iamVjdE5vdEFycmF5KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSAmJiBpdGVtICE9PSBudWxsKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzQXJyYXkoaXRlbSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzT2JqZWN0KGEpIHtcbiAgICAgICAgcmV0dXJuIGEgIT09IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnO1xuICAgIH07XG5cbiAgICBzdGF0aWMgaXNOdW1iZXIoYSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGEpICYmIHR5cGVvZiBhID09PSAnbnVtYmVyJztcbiAgICB9O1xuXG4gICAgc3RhdGljIGlzRnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG4gICAgfTtcblxuICAgIHN0YXRpYyBpc0RhdGUoYSl7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09ICdbb2JqZWN0IERhdGVdJ1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1N0cmluZyhhKXtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCBhIGluc3RhbmNlb2YgU3RyaW5nXG4gICAgfVxuXG4gICAgc3RhdGljIGluc2VydE9yQXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3Rvciwgb3BlcmF0aW9uLCBiZWZvcmUpIHtcblxuICAgICAgICB2YXIgc2VsZWN0b3JQYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KC8oW1xcLlxcI10pLyk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcGFyZW50W29wZXJhdGlvbl0oc2VsZWN0b3JQYXJ0cy5zaGlmdCgpLCBiZWZvcmUpOy8vXCI6Zmlyc3QtY2hpbGRcIlxuICAgICAgICBcbiAgICAgICAgd2hpbGUgKHNlbGVjdG9yUGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yTW9kaWZpZXIgPSBzZWxlY3RvclBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JJdGVtID0gc2VsZWN0b3JQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yTW9kaWZpZXIgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuY2xhc3NlZChzZWxlY3Rvckl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvck1vZGlmaWVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmF0dHIoJ2lkJywgc2VsZWN0b3JJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5zZXJ0U2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5pbnNlcnRPckFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IsIFwiaW5zZXJ0XCIsIGJlZm9yZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFwcGVuZFNlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmluc2VydE9yQXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgXCJhcHBlbmRcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdE9yQXBwZW5kKHBhcmVudCwgc2VsZWN0b3IsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHBhcmVudC5zZWxlY3Qoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuYXBwZW5kU2VsZWN0b3IocGFyZW50LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG5cbiAgICBzdGF0aWMgc2VsZWN0T3JJbnNlcnQocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBwYXJlbnQuc2VsZWN0KHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaW5zZXJ0U2VsZWN0b3IocGFyZW50LCBzZWxlY3RvciwgYmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH07XG5cbiAgICBzdGF0aWMgbGluZWFyR3JhZGllbnQoc3ZnLCBncmFkaWVudElkLCByYW5nZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBVdGlscy5zZWxlY3RPckFwcGVuZChzdmcsIFwiZGVmc1wiKTtcbiAgICAgICAgdmFyIGxpbmVhckdyYWRpZW50ID0gZGVmcy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBncmFkaWVudElkKTtcblxuICAgICAgICBsaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4MSArIFwiJVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5MSArIFwiJVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4MiArIFwiJVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5MiArIFwiJVwiKTtcblxuICAgICAgICAvL0FwcGVuZCBtdWx0aXBsZSBjb2xvciBzdG9wcyBieSB1c2luZyBEMydzIGRhdGEvZW50ZXIgc3RlcFxuICAgICAgICB2YXIgc3RvcHMgPSBsaW5lYXJHcmFkaWVudC5zZWxlY3RBbGwoXCJzdG9wXCIpXG4gICAgICAgICAgICAuZGF0YShyYW5nZSk7XG5cbiAgICAgICAgdmFyIHN0b3BzTWVyZ2UgPSBzdG9wcy5lbnRlcigpLmFwcGVuZChcInN0b3BcIikubWVyZ2Uoc3RvcHMpO1xuXG4gICAgICAgIHN0b3BzTWVyZ2UuYXR0cihcIm9mZnNldFwiLCAoZCwgaSkgPT4gaSAvIChyYW5nZS5sZW5ndGggLSAxKSlcbiAgICAgICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBkID0+IGQpO1xuXG4gICAgICAgIHN0b3BzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2FuaXRpemVIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSwgMTApIHx8IDQwMCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBzYW5pdGl6ZVdpZHRoID0gZnVuY3Rpb24gKHdpZHRoLCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuICh3aWR0aCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJyksIDEwKSB8fCA5NjApO1xuICAgIH07XG5cbiAgICBzdGF0aWMgYXZhaWxhYmxlSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIFV0aWxzLnNhbml0aXplSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyKSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGF2YWlsYWJsZVdpZHRoID0gZnVuY3Rpb24gKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgVXRpbHMuc2FuaXRpemVXaWR0aCh3aWR0aCwgY29udGFpbmVyKSAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGd1aWQoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArXG4gICAgICAgICAgICBzNCgpICsgJy0nICsgczQoKSArIHM0KCkgKyBzNCgpO1xuICAgIH1cblxuICAgIC8vcGxhY2VzIHRleHRTdHJpbmcgaW4gdGV4dE9iaiwgYWRkcyBhbiBlbGxpcHNpcyBpZiB0ZXh0IGNhbid0IGZpdCBpbiB3aWR0aFxuICAgIHN0YXRpYyBwbGFjZVRleHRXaXRoRWxsaXBzaXModGV4dEQzT2JqLCB0ZXh0U3RyaW5nLCB3aWR0aCl7XG4gICAgICAgIHZhciB0ZXh0T2JqID0gdGV4dEQzT2JqLm5vZGUoKTtcbiAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudD10ZXh0U3RyaW5nO1xuXG4gICAgICAgIHZhciBtYXJnaW4gPSAwO1xuICAgICAgICB2YXIgZWxsaXBzaXNMZW5ndGggPSA5O1xuICAgICAgICAvL2VsbGlwc2lzIGlzIG5lZWRlZFxuICAgICAgICBpZiAodGV4dE9iai5nZXRDb21wdXRlZFRleHRMZW5ndGgoKT53aWR0aCttYXJnaW4pe1xuICAgICAgICAgICAgZm9yICh2YXIgeD10ZXh0U3RyaW5nLmxlbmd0aC0zO3g+MDt4LT0xKXtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE9iai5nZXRTdWJTdHJpbmdMZW5ndGgoMCx4KStlbGxpcHNpc0xlbmd0aDw9d2lkdGgrbWFyZ2luKXtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudD10ZXh0U3RyaW5nLnN1YnN0cmluZygwLHgpK1wiLi4uXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRPYmoudGV4dENvbnRlbnQ9XCIuLi5cIjsgLy9jYW4ndCBwbGFjZSBhdCBhbGxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGxhY2VUZXh0V2l0aEVsbGlwc2lzQW5kVG9vbHRpcCh0ZXh0RDNPYmosIHRleHRTdHJpbmcsIHdpZHRoLCB0b29sdGlwKXtcbiAgICAgICAgdmFyIGVsbGlwc2lzUGxhY2VkID0gVXRpbHMucGxhY2VUZXh0V2l0aEVsbGlwc2lzKHRleHREM09iaiwgdGV4dFN0cmluZywgd2lkdGgpO1xuICAgICAgICBpZihlbGxpcHNpc1BsYWNlZCAmJiB0b29sdGlwKXtcbiAgICAgICAgICAgIHRleHREM09iai5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgLjkpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuaHRtbCh0ZXh0U3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIChkMy5ldmVudC5wYWdlWCArIDUpICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgKGQzLmV2ZW50LnBhZ2VZIC0gMjgpICsgXCJweFwiKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0ZXh0RDNPYmoub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGljIGdldEZvbnRTaXplKGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnQtc2l6ZVwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTY2FsZShzY2FsZU5hbWUpIHtcbiAgICAgICAgdmFyIHNjYWxlRnVuY3Rpb25OYW1lID0gJ3NjYWxlJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoc2NhbGVOYW1lKTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgcmV0dXJuIGQzW3NjYWxlRnVuY3Rpb25OYW1lXSgpO1xuICAgICAgICB9Y2F0Y2ggKGUpe1xuICAgICAgICAgICAgdGhyb3cgJ09EQy1EMyAtIHNjYWxlIG5vdCBzdXBwb3J0ZWQ6ICcrc2NhbGVOYW1lKyAnICgnK3NjYWxlRnVuY3Rpb25OYW1lKycpJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVBeGlzKG9yaWVudCwgc2NhbGUpe1xuICAgICAgICB2YXIgYXhpc0ZuTmFtZSA9ICdheGlzJytVdGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIob3JpZW50KTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgcmV0dXJuIGQzW2F4aXNGbk5hbWVdKHNjYWxlKVxuICAgICAgICB9Y2F0Y2ggKGUpe1xuICAgICAgICAgICAgdGhyb3cgJ09EQy1EMyAtIGF4aXMgb3JpZW50IG5vdCBzdXBwb3J0ZWQ6ICcrb3JpZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuIl19
